<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NQualityOfLife</name>
    </assembly>
    <members>
        <member name="T:NQualityOfLife.AI.Jobs">
            <summary><see cref="T:Verse.AI.Job"/> utility methods</summary>
        </member>
        <member name="M:NQualityOfLife.AI.Jobs.IsReserved(Verse.Thing,Verse.Pawn@)">
            <summary></summary>
            <param name="possibleJobTarget"></param>
            <param name="byPawn">The <see cref="P:Verse.AI.ReservationManager.Reservation.Claimant"/> of the first found <see cref="T:Verse.AI.ReservationManager.Reservation"/> on the given <paramref name="possibleJobTarget"/></param>
            <returns><see langword="true"/> if the <paramref name="possibleJobTarget"/> is reserved by anyone</returns>
        </member>
        <member name="M:NQualityOfLife.AI.Toil_.UnDraftIfDrafted(Verse.Pawn)">
            <summary>null checks included</summary>
            <param name="pawn"></param>
            <returns>Toil with the un-draft action</returns>
        </member>
        <member name="M:NQualityOfLife.AI.Find.DefensivePositions(Verse.Pawn,System.Int32@,RimWorld.Faction,Verse.Map,Verse.Region,System.Single,System.Byte,System.Boolean)">
            <summary></summary>
            <param name="inRegion"></param>
            <param name="faction"></param>
            <param name="positionCount"></param>
            <param name="map"></param>
            <param name="pawn"></param>
            <param name="minimumCover"></param>
            <param name="maxPositionsToGet"></param>
            <param name="debug"></param>
            <returns>Never null</returns>
        </member>
        <member name="M:NQualityOfLife.AI.Find.DefensivePositions(Verse.Region,RimWorld.Faction,System.Int32@,Verse.Map,Verse.Pawn,System.Single,System.Byte,System.Boolean)">
            <summary></summary>
            <param name="inRegion"></param>
            <param name="faction"></param>
            <param name="positionCount"></param>
            <param name="map"></param>
            <param name="pawn"></param>
            <param name="minimumCover"></param>
            <param name="maxPositionsToGet"></param>
            <param name="debug"></param>
            <returns>Never null</returns>
        </member>
        <member name="F:NQualityOfLife.Weapons.SuppressionSystem.SuppressionHediff.maxPinTimePerBuller">
            <summary>How many ticks can one bullet add to the timer?</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.SuppressionSystem.SuppressionHediff.minPinTimePerBuller">
            <summary>How many ticks should be the minimum amount to add?</summary>
        </member>
        <member name="M:NQualityOfLife.Weapons.SuppressionSystem.Utils_Suppression.CanSuppress(Verse.Pawn)">
            <summary>Can the given pawn be affected by supression?</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.postShotSmokeSize">
            <summary>Spawn smoke after shooting? -1f is default/no smoke</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.magazineSize">
            <summary>The max capacity of the magazine</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.reloadTicks">
            <summary>The reload job duration ticks</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.bipodGraphic">
            <summary>Optional alternate graphic to use when the bipod is deployed</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.reloadStartSound">
            <summary>The <see cref="T:Verse.SoundDef"/> to play when a <see cref="T:Verse.Pawn"/> starts reloading the weapon</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.reloadDoneSound">
            <summary>The <see cref="T:Verse.SoundDef"/> to play when a <see cref="T:Verse.Pawn"/> is done reloading the weapon</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.weaponType">
            <summary><see cref="T:NQualityOfLife.Weapons.WeaponType"/> type flags</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.durabilityPerShot">
            <summary>How much durability is consumed per shot, 0 is default</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.debug">
            <summary>Enable debug logging for this weapon</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.backBlast">
            <summary>Does the weapon cause a back blast?</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.hasBipod">
            <summary>Does the weapon have a bipod that can be deployed?</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp.magazine">
            <summary>The current amount of bullets in the magazine</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp.myPawn">
            <summary>The <see cref="T:Verse.Pawn"/> who is currently using the weapon</summary>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.DeployBipod(Verse.Pawn)">
            <summary>Start deploying the bipod job</summary>
            <param name="pawn"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException">The bipod is already deployed or the weapon doesn't have one</exception>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.Start_DeployBipod_Job">
            <summary>Make and start a bipod deploy job</summary>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.SetBipodDeployed(Verse.Pawn)">
            <summary>Set the bipod state of the weapon to deployed</summary>
            <param name="pawn"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException">Bipod is already deployed</exception>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.Reload(Verse.Pawn,System.Boolean)">
            <summary>Start a reload job</summary>
            <param name="pawn"></param>
            <param name="noCooldown"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.Start_Reload_Job(System.Boolean)">
            <summary>Create and start the reload job</summary>
            <param name="noCooldown"></param>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.SetMagazineFull(Verse.Pawn)">
            <summary>Set the magazine state to full</summary>
            <param name="pawn"></param>
        </member>
        <member name="M:NQualityOfLife.Animal.Utils_Animal.IsHiddenFromPredator(Verse.Pawn,Verse.Pawn,Verse.Map)">
            <summary></summary>
            <param name="prey"></param>
            <param name="predator"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.Utils_Animal.IsAcceptablePreyFor(Verse.Pawn,Verse.Pawn,System.Boolean,Verse.Map,System.Boolean)">
            <summary>Is <see langword="this"/> <paramref name="prey"/> valid for the given <paramref name="predator"/>?</summary>
            <param name="prey"></param>
            <param name="predator"></param>
            <param name="baseGameResult"></param>
            <param name="map"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Utils_Animal.ValidPreyForMe(Verse.Pawn,Verse.Pawn,System.Boolean,Verse.Map)">
            <summary>Check if the <paramref name="prey"/> is valid for <see langword="this"/> <paramref name="predator"/></summary>
            <param name="predator"></param>
            <param name="prey"></param>
            <param name="debugOnGUI"></param>
            <param name="map"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Solitary.LordJob_Dwelling.#ctor">
            <summary>Empty constructor is needed to prevent errors</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Solitary.Dwelling.SpawnDwellingFlooring(Verse.IntVec3,Verse.Map,Verse.ThingDef)">
            <summary>Spawns decorative stuff on the cell</summary>
            <param name="cell">Where to spawn?</param><param name="map">What map?</param><param name="flooringDef">What to spawn?</param>
        </member>
        <member name="M:NQualityOfLife.Animal.Solitary.Dwelling.DigDwelling(Verse.Pawn,Verse.Map,Verse.Region,System.Boolean)">
            <summary>Tries to queue a digging job for the given dweller animal</summary>
            <param name="pawn"></param><param name="map"></param>
            <param name="existingDwellingToExpand">Expand this existing dwelling, try to dig new if this is null</param>
            <param name="debug"></param>
            <returns>True if was able to queue the digging job</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Solitary.Dwelling.NewDwelling(Verse.Pawn,Verse.Map,System.Nullable{System.Int32},Verse.AI.Group.Lord,System.Boolean)">
            <summary>Create a new dwelling lord for the given pawn</summary>
            <param name="pawn"></param><param name="map"></param><param name="maxDwellers"></param>
            <param name="oldLord"></param><param name="isMother"></param>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.DutyDefOf">
            <summary>XML defs</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DutyDefOf.NQoL_Dwell">
            <summary>XML def for dweller animals</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.IsWarm(NQualityOfLife.Animal.Dweller.DwellingType)">
            <summary></summary>
            <param name="dwellingType"></param>
            <returns>True if the dwelling type provides protection from extreme temperatures</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.ValidDwellingsForPawn(NQualityOfLife.Types.UnOrderedList{System.ValueTuple{Verse.IntVec3,NQualityOfLife.Animal.Dweller.DwellingType}},Verse.Pawn,Verse.Map,NQualityOfLife.Animal.Dweller.DwellingType)">
            <summary>Filters out invalid dwellings for the given pawn</summary>
            <param name="dwellings">The un-validated dwellings</param><param name="pawn"></param><param name="map"></param>
            <param name="ofType"></param>
            <returns>A new list with invalid dwellings removed</returns>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingFinder.DwellingCache">
            <summary>Cached dwellings for each map</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.GoodDwellingSpots(Verse.Map,Verse.Pawn,Verse.AI.Group.Lord,System.Boolean,System.Boolean)">
            <summary>Not null</summary>
            <param name="map"></param><param name="pawn">Get the valid dwellings for this pawn</param><param name="pawnLord"></param><param name="debug"></param>
            <param name="isAsyncOperation"></param>
            <returns>A list of valid dwellings for the pawn, if pawn is not given, will return all valid dwellings of all types. - not null</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Jobs.TryMakeHaulingCorpseToDwellingJob(Verse.Pawn,Verse.IntVec3,Verse.Map,Verse.ThingDef)">
            <summary>Tries to get a fresh corpse to haul, and if found returns the hauling job, Does not reserve or start the job, only creates it.</summary>
            <param name="pawn"></param>
            <param name="cellInDwelling">Where the corpse should be hauled, and where to spawn dwelling deco</param>
            <param name="myMap"></param>
            <param name="dwellingDecoToSpawn"></param>
            <returns>null if no jobs available, else the job</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Jobs.TryMakeCleanDwellingJob(Verse.Pawn,Verse.Map,Verse.AI.Group.Lord)">
            <summary>Returns null or the job ready to be started, Does not reserve or start the job, only creates it.</summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <param name="myLord"></param>
            <returns>null if no job, or the job</returns>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.JobGiver_HaulCorpseToDwelling">
            <summary>Haul fresh corpses to dwelling</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_HaulCorpseToDwelling.TryGiveJob(Verse.Pawn)">
            <summary>Try to give haul job</summary>
            <param name="pawn">The pawn who will do the job</param>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling">
            <summary>Remove rotting corpses from dwelling to prevent lung rot</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling.TryIssueJobPackage(Verse.Pawn,Verse.AI.JobIssueParams)">
            <summary>Try to give haul job</summary>
            <param name="pawn">The pawn who will do the job</param>
            <param name="jobParams">jobParams</param>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling.TryGiveJob(Verse.Pawn)">
            <summary>Try to give haul job</summary>
            <param name="pawn">The pawn who will do the job</param>
        </member>
        <member name="P:NQualityOfLife.Animal.LordJob_Animal.Map">
            <summary>Get the map of the lord (lordManager) - Can be null if the lord / lordManager has not yet initialized</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.BuildingComp.Notify_AddBedThoughts(Verse.Pawn)">
            <summary>N/A - Only applies to pawn comps</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.BuildingComp.Notify_Killed(Verse.Map,System.Nullable{Verse.DamageInfo})">
            <summary>N/A - Only applies to pawn comps</summary><param name="prevMap">N/A</param><param name="dinfo">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.BuildingComp.CompAllowVerbCast(Verse.Verb)">
            <summary>N/A - Only applies to apparel comps</summary><param name="verb"></param><returns></returns>
        </member>
        <member name="T:NQualityOfLife.Comps.ItemComp">
            <summary>A <see cref="T:Verse.ThingComp"/> that is to be applied to items only</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_Unequipped(Verse.Pawn)">
            <summary>Is called when the weapon or apparel is unequipped</summary>
            <param name="pawn">The pawn who unequipped this thing</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_KilledPawn(Verse.Pawn)">
            <summary>Called on all equipment when a pawn kills another pawn</summary>
            <param name="pawn">The pawn that was killed</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_WearerDied">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_Arrested(System.Boolean)">
            <summary>N/A</summary><param name="succeeded">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_WearerDied">
            <summary>Called when the pawn wearing this apparel has died</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.CompAllowVerbCast(Verse.Verb)">
            <summary>Can the verb be casted while wearing this?</summary>
            <param name="verb"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.PostIngested(Verse.Pawn)">
            <summary>N/A</summary><param name="ingester">>N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.PrePostIngested(Verse.Pawn)">
            <summary>N/A</summary><param name="ingester">>N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_UsedVerb(Verse.Pawn,Verse.Verb)">
            <summary>N/A</summary><param name="pawn">N/A</param><param name="verb">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Released">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Downed">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Arrested(System.Boolean)">
            <summary>N/A</summary><param name="succeeded">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.GetAdditionalHarvestYield">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_MapRemoved">
            <summary><see cref="F:NQualityOfLife.Comps.PawnComp.myMap"/> is set to <see langword="null"/></summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Killed(Verse.Map,System.Nullable{Verse.DamageInfo})">
            <summary>Triggers when the pawn is killed || <see cref="F:NQualityOfLife.Comps.PawnComp.alive"/> is set to <see langword="false"/></summary>
            <param name="prevMap"></param>
            <param name="dinfo"></param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_AbandonedAtTile(System.Int32)">
            <summary><see cref="F:NQualityOfLife.Comps.PawnComp.myMap"/> is set to <see langword="null"/> and <see cref="F:NQualityOfLife.Comps.PawnComp.spawned"/> is set to <see langword="false"/></summary>
            <param name="tile"></param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.PostSpawnSetup(System.Boolean)">
            <summary><see cref="F:NQualityOfLife.Comps.PawnComp.spawned"/> is set to <see langword="true"/> <see cref="F:NQualityOfLife.Comps.PawnComp.myMap"/> is set to <see cref="F:Verse.ThingComp.parent"/>.Map</summary>
            <param name="respawningAfterLoad"></param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_LordDestroyed">
            <summary>Called when the lord of this pawn is destroyed</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Arrested(System.Boolean)">
            <summary>Called when this pawn is getting arrested</summary>
            <param name="succeeded">true if was successfully arrested</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Released">
            <summary>Called when the pawn is released from prison / slavery etc</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Downed">
            <summary>Called when this pawn is downed</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Equipped(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_UsedWeapon(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_WearerDied">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Unequipped(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="T:NQualityOfLife.Settings.NQualityOfLife_Mod">
            <summary>My mod class</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Mod.Instance">
            <summary>The instance of my 'Mod'</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.#ctor(Verse.ModContentPack)">
            <summary>My <see cref="T:Verse.Mod"/> class constructor</summary>
            <param name="content"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.DoSettingsWindowContents(UnityEngine.Rect)">
            <summary>My mod settings menu contents</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.SettingsCategory">
            <summary>My mod settings label - Displayed in the mod settings list</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_">
            <summary>Utils for creating setting menus</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions">
            <summary>Extension to 'Listing_Standard' for creating setting menus</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.EndScrollLister">
            <summary>Ideally should be called inside a 'finally' block to prevent cascading errors</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.EndScrollLister(System.Single@)">
            <summary>Ideally should be called inside a 'finally' block to prevent cascading errors</summary>
            <param name="finalLength"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.End">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.End_Internal(System.Single@)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.End_Internal(System.Single@)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.EndScrollLister(System.Single@)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.GetRect(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.GetRect(System.Single,NQualityOfLife.Types.Ratio)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.GetRect(System.Single,NQualityOfLife.Types.Ratio)">
            <summary>Creates a new <see cref="T:NQualityOfLife.Geometry.Rectangle"/> at the end of <see langword="this"/> <see cref="T:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions"/> and extends the lenght</summary>
            <param name="height"></param>
            <param name="width"></param>
            <returns>A <see cref="T:NQualityOfLife.Geometry.Rectangle"/> a the end of the <see cref="T:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions"/></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.GapLine(System.Single)">
            <summary>Draw a horizontal line with a gap</summary>
            <param name="gapHeight"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabelTranslated">Inner setting label</param><param name="innerSetting">Inner setting bool</param>
            <param name="topSettingTipTranslated">Main setting tooltip</param>
            <param name="innerSettingTipTranslated">Inner setting tip</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting 1 label</param><param name="innerSetting1">Inner setting 1 bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTipTranslated">Top setting tooltip</param>
            <param name="innerSettingTip1Translated">Inner setting 1 tip</param>
            <param name="innerSettingTip2Translated">Inner setting 2 tip</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param><param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param><param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param>
            <param name="innerSettingTip3Translated">Tooltip for setting 3</param><param name="innerSettingTip4Translated">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.Boolean,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting in a horizontal row</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="horizontal">Must be true, if false you should call a different method will redirect if called with false</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerTip1Translated">Tooltip for the first inner setting</param><param name="innerTip2Translated">Tooltip for setting 2</param>
            <param name="innerTip3Translated">Tooltip for setting 3</param><param name="innerTip4Translated">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param>
            <param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5Translated">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6Translated">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param>
            <param name="innerSettingTip3Translated">Tooltip for setting 3</param><param name="innerSettingTip4Translated">Tooltip for setting 4</param>
            <param name="innerSettingTip5Translated">Tooltip for setting 5</param><param name="innerSettingTip6Translated">Tooltip for setting 6</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.Slider(System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Int32@,System.Int32,System.Int32,System.String,System.Func{System.Int32,System.String})"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Int32@,System.Int32,System.Int32,System.String,System.Func{System.Int32,System.String})">
            <summary>Draw a slider with label and visible value</summary>
            <param name="labelTranslated">The label that is displayed above the slider</param>
            <param name="setting">The float we are adjusting, will be drawn on top of the slider</param>
            <param name="min">Minimum allowed input value</param><param name="max">Maximum allowed input value</param>
            <param name="customTooltip">Tooltip, if null: use default</param>
            <param name="specialNumberFormatter">Optinally convert the selected int to something else for display purposes.</param>
            <returns>value of setting</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Single@,System.Single,System.Single,System.String)">
            <summary>Draw a slider with label and visible value</summary>
            <param name="labelTranslated">The label that is displayed above the slider</param>
            <param name="setting">The float we are adjusting, will be drawn on top of the slider</param>
            <param name="min">Minimum allowed input value</param><param name="max">Maximum allowed input value</param>
            <param name="customTooltip">Tooltip, if null: use default</param>
             <returns>setting</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Single,System.Single,System.Single,System.String)">
            <summary>Draw a slider with label and visible value</summary>
            <param name="labelTranslated">The label that is displayed above the slider</param>
            <param name="setting">The float we are adjusting, will be drawn on top of the slider</param>
            <param name="min">Minimum allowed input value</param><param name="max">Maximum allowed input value</param>
            <param name="customTooltip">Tooltip, if null: use default</param>
             <returns>setting</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawColumns(UnityEngine.Color,UnityEngine.Color,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single,System.Boolean)">
            <summary>Draw 4 columns with specified height</summary>
            <param name="outlineColor">Outline color</param><param name="fillColor">Column fill color</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Border thickness</param>
            <param name="height">Height of the columns</param>
            <param name="progressScroll">Set to false to disable adding of gap. (Useful for some cases) Normally should leave to true</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawHorizontalCheckButtons(System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32)">
            <summary>Draw 4 check box buttons in a horizontal row with grey border and no fill color</summary>
            <param name="setting1">Left most button setting</param><param name="setting2">Left middle button setting</param>
            <param name="setting3">Right middle button setting</param><param name="setting4">Right most button setting</param>
            <param name="label1">Left most button label</param><param name="label2">Left middle button label</param>
            <param name="label3">Right middle button label</param><param name="label4">Right most button label</param>
            <param name="borderThickness">Button border thickness pixels</param>
            <param name="tooltip1"></param><param name="tooltip2"></param>
            <param name="tooltip3"></param><param name="tooltip4"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawHorizontalCheckButtons(UnityEngine.Color,UnityEngine.Color,System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32)">
            <summary>Draw 4 check box buttons in a horizontal row</summary>
            <param name="outlineColor">Button border color</param><param name="fillColor">Button box fill color</param>
            <param name="setting1">Left most button setting</param><param name="setting2">Left middle button setting</param>
            <param name="setting3">Right middle button setting</param><param name="setting4">Right most button setting</param>
            <param name="label1">Left most button label</param><param name="label2">Left middle button label</param>
            <param name="label3">Right middle button label</param><param name="label4">Right most button label</param>
            <param name="borderThickness">Button border thickness pixels</param>
            <param name="tooltip1"></param><param name="tooltip2"></param>
            <param name="tooltip3"></param><param name="tooltip4"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelLargeCentered(System.String,System.Boolean)">
            <summary>Draw a large label centered with the given (translated) text.</summary>
            <param name="labelTranslated">The translated text to draw.</param>
            <param name="debug">Draw debug rects</param>
            <returns>The rect that contains the text.</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.Label(System.String,System.String,System.Boolean,System.Action,System.Nullable{UnityEngine.Color},System.Boolean)">
            <summary>Draw text with optional tooltip, highlight and click action</summary>
            <param name="textTranslated"></param>
            <param name="toolTipKey"></param>
            <param name="tipIsTranslationKey"></param>
            <param name="clickAction"></param>
            <param name="backroundColor"></param>
            <param name="playClickSound"></param>
            <returns>The <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that contains the text</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelDouble(System.String,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelDouble(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelDouble(System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="leftLabelTranslated"></param>
            <param name="rightLabelTranslated"></param>
            <param name="tipTranslated"></param>
            <param name="onlyHighlightIfHasTooltip">Only draw the highlight on mouse over if the label has a tooltip?</param>
            <returns>The <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that contains the text</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelCentered(System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="labelTranslated"></param><param name="tooltip"></param><param name="debug"></param>
            <returns>The rect that contains the text.</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.CheckboxLabeled(System.String,System.Boolean@,System.String,NQualityOfLife.Types.Factor,NQualityOfLife.Types.Ratio,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw a draggable labeled checbox with an optional tooltip</summary>
            <param name="labelTranslated"></param>
            <param name="checkOn"></param>
            <param name="tooltipTranslated"></param>
            <param name="height"></param>
            <param name="labelPct"></param>
            <param name="onlyHighlightIfHasTooltip"></param>
            <param name="paintable"></param>
            <param name="tooltipsAreTranslationKeys"></param>
            <returns>The current value of this checkbox</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.CheckboxDualLabeled(System.String,System.String,System.Boolean,System.String,NQualityOfLife.Types.Factor,NQualityOfLife.Types.Ratio,System.Boolean,System.Boolean,System.Boolean,NQualityOfLife.Types.Ratio)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.CheckboxDualLabeled(System.String,System.String,System.Boolean@,System.String,NQualityOfLife.Types.Factor,NQualityOfLife.Types.Ratio,System.Boolean,System.Boolean,System.Boolean,NQualityOfLife.Types.Ratio)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.CheckboxDualLabeled(System.String,System.String,System.Boolean@,System.String,NQualityOfLife.Types.Factor,NQualityOfLife.Types.Ratio,System.Boolean,System.Boolean,System.Boolean,NQualityOfLife.Types.Ratio)">
            <summary>Draw a checkbox with two labels, spaced the same way as <see cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelDouble(System.String,System.String,System.String,System.Boolean)"/></summary>
            <param name="leftLabelTranslated"></param>
            <param name="rightLabelTranslated"></param>
            <param name="checkOn"></param>
            <param name="tooltipTranslated"></param>
            <param name="height"></param>
            <param name="labelPct"></param>
            <param name="onlyHighlightIfHasTooltip"></param>
            <param name="paintable"></param>
            <param name="tooltipsAreTranslationKeys"></param>
            <param name="rightLabelRatio">Leave as <see langword="default"/> for 50/50 split</param>
            <returns>The <see cref="T:NQualityOfLife.Geometry.Rectangle"/>s that contain the lables</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DualCheckboxLabel(System.String,System.String,System.String,System.Boolean@,System.Boolean@,System.Single@,System.String,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DualCheckboxLabel(System.String,System.String,System.String,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DualCheckboxLabel(System.String,System.String,System.String,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>Draw a dual checkbox with three labels</summary>
            <param name="labelTranslated">The left most label before the check boxes</param>
            <param name="label_A">The label text next to the first check box</param>
            <param name="label_B">The label text next to the second check box</param>
            <param name="checkOn_A">The state of the first check box</param>
            <param name="checkOn_B">The state of the second check box</param>
            <param name="labelTip">The tooltip of the <paramref name="labelTranslated"/></param>
            <param name="tooltip_A">The tooltip of <paramref name="label_A"/></param>
            <param name="tooltip_B">The tooltip of <paramref name="label_B"/></param>
            <param name="height">Leave to <see langword="default"/> to calculate the needed height</param>
            <param name="labelPct"></param>
            <param name="paintable"></param>
            <param name="tooltipsAreTranslationKeys"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKeys``2(System.Collections.Generic.IDictionary{``0,``1},NQualityOfLife.Settings.SettingProfile)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="keyValuePairs">The dict of defs etc to convert to settings data strings</param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKeys``1(System.Collections.Generic.IList{``0},NQualityOfLife.Settings.SettingProfile)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="TK">The type, such as Verse.Def</typeparam>
            <param name="keys">The list of defs etc to convert to settings data strings</param>
            <param name="profile"></param>
            <returns>A List of 'Profile.Data_Key' strings</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKeys``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0})">
            <summary>Extracts the actual values and keys from a list of setting keys. (Input list format: 'Profile.DataName_Key')</summary>
            <typeparam name="T"></typeparam>
            <param name="keyValuePairs"></param>
            <returns>A dictionary of the keys and values, with Profile. and _Key removed from the keys</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKeys(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey})">
            <summary>Extracts the data from a list of 'Profile.Data_Key' strings</summary>
            <param name="keys">List of setting keys starting with 'profile.' and ending with '_Key'</param>
            <returns>The defNames of the defs, or equivalent</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKey(NQualityOfLife.Settings.SettingKey,NQualityOfLife.Settings.SettingProfile)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <param name="key"></param>
            <param name="profile"></param>
            <returns>A 'Profile.t_Key' string</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKey``1(``0,NQualityOfLife.Settings.SettingProfile)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="profile"></param>
            <returns>A 'Profile.t_Key' string</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForCurrentProfile(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey})">
            <summary>Filters out the keys to get only the keys for the current profile</summary>
            <param name="keys">the input setting data keys</param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForProfile(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey},NQualityOfLife.Settings.SettingProfile)">
            <summary>Filters out the keys to get only the keys for the current profile</summary>
            <param name="keys">the input setting data keys</param>
            <param name="profile"></param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKey(NQualityOfLife.Settings.ProfileSettingKey)">
            <summary>Extracts the data from a 'Profile.Data_Key' string</summary>
            <param name="k">A setting key starting with 'profile.' and ending with '_Key'</param>
            <returns>The defName of the def, or equivalent</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForCurrentProfile``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0})">
            <summary>Filters out the keys to get only the keys for the current profile (input strings foramt expected: 'Profile.DataName_Key')</summary>
            <typeparam name="T"></typeparam>
            <param name="keysForAllProfiles"></param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForProfile``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0},NQualityOfLife.Settings.SettingProfile)">
            <summary>Filters out the keys to get only the keys for the provided profile</summary>
            <typeparam name="T"></typeparam>
            <param name="keysForAllProfiles"></param>
            <param name="profile"></param>
            <returns>All the raw keys for 'profile' in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDefs``2(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.SettingKey,``1})">
            <summary>Expected input is a list of defNames</summary>
            <typeparam name="TD"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDefs``1(System.Collections.Generic.IList{NQualityOfLife.Settings.SettingKey})">
            <summary>Extract the Defs from a list of 'defName's</summary>
            <typeparam name="TD">Def type</typeparam>
            <param name="defNames">The list of defNames</param>
            <returns>A list of Defs of type D</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDef``1(NQualityOfLife.Settings.SettingKey)">
            <summary>Extract the Def from a 'defName'</summary>
            <typeparam name="TD">Def type</typeparam>
            <param name="defName">The defName</param>
            <returns>The def</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_Int(NQualityOfLife.Settings.SettingKey,System.Nullable{System.Int32},System.Int32,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved int value</summary>
            <param name="settingKey">The unique key of the setting data - Should not have the profile prefix!</param>
            <param name="directInt">The int field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved int value or fallback if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_Float(NQualityOfLife.Settings.SettingKey,System.Nullable{System.Single},System.Single,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved float value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="directFloat">The float field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved float value or fallback if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.SetSettingValue_Float(NQualityOfLife.Settings.SettingKey,System.Single,System.Nullable{NQualityOfLife.Settings.SettingProfile})">
            <summary>Sets the saved float value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="newValue">Set this value as the new value</param>
            <param name="profile"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_String(NQualityOfLife.Settings.SettingKey,System.String,System.String,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved string value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="directString">The string field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved string value or fallback if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingEnabled(NQualityOfLife.Settings.SettingKey,System.Nullable{System.Boolean},System.Nullable{NQualityOfLife.Settings.SettingProfile},System.Boolean,NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved <see cref="T:System.Boolean"/> value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="directBool">The bool field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys">Copy the setting from a legacy key if found.</param>
            <returns>The saved <see cref="T:System.Boolean"/> value or <paramref name="fallback"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.LabelLarge(UnityEngine.Rect,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.LabelLarge(NQualityOfLife.Geometry.Rectangle,System.String,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.LabelLarge(NQualityOfLife.Geometry.Rectangle,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw text in a large font and center it inside a Rect</summary>
            <param name="rect">Text inside this Rect</param>
            <param name="labelTranslated">label text</param>
            <param name="centerX"></param>
            <param name="centerY"></param>
            <param name="debug">Draw debug info</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.TextArea(UnityEngine.Rect,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="rect"></param>
            <param name="text">The current text in the area</param>
            <param name="tooltip"></param>
            <param name="readOnly"></param>
            <returns>The text in the text area after user input</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button(UnityEngine.Rect,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Button(UnityEngine.Rect,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button_Confirmation_HyperLink(NQualityOfLife.Geometry.Rectangle,System.String,System.String,System.String,NQualityOfLife.Types.URL)">
            <summary>Draws a button that opens a pop-up confirmation window with the given link</summary>
            <param name="rect">The rect where the button is drawn</param>
            <param name="labelKey">The text on this button</param>
            <param name="tooltipKey">The tooltpi when hovering over this button</param>
            <param name="confirmationLabelKey">The header text on the confirmation pop-up</param>
            <param name="hyperLink"></param>
            <returns><see langword="true"/> when clicking the button</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button(NQualityOfLife.Geometry.Rectangle,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>Draw a rectangular button inside the given <paramref name="rect"/></summary>
            <param name="rect">The rectangle that the button occupies</param>
            <param name="labelKey">Label translation key</param>
            <param name="tooltipKey">Tooltip translation key, no tooltip if <see langword="null"/></param>
            <param name="maxHeight">Limit how tall the button can be at maximum</param>
            <param name="minHeight">The minimum height that the button can be.</param>
            <param name="labelIsPreTranslated">Is the label already translated, or do we translate it here?</param>
            <param name="tooltipIsPreTranslated">Is the tooltip already translated, or do we translate it here?</param>
            <returns><see langword="true"/> when the button is pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button_Confirmation(NQualityOfLife.Geometry.Rectangle,System.String,System.String,System.String,System.Action,System.String)">
            <summary>Draws a button that when pressed; opens a popup window to confirm or cancel the action.</summary>
            <param name="rect">Draw button inside this rect</param>
            <param name="labelKey"></param>
            <param name="tooltipKey"></param>
            <param name="confirmationLabelKey"></param>
            <param name="actionOnConfirm">Action on pressing confirm on the pop-up</param>
            <param name="confirmationExtraLabel_Translated"></param>
            <returns>True when this button is pressed (not the confirmation popup button)</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ClickAction(UnityEngine.Rect,System.Boolean,Verse.SoundDef,System.Boolean,Verse.SoundDef)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.ClickAction(NQualityOfLife.Geometry.Rectangle,System.Boolean,Verse.SoundDef,System.Boolean,Verse.SoundDef)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ClickAction(NQualityOfLife.Geometry.Rectangle,System.Boolean,Verse.SoundDef,System.Boolean,Verse.SoundDef)">
            <summary></summary>
            <param name="rectangle"></param>
            <param name="doMouseoverSound"></param>
            <param name="customHoverSound"></param>
            <param name="doClickSound"></param>
            <param name="customClickSound"></param>
            <returns><see langword="true"/> when the <paramref name="rectangle"/> is clicked</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Hyperlink(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Types.URL,System.Boolean,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="rect"></param>
            <param name="link"></param>
            <param name="copyToClipboardOnClick">Copy to clipboard on click? || if set to <see langword="false"/>; will open the web page on click</param>
            <param name="customToolTipKey"></param>
            <param name="centered"></param>
            <param name="debug"></param>
            <returns>The rect containing the hyperlink text</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabs(UnityEngine.Rect,System.Int32@,System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.Single,System.Int32)">
            <summary>Draw 4 tab buttons at the top of the given Rect</summary>
            <param name="parentRect">Draw at the top of this</param>
            <param name="currentSelectedTabId">The currently active tab (1-6)</param>
            <param name="outlinePixels">Tab button outline thickness</param>
            <param name="heightPixels">Height of the tab buttons</param><param name="tabIdOffset"></param>
            <param name="tip1Key">Tooltip translation key for the button, null means no tip</param><param name="tip2Key">Tooltip translation key for the button, null means no tip</param>
            <param name="tip3Key">Tooltip translation key for the button, null means no tip</param><param name="tip4Key">Tooltip translation key for the button, null means no tip</param>
            <param name="label1">Label of the left most tab</param><param name="label2">Label of the 2. tab from the left</param>
            <param name="label3">Label of the 3. tab from the left</param><param name="label4">Label of the right most tab</param>
            <param name="selectSound">Play this sound when selecting a new tab</param>
            <param name="rejectSound">Play this sound if selecting already open tab</param>
            <param name="hoverSound">Play this sound on mouse hover</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabs(UnityEngine.Rect,System.Int32@,System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.Single,System.Int32)">
            <summary>Draw 6 tab buttons at the top of the given Rect</summary>
            <param name="parentRect">Draw at the top of this</param>
            <param name="currentSelectedTabId">The currently active tab (1-6)</param>
            <param name="outlinePixels">Tab button outline thickness</param>
            <param name="label1">Label of the left most tab</param><param name="label2">Label of the 2. tab from the left</param>
            <param name="label3">Label of the 3. tab from the left</param><param name="label4">Label of the 4. tab from the left</param>
            <param name="label5">Label of the 5. tab from the left</param><param name="label6">Label of the right most tab</param>
            <param name="tip1Key">Tooltip translation key for the button, null means no tip</param><param name="tip2Key">Tooltip translation key for the button, null means no tip</param>
            <param name="tip3Key">Tooltip translation key for the button, null means no tip</param><param name="tip4Key">Tooltip translation key for the button, null means no tip</param>
            <param name="tip5Key">Tooltip translation key for the button, null means no tip</param><param name="tip6Key">Tooltip translation key for the button, null means no tip</param>
            <param name="selectSound">Play this sound when selecting a new tab</param>
            <param name="rejectSound">Play this sound if selecting already open tab</param>
            <param name="hoverSound">Play this sound on mouse hover</param>
            <param name="buttonHeightPixels"></param><param name="tabIdOffset"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabButton(NQualityOfLife.Geometry.Rectangle,System.Int32,System.String,System.Int32@,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.String,System.Boolean,System.Single)">
            <summary></summary>
            <param name="tabButtonRect"></param>
            <param name="thisTabId"></param>
            <param name="label"></param>
            <param name="currentSelectedTabId"></param>
            <param name="selectSound"></param>
            <param name="rejectSound"></param>
            <param name="hoverSound"></param>
            <param name="tooltipKey"></param>
            <param name="debug"></param>
            <param name="buttonHeightPixels"></param>
            <returns>The LabelLarge Rect inside the button</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single)">
            <summary>Draw 2 vertical column Rects inside a Rect with grey border and no fill color</summary>
            <param name="rect"></param>
            <param name="L">Left column</param><param name="R">Right column</param>
            <param name="outlinePixels">Column border thickness pixels</param>
            <param name="middleGap">Move the columns away from each other by this amount.</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle,UnityEngine.Color,UnityEngine.Color,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single)">
            <summary>Draw 2 vertical column Rects inside a Rect</summary>
            <param name="rect"></param>
            <param name="outlineColor">Column border color</param><param name="fillColor">Column fill color</param>
            <param name="L">Left column</param><param name="R">Right column</param>
            <param name="outlinePixels">Column border thickness pixels</param>
            <param name="middleGap">Move the columns away from each other by this amount.</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Single,System.Int32)">
            <summary>Draw 3 vertical column Rects inside a Rect with grey borders and no fill color</summary>
            <param name="rect"></param>
            <param name="L">Left column</param><param name="R">Right column</param><param name="M">Middle column</param>
            <param name="ColumnWidthPercent">How wide the columns should be (0f-1f) 1f = 1/3 of parent rect</param>
            <param name="outlinePixels">Column border thickness pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle,UnityEngine.Color,UnityEngine.Color,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Single,System.Int32)">
            <summary>Draw 3 vertical column Rects inside a Rect</summary>
            <param name="rect"></param>
            <param name="outlineColor"></param><param name="fillColor"></param>
            <param name="L">Left column</param><param name="R">Right column</param><param name="M">Middle column</param>
            <param name="ColumnWidthPercent">How wide the columns should be (0f-1f) 1f = 1/3 of parent rect</param>
            <param name="outlinePixels">Column border thickness pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32)">
            <summary>Draw 4 new vertical column Rects inside a Rect with default colors</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Color,UnityEngine.Color,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32)">
            <summary>Draw 4 new vertical column Rects inside a Rect</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="outlineColor">Column border color</param>
            <param name="fillColor">Column fill color</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32)">
            <summary>Draw 6 new vertical column Rects inside a Rect with default border and fill colors</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="A">1. from the left, Left most column</param><param name="B">2. from the left</param>
            <param name="C">3. from the left</param><param name="D">4. from the left</param>
            <param name="E">5. from the left</param><param name="F">6. from the left, Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Color,UnityEngine.Color,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32)">
            <summary>Draw 6 new vertical column Rects inside a Rect</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="outlineColor">Column border color</param><param name="fillColor">Column fill color</param>
            <param name="A">1. from the left, Left most column</param><param name="B">2. from the left</param>
            <param name="C">3. from the left</param><param name="D">4. from the left</param>
            <param name="E">5. from the left</param><param name="F">6. from the left, Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawNewBorderInsideRectWithPads(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single,System.Single)">
            <summary>Draw with default colors</summary>
            <param name="outerRect"></param>
            <param name="newRect"></param>
            <param name="borderThickness"></param>
            <param name="outerPadding"></param>
            <param name="innerPadding"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Draw(NQualityOfLife.Geometry.Rectangle,UnityEngine.Color,UnityEngine.Color,System.Int32)">
            <summary>Draw the <paramref name="rect"/> with the given border and fill color</summary>
            <param name="rect"></param>
            <param name="fillColor"></param>
            <param name="borderColor"></param>
            <param name="borderThickness"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings.NewPopUpWindow_GeneratedToggles(System.String,System.String,System.Collections.Generic.Dictionary{NQualityOfLife.Settings.ProfileSettingKey,System.Boolean},System.Collections.Generic.IEnumerable{Verse.Def},System.Action{System.Collections.Generic.Dictionary{NQualityOfLife.Settings.ProfileSettingKey,System.Boolean}},System.Boolean,NQualityOfLife.Settings.SettingProfile,System.Func{Verse.Def,System.String},System.Boolean,Verse.WindowStack)">
            <summary>Create and pop a <see langword="new"/> <see cref="T:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings"/> with a list of toggles</summary>
            <param name="headerTextKey">The translation key for the header text</param>
            <param name="topTextKey">The translation key for the optional text under the header</param>
            <param name="existingData">The existing saved data</param>
            <param name="defsToKeys">A list of <see cref="T:Verse.Def"/>s that we use as keys for the toggles</param>
            <param name="onConfirm"></param>
            <param name="defaultToggle">The default state of the toggle</param>
            <param name="profile"></param>
            <param name="customTooltip"><see cref="T:System.Func`2"/> that creates the tooltip for the specific <see cref="T:Verse.Def"/></param>
            <param name="drawTextures"></param>
            <param name="windowStack"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings.NewPopUpWindow_GeneratedSliders(System.String,System.Collections.Generic.Dictionary{NQualityOfLife.Settings.ProfileSettingKey,System.Int32},System.Collections.Generic.IEnumerable{Verse.Def},System.Action{System.Collections.Generic.Dictionary{NQualityOfLife.Settings.ProfileSettingKey,System.Int32}},System.Func{Verse.Def,System.String},System.Nullable{System.Int32},NQualityOfLife.Settings.SettingProfile,System.Func{Verse.Def,System.Int32},System.ValueTuple{System.Int32,System.Int32},Verse.WindowStack)">
            <summary>Create and pop a <see langword="new"/> <see cref="T:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings"/> with a list of sliders</summary>
            <param name="headerTextKey">The translation key of the header text at the top of the window</param>
            <param name="existingData">The current/existing data for each slider/setting</param>
            <param name="defsToKeys">The <see cref="T:Verse.Def"/>s that correspond to the keys</param>
            <param name="onConfirm">The action to invoke when pressing confirm, usually a method that saves the new settings</param>
            <param name="sliderLabelMaker">The <see cref="T:System.Func`2"/> that decides what the label is for the def related slider</param>
            <param name="defaultNumber">The default value to use if there is no <paramref name="existingData"/> for the given key</param>
            <param name="profile">The setting profile that this pop-up window is for</param>
            <param name="defaultNumFromDef">This takes priority over <paramref name="defaultNumber"/> if provided</param>
            <param name="sliderMinMax">The min and max values for the sliders</param>
            <param name="windowStack"></param>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings.DoDefIcons">
            <summary>Draw the textures of the <see cref="T:Verse.Def"/>s next to the setting</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.GetData(System.Collections.Generic.List{NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.GraphData},System.Int32,NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.State@)">
            <summary></summary>
            <param name="data">The graphs to get the data for</param>
            <param name="forTick"></param>
            <param name="state"></param>
            <returns>True if the data was successfully collected</returns>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow">
            <summary>Base pop up window - Pop up windows are draggable, resizable windows that are drawn on top of other UI elements</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.HeaderTextTranslated">
            <summary>The translated header text to draw at the top of the window</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.TextTranslated">
            <summary>Optional text to draw under the header</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Header">
            <summary>The top part of the window - Intended for a header text</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.HeaderTextBox">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.TextArea">
            <summary>The middle section of the window - Intended for text input fields or other controls or displays</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.TextAreaTextBox">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Bottom">
            <summary>The bottom part of the window - Intended for controls such as confirm or cancel buttons</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.BottomPixels">
            <summary>The size (height) of the bottom rect</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Debug">
            <summary>Debug the ui elements</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.DefaultInitialSize">
            <summary>'DefaultInitialSize' / (500f, 250f)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.#ctor(System.String,System.String,System.Single)">
            <summary>The base pop up window with a header and text</summary>
            <param name="headerTextTranslated"></param><param name="textTranslated">Text drawn under the header</param><param name="bottomPixels"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.#ctor(System.String,System.Single)">
            <summary>The base pop up window with only a header</summary>
            <param name="headerTextTranslated"></param><param name="bottomPixels"></param>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow.InitialSize">
            <summary>The initial size of the popup window (x, y) - Default is 'DefaultInitialSize' / (500f, 250f)</summary>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow.InitialPosition">
            <summary>The initial position of the window when it is created - Middle of the screen by default</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.DoWindowContents(UnityEngine.Rect)">
            <summary>Should be called in the overrides, Draws the contents of the pop up window, such as text and or buttons.</summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.WindowUpdate">
            <summary>By default only maintains the sound sustainer if any</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.ExtraOnGUI">
            <summary>Does not do anything by default</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.WindowOnGUI">
            <summary>Called before <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.DoWindowContents(UnityEngine.Rect)"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.LateWindowOnGUI(UnityEngine.Rect)">
            <summary>Is called after <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.WindowOnGUI"/> and <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.DoWindowContents(UnityEngine.Rect)"/></summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreOpen">
            <summary>Sets initial size and position and does some other stuff || Called before <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostOpen"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostOpen">
            <summary>Plays the appear sound and starts the sound sustainer if any || Called after <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreOpen"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreClose">
            <summary>Does not do anything by default || Called before <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostClose"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostClose">
            <summary>Does not do anything by default || Called after <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreClose"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.OnAcceptKeyPressed">
            <summary>Called on accept key press (Enter)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.OnCancelKeyPressed">
            <summary>Called on cancel key press (Esc)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.SetInitialSizeAndPosition">
            <summary>Sets the size and position, and makes sure the window is on screen.</summary>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow.CloseButtonText">
            <summary>The text on the default close button</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_IdeoRoleSettings.OnAcceptPressed">
            <summary>Saves the settings</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation">
            <summary>A pop up window with confirm and cancel buttons</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmAction">
            <summary>Action to invoke when pressing confirm - Can be null - Should be invoked last if multiple actions!</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelAction">
            <summary>Action to invoke when pressing cancel - Can be null - Should be invoked last if multiple actions!</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.AllowConfirmWithEnter">
            <summary>Set this to false to allow for a better text input experience.</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmTooltipKey">
            <summary>Confirm button hover tooltip translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelTooltipKey">
            <summary>Cancel button hover tooltip translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmKey">
            <summary>Confirm button label translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelKey">
            <summary>Cancel button label translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.DrawButtons">
            <summary>Draw the default buttons that invoke the default actions?</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.#ctor(System.String,System.Single)">
            <summary>Will not draw the base confirm / cancel buttons</summary>
            <param name="headerTextKey"></param><param name="bottomPixels"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.#ctor(System.String,System.Boolean,System.Single)">
            <summary>Draw the base confirm / cancel buttons</summary>
            <param name="headerTextKey"></param><param name="closeOnConfirm">Close the window instance when pressing confirm</param><param name="bottomPixels"></param>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.InitialSize">
            <summary>The initial size of the confirmation popup window (x, y) - Default is (600f, 250f)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.DoWindowContents(UnityEngine.Rect)">
            <summary>If 'DrawButtons' is true, draws the default cancel and confirm buttons, else draws the default popup window.</summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnAcceptKeyPressed">
            <summary>Must be called last inside the OnAcceptPressed() method! - Calls the confirm actions (ConfirmAction) when pressing accept / enter</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnAcceptPressed">
            <summary>Calls the confirm actions (ConfirmAction) when pressing accept / enter</summary>
            <returns>True if we should accept the input, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnCancelKeyPressed">
            <summary>Calls the cancel actions (CancelAction) when pressing cancel / esc</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_ColorSelector.OnAcceptPressed">
            <summary>Invokes the confirm action and color confirm action</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ScrollControls(UnityEngine.Rect,NQualityOfLife.Settings.Utils_.PopUpWindow,NQualityOfLife.Types.Factor2@,NQualityOfLife.Types.Vector2Float@)">
            <summary></summary>
            <param name="displayRect"></param>
            <param name="popUpWindow"></param>
            <param name="scaler"></param>
            <param name="DisplayOffset"></param>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput">
            <summary>Use helper method -> 'NewPopUpWindow_TextInput'</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.NewPopUpWindow_TextInput(System.String,System.String,System.Action{System.String},System.Boolean,Verse.WindowStack)">
            <summary>Example usage: 'NewPopUpWindow_TextInput("NQoL_Animal_Color", TechLevel_.Animal_ColorHex, newText => TechLevel_.Animal_ColorHex = newText))'</summary>
            <param name="headerTextKey">Example usage: '"NQoL_Animal_Color"'</param>
            <param name="initialValue">Example usage: 'TechLevel_.Animal_ColorHex'</param>
            <param name="confirmAction">Example usage: 'newText => TechLevel_.Animal_ColorHex = newText'</param>
            <param name="closeOnConfirm">Close the window on confirm/accept (true) or keep it open (false).</param>
            <param name="windowStack">Optional, will find if null</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.NewPopUpWindow_TextInput(System.String,System.String,System.String,System.Action{System.String},System.Action,System.Boolean,Verse.WindowStack)">
            <summary>Example usage: 'NewPopUpWindow_TextInput("NQoL_Animal_Color", TechLevel_.Animal_ColorHex, newText => TechLevel_.Animal_ColorHex = newText))'</summary>
            <param name="headerTextKey">Example usage: '"NQoL_Animal_Color"'</param>
            <param name="topTextKey"></param>
            <param name="initialValue">Example usage: 'TechLevel_.Animal_ColorHex'</param>
            <param name="confirmAction">Example usage: 'newText => TechLevel_.Animal_ColorHex = newText'</param>
            <param name="confirmAction_2">Example usage: '() => NQualityOfLife_Mod.NQualityOfLife_Settings.Write()'</param>
            <param name="closeOnAccept">Close the window on accept (true) or keep it open (false).</param>
            <param name="windowStack">Optional, will find if null</param>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextEntry">
            <summary>User inputted text</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextConfirmAction">
            <summary>Action to invoke on confirm using the inputted text as a parameter</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextCancelAction">
            <summary>Action to invoke on cancel using the inputted text as a parameter</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.IsFocus_ForKeyboardInput(UnityEngine.Rect)">
            <summary>Is this rect the current focus for keyboard inputs?</summary>
            <param name="inputRect">The rect for the input widget</param>
            <returns>True if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.MouseHover(UnityEngine.Rect,System.Boolean)">
            <summary>Return <see langword="true"/> when the mouse is over the given <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="debug">Enable debug draw.</param>
            <returns><see langword="true"/> if mouse is over the <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PositionForBottomRightCorner(Verse.Window)">
            <summary>Gets the position for the <paramref name="window"/> that positions it in the bottom right corner of the screen with some margin</summary>
            <param name="window"></param>
            <returns></returns><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PositionForTopLeftCorner(Verse.Window)">
            <summary>Gets the position for the <paramref name="window"/> that positions it in the top left corner of the screen with some margin</summary>
            <param name="window"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToTopLeftCorner(Verse.Window)">
            <summary>Move the <paramref name="window"/> to the top left corner of the screen</summary>
            <param name="window"></param><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToFullScreen(Verse.Window,System.Single)">
            <summary>Set the window to full screen</summary>
            <param name="window"></param>
            <param name="border">How much gap to leave between the screen edges and the window</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.MoveToTheLeftOf(Verse.Window,Verse.Window)">
            <summary>Move the given <see cref="T:Verse.Window"/> to the left of the other <paramref name="window"/></summary>
            <param name="thisWindow"></param>
            <param name="window"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.AddPadding(NQualityOfLife.Geometry.Rectangle,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.AddPadding(UnityEngine.Rect,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.AddPadding(UnityEngine.Rect,System.Single)">
            <summary></summary>
            <param name="rect">Input rect</param>
            <param name="padding">How much gap to add between the outer rect and the new rect</param>
            <returns>A new Rect that is inside the input rect</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.TooltipAndHighlight(UnityEngine.Rect,System.String,System.Boolean,System.Boolean)">
            <summary>Draw a semi transparent highlight on top of the <paramref name="rect"/> when the mouse is on top of it || and show tooltip</summary>
            <param name="rect"></param>
            <param name="tooltip"></param>
            <param name="tipIsTranslationKey"></param>
            <param name="onlyHighlightIfHasTooltip"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.TooltipAndHighlight(UnityEngine.Rect,UnityEngine.Rect,System.String,System.Boolean)">
            <summary>Highlight both rects when hovering over <paramref name="rect_A"/>, and draw tooltips when hovering over <paramref name="rect_A"/></summary>
            <param name="rect_A">Tooltip and highlight on hover</param><param name="rect_B">Highlight when hovering over <paramref name="rect_A"/></param><exception cref="T:System.ArgumentNullException"></exception>
            <param name="tooltip">Tooltip on hovering over <paramref name="rect_A"/></param><param name="tipIsTranslationKey">Is the tip already translated, or a translation key?</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect)">
            <summary>Draw a highlight over the <paramref name="rect"/> when the mouse is over it</summary>
            <param name="rect"></param><returns><see langword="true"/> on hover</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect,UnityEngine.Rect)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.OnHover(UnityEngine.Rect,System.Action)">
            <summary>Trigger an <see cref="T:System.Action"/> when the mouse enters the <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="action"></param>
            <returns><see langword="true"/> on hover</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.OnHover(UnityEngine.Rect,System.Action,System.Action)">
            <summary>Trigger two <see cref="T:System.Action"/>s when the mouse enters the <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="action_A"></param><param name="action_B"></param>
            <returns><see langword="true"/> on hover</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabelTranslated">Inner setting label</param><param name="innerSetting">Inner setting bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTipTranslated">Tooltip for the first inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Internal_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabelTranslated">Inner setting label</param><param name="innerSetting">Inner setting bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTipTranslated">Tooltip for the first inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting 1 label</param><param name="innerSetting1">Inner setting 1 bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param>
            <param name="innerSettingTip2">Tooltip for the second inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 3 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param><param name="innerSettingTip3">Tooltip for setting 3</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 3 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param><param name="innerSettingTip3Translated">Tooltip for setting 3</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
            <param name="innerSettingTip5">Tooltip for setting 5</param><param name="innerSettingTip6">Tooltip for setting 6</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5Translated">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6Translated">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param>
            <param name="innerSettingTip3Translated">Tooltip for setting 3</param><param name="innerSettingTip4Translated">Tooltip for setting 4</param>
            <param name="innerSettingTip5Translated">Tooltip for setting 5</param><param name="innerSettingTip6Translated">Tooltip for setting 6</param>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.SearchWindow">
            <summary>Pop-Up window for searching the XMLE settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.PreOpen">
            <summary>Set 'exampleStartingLevel' to the current player tech level</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.PostClose">
            <summary>Re-calculate and set the player tech level if player is in game, and write setting data to file.</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.Pop">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.Pop.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.ProfileSettingKey">
            <summary>A setting key made from a 'SettingProfile' and a 'SettingKey'</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.ProfileSettingKey.ToString">
            <summary></summary>
            <returns>"Profile.Data_Key"</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.ToString">
            <summary></summary>
            <returns>"Profile"</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(NQualityOfLife.Settings.SettingProfile,NQualityOfLife.Settings.SettingProfile)">
            <summary>Compare the internal profile strings</summary><param name="a"></param><param name="b"></param><returns>True if the profile strings match / The 2 profiles are the same profile || True if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(NQualityOfLife.Settings.SettingProfile,NQualityOfLife.Settings.SettingProfile)">
            <summary>Compare the internal profile strings</summary><param name="a"></param><param name="b"></param><returns>False if the profile strings match / The 2 profiles are the same profile || False if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(System.String,NQualityOfLife.Settings.SettingProfile)">
            <summary>Compare the given string to the internal string of the given profile</summary><param name="a"></param><param name="b"></param><returns>True if the string matches the given profile, false if they don't match || True if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(System.String,NQualityOfLife.Settings.SettingProfile)">
            <summary>Compare the given string to the internal string of the given profile</summary><param name="a"></param><param name="b"></param><returns>False if the string matches the given profile, true if they don't match || False if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(NQualityOfLife.Settings.SettingProfile,System.String)">
            <summary>Compare the internal profile string to the given string</summary><param name="a"></param><param name="b"></param><returns>True if the profile strings matches the given string / The 2 profiles are the same profile || True if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(NQualityOfLife.Settings.SettingProfile,System.String)">
            <summary>Compare the internal profile string to the given string</summary><param name="a"></param><param name="b"></param><returns>False if the profile strings matches the given string / The 2 profiles are the same profile || False if the profiles are the same</returns>
        </member>
        <member name="T:NQualityOfLife.Settings.NQualityOfLife_Settings">
            <summary>My mod settings class</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.rocketCacheHasBeenPurged">
            <summary>True when the rocketman cache has been purged during this session and thus doesn't need to be again.</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.Write(System.Boolean)">
            <summary>Write the settings to file</summary>
            <param name="dontPurgeRocketCache">Set to true if purging the cache is not needed</param>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.TryPurgeRocketCache">
            <summary>Try purge the rocketman cache if rocketman loaded</summary>
            <returns>false on error</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.PurgeRocketCache">
            <summary>Sets 'Gagarin.Context.IsUsingCache' to false when writing mod settings, to allow conditional xml patches to apply.</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Infestation_Light_Max_For_Insects_100">
            <summary>int 0 - 100</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Infestation_Temperature_Range_Min">
            <summary>-20 - 60</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Infestation_Temperature_Range_Max">
            <summary>-20 - 60</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Research_TechLevel_Progression_Slider">
            <summary>Must be 0f - 1f</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Research_TechLevel_Progression_Skip_Slider">
            <summary>Must be 0f - 1f</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.architectPosData">
            <summary>Key: $"{Utils.Settings.profile}.{item.defName}_Key"</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.architectColData">
            <summary>Key: $"{Utils.Settings.profile}.{item.defName}_Key"</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.mainButtonPosData">
            <summary>Keys: SettingProfileKey</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.mainButtonSizeData">
            <summary>Keys: SettingProfileKey</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalLetterFilterDefFilterData">
            <summary>Keys are formatted as Profile.defName_Key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalMessageFilterDefFilterData">
            <summary>Keys are formatted as Profile.defName_Key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalLetterFilterTextProfiles">
            <summary>Keys are the profiles, value is the text data</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalMessageFilterTextProfiles">
            <summary>Keys are the profiles, value is the text data</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.diseaseEventFilterData">
            <summary>Data keys saved in the Profile.Key_Key format</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Cache`2.#ctor(System.Func{System.Collections.Generic.Dictionary{`0,`1}},System.Func{`0,`1})">
            <summary></summary>
            <param name="populator">returns the fully built cache data dictionary</param>
            <param name="getSingle"></param>
        </member>
        <member name="T:NQualityOfLife.Types.HashList`1">
            <summary><see cref="T:NQualityOfLife.Types.HashList`1"/> is a 'hash list' or 'dictionary list'. It is essentially a combination of a <see cref="T:System.Collections.Generic.List`1"/> and a <see cref="T:System.Collections.Generic.HashSet`1"/>.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.HashList`1.ContainsAll(System.Collections.Generic.IList{`0})">
            <summary>Check of <see langword="this"/> <see cref="T:NQualityOfLife.Types.HashList`1"/> contains all the items of '<paramref name="ofTheseList"/>'</summary><param name="ofTheseList"></param>
            <returns><see langword="true"/> if this <see cref="T:NQualityOfLife.Types.HashList`1"/> contains all the items in the given <see cref="T:System.Collections.Generic.IList`1"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="ofTheseList"/> is <see langword="null"/></exception><remarks>Duplicates in the <paramref name="ofTheseList"/> will be ignored as <see cref="T:NQualityOfLife.Types.HashList`1"/> can only contain one of each item</remarks>
            <inheritdoc cref="M:NQualityOfLife.Types.OrderedList`1.ContainsAll(System.Collections.Generic.IList{`0})"/>
        </member>
        <member name="T:NQualityOfLife.Types.IListInterface`1">
            <summary>Interface for lists and other collections</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.IListInterface`1.Size">
            <summary>The size / <see cref="P:System.Collections.Generic.ICollection`1.Count"/> of the list</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.SetInternalData(System.Collections.Generic.ICollection{`0})">
            <summary>Set the internal <paramref name="data" /> of this list to the given values</summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.CountAllWhere(System.Predicate{`0})">
            <summary>Count how many items on the list match the <paramref name="predicate" /></summary>
            <param name="predicate"></param><returns>The count of items that matched the <paramref name="predicate" /></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.CountTill(System.Int32,System.Predicate{`0})">
            <summary>Count all the matching items until the <paramref name="maxCount" /> or the end of the list</summary>
            <param name="maxCount"></param>
            <param name="predicate"></param><returns>The count of items that matched the <paramref name="predicate" /></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Remove(`0,System.Int32,System.Boolean)">
            <summary>Remove the specified <paramref name="amount" /> of the <paramref name="item" /> || or until there are none left.</summary>
            <param name="item"></param>
            <param name="amount">The amount of items to remove.</param>
            <param name="lastFoundFirst">Remove the last found <paramref name="item"/> first || set to <see langword="false"/> to remove first found <paramref name="item"/> instead</param>
            <returns>The actual amount of items removed</returns><exception cref="T:System.NotSupportedException">List is read only</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.RemoveLast(`0)">
            <summary>Remove the last found instance of the given <paramref name="item"/> from the list</summary>
            <param name="item"></param><exception cref="T:System.NotSupportedException">List is read only</exception>
            <returns><see langword="true"/> if the <paramref name="item"/> was found and removed</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.RemoveAll(`0)">
            <summary>Remove all the instances of the given <paramref name="item" /></summary>
            <param name="item"></param><exception cref="T:System.NotSupportedException">List is read only</exception>
            <returns>The amount of items removed</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.RemoveAllWhere(System.Predicate{`0})">
            <summary>Remove all items that match the given <paramref name="where"/> <see cref="T:System.Predicate`1"/></summary>
            <param name="where">Remove all items that match this <see cref="T:System.Predicate`1"/></param>
            <returns>The amount of items removed</returns><exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ArgumentNullException">If predicate is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ToArray">
            <summary>Create an array from the list</summary>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ToArray(System.Int32,System.Int32)">
            <summary></summary>
            <param name="startingFrom">Add the items from this <see cref="T:NQualityOfLife.Types.IListInterface`1"/> starting at this index</param>
            <param name="count">How many items to add to the array</param>
            <returns>An array with the items from this <see cref="T:NQualityOfLife.Types.IListInterface`1"/>, starting at <paramref name="startingFrom" /></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ToList">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.FormatAsString(NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags)">
            <summary>Format the <see cref="T:NQualityOfLife.Types.IListInterface`1"/> as a <see cref="T:System.String"/> according to the given <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/> and <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/></summary>
            <param name="formatMode"></param>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.FormatAsString(NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{`0,System.String})">
            <summary>Format the <see cref="T:NQualityOfLife.Types.IListInterface`1"/> as a <see cref="T:System.String"/> according to the given <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/> and <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/></summary>
            <param name="formatMode"></param>
            <param name="displayMode"></param>
            <param name="specialFormatter"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Any">
            <summary>Check of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains any items</summary>
            <returns><see langword="true"/> if the <see cref="T:NQualityOfLife.Types.IListInterface`1"/> has any items</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Last">
            <summary>Get the last item on the <see cref="T:NQualityOfLife.Types.IListInterface`1"/></summary><returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.First">
            <summary>Get the first item of this <see cref="T:NQualityOfLife.Types.IListInterface`1"/></summary><returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.FirstOrFallBack(System.Predicate{`0},`0)">
            <summary>Return the first item that matches the given <paramref name="predicate"/>, or <paramref name="fallback"/> if none found</summary>
            <param name="predicate"></param>
            <param name="fallback"></param>
            <returns>The first item that matched the <paramref name="predicate"/>, or <paramref name="fallback"/> if none did</returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.AddRange(System.Collections.Generic.IList{`0})">
            <summary></summary>
            <param name="range"></param>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary></summary>
            <param name="range"></param>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.AddSafe(`0)">
            <summary>Add the value only if it doesn't already exist in the <see cref="T:NQualityOfLife.Types.IListInterface`1"/></summary><param name="value">The item to add</param><returns><see langword="true"/> if the item was added. || <see langword="false"/> if the item was not added</returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAll(`0[])">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterface`1.ContainsAll(System.Collections.Generic.IList{`0})"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAll(System.Collections.Generic.IList{`0})">
            <summary>Check of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains all the items of '<paramref name="ofTheseList"/>'</summary><param name="ofTheseList"></param>
            <returns><see langword="true"/> if this <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains all the items in the given <see cref="T:System.Collections.Generic.IList`1"/> (<paramref name="ofTheseList"/>) || Will always return <see langword="false"/> if the <paramref name="ofTheseList"/> has more items than <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="ofTheseList"/> is <see langword="null"/></exception><remarks>Note that if the <paramref name="ofTheseList"/> has more items than <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> this method will always return <see langword="false"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAny(`0[])">
            <summary>Check if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains any of the given items</summary>
            <param name="ofThese"></param><exception cref="T:System.ArgumentNullException"><paramref name="ofThese"/> is <see langword="null"/></exception>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains any of the given items</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAny(System.Collections.Generic.IList{`0},`0@)">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterface`1.ContainsAny(`0[])"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAnyWhere(System.Predicate{`0})">
            <summary>Check if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains any item that matches the <paramref name="predicate"/></summary>
            <param name="predicate"></param><exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains any items that matches the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.FirstIndexOf(System.Predicate{`0})">
            <summary>Get the index of the first found match in the list || or -1 if there were no matches</summary>
            <param name="predicate"></param>
            <returns>The index of the first found thing that matches the <paramref name="predicate"/> ||, or -1 if none</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.LastIndexOf(System.Predicate{`0})">
            <summary>Get the index of the last found match in the list || or -1 if there were no matches</summary>
            <param name="predicate"></param>
            <returns>The index of the last found thing that matches the <paramref name="predicate"/> ||, or -1 if none</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Find(System.Predicate{`0},System.Func{`0,`0,`0})">
            <summary>Filter the items of the list using the <see cref="T:System.Predicate`1"/> and then find the best matching item using the <see cref="T:System.Func`3"/></summary>
            <param name="where">Filter the possible items using this <see cref="T:System.Predicate`1"/></param><exception cref="T:System.ArgumentNullException"></exception>
            <param name="betterMatch">In the <see cref="T:System.Func`3"/><para><typeparamref name="T"/>1 is the best item found so far</para><para><typeparamref name="T"/>2 is the next item in the list that we are comparing against the best found item.</para><para><typeparamref name="T"/>Result is the item that is a better match from the given two</para></param>
            <returns>The item that matched the <see cref="T:System.Predicate`1"/> and was the best match according to the given <see cref="T:System.Func`3"/><para>Or <see langword="null"/> if the list has no items, none of the items passed the <see cref="T:System.Predicate`1"/> or <see langword="null"/> was the best matching item</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Find(System.Func{`0,`0,`0})">
            <summary>Find the best matching item from the list</summary><exception cref="T:System.ArgumentNullException"></exception>
            <param name="betterMatch">In the <see cref="T:System.Func`3"/><para><typeparamref name="T"/>1 is the best item found so far</para><para><typeparamref name="T"/>2 is the next item in the list that we are comparing against the best found item.</para><para><typeparamref name="T"/>Result is the item that is a better match from the given two</para></param>
            <returns>The item that was the best match according to the given <see cref="T:System.Func`3"/><para>Or <see langword="null"/> if there were no items in the list or <see langword="null"/> was the best matching item</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Transform``1(System.Func{`0,``0})">
            <summary>Transform the contents of the list to a new type <typeparamref name="TN"/></summary>
            <typeparam name="TN">The new <see cref="T:System.Type"/> of the list contents || Can also be the same as <typeparamref name="T"/> if you want to only modify the items but not change their <see cref="T:System.Type"/></typeparam>
            <param name="func">The function to apply to all the items of the list</param>
            <returns>A <see langword="new"/> list of <see cref="T:System.Type"/> <typeparamref name="TN"/> with the contents transformed by the given <paramref name="func"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.CopyWhere(System.Predicate{`0})">
            <summary>Make a new list from the given collection where the items satisfy the <paramref name="where"/> <see cref="T:System.Predicate`1"/></summary>
            <param name="where"></param>
            <returns>The matching input elements to list</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Copy">
            <summary>Make a copy of the list</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Copy(System.Int32,System.Int32)">
            <summary>Makes a copy of the list starting at the given index</summary>
            <param name="startingFrom">Start copying the list from this index</param>
            <param name="count">How many items to get at the maximum</param>
            <returns>A copy of the original list starting at the given index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.SelectRandomSet(System.Int32)">
            <summary></summary>
            <param name="maxItemsToGet"></param>
            <remarks>If <paramref name="maxItemsToGet"/> is greater or equal to the item count of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/>; will return a copy of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/></remarks>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with randomly selected items from <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/></returns><exception cref="T:System.IndexOutOfRangeException"><paramref name="maxItemsToGet"/> is &lt;= 0</exception>
        </member>
        <member name="T:NQualityOfLife.Types.IListInterfaceData`2">
            <summary>Extension to the base IListInterface, Specifies the type of the internal data list</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TInternalDataList">The type of the internal list that stores the data</typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.IListInterfaceData`2.InternalData">
            <summary>The data stored inside the IListInterface</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceData`2.ToList``1(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterfaceType`2.ToList``1(System.Int32,System.Int32)"/>
        </member>
        <member name="T:NQualityOfLife.Types.IListInterfaceType`2">
            <summary>Extension to the base IListInterface, Specifies the type of the list</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TListType">The type of the list that implements this interface</typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.CopyWhere(System.Predicate{`0})">
            <summary>Make a copy of this list from the given collection <paramref name="where"/> the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <param name="where"></param>
            <returns>The matching input elements to a <see langword="new"/> list</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.Copy">
            <summary>Make a copy of the list</summary>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.ToList``1">
            <summary>Make a <see langword="new"/> list from the contents of this list in a different list type</summary>
            <typeparam name="TList"></typeparam>
            <returns>The newly created list</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.ToList``1(System.Int32,System.Int32)">
            <summary></summary>
            <typeparam name="TList"></typeparam>
            <param name="startingFrom"></param>
            <param name="count"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.Copy(System.Int32,System.Int32)">
            <summary>Makes a copy of the list starting at the given index</summary>
            <param name="startingFrom">Start copying the list from this index</param>
            <param name="count">How many items to get at the maximum</param>
            <returns>A copy of the original list starting at the given index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.SelectRandomSet(System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterface`1.SelectRandomSet(System.Int32)"/>
        </member>
        <member name="T:NQualityOfLife.Types.IReadOnlyListInterface`1">
            <summary>Extends <see cref="T:System.Collections.Generic.IReadOnlyList`1"/></summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.IReadOnlyListInterface`1.SetReadOnly">
            <summary>Sets the list to read only and returns itself as a <see cref="T:NQualityOfLife.Types.IReadOnlyListInterface`1"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.IReadOnlyListInterface`1.AsReadOnly">
            <summary>Get a reference to the list as a <see cref="T:NQualityOfLife.Types.IReadOnlyListInterface`1"/> || should not mutate the list</summary>
        </member>
        <member name="T:NQualityOfLife.Types.OrderedList`1">
            <summary><see cref="T:NQualityOfLife.Types.OrderedList`1"/> is a <see cref="T:System.Collections.Generic.List`1"/> that implements <see cref="T:NQualityOfLife.Types.IListInterface`3"/> and explicitly preserves item order</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.OrderedList`1.Item(System.Int32)">
            <summary></summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.Add(`0)">
            <summary>Add the given <paramref name="item"/> to the end of the <see cref="T:NQualityOfLife.Types.OrderedList`1"/> list</summary>
            <param name="item"></param>
            <exception cref="T:System.InvalidOperationException">The list is read only</exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.Clear">
            <summary>Clear all the data</summary>
            <exception cref="T:System.InvalidOperationException">The list is read only</exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.Remove(`0)">
            <summary>Remove the first found instance of the given <paramref name="item"/></summary>
            <param name="item"></param>
            <returns><see langword="true"/> if the <paramref name="item"/> was successfully removed.</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.RemoveAt(System.Int32)">
            <summary>Remove the item at the given <paramref name="index"/> from the list</summary>
            <param name="index">Remove the item at this <paramref name="index"/> || Must be above -1 and below the size of the list</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.IndexOf(`0)">
            <summary>Get the index of the given <paramref name="item"/></summary><param name="item"></param>
            <returns>the zero based index of the <paramref name="item"/> || or -1 if the item was not found in the list</returns>
        </member>
        <member name="T:NQualityOfLife.Types.ITreeNode`3">
            <summary></summary>
            <typeparam name="TNode">The type of the node that implements this interface</typeparam>
            <typeparam name="TData">The type of the data that this node contains</typeparam>
            <typeparam name="TTree">The type of the tree that contains this node</typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Parent">
            <summary>The parent of this node - If null, the node is the root of the tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Tree">
            <summary>Get the tree that contains this node</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Children">
            <summary>Get the direct child nodes of this node</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Depth">
            <summary>The depth of the node in the tree, where 0 is the root node</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Data">
            <summary>Get or set the data that this node contains</summary>
        </member>
        <member name="M:NQualityOfLife.Types.ITreeNode`3.DataFormatted``1(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Types.ITreeNode`3.Add(`1)">
            <summary>Add a <see langword="new"/> child node to this node with the given data</summary>
            <param name="newDataNode"></param>
            <returns>The newly added <typeparamref name="TNode"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.ITreeNode`3.DataFormatted(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary></summary>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Root">
            <summary>The root node of the tree, The root node does not have a parent || Calling this on the root node will return null</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.SubRoot">
            <summary>The root node of this sub tree || or Root if this is not a sub tree || Calling this on the root node will return null</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Path">
            <summary>The string representation of the branch ending with this node</summary>
        </member>
        <member name="T:NQualityOfLife.Types.ITree`3">
            <summary></summary>
            <typeparam name="TNode">The type of the node that this tree is made from</typeparam>
            <typeparam name="TTree">The type of the tree that implements this interface</typeparam>
            <typeparam name="TData">The type of the data that this tree can contain</typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.Root">
            <summary>The root node of the tree, The root node does not have a parent</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.LocalRoot">
            <summary>The node where this tree starts inside a parent tree || or Root if this tree is not a sub tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.Count">
            <summary>The total nodes in the tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.Depth">
            <summary>The max depth of the tree, where 0 is only the root node</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.AllNodes">
            <summary>Get all the nodes that are a part of the tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.ParentTree">
            <summary>The parent tree of a sub tree || or null if this is not a sub tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.IsSubTree">
            <summary>Is this tree a sub tree / branch of another tree?</summary>
        </member>
        <member name="M:NQualityOfLife.Types.ITree`3.IsSubTreeOf(`2)">
            <summary>Is this tree a sub tree / branch of the given tree?</summary>
            <param name="tree"></param><returns></returns>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.rootNode">
            <summary>The <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> that is the root of this <see cref="T:NQualityOfLife.Types.Tree`1"/></summary>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.Node._containedData">
            <summary>The data that is linked / represented by this node</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.Node._parent">
            <summary>The direct parent node of this node, or null if this node is the root of a tree</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.Node._children">
            <summary>The direct child nodes of this node</summary>
        </member>
        <member name="P:NQualityOfLife.Types.Tree`1.Node.Item(System.Int32)">
            <summary>Get a direct child of this node by index</summary>
            <param name="index"></param><returns>One of the direct child nodes</returns>
        </member>
        <member name="P:NQualityOfLife.Types.Tree`1.Node.Count">
            <summary>Get how many direct child nodes this node has</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.Node.Add(NQualityOfLife.Types.Tree{`0}.Node)">
            <summary>Add the given node to the child nodes if this node</summary>
            <param name="item"></param>
        </member>
        <member name="T:NQualityOfLife.Types.Direction">
            <summary><see cref="T:NQualityOfLife.Types.Direction"/> is a vector with a <see cref="P:NQualityOfLife.Types.Direction.Magnitude"/> of 1f</summary>
        </member>
        <member name="T:NQualityOfLife.Types.Factor">
            <summary>A positive float value</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.#ctor(System.Single)">
            <summary>The input float must be positive or the constructor will <see langword="throw"/> a <see cref="T:System.ArgumentOutOfRangeException"/></summary>
            <param name="factor"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor,System.UInt32)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="rightInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(System.UInt32,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="leftInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(System.Int32,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="leftInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor,NQualityOfLife.Types.Ratio)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="ratio"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Ratio,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="ratio"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(System.Single,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="number"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor,System.Single)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="number"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Division(NQualityOfLife.Types.Factor,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Division(System.Single,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Division(NQualityOfLife.Types.Factor,System.Single)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(NQualityOfLife.Types.Factor,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(NQualityOfLife.Types.Factor,System.Single)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(System.Single,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="number"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(NQualityOfLife.Types.Factor,System.UInt32)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(System.UInt32,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Subtraction(NQualityOfLife.Types.Factor,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Subtraction(NQualityOfLife.Types.Factor,System.Single)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="number"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Subtraction(System.Single,NQualityOfLife.Types.Factor)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="number"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.LargerOf(NQualityOfLife.Types.Factor)">
            <summary>Returns the larger value</summary><param name="otherValue"></param><returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.Abs">
            <summary></summary>
            <returns>this <see cref="T:NQualityOfLife.Types.Factor"/> un-changed</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <remarks>Trying to get the Abs() with an <see cref="F:NQualityOfLife.Types.Factor.invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.Percentage">
            <summary>Represents a <see cref="T:System.Single"/> value as a <see cref="T:NQualityOfLife.Types.Percentage"/>, a <see cref="T:System.Single"/> of '1f' is 100% when casting</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Percentage.PercentageValue">
            <summary>0%~100% || 0%~100% to float -> 0f~1f</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(System.Single,System.Single)">
            <summary>Creates a Percentage - of/max</summary>
            <param name="of"></param>
            <param name="max">Max value</param>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Explicit(NQualityOfLife.Types.Percentage)~NQualityOfLife.Types.Ratio">
            <summary>Converts a Percentage with a value between: 0f~100f to a ratio: 0f~1f</summary>
            <param name="percentage"></param>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.RoundToInt">
            <summary></summary>
            <returns>The percentage as an <see cref="T:System.Int32"/> (0~100)</returns>
        </member>
        <member name="T:NQualityOfLife.Types.Ratio">
            <summary>A float value between 0 and 1 - the value is stored in a byte, so some precision is lost.</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Single)">
            <summary></summary>
            <param name="ratio"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.#ctor(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Int32)">
            <summary></summary>
            <param name="ratio"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Byte)">
            <summary>Set the internal value directly 0~255</summary>
            <param name="value">0~255 - 0~1</param>
        </member>
        <member name="P:NQualityOfLife.Types.Ratio.Inverse">
            <summary>1f - <see langword="this"/> <see cref="T:NQualityOfLife.Types.Ratio"/></summary>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio2.#ctor(UnityEngine.Vector2)">
            <summary></summary>
            <param name="vector2"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio2.#ctor(System.Single,System.Single)">
            <summary></summary>
            <param name="x"></param>
            <param name="y"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Element.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns><see langword="true"/> if the two <see cref="T:NQualityOfLife.Types.Element"/>s are the same atomic number, isotope is ignored</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Atom.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns><see langword="true"/> if the two <see cref="T:NQualityOfLife.Types.Atom"/> are the same atomic number and isotope</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Atom.op_Equality(NQualityOfLife.Types.Atom,NQualityOfLife.Types.Atom)">
            <summary></summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Types.Atom.Equals(System.Object)"/>
        </member>
        <member name="F:NQualityOfLife.Types.PeriodicTable.elements">
            <summary>The data is structured [row][column]!</summary>
        </member>
        <member name="T:NQualityOfLife.Types.IVector`1">
            <summary>A vector composed of the specified type</summary>
            <typeparam name="T">The type of the vector</typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.IVector`1.Magnitude">
            <summary>The magnitude of the vector</summary>
        </member>
        <member name="T:NQualityOfLife.Types.IVector2`1">
            <summary>a 2 dimensional vector composed of the specified type</summary>
            <typeparam name="T">The type of the vector</typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.IVector2`1.Deconstruct(`0@,`0@)">
            <summary>Get the X and Y components of the 2D vector</summary>
            <param name="x">The X component of the vector</param>
            <param name="y">The Y component of the vector</param>
        </member>
        <member name="T:NQualityOfLife.Types.Vector2Float">
            <summary>A generic vector composed of two floats</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Vector2Float.#ctor(System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Types.Vector2Float"/>
        </member>
        <member name="T:NQualityOfLife.Types.IVector3`1">
            <summary>a 3 dimensional vector composed of the specified type</summary>
            <typeparam name="T">The type of the vector</typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.IVector3`1.Deconstruct(`0@,`0@,`0@)">
            <summary>Get the X, Y and Z components of the 3D vector</summary>
            <param name="x">The X component of the vector</param>
            <param name="y">The Y component of the vector</param>
            <param name="z">The Z component of the vector</param>
        </member>
        <member name="M:NQualityOfLife.Types.UnOrderedList`1.Remove(`0)">
            <summary>Remove the given <paramref name="item"/>, || (The last item on the list will replace the given items index, unless the given index is the last item)</summary>
            <param name="item"></param><exception cref="T:System.InvalidOperationException"></exception>
            <returns><see langword="true"/> if the <paramref name="item"/> was successfully removed.</returns>
        </member>
        <member name="M:NQualityOfLife.Types.UnOrderedList`1.RemoveAt(System.Int32)">
            <summary>Remove the item at the given index from the list. || (the last item on the list will be moved to this index, unless the given index is the last item)</summary>
            <param name="index"></param><exception cref="T:System.InvalidOperationException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:NQualityOfLife.Types.IInterface">
            <summary>Parent interface for all interfaces in NQualityOfLife</summary>
        </member>
        <member name="T:NQualityOfLife.Types.ICastable`1">
            <summary>The <see cref="T:System.Type"/> can be cast to <typeparamref name="T"/> explicitly or implicitly</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.ICastable`1.CastTo">
            <summary>Cast <see langword="this"/> <see cref="T:NQualityOfLife.Types.ICastable`1"/> to a <typeparamref name="T"/></summary>
            <returns><see langword="this"/> <see cref="T:NQualityOfLife.Types.ICastable`1"/> casted to <typeparamref name="T"/></returns>
        </member>
        <member name="T:NQualityOfLife.Types.IInverse`2">
            <summary>A pair of values that are the inverse of each other</summary>
            <typeparam name="TA"><typeparamref name="TA"/> == 1/<typeparamref name="TB"/> | <typeparamref name="TA"/> == <typeparamref name="TB"/>^-1</typeparam><typeparam name="TB"><typeparamref name="TB"/> == 1/<typeparamref name="TA"/> | <typeparamref name="TB"/> == <typeparamref name="TA"/>^-1</typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.IInverse`2.Inverse">
            <summary>1/<typeparamref name="TA"/> == <typeparamref name="TB"/></summary>
        </member>
        <member name="T:NQualityOfLife.Types.IFloat">
            <summary>Interface for types that are used for math</summary>
        </member>
        <member name="P:NQualityOfLife.Types.IFloat.Value">
            <summary>The value of this <see cref="T:NQualityOfLife.Types.IFloat"/> when converted to <see cref="T:System.Single"/> || For example <see cref="T:NQualityOfLife.Types.Percentage"/> of 100% will return 1f</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat.Equals(System.Single,System.Single)">
            <summary></summary><param name="other"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IFloat"/> is approximately equal to the given <see cref="T:System.Single"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat.EqualsApprox(System.Single,System.Single)">
            <summary></summary><param name="other"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IFloat"/> is approximately equal to the given <see cref="T:System.Single"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat.EqualsExact(System.Single)">
            <summary></summary><param name="other"></param><returns><see langword="true"/> if the <see cref="T:System.Single"/> values are exactly the same, to the bit level.</returns>
        </member>
        <member name="T:NQualityOfLife.Types.IFloat`1">
            <summary>Provies methods for comparing instances of <typeparamref name="TV"/> to each other and to <see cref="T:System.Single"/>s</summary>
            <typeparam name="TV"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat`1.NewWithValue(System.Single)">
            <summary></summary>
            <param name="value"></param>
            <returns>a <see langword="new"/> instance of <typeparamref name="TV"/> that is equal to the provided <paramref name="value"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat`1.Equals(`0,System.Single)">
            <summary></summary>
            <param name="other"></param>
            <param name="epsilon">How much the values can deviate to still be considered equal</param>
            <returns><see langword="true"/> if the two instances of <typeparamref name="TV"/> are equal within the given <paramref name="epsilon"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat`1.EqualsApprox(`0,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Types.IFloat`1.Equals(`0,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat`1.EqualsExact(`0)">
            <summary></summary><param name="other"></param><returns><see langword="true"/> if the <see cref="T:System.Single"/> values are exactly the same, to the bit level.</returns>
        </member>
        <member name="T:NQualityOfLife.Types.IRatio">
            <summary>The <see cref="T:System.Type"/> is equivelant to a <see cref="T:System.Single"/> in a 0~1 range</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IRatio.Chance">
            <summary></summary>
            <returns><see langword="true"/> or <see langword="false"/> based on the current value of the <see cref="T:NQualityOfLife.Types.IRatio"/></returns>
        </member>
        <member name="T:NQualityOfLife.Types.IMath">
            <summary>Provides math operations</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IMath.Clamp(System.Single,System.Single)">
            <summary>Clamp inclusive</summary>
            <param name="min"></param><param name="max"></param>
            <returns>a <see cref="T:System.Single"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath.LargerOf(System.Single)">
            <summary>Returns the larger <see cref="T:System.Single"/> value</summary>
            <param name="other"></param>
            <returns>The larger of the two <see cref="T:System.Single"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath.SmallerOf(System.Single)">
            <summary>Returns the smaller <see cref="T:System.Single"/> value</summary>
            <param name="other"></param>
            <returns>The smaller of the two <see cref="T:System.Single"/> values</returns>
        </member>
        <member name="T:NQualityOfLife.Types.IMath`1">
            <summary>Provides math operations to the implementing <see cref="T:System.Type"/> '<typeparamref name="T"/>'</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.Clamp(`0,`0)">
            <summary>Clamp inclusive</summary>
            <param name="min"></param><param name="max"></param>
            <returns><typeparamref name="T"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.Abs">
            <summary>|<typeparamref name="T"/>|</summary>
            <returns>The absolute (non negative) value of <typeparamref name="T"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.SmallerOf(`0)">
            <summary>Returns the smaller value</summary>
            <param name="other"></param>
            <returns>The smaller of the two <typeparamref name="T"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.Min(`0)">
            <summary>Returns the smaller value</summary>
            <param name="other"></param>
            <returns>The smaller of the two <typeparamref name="T"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.LargerOf(`0)">
            <summary>Returns the larger value</summary>
            <param name="other"></param>
            <returns>The larger of the two <typeparamref name="T"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.Max(`0)">
            <summary>Returns the larger value</summary>
            <param name="other"></param>
            <returns>The larger of the two <typeparamref name="T"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.RoundToInt">
            <summary>Round to the closest <see cref="T:System.Int32"/></summary>
            <returns><see cref="T:System.Int32"/> that is closest to the value of this <typeparamref name="T"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.ClampRatio(NQualityOfLife.Types.Ratio,NQualityOfLife.Types.Ratio)">
            <summary>Clamp the value into a <see cref="T:NQualityOfLife.Types.Ratio"/></summary><param name="min"></param><param name="max"></param>
            <returns><paramref name="min"/>, <paramref name="max"/> or a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.ClampRatio">
            <summary>Clamp the value into a <see cref="T:NQualityOfLife.Types.Ratio"/></summary>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.LineExtensions.DrawLineHorizontal(NQualityOfLife.Geometry.Point2D,NQualityOfLife.Geometry.Point2D,UnityEngine.Color,System.Single)">
            <summary>Draw a horizontal line starting from start going right</summary>
            <param name="color"></param><param name="start"></param><param name="end"></param><param name="thickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Types.LineExtensions.DrawLineVertical(NQualityOfLife.Geometry.Point2D,UnityEngine.Color,System.Single,System.Single)">
            <summary>Draw a vertical line starting from start going down</summary>
            <param name="color"></param>
            <param name="thickness"></param><param name="start"></param><param name="height"></param>
            <returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Types.LineExtensions.DrawLineHorizontal(NQualityOfLife.Geometry.Point2D,UnityEngine.Color,System.Single,System.Single)">
            <summary>Draw a <see cref="T:NQualityOfLife.Geometry.HorizontalLine"/> line starting from <paramref name="start"/> going right</summary>
            <param name="color"></param><param name="start"></param><param name="length"></param><param name="thickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="T:NQualityOfLife.Types.StaticFieldInfo">
            <summary><see cref="T:System.Reflection.FieldInfo"/> of a <see langword="static"/> field</summary>
        </member>
        <member name="M:NQualityOfLife.Types.StaticFieldInfo.GetValue">
            <summary>Get the value of the <see langword="static"/> field</summary>
            <returns>an <see cref="T:System.Object"/> that contains the value of the <see langword="static"/> field</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <inheritdoc cref="M:System.Reflection.FieldInfo.GetValue(System.Object)"/>
        </member>
        <member name="M:NQualityOfLife.Types.StaticFieldInfo.SetValue(System.Object)">
            <summary>Set the value of the <see langword="static"/> field to the <paramref name="newValue"/></summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <inheritdoc cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)"/>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.R">
            <summary>Set or get the Red 'RGBA' component</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.G">
            <summary>Set or get the Green 'RGBA' component</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.B">
            <summary>Set or get the Blue 'RGBA' component</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.A">
            <summary>Get the A (Transparency) 'RGBA' component - || 255 is max opacity, 0 is fully transparent</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.HexCode">
            <summary>Get or set the hex color code (#AA4435FF)</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.AsRGBA">
            <summary>Get or set the color as 'RGBA'</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.AsRGB">
            <summary>Get or set the color as 'RGB'</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.UnityColor">
            <summary>Get or set the color as 'UnityEngine.Color'</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.ToColorTag">
            <summary>Get the &lt;color&gt; tag</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorRGBA.A">
            <summary>Set or get the A (Transparency) 'RGBA' component - || 255 is max opacity, 0 is fully transparent</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorRGBA.AsRGBA">
            <summary>Get or set the color as 'RGBA'</summary>
        </member>
        <member name="T:NQualityOfLife.Colors.Hex">
            <summary>Represents a hex color code such as #FF2277FF</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.AsRGBA">
            <summary>Convert a hex color code such as #FF15ABFF into its RGBA components. If the hex code doesn't have an Alpha component like in '#FF15AB', it will be returned as 255. - The input hex code can start with or without '#'</summary>
            <returns>If input is null or empty => (0, 0, 0, 255)</returns>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.AsRGB">
            <summary>Convert a hex color code such as #FF15AB into its RGB components. If the hex code has an Alpha component like in '#FF00AAF6', it will be ignored</summary>
            <returns> If input is null or empty => (0, 0, 0)</returns>
        </member>
        <member name="F:NQualityOfLife.Colors.Hex.White">
            <summary>Pure white</summary>
        </member>
        <member name="F:NQualityOfLife.Colors.Hex.Black">
            <summary>Pure black</summary>
        </member>
        <member name="F:NQualityOfLife.Colors.Hex.Red">
            <summary>Pure red</summary>
        </member>
        <member name="F:NQualityOfLife.Colors.Hex.Green">
            <summary>Pure green</summary>
        </member>
        <member name="F:NQualityOfLife.Colors.Hex.Blue">
            <summary>Pure blue</summary>
        </member>
        <member name="F:NQualityOfLife.Geometry.Rectangle.position">
            <summary>Top left corner</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.Rectangle.Position">
            <summary>Top left corner</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Diagonal">
            <summary>The distance from corner to corner</summary>
        </member>
        <member name="F:NQualityOfLife.Geometry.Square.position">
            <summary>Top left corner</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.Square.Position">
            <summary>Top left corner</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint2D.X">
            <summary>The X (Horizontal) position of the point</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint2D.Y">
            <summary>The Y (Vertical) position of the point</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.IPoint2D)">
            <summary>Get the distance to another point</summary><param name="other"></param>
            <returns>The eucledian distance from <see langword="this"/> point to the given point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.Point2D)">
            <summary>Get the distance to another point</summary><param name="other"></param>
            <returns>The eucledian distance from <see langword="this"/> point to the given point</returns>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint2D.Position">
            <summary>A <see cref="T:NQualityOfLife.Geometry.Point2D"/> representation of <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IPoint2D"/></summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Draw">
            <summary>Draw the point on the screen</summary>
            <returns>The point that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Draw(NQualityOfLife.Colors.IColor)">
            <summary>Draw the point on the screen in the given color</summary>
            <param name="iColor">What color to draw the point in</param><returns>The point that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Draw(UnityEngine.Color)">
            <summary>Draw the point on the screen in the given color</summary>
            <param name="color">What color to draw the point in</param><returns>The point that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.Point2D[])">
            <summary>Sum all positions</summary><param name="others"></param>
            <returns><see cref="T:NQualityOfLife.Geometry.Point2D"/> with a position that is the sum of all the positions of the given points</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.Point2D[])">
            <summary>The average position of all the given points</summary><param name="others"></param>
            <returns><see cref="T:NQualityOfLife.Geometry.Point2D"/> with a position that is the average of all the positions of the given points</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.IPoint2D[])">
            <summary>Sum all positions</summary><param name="others"></param>
            <returns><see cref="T:NQualityOfLife.Geometry.IPoint2D"/> with a position that is the sum of all the positions of the given points</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.IPoint2D[])">
            <summary>The average position of all the given points</summary><param name="others"></param>
            <returns><see cref="T:NQualityOfLife.Geometry.IPoint2D"/> with a position that is the average of all the positions of the given points</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.NewLine(NQualityOfLife.Geometry.Point2D)">
            <summary>Create a new line from the given points</summary><param name="endPoint">The B point of the Line2D</param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> starting at <see langword="this"/> point and ending with the given other point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.NewLine(NQualityOfLife.Geometry.Point2D,System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> that starts at <see langword="this"/> point and ends with a point in the direction of the given point, and with the given length</summary>
            <param name="endPointDirection"></param>
            <param name="distance"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Point(NQualityOfLife.Geometry.Point2D,System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> in the direction of the given point, and with the given <paramref name="distance"/> from <see langword="this"/> point</summary>
            <param name="endPointDirection"></param>
            <param name="distance"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Point(NQualityOfLife.Units.Degrees,System.Single)">
            <summary>Get a <see langword="new"/> point that is at the given <paramref name="angle"/> and <paramref name="distance"/> from <see langword="this"/> point</summary>
            <param name="angle"></param>
            <param name="distance"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.DirectionTo(NQualityOfLife.Geometry.Point2D)">
            <summary></summary>
            <param name="other"></param>
            <returns>A <see cref="T:NQualityOfLife.Types.Direction"/> vector pointing towards the <paramref name="other"/> point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Angle(NQualityOfLife.Geometry.Point2D)">
            <summary></summary>
            <param name="endPoint"></param>
            <returns>The angle towards the <paramref name="endPoint"/> in <see cref="T:NQualityOfLife.Units.Degrees"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.MidPoint(NQualityOfLife.Geometry.Point2D)">
            <summary>Get the mid point between two points</summary><param name="other"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> between <see langword="this"/> instance and the given <paramref name="other"/> point</returns>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint3D.X">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPoint2D.X"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint3D.Y">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPoint2D.Y"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.Distance(NQualityOfLife.Geometry.IPoint3D)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.IPoint2D)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.Distance(NQualityOfLife.Geometry.Point3D)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.Point2D)"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint3D.Position">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPoint2D.Position"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.SumOf(NQualityOfLife.Geometry.Point3D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.Point2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.AverageOf(NQualityOfLife.Geometry.Point3D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.Point2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.SumOf(NQualityOfLife.Geometry.IPoint3D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.IPoint2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.AverageOf(NQualityOfLife.Geometry.IPoint3D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.IPoint2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.NewLine(NQualityOfLife.Geometry.Point3D)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.NewLine(NQualityOfLife.Geometry.Point2D)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.DirectionTo(NQualityOfLife.Geometry.Point3D)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.DirectionTo(NQualityOfLife.Geometry.Point2D)"/>
        </member>
        <member name="T:NQualityOfLife.Geometry.ILine2D">
            <summary>A 2 dimensional line</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine2D.A">
            <summary>The A point / start of the line</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine2D.B">
            <summary>The B point / end of the line</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine2D.Middle">
            <summary>The midpoint between A and B</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine2D.Length">
            <summary>The Length of the line / distance between A and B</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Draw(System.Single)">
            <summary>Draw the line with the given line thickness and default color</summary>
            <param name="lineThickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Draw(NQualityOfLife.Colors.IColor,System.Single)">
            <summary>Draw the line with the given line thickness and color</summary>
            <param name="iColor">Draw the line in this color</param><param name="lineThickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Draw(UnityEngine.Color,System.Single)">
            <summary>Draw the line with the given line thickness and color</summary>
            <param name="color">Draw the line in this color</param><param name="lineThickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Deconstruct(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <summary></summary>
            <param name="a">A point of the line</param>
            <param name="b">B point of the line</param>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.Point2D)">
            <summary></summary><param name="point"></param>
            <returns><see langword="true"/> if the given point is any point on the line</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.IPoint2D)">
            <summary></summary><param name="point"></param>
            <returns><see langword="true"/> if the given point is any point on the line</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.SetAngleAroundA(NQualityOfLife.Units.Degrees)">
            <summary>Set the angle such that the 'A' point of the line stays in the same position</summary>
            <param name="degrees"></param><returns>A new line that has the same 'A' point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.SetAngleAroundB(NQualityOfLife.Units.Degrees)">
            <summary>Set the angle such that the 'B' point of the line stays in the same position</summary>
            <param name="degrees"></param><returns>A new line that has the same 'B' point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.RotateAroundA(NQualityOfLife.Units.Degrees)">
            <summary>Rotate the line such that the 'A' point of the line stays in the same position</summary>
            <param name="degrees"></param><returns>A new line that has the same 'A' point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.RotateAroundB(NQualityOfLife.Units.Degrees)">
            <summary>Rotate the line such that the 'B' point of the line stays in the same position</summary>
            <param name="degrees"></param><returns>A new line that has the same 'B' point</returns>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine3D.A">
            <inheritdoc cref="P:NQualityOfLife.Geometry.ILine2D.A"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine3D.B">
            <inheritdoc cref="P:NQualityOfLife.Geometry.ILine2D.B"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine3D.Middle">
            <summary>The midpoint between A and B</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine3D.Length">
            <summary>The Length between A and B</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine3D.Contains(NQualityOfLife.Geometry.Point3D)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.Point2D)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine3D.Contains(NQualityOfLife.Geometry.IPoint3D)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.IPoint2D)"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.Middle">
            <summary>The point in the middle of the shape.</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPolygon.Area">
            <summary>The area of the 2D shape</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Area">
            <summary>The area of the 3D shape</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Volume">
            <summary>The volume of the 3D shape</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Position">
            <summary>The point in the middle of the 3D shape. or the position of the point.</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Middle">
            <summary>The point in the middle of the 3D shape. or the position of the point.</summary>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle.InDegrees">
            <summary>The value of this <see cref="T:NQualityOfLife.Units.IAngle"/> in <see cref="T:NQualityOfLife.Units.Degrees"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle.InRadians">
            <summary>The value of this <see cref="T:NQualityOfLife.Units.IAngle"/> in <see cref="T:NQualityOfLife.Units.Radians"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle.ToDegrees">
            <summary>The value of this <see cref="T:NQualityOfLife.Units.IAngle"/> converted to <see cref="T:NQualityOfLife.Units.Degrees"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle.ToRadians">
            <summary>The value of this <see cref="T:NQualityOfLife.Units.IAngle"/> converted to <see cref="T:NQualityOfLife.Units.Radians"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.IAngle`1">
            <summary></summary>
            <typeparam name="TU">The unit of the <see cref="T:NQualityOfLife.Units.IAngle"/></typeparam>
        </member>
        <member name="M:NQualityOfLife.Units.IAngle`1.Abs">
            <summary>Get the Absolute value</summary>
            <returns>The absolute value (non negative) of the angle</returns>
            <remarks>y = |x|</remarks>
        </member>
        <member name="M:NQualityOfLife.Units.IAngle`1.Normalize">
            <summary></summary>
            <returns>0~360 <see cref="T:NQualityOfLife.Units.Degrees"/> in <typeparamref name="TU"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.IAngle`1.NormalizeSigned">
            <summary></summary>
            <returns>-180~180 <see cref="T:NQualityOfLife.Units.Degrees"/> in <typeparamref name="TU"/></returns>
        </member>
        <member name="F:NQualityOfLife.Units.Degrees.valueDegrees">
            <summary><see cref="T:NQualityOfLife.Units.Degrees"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Degrees.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Degrees.valueDegrees"/>
        </member>
        <member name="F:NQualityOfLife.Units.Radians.valueRadians">
            <summary><see cref="T:NQualityOfLife.Units.Radians"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Radians.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Radians.valueRadians"/>
        </member>
        <member name="T:NQualityOfLife.Units.AngularVelocity_ω">
            <summary>AngularVelocity ω || <see cref="T:NQualityOfLife.Units.Radians"/> / <see cref="T:NQualityOfLife.Units.Second"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.AngularVelocity_ω._radiansPerSecond">
            <inheritdoc cref="T:NQualityOfLife.Units.AngularVelocity_ω"/>
        </member>
        <member name="P:NQualityOfLife.Units.AngularVelocity_ω.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.AngularVelocity_ω._radiansPerSecond"/>
        </member>
        <member name="M:NQualityOfLife.Units.Distance.#ctor(NQualityOfLife.Units.Velocity,NQualityOfLife.Units.Second)">
            <summary>The distance traveled in the given time at the given speed</summary>
            <param name="velocity">The constant velocity/speed vector</param><param name="time">How long to travel at the given speed</param>
        </member>
        <member name="F:NQualityOfLife.Units.Rankine.ZeroCelciusRa">
            <summary>Freezing point of water in <see cref="T:NQualityOfLife.Units.Rankine"/> (0°C)</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Rankine.ZeroFahrenheitRa">
            <summary>Zero <see cref="T:NQualityOfLife.Units.Fahrenheit"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Rankine.Ra">
            <summary>Rankine</summary>
        </member>
        <member name="P:NQualityOfLife.Units.Rankine.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Rankine.Ra"/>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Rankine,NQualityOfLife.Units.Rankine)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Rankine,NQualityOfLife.Units.Fahrenheit)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Fahrenheit,NQualityOfLife.Units.Rankine)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Rankine,NQualityOfLife.Units.Kelvin)">
            <summary></summary><param name="left"></param><param name="kelvin"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Kelvin,NQualityOfLife.Units.Rankine)">
            <summary></summary><param name="kelvin"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.IdealGasConstant.op_Multiply(NQualityOfLife.Units.IdealGasConstant,NQualityOfLife.Units.Kelvin)">
            <summary></summary>
            <param name="gasConstant"></param>
            <param name="temperature"></param>
            <returns><see cref="T:NQualityOfLife.Units.AbstractUnit"/> with a dimension of (T^-2L²MN^-1)</returns>
        </member>
        <member name="M:NQualityOfLife.Units.IdealGasConstant.op_Multiply(NQualityOfLife.Units.Kelvin,NQualityOfLife.Units.IdealGasConstant)">
            <summary></summary>
            <param name="gasConstant"></param>
            <param name="temperature"></param>
            <returns><see cref="T:NQualityOfLife.Units.AbstractUnit"/> with a dimension of (T^-2L²MN^-1)</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Mol.#ctor(NQualityOfLife.Units.Pascal,NQualityOfLife.Units.Volume,NQualityOfLife.Units.Kelvin)">
            <summary>Get the amount of matter using the ideal gas law</summary>
            <param name="pressure"></param>
            <param name="volumeOfContainer"></param>
            <param name="temperature"></param>
        </member>
        <member name="T:NQualityOfLife.Units.IDimensionallyEquivalent`2">
            <summary>The unit is dimensionally equivalent to another unit, but not used in the same context / is not meaningfully comparable.</summary>
            <typeparam name="TA"></typeparam><typeparam name="TB"></typeparam>
        </member>
        <member name="T:NQualityOfLife.Units.Torque">
            <summary>Unit for Torque - NewtonMeter - (<see cref="T:NQualityOfLife.Units.Newton"/> * <see cref="T:NQualityOfLife.Units.Meter"/>)</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Acceleration">
            <summary>Acceleration - m/s^2</summary>
        </member>
        <member name="T:NQualityOfLife.Units.AccelerationVector">
            <summary>3D acceleration vector</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Area">
            <summary>Unit of <see cref="T:NQualityOfLife.Units.Area"/> || Usually used with <see cref="T:NQualityOfLife.Units.Meter"/> but that is not required</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Joule">
            <summary>The Joule is an unit of energy</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Joule.j">
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="T:NQualityOfLife.Units.ISpeed`1">
            <summary></summary>
            <typeparam name="U">The unit of speed</typeparam>
        </member>
        <member name="P:NQualityOfLife.Units.ISpeed`1.SpeedOfLight">
            <summary><seealso href="https://en.wikipedia.org/wiki/Speed_of_light">Speed of light</seealso> in units of <typeparamref name="U"/> || Also known as the <seealso href="https://en.wikipedia.org/wiki/Planck_units">Planck speed</seealso></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ISpeed`1.InPlanckSpeed">
            <summary>The speed of <see langword="this"/> <typeparamref name="U"/> in <see cref="T:NQualityOfLife.Units.PlanckSpeed"/></summary>
        </member>
        <member name="M:NQualityOfLife.Units.PlanckSpeed.#ctor(NQualityOfLife.Units.Acceleration,NQualityOfLife.Units.Second)">
            <summary>The speed delta from accelerating at the given rate for the given time</summary>
            <param name="acceleration"></param>
            <param name="seconds"></param>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Acceleration,NQualityOfLife.Units.Second)">
            <summary>The speed delta from accelerating at the given rate for the given time</summary>
            <param name="acceleration"></param>
            <param name="seconds"></param>
        </member>
        <member name="P:NQualityOfLife.Units.Speed.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Speed.metersPerSecond"/>
        </member>
        <member name="T:NQualityOfLife.Units.IVelocity`1">
            <summary>A vector that can be used to reprecent velocity in a 2D or 3D context</summary>
            <typeparam name="TSpeed">The unit of speed</typeparam>
        </member>
        <member name="T:NQualityOfLife.Units.Velocity">
            <summary>Velocity is a 3D speed vector</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Joule)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> of a container with <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/> and the given <paramref name="energy"/></summary>
            <param name="energy"></param>
            <returns>The <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> inside this <see cref="T:NQualityOfLife.Units.Volume"/> with the given <paramref name="energy"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Pascal)">
            <summary>Solve the total <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> inside <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/> at the given <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso></summary>
            <param name="pressure"></param>
            <returns>The total <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> inside <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Mol,NQualityOfLife.Units.Kelvin)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> inside the <see cref="T:NQualityOfLife.Units.Volume"/> when it has the given amount of matter at the specified <paramref name="temperature"/></summary>
            <param name="a"></param>
            <param name="temperature"></param>
            <returns>The resulting <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Kelvin,NQualityOfLife.Units.Mol)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Mol,NQualityOfLife.Units.Kelvin)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Pascal,NQualityOfLife.Units.Mol)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Kelvin">temperature</seealso> of the gas inside the <see cref="T:NQualityOfLife.Units.Volume"/> when at the given <paramref name="pressure"/></summary>
            <param name="pressure"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Mol,NQualityOfLife.Units.Pascal)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Pascal,NQualityOfLife.Units.Mol)"/>
        </member>
        <member name="T:NQualityOfLife.Units.IDimension">
            <summary>Interface for units - Used for <see href="https://en.wikipedia.org/wiki/Dimensional_analysis">dimensional analysis</see></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IDimension.Dimension">
            <summary>The dimensionality of the unit</summary>
        </member>
        <member name="T:NQualityOfLife.Units.IMetricSystem">
            <summary>Interface for units of the metric system</summary>
        </member>
        <member name="T:NQualityOfLife.Units.IMetricSystemFloats">
            <summary>Interface for units of the metric system</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Dimension">
            <summary><see langword="struct"/> for performing <see href="https://en.wikipedia.org/wiki/Dimensional_analysis">Dimensional analysis</see></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Dimension.BaseDimension">
            <summary>The base dimensions that all other dimensions / units are derived from</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.T">
            <summary>Time dimension - <see cref="T:NQualityOfLife.Units.Second"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.L">
            <summary>Length dimension - <see cref="T:NQualityOfLife.Units.Meter"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.M">
            <summary>Mass dimension - <see cref="T:NQualityOfLife.Units.Kg"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.I">
            <summary>Electric Current dimension - <see cref="T:NQualityOfLife.Units.Ampere"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.Θ">
            <summary>Absolute Temperature dimension - <see cref="T:NQualityOfLife.Units.Kelvin"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.N">
            <summary>Amount of Substance dimension - <see cref="T:NQualityOfLife.Units.Mol"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.J">
            <summary>Luminous Intensity dimension</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Dimension.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Create a Dimension object with the given dimensions</summary>
            <param name="T">Time - <see cref="T:NQualityOfLife.Units.Second"/></param>
            <param name="L">Length dimension - <see cref="T:NQualityOfLife.Units.Meter"/></param>
            <param name="M">Mass dimension - <see cref="T:NQualityOfLife.Units.Kg"/></param>
            <param name="I">Electric Current dimension - <see cref="T:NQualityOfLife.Units.Ampere"/></param>
            <param name="Θ">Absolute Temperature dimension - <see cref="T:NQualityOfLife.Units.Kelvin"/></param>
            <param name="N">Amount of Substance dimension - <see cref="T:NQualityOfLife.Units.Mol"/></param>
            <param name="J">Luminous Intensity dimension</param>
        </member>
        <member name="T:NQualityOfLife.Units.Dimension.ParseStep">
            <summary>enum for tracking the state of the string parser</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Dimension.#ctor(System.String)">
            <summary>Create a <see cref="T:NQualityOfLife.Units.Dimension"/> object with the given dimensions parsed from a <see cref="T:System.String"/></summary>
            <param name="fromString"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Internal error if the parser tries to access an invalid dimension address</exception>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Time">
            <summary>Time - <see cref="T:NQualityOfLife.Units.Second"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Length">
            <summary>Length - <see cref="T:NQualityOfLife.Units.Meter"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Mass">
            <summary>Mass - <see cref="T:NQualityOfLife.Units.Kg"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Temperature">
            <summary>Absolute Temperature - <see cref="T:NQualityOfLife.Units.Kelvin"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.AmountOfSubstance">
            <summary>Amount Of Substance - <see cref="T:NQualityOfLife.Units.Mol"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Frequency">
            <summary>Frequency - <see cref="T:NQualityOfLife.Units.Hertz"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricalResistivity">
            <summary><seealso href="https://en.wikipedia.org/wiki/Electrical_resistivity_and_conductivity">Resistivity</seealso> is a property of materials.</summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricalConductivity">
            <summary><seealso href="https://en.wikipedia.org/wiki/Electrical_resistivity_and_conductivity">Conductivity</seealso> is a property of materials.</summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricPotentialDifference">
            <summary>Electric Potential Difference - <see cref="T:NQualityOfLife.Units.Volt"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ThermalResistivity">
            <summary><seealso href="https://en.wikipedia.org/wiki/Thermal_conductivity_and_resistivity">Resistivity</seealso> is a property of materials.</summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ThermalConductivity">
            <summary><seealso href="https://en.wikipedia.org/wiki/Thermal_conductivity_and_resistivity">Conductivity</seealso> is a property of materials.</summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Energy">
            <summary>Energy - <see cref="T:NQualityOfLife.Units.Joule"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Force">
            <summary>Force - <see cref="T:NQualityOfLife.Units.Newton"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Resistance">
            <summary>Electrical Resistance - <see cref="T:NQualityOfLife.Units.OhmΩ"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Acceleration">
            <summary>The <see cref="T:NQualityOfLife.Units.Dimension"/> of <see cref="P:NQualityOfLife.Units.Dimension.Acceleration"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Power">
            <summary>Power - <see cref="T:NQualityOfLife.Units.Watt"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Area">
            <summary><seealso cref="T:NQualityOfLife.Units.Area">Area</seealso> has a dimensionality of <seealso cref="P:NQualityOfLife.Units.Dimension.Length">Length</seealso> * <seealso cref="P:NQualityOfLife.Units.Dimension.Length">Length</seealso></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Pressure">
            <summary>The <see cref="T:NQualityOfLife.Units.Dimension"/> of <see cref="P:NQualityOfLife.Units.Dimension.Pressure"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Capacitance">
            <summary>The <see cref="T:NQualityOfLife.Units.Dimension"/> of <see cref="P:NQualityOfLife.Units.Dimension.Capacitance"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Inductance">
            <summary>The <see cref="T:NQualityOfLife.Units.Dimension"/> of <see cref="P:NQualityOfLife.Units.Dimension.Inductance"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Volume">
            <summary>The <see cref="T:NQualityOfLife.Units.Dimension"/> of <see cref="P:NQualityOfLife.Units.Dimension.Volume"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Farad">
            <summary>An unit of capacitance || coulomb per volt || The capacity for a body to store charge</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Farad.capacitance">
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.ReactanceX,NQualityOfLife.Units.AngularVelocity_ω)">
            <summary>1/(<seealso cref="T:NQualityOfLife.Units.AngularVelocity_ω">ω</seealso><seealso cref="F:NQualityOfLife.Utils.Common.Chars.dotProd">⋅</seealso>|Xc|)</summary>
            <param name="reactanceXc"></param>
            <param name="angularVelocity"></param>
        </member>
        <member name="P:NQualityOfLife.Units.Farad.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Farad.capacitance"/>
        </member>
        <member name="T:NQualityOfLife.Units.ICharge">
            <summary>Electric charge</summary>
        </member>
        <member name="T:NQualityOfLife.Units.ElementaryCharge">
            <summary>The charge of one electron(-) or proton(+)</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Charge">
            <summary>Coulomb is the unit of electric charge || "It is defined to be equal to the electric charge delivered by a 1 ampere current in 1 second."(Wikipedia) || Coulomb == Ampere * Second</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.op_Division(NQualityOfLife.Units.Charge,NQualityOfLife.Units.Second)">
            <summary></summary><param name="charge"></param><param name="time"></param>
            <returns>The current that the given charge can produce for the given time</returns>
        </member>
        <member name="T:NQualityOfLife.Units.Ampere">
            <summary>Ampere is how many Charges / Second are moving past a given point</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.op_Multiply(NQualityOfLife.Units.Ampere,NQualityOfLife.Units.Second)">
            <summary></summary><param name="current"></param><param name="time"></param>
            <returns>The total charge transferred at the given current and time</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.op_Multiply(NQualityOfLife.Units.Second,NQualityOfLife.Units.Ampere)">
            <summary></summary><param name="current"></param><param name="time"></param>
            <returns>The total charge transferred at the given current and time</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.op_Multiply(NQualityOfLife.Units.Ampere,NQualityOfLife.Units.OhmΩ)">
            <summary></summary><param name="current"></param><param name="resistance"></param>
            <returns>The voltage over the resistor with the given current</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.op_Multiply(NQualityOfLife.Units.OhmΩ,NQualityOfLife.Units.Ampere)">
            <summary></summary><param name="current"></param><param name="resistance"></param>
            <returns>The voltage over the resistor with the given current</returns>
        </member>
        <member name="T:NQualityOfLife.Units.Henry">
            <summary>The Henry is the unit of electrical inductance</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Henry.henry">
            <inheritdoc cref="T:NQualityOfLife.Units.Henry"/>
        </member>
        <member name="T:NQualityOfLife.Units.Tesla">
            <summary>The <see cref="T:NQualityOfLife.Units.Tesla"/> is an unit of <seealso cref="T:NQualityOfLife.Units.Weber">magnetic flux</seealso> density || <see cref="T:NQualityOfLife.Units.Weber"/> per square meter</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Weber">
            <summary>volt second || The Weber is an unit of magnetic flux || 1Wb == 1V * 1s || Weber == Henry * Ampere</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Watt">
            <summary>The Watt is an unit of power || the energy(Joule) / second(Second)</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Multiply(NQualityOfLife.Units.Watt,NQualityOfLife.Units.Second)">
            <summary></summary><param name="power"></param><param name="time"></param>
            <returns>The total energy over time with the given power</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Multiply(NQualityOfLife.Units.Second,NQualityOfLife.Units.Watt)">
            <summary></summary><param name="power"></param><param name="time"></param>
            <returns>The total energy over time with the given power</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Division(NQualityOfLife.Units.Watt,NQualityOfLife.Units.Ampere)">
            <summary></summary><param name="power"></param><param name="perCurrent"></param>
            <returns>The voltage required to achieve the given power with the given current</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Division(NQualityOfLife.Units.Watt,NQualityOfLife.Units.Volt)">
            <summary></summary><param name="power"></param><param name="voltage"></param>
            <returns>The current required to achieve the given power with the given voltage</returns>
        </member>
        <member name="T:NQualityOfLife.Units.Resistivity">
            <summary>Electrical Resistivity</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Conductivity">
            <summary>Electrical Conductivity</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Volt">
            <summary>The Volt is an unit of electric potential</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Volt.volts">
            <inheritdoc cref="T:NQualityOfLife.Units.Volt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Multiply(NQualityOfLife.Units.Charge,NQualityOfLife.Units.Volt)">
            <summary></summary>
            <param name="charge"></param>
            <param name="voltage"></param>
            <returns>The total amount of stored energy</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Multiply(NQualityOfLife.Units.Volt,NQualityOfLife.Units.Charge)">
            <summary></summary>
            <param name="charge"></param>
            <param name="voltage"></param>
            <returns>The total amount of stored energy</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Division(NQualityOfLife.Units.Volt,NQualityOfLife.Units.Ampere)">
            <summary></summary>
            <param name="voltage"></param>
            <param name="current"></param>
            <returns>The resistance of the system with the given current and voltage</returns>
        </member>
        <member name="T:NQualityOfLife.Units.Newton">
            <summary>The <see cref="T:NQualityOfLife.Units.Newton"/> is an unit of <seealso cref="T:NQualityOfLife.Units.IForce">force</seealso></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Newton.newtons">
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="T:NQualityOfLife.Units.Force">
            <summary><see cref="T:NQualityOfLife.Units.Force"/> vector</summary>
        </member>
        <member name="T:NQualityOfLife.Units.AbstractUnit">
            <summary>A Value that has some other dimensionality than any defined unit.</summary>
        </member>
        <member name="T:NQualityOfLife.Units.ThermalResistivity">
            <summary>Thermal Resistivity</summary>
        </member>
        <member name="T:NQualityOfLife.Units.ThermalConductivity">
            <summary>Thermal Conductivity</summary>
        </member>
        <member name="P:NQualityOfLife.Units.BoltzmannConstant.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.BoltzmannConstant.valJoulesPerKelvin"/>
        </member>
        <member name="T:NQualityOfLife.Units.HeatCapacity">
            <summary>Heat capacity - joules/Kelvin</summary>
        </member>
        <member name="T:NQualityOfLife.Units.SpecificHeatCapacity">
            <summary>Specific heat capacity - J/(Kg*K)</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Gray">
            <summary>Unit for absorbed dose of ionizing radiation - J/Kg - (<see cref="T:NQualityOfLife.Units.Joule"/> / <see cref="T:NQualityOfLife.Units.Kg"/>) || 1 <see cref="T:NQualityOfLife.Units.Gray"/> == 100 <see cref="T:NQualityOfLife.Units.Rad"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Rad">
            <summary>Unit for absorbed dose of ionizing radiation - 1 <see cref="T:NQualityOfLife.Units.Rad"/> == 0.01 <see cref="T:NQualityOfLife.Units.Gray"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Roentgen_Rem">
            <summary>Unit for Health effect of ionizing radiation - 1 <see cref="T:NQualityOfLife.Units.Roentgen_Rem"/> == 0.01 <see cref="T:NQualityOfLife.Units.Sievert"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Sievert">
            <summary>Unit for Health effect of ionizing radiation - J/Kg - (<see cref="T:NQualityOfLife.Units.Joule"/> / <see cref="T:NQualityOfLife.Units.Kg"/>) || 1 <see cref="T:NQualityOfLife.Units.Sievert"/> == 100 <see cref="T:NQualityOfLife.Units.Roentgen_Rem"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.RadiationExposure">
            <summary>Unit for Radiation Exposure - C/Kg - (<see cref="T:NQualityOfLife.Units.Charge"/> / <see cref="T:NQualityOfLife.Units.Kg"/>)</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Roentgen">
            <summary>Unit for Radiation Exposure || 1 <see cref="T:NQualityOfLife.Units.Roentgen"/> == 2.58×10^−4 <see cref="T:NQualityOfLife.Units.Charge"/>/<see cref="T:NQualityOfLife.Units.Kg"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Celsius">
            <summary>Celsius degrees</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Celsius.AbsoluteZeroC">
            <summary>Absolute zero in Celsius</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Celsius.C">
            <summary>floating point value in Celsius</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Equality(NQualityOfLife.Units.Celsius,NQualityOfLife.Units.Celsius)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Equality(NQualityOfLife.Units.Celsius,System.Single)">
            <summary></summary><param name="left"></param><param name="celsius">A floating point number in Celsius</param><returns>True if the two temperature values represent the same temperature || True if the two Celsius degree values are equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Inequality(NQualityOfLife.Units.Celsius,System.Single)">
            <summary></summary><param name="left"></param><param name="celsius">A floating point number in Celsius</param><returns>True if the two Celsius degree values are not equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Equality(System.Single,NQualityOfLife.Units.Celsius)">
            <summary></summary><param name="right"></param><param name="celsius">A floating point number in Celsius</param><returns>True if the two temperature values represent the same temperature || True if the two Celsius degree values are equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Inequality(System.Single,NQualityOfLife.Units.Celsius)">
            <summary></summary><param name="right"></param><param name="celsius">A floating point number in Celsius</param><returns>True if the two Celsius degree values are not equal</returns>
        </member>
        <member name="F:NQualityOfLife.Units.Fahrenheit.AbsoluteZeroF">
            <summary>Absolute Zero in Fahrenheit (0K)</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Fahrenheit.ZeroCelciusF">
            <summary>Freezing point of water in Fahrenheit (0°C)</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Fahrenheit.F">
            <summary>Fahrenheit</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Fahrenheit,NQualityOfLife.Units.Fahrenheit)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Fahrenheit,NQualityOfLife.Units.Kelvin)">
            <summary></summary><param name="left"></param><param name="kelvin"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Fahrenheit,NQualityOfLife.Units.Celsius)">
            <summary></summary><param name="left"></param><param name="celsius"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Kelvin,NQualityOfLife.Units.Fahrenheit)">
            <summary></summary><param name="kelvin"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Celsius,NQualityOfLife.Units.Fahrenheit)">
            <summary></summary><param name="celsius"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Fahrenheit,System.Single)">
            <summary></summary><param name="left"></param><param name="fahrenheit"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(System.Single,NQualityOfLife.Units.Fahrenheit)">
            <summary></summary><param name="fahrenheit"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="T:NQualityOfLife.Units.ITemperature">
            <summary>Interface for temperature units</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.IsAbsoluteZero">
            <summary>Is the current value of this instance 0 <see cref="T:NQualityOfLife.Units.Kelvin"/>?</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.ToC">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Celsius"/> degrees</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.InC">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Celsius"/> degrees as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.ToK">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Kelvin"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.InK">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Kelvin"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.ToF">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Fahrenheit"/> degrees</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.InF">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Fahrenheit"/> degrees as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperatureAdditional.ToRa">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Rankine"/> degrees</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperatureAdditional.InRa">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Rankine"/> degrees as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Kelvin">
            <summary>Kelvin is the unit of absolute temperature</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Kelvin.ZeroCelsiusK">
            <summary>0C in kelvin</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Kelvin.K">
            <summary>Kelvin</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Kelvin.#ctor(System.Single)">
            <summary></summary>
            <param name="kelvin"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:NQualityOfLife.IO.IIO">
            <summary>Interface for file paths and folders</summary>
        </member>
        <member name="P:NQualityOfLife.IO.IIO.Exists">
            <summary>Returns <see langword="true"/> if the <see cref="T:System.IO.Directory"/> or <see cref="T:System.IO.File"/> exists and is found</summary>
        </member>
        <member name="T:NQualityOfLife.IO.IFolder">
            <summary>Interface for folders / <seealso cref="T:System.IO.Directory">directories</seealso></summary>
        </member>
        <member name="T:NQualityOfLife.IO.IFile">
            <summary>Interface for files</summary>
        </member>
        <member name="T:NQualityOfLife.IO.IFileType">
            <summary>Interface for files</summary>
        </member>
        <member name="P:NQualityOfLife.IO.IFileType.FileExtension">
            <summary>The file extension string of the file, such as 'xml', 'txt' or 'png'</summary>
        </member>
        <member name="P:NQualityOfLife.IO.FolderPath.Exists">
            <inheritdoc cref="M:System.IO.Directory.Exists(System.String)"/>
        </member>
        <member name="P:NQualityOfLife.IO.FilePath.Exists">
            <inheritdoc cref="M:System.IO.File.Exists(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FileName.#ctor(System.String,System.String)">
            <summary></summary>
            <param name="name">The name of the file</param>
            <param name="extension">The file extension || do not include the dot</param>
        </member>
        <member name="F:NQualityOfLife.IO.File_.myLocalModPath">
            <summary>The path on my local PC, only intended to be used for DEV tools that are not supposed to work or be included in released features</summary>
        </member>
        <member name="M:NQualityOfLife.IO.File_.CaptureFirstMatchingXMLNode(System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="rawText"></param>
            <param name="xmlNode"></param>
            <param name="targetNodeData">Data inside the node must match this.</param>
            <param name="debugLogging"></param>
            <returns>3 nulls if no match found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ReplaceFirstMatchingXMLNode(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="originalRawText"></param>
            <param name="xmlNode"></param>
            <param name="newValue"></param>
            <param name="oldValue">Node must have this value to be matched</param>
            <param name="debugLogging"></param>
            <returns>The input text with the specified node replaced</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.UpdateAboutXML(NQualityOfLife.IO.FolderPath,NQualityOfLife.IO.FileName,System.Boolean)">
            <summary></summary>
            <param name="folderPath"></param>
            <param name="fileName"></param>
            <param name="debugLogging"></param>
            <returns><see langword="true"/> if was successfully updated or no update needed, || <see langword="false"/> if update failed</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.IncrementVersion(System.String,System.String@)">
            <summary></summary>
            <param name="oldVersion"></param>
            <param name="newVersion"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.WriteTextFile(NQualityOfLife.IO.FilePath,System.String)">
            <summary>Set the text of the specified file to the given <paramref name="text"/><para>If the file doesn't exist a new one is created. Else it is overwritten</para></summary>
            <param name="filePath">The full path to the target file</param>
            <param name="text">The new text for the file</param>
            <returns><see langword="false"/> if there was an error</returns>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ReadFirstLine(NQualityOfLife.IO.FilePath)">
            <summary>Reads the first line of the specified text file</summary>
            <param name="filePath">The full path to the file</param>
            <returns>The text <see cref="T:System.String"/> on the first line or <see langword="null"/> if failed</returns>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateFolderPath(NQualityOfLife.IO.FolderPath)">
            <summary>Makes sure the path is valid and that the target folder exists</summary>
            <param name="folderPath"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateFilePath(NQualityOfLife.IO.FilePath)">
            <summary>Makes sure the path is valid and that the target file exists</summary>
            <param name="fullFilePath"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateXMLFile(NQualityOfLife.IO.FolderPath,NQualityOfLife.IO.FileName,System.Boolean,System.Boolean)">
            <summary>Checks the validity of the path <seealso cref="T:System.String">strings</seealso>, if the fileName ends with an xml file, if the file exists, and has a valid xml header</summary>
            <param name="folderPath">The folder path of the file</param>
            <param name="fileName">The name of the file, must end with '.xml' to be valid</param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="isNewFile"></param>
            <returns><see langword="true"/> if valid, else <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateXMLFile(NQualityOfLife.IO.FilePath,System.Boolean,System.Boolean)">
            <summary>Checks the validity of the path <see cref="T:System.String"/>, if it ends with an xml file, if the file exists, and has a valid xml header</summary>
            <param name="filePath">The full file path of the target file</param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="isNewFile"></param>
            <returns>True if valid, else false</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.OverWriteFirstMatchingXMLNode(NQualityOfLife.IO.FolderPath,NQualityOfLife.IO.FileName,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="folderPath"></param>
            <param name="fileName"></param>
            <param name="xmlNode"></param>
            <param name="newValue"></param>
            <param name="oldValue"></param>
            <param name="xmlNode2"></param>
            <param name="newValue2"></param>
            <param name="oldValue2"></param>
            <param name="debugLogging"></param>
            <returns>True if the write was succesfull, or no changes were needed</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.CreateAnalyzerXML(System.Reflection.Assembly,System.String,NQualityOfLife.IO.FileName,NQualityOfLife.IO.FolderPath,System.Boolean,System.Boolean)">
            <summary>Create an 'Analyzer.xml' file for use with 'Dubs Performance Analyzer'</summary>
            <param name="assembly">Create the Analyzer.xml for this <see cref="T:System.Reflection.Assembly"/></param>
            <param name="categoryName">The category name that will be displayed in game in the analyzer ui</param>
            <param name="fileName">Must be: 'Analyzer.xml' for the analyzer to detect it.</param>
            <param name="folderPath">Where to create the file? Should be the root folder of the mod, or the analyzer wont find it.</param>
            <param name="allowOverWrite">Allow over writing the existing file?</param>
            <param name="creatingNew">Are we creating a new file?</param>
            <returns><see langword="true"/> if file creation was successful, else <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAssembliesFromFolder(System.IO.DirectoryInfo,System.String@,System.Boolean,System.Boolean,System.String)">
            <summary>Get a list of (reflection only) <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> in the specified <paramref name="folder"/>, or in sub folders of the specified folder</summary>
            <param name="folder"><see cref="T:System.IO.DirectoryInfo"/> of the target <paramref name="folder"/></param>
            <param name="message">Error message <see cref="T:System.String"/> or <see langword="null"/> if no error</param>
            <param name="checkSubFolders">Also get <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> from sub folders inside the specified folder</param>
            <param name="onlyAsFallback">Only check for <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> in sub folders, if none were found in the primary target folder, <paramref name="checkSubFolders"/> must also be <see langword="true"/></param>
            <param name="assemblyFolderMustBeCalled">The <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> must be inside a folder named x, if <see langword="null"/>: this condition is ignored</param>
            <returns>List of the found <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> or empty list</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAssembliesFromFolder(System.Collections.Generic.List{System.Reflection.Assembly}@,NQualityOfLife.IO.FolderPath,System.String@,System.String)">
            <summary>Add the (reflection only) <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> from a folder to an existing list of <seealso cref="T:System.Reflection.Assembly">assemblies</seealso>, or if the list is null, create a new list.</summary>
            <param name="assemblies">A pre existing list of <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> that we want to add more <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> to</param>
            <param name="folderPath">The full file <paramref name="folderPath"/> to the folder that contains the <seealso cref="T:System.Reflection.Assembly">assemblies</seealso></param>
            <param name="message">Soft error message <see cref="T:System.String"/></param>
            <param name="assemblyFolderMustBeCalled">The folder that contains the .dll files must have this name</param>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAssembliesFromFolder(NQualityOfLife.IO.FolderPath,System.String@,System.Boolean,System.Boolean,System.String)">
            <summary>Get a list of (reflection only) <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> in the specified folder folderPath, or in sub folders of the specified folder</summary>
            <param name="folderPath">Full folderPath to the target folder, such as a mod root folder</param>
            <param name="message">Error message <see cref="T:System.String"/> or <see langword="null"/> if no error</param>
            <param name="checkSubFolders">Also get <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> from sub folders inside the specified folder</param>
            <param name="onlyAsFallback">Only check for <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> in sub folders, if none were found in the primary target folder, checkSubFolders must also be true</param>
            <param name="assemblyFolderMustBeCalled">The <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> must be inside a folder named x, if <see langword="null"/>: this condition is ignored</param>
            <returns>List of the found <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> or empty list - never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFileVersion(NQualityOfLife.IO.FilePath,System.String@)">
            <summary>Get the file version of the file at the given path</summary>
            <param name="filePath"></param>
            <param name="message"></param>
            <returns><see langword="null"/>, <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null symbol</seealso> or the found version</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAssemblyVersion(System.Reflection.Assembly,System.String@)">
            <summary>Get the version from the assembly meta data</summary>
            <param name="assembly"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFileVersion(System.Reflection.Assembly,System.String@)">
            <summary>Get the actual file version of the given assembly (.dll) file</summary>
            <param name="assembly"></param><param name="message"></param>
            <returns>The file version of the actual .dll file.</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetVersion(System.Reflection.Assembly,System.String@,System.String@)">
            <summary>Get the file and assembly version of the given assembly</summary>
            <param name="assembly"></param>
            <param name="messageFileVer">The file version of the actual .dll file</param>
            <param name="messageAssemblyVer">The internal version from the assembly metadata</param>
            <returns>(<see cref="T:System.String"/>? fileVersion, <see cref="T:System.String"/>? assemblyVersion)</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetVersion(Verse.ModMetaData,System.String@)">
            <summary>Try get the mod version from the meta data - Tries to look for the version in the description text if no explicit version field exists - Returns null if the version data is not given or found</summary>
            <param name="modMetaData"></param><param name="message"><see langword="null"/> if was succesfull, else contains some info about why info was not found</param>
            <returns>null if no version field or info was found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetVersion(Verse.Mod,System.String@,System.String@,System.String)">
            <summary>Try get the mod version in order: About.xml -> Assembly (version and or file version)</summary>
            <param name="mod"></param>
            <param name="message_FileVer"></param>
            <param name="message_AssemblyVer"></param>
            <param name="skipAssembliesWith">Skip assemblies with the provided <see cref="T:System.String"/> in their name</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAboutFile(NQualityOfLife.IO.FolderPath,System.String@)">
            <summary>Get a FileInfo of the about xml, or <see langword="null"/> if not found</summary>
            <param name="aboutFolderPath">The full path to the About folder that contains the About.xml</param>
            <param name="message">Error message or <see langword="null"/></param>
            <returns>FileInfo of the About.xml or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFile(NQualityOfLife.IO.FolderPath,NQualityOfLife.IO.FileName,System.String@)">
            <summary>Get a file from a folder</summary>
            <param name="fileName">Tho path to the folder containing the file.</param>
            <param name="message">Error message or <see langword="null"/></param>
            <param name="folderPath">The name of the file to get</param>
            <returns>FileInfo of the file or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetXMLNode_FromModAboutFile(System.String,System.String,Verse.ModMetaData,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Gets the xmlNodes inside the specified node</summary>
            <param name="modPackageId">For example "niilo007.niilosqol"</param>
            <param name="xmlNode">Format in the name of the node, with no slashes or greater / less than symbols For example: "supportedVersions"</param>
            <param name="metaData"></param>
            <param name="logNonCaptureRelatedErrors"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns><see cref="T:System.String"/> of the value inside the node, or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFirstMatchingXMLNode_FromFile(System.IO.FileInfo,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="file"></param>
            <param name="xmlNode"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFirstMatchingXMLNode_FromFile(NQualityOfLife.IO.FilePath,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="filePath"></param>
            <param name="xmlNode"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Medical.Hediffs.HediffGiverDormantDisease">
            <summary>Will randomly give the specified <see cref="T:Verse.HediffDef"/> to the <see cref="T:Verse.Pawn"/><para>The <see cref="T:Verse.Hediff"/> must be of the <see cref="T:System.Type"/> <see cref="T:NQualityOfLife.Medical.Hediffs.DormantDisease"/></para></summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.PreCachedMedicalMasks.preCachedApparelThatHelpsGermResistance">
            <summary>This is used for the disease spread message, it does not contain all germ resistant apparel. Helmets are excluded for example.</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.PreCachedMedicalMasks.preCachedMedicalMasks">
            <summary>Contains specifically medical apparel, such as the surgical mask from vanilla expanded. This list is used for extra buffs in calculations.</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.GermMaker.MakeOrGetGermForDisease(Verse.HediffDef,System.Boolean@)">
            <summary>Create a filth germ def for the disease, or get a manuallu defined def</summary>
            <param name="hediffDef"></param>
            <param name="gotExisting"></param>
            <returns><see cref="T:Verse.ThingDef"/> of the germs associated with the <paramref name="hediffDef"/> || <see langword="null"/> only if there was an error</returns>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.GermMaker.diseaseSpreadEnabled">
            <summary>Is the disease spread system enabled?</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.GermMaker.difficultyRatio">
            <summary>Affects base infection chance</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.TryMakeFilth_Fast(Verse.ThingDef,Verse.IntVec3,Verse.Map,System.Int32,System.UInt16,System.String,Verse.Thing)">
            <summary></summary>
            <param name="filthDef"></param>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="amount"></param>
            <param name="attempts"></param>
            <param name="source"></param>
            <param name="sourceThing"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.PawnCanSpreadAnyDiseaseNow(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>True if pawn can spread disease, false if cant</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.PawnCanSpreadDisease(Verse.Pawn,Verse.Hediff)">
            <summary>Checks if the given pawn can spread germs from the specified disease instance.</summary>
            <param name="pawn"></param>
            <param name="myDisease">The infectious disease the pawn has</param>
            <returns>True if pawn can spread the disease, false if cant</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.TryGetInfectiousDisease(Verse.Pawn,Verse.ThingDef@)">
            <summary>Gets the first found infectious disease if it exists</summary>
            <param name="pawn">Pawn to check</param>
            <param name="filthDef">The ThingDef Filth that is the germs dropped by the disease, null if no disease found</param>
            <returns>The first Hediff or null if no disease found.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.IsInfectiousDisease(Verse.HediffDef,Verse.ThingDef@)">
            <summary>Is the given hediff an infectious disease for the purposes of the disease spread system, or other integrated systems.</summary>
            <param name="hediffDef">Is this hediff an infectious disease?</param>
            <param name="filthDef">The Filth (ThingDef) that corresponds to this disease.</param>
            <returns>True if hediff is an infectious disease. else false.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.IsCarryingGerms(Verse.Pawn,Verse.HediffDef@,RimWorld.Filth@)">
            <summary>Returns true if the given pawn is carrying (has Filth attached to them) that corresponds to an infectious disease.</summary>
            <param name="pawn">Check this pawn for germs.</param>
            <param name="disease">The disease of the germs that are found, or null if no germs are found.</param>
            <param name="germFilth"></param>
            <returns>Returns true if the given pawn is carrying germs</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.ShouldInfectPawnWith(Verse.Pawn,Verse.HediffDef,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Percentage@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@,System.Collections.Generic.List{RimWorld.Trait}@,System.Single)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="disease"></param>
            <param name="generalResistance"></param>
            <param name="immunityToThis"></param>
            <param name="negativeModifiers"></param>
            <param name="affectingTraits">A list of traits that contributed to the final chance, or empty list if there were none.</param>
            <param name="baseInfectionChance"></param>
            <param name="positiveModifiers"></param>
            <returns>True if tha pawn should be infected with the specified disease.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.InfectionResistCoinFlipWithModifiers(Verse.Pawn,System.Single,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@,System.Collections.Generic.List{RimWorld.Trait}@)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="baseChance">Base chance that is then modified by traits etc.</param>
            <param name="positiveModifiers"></param>
            <param name="negativeModifiers"></param>
            <param name="affectingTraits">A list of traits that contributed to the calculation. or empty list if none.</param>
            <returns>True if the pawn resisted the infection attempt, else false.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.GetNegativeModifiers(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>a positive float of the negative modifiers for germ resistance for the given pawn.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.GetPositiveModifiers(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>a positive float of the modifiers for germ resistance for the given pawn.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.GetClothingGermResistance(Verse.ThingDef,Verse.BodyDef,System.Boolean)">
            <summary></summary>
            <param name="apparel"></param>
            <param name="raceBody"></param>
            <param name="useToxResistStat"></param>
            <returns>float value in the 0.0f - 1.0f range</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.ImmunityToDisease(Verse.Pawn,Verse.HediffDef)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="disease"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoLAction_DiseaseEventFilter_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.SpecialThingFilterWorker_Infectious">
            <summary>Used to filter infected animals in pens</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.SpecialThingFilterWorker_Non_Infectious">
            <summary>Used to filter non infected animals in pens</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.CompQuarantineBed">
            <summary></summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.HasChildParts(Verse.BodyPartRecord)">
            <summary></summary>
            <param name="part"></param>
            <returns>True if the given part has child parts</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.GetDirectChildParts(Verse.BodyPartRecord)">
            <summary>Gets the child parts directly attached to this part</summary>
            <param name="part">Get the child parts directly attached to this part</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.SeverityPerDay(Verse.Hediff)">
            <summary>Gets the base severity per day for the hediff</summary>
            <param name="hediff"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.Hediffs(Verse.BodyPartRecord,Verse.Pawn)">
            <summary>Gets all the hediffs affecting the given part on the given pawn</summary>
            <param name="part"></param>
            <param name="pawn"></param>
            <returns>All the hediffs on the given body part of the pawn</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.Hediffs(Verse.BodyPartRecord,Verse.Pawn,System.Int32@)">
            <summary>Get all the <see cref="T:Verse.Hediff"/>s on the given <paramref name="part"/></summary>
            <param name="part"></param>
            <param name="pawn"></param>
            <param name="count"></param>
            <returns>Not null</returns>
        </member>
        <member name="F:NQualityOfLife.Medical.Surgery.SurgerySuccessInfo_Patch_1.report_Quality">
            <summary>The details for the surgery fail letter</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Surgery.Utils_Surgery.CanEverFail(RimWorld.Recipe_Surgery)">
            <summary>Can this surgery ever fail?</summary>
            <param name="surgery">The surgery to perform</param>
            <returns>true if can fail, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Surgery.Utils_Surgery.CanEverFail(NQualityOfLife.Medical.Surgery.RecipeDef)">
            <summary>Can this type of surgery / recipeDef ever fail?</summary>
             <param name="surgery">The surgery recipe</param>
             <returns>true if can fail, else false</returns>
        </member>
        <member name="T:NQualityOfLife.Medical.LocalSettings">
            <summary>Settings on start up</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.LocalSettings.debugMode">
            <summary>debug mode bool</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.CPR_Utils">
            <summary>CPR related helper functions</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.SomeoneBetterAtCPRIsFree(Verse.Pawn,Verse.Pawn,Verse.Pawn@,System.Boolean@,System.Nullable{System.Single},System.Boolean)">
            <summary></summary>
            <param name="patient"></param>
            <param name="me"></param>
            <param name="betterPawn">The pawn who is better and available to take over</param>
            <param name="otherPawnOnTheWayOrHere">Is the other pawn heading to help?</param>
            <param name="myCPRPower">float of my CPR power, if left to null it will be re calculated</param>
            <param name="orderBetterPawnToHelp">Should we order a better pawn to come help if able?</param>
            <returns>True if someone is better and able to help</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetCPRStrengthOfPawn(Verse.Pawn)">
            <summary>Get the CPR strength of a pawn</summary>
            <param name="doctor">Get the CPR strength of this pawn</param>
            <returns>float CPRStrength, and float techniqueMultiplier</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetDeathRattleHediffsToTreat(Verse.Pawn)">
            <summary></summary>
            <param name="patient"></param>
            <returns>Not <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.HasAnyApplicableHediff(Verse.Pawn)">
            <summary>Does the pawn have any hediffs that can be treated with CPR?</summary>
            <param name="patient">The pawn who's hediffs to check</param>
            <returns><see langword="true"/> if has any applicable hediff</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetHediffsToTreat(Verse.Pawn)">
            <summary></summary>
            <param name="patient">Pawn to check</param>
            <returns>IEnumerable of all the hediffs that CPR will treat - Not null</returns>
        </member>
        <member name="T:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other">
            <summary>Perform CPR on an other pawn</summary>
        </member>
        <member name="P:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.PotentialWorkThingRequest">
            <summary>Pawns only</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.PotentialWorkThingsGlobal(Verse.Pawn)">
            <summary>Only pawns with any hediff</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.GoodLayingStatusForTend(Verse.Pawn)">
            <summary>Determine if GoodLayingStatusForTend</summary>
            <param name="patient">Check if this pawn is in a good position to be tended</param>
            <returns>bool, true if good status</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.HasJobOnThing(Verse.Pawn,Verse.Thing,System.Boolean)">
            <summary>Determine if pawn has a CPR job on an other pawn</summary>
            <param name="pawn">The doctor who is looking for a CPR job</param>
            <param name="t">The pawn to check for a job</param>
            <param name="forced"></param>
            <returns>bool, true if there is a CPR job that needs to be done</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.JobOnThing(Verse.Pawn,Verse.Thing,System.Boolean)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="t">The pawn to check for a job</param>
            <param name="forced">false</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.IsAnyColonistPerformingCPROn(Verse.Pawn,Verse.Map)">
            <summary>Determine if any colonist is performing CPR on the target pawn</summary>
            <param name="patient">check if anyone is performing CPR on this pawn</param>
            <param name="map"></param>
            <returns><see langword="true"/> if someone is doing CPR</returns>
        </member>
        <member name="T:NQualityOfLife.Medical.JobDriver_Perform_CPR">
            <summary>CPR job driver</summary>
        </member>
        <member name="P:NQualityOfLife.Medical.JobDriver_Perform_CPR.Patient">
            <summary>The patient is the pawn who needs CPR</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.JobDriver_Perform_CPR.PawnOnTheWay">
            <summary>The pawn who is on the way to help</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.JobDriver_Perform_CPR.TryMakePreToilReservations(System.Boolean)">
            <summary>Determine if possible to do CPR job</summary>
            <param name="errorOnFailed">output error on failed reservations</param>
            <returns>bool true if success</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.JobDriver_Perform_CPR.MakeNewToils">
            <summary>Create the sequence of jobs for CPR</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.NQoLDeathRattle.LocalSettings">
            <summary>
            Settings on startup
            </summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.AuthorDataComp">
            <summary>This comp stores data about who has worked on the item and for how long, this is then intended to be used in the quality calculations</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2">
            <summary>Changes the <see cref="P:Verse.UnfinishedThing.Creator"/> to <see cref="F:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2.p"/> and then sets <see cref="F:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2.p"/> to <see langword="null"/></summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_3.Prefix(Verse.UnfinishedThing,Verse.Pawn)">
            <summary>Set <see cref="F:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2.p"/> to <paramref name="pawn"/> if <paramref name="__result"/> is not <see langword="null"/></summary>
            <param name="__result"></param>
            <param name="pawn"></param>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_3.Postfix(Verse.UnfinishedThing,Verse.Pawn)">
            <summary>Set <see cref="F:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2.p"/> to <paramref name="pawn"/> if <paramref name="__result"/> is not <see langword="null"/></summary>
            <param name="__result"></param>
            <param name="pawn"></param>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_1">
            <summary>This patch is used to track the amount of work done by each pawn, the data is saved in the <see cref="T:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.AuthorDataComp"/> that all <see cref="T:Verse.UnfinishedThing"/>s have</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NoForcedRain_1">
            <summary>Disables the artificial rain commonality/duration increase</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NoForcedRain_2">
            <summary>Disables the artificial rain commonality/duration increase</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NQoL_FixRimAtomicsLogSpam">
            <summary>Temporary patch to fix a spammy Rimatomics log debug message</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.DoNotForbidDroppedWeapon_Patch">
            <summary>Changes it so dropped items are not forbidden</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.OnGameLoad_Patch.NQoLAction_PopNewPlayerInfo">
            <summary>Used to trigger the new player pop up manually, for debugging / translation purposes</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Text_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Text_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_VisibleRaidPoints">
            <summary>Adds the incident points to the end of the letter text</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Text_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Text_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch._invertEnabled">
            <summary>Is the letter stack inversion enabled?</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch._filterByDef">
            <summary>Filter <see cref="T:Verse.Letter"/>s by <see cref="T:Verse.Def"/>?</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch._filterByText">
            <summary>Filter <see cref="T:Verse.Letter"/>s by text?</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch._parsedBlacklist">
            <summary>The blacklist keywords for the <see cref="T:Verse.Letter"/> text filter</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.Prefix(Verse.Letter,System.Int32,System.Boolean@)">
            <summary></summary>
            <param name="let"></param>
            <param name="delayTicks"></param>
            <param name="__state"><see langword="true"/> if the <see cref="T:Verse.Letter"/> was supressed</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.DismissAllLetters(Verse.Letter)">
            <summary>Sets <see cref="F:NQualityOfLife.MiscFixes.LetterUtility.runLateLetterClose"/> to <see langword="true"/> causing <see cref="M:NQualityOfLife.MiscFixes.LetterUtility.CloseAllLetters"/> to run during the next update</summary>
            <param name="letter"></param>
            <returns><see langword="true"/> if middle click is pressed</returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch">
            <summary>Patch for triggering auto assign stuff when capturing a prisoner</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch.Prefix(RimWorld.JobDriver_TakeToBed,System.Boolean@)">
            <summary></summary>
            <param name="__instance"></param>
            <param name="__state">Will be set to true in the prefix, if the pawn is not yet a prisoner</param>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch.Postfix(RimWorld.JobDriver_TakeToBed,System.Boolean@)">
            <summary></summary>
            <param name="__instance"></param>
            <param name="__state">Will be true here if was not yet prisoner in prefix</param>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NQoL_FoodUtility">
            <summary>Utilities for giving hediffs after food consumption</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.NQoL_FoodUtility.AddRandomFoodParasitesHediff(Verse.Pawn,Verse.Thing,RimWorld.FoodPoisonCause)">
            <summary>50/50 chance to add either the GutWorms or MuscleParasites hediff</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerBedAssignment">
            <summary>This class contains all the relevant patches and code for the prisoner bed assignment feature</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerBedAssignment.NQoL_Prisoner_Bed_Assign_Patch">
            <summary>Show prisoners as valid candidates when selecting owner of prisoner bed</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerBedAssignment.NQoL_Prisoner_Bed_Assign_Patch_2">
            <summary>Enable the owner assignment gizmo for prison beds</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerDoorPatches">
            <summary>The patches related to prisoner door opening</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.Prisoners.PrisonerDoorPatches.NQoL_PrisonersDoor_Patch.Postfix(System.Boolean)">
            <summary>Do not change</summary>
            <param name="__result"></param>
            <returns>Do not change</returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerDoorPatches.NQoL_PrisonersCellDoor_Patch_2">
            <summary>Open all cell doors on prison break start</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerDoorPatches.NQoL_PrisonersCellDoor_Patch_3">
            <summary>Open all cell doors on prison break start - keep open for longer than normal</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.Prisoners.PrisonerSapperPatches.MakeEscapeJob(Verse.Pawn)">
            <summary></summary>
            <param name="prisoner"></param>
            <returns>The escape <see cref="T:Verse.AI.Job"/> if there is one, else <see langword="null"/></returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerSapperPatches.NQoL_PrisonerEscape_Patch_2">
            <summary>Changes all the duties to the custom escape duty</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.NQoL_Pawn_Downed_Self_Preservation_Patch.Postfix(System.Boolean,Verse.Pawn_HealthTracker)">
            <summary></summary>
            <param name="__result">ShouldBeDowned return</param>
            <param name="__instance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.NQoL_QuestNode_GetFaction_Patch.Postfix(System.Boolean,RimWorld.Faction)">
            <summary></summary>
            <param name="__result">IsGoodFaction return</param>
            <param name="faction"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.NQoL_IncidentWorker_CanFireNow_Patch.Postfix(System.Boolean,RimWorld.IncidentWorker,RimWorld.IncidentParms)">
            <summary></summary>
            <param name="__result">IncidentWorker.CanFireNow return</param>
            <param name="__instance"></param>
            <param name="parms"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.ShouldSuppress(RimWorld.TechLevel,RimWorld.IncidentDef)">
            <summary>Should the given IncidentDef be disallowed from happening?</summary>
            <param name="playerTechLevel"></param>
            <param name="instanceDef"></param>
            <returns>True if this IncidentDef should not be allowed to fire</returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.ShouldSuppress(RimWorld.IncidentDef,RimWorld.TechLevel,RimWorld.IncidentParms)">
            <summary>Check it the given incident def should be suppressed given the specific params</summary>
            <param name="instanceDef"></param>
            <param name="playerTechLevel"></param>
            <param name="parms"></param>
            <returns>True if this incident should not be allowed to happen</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.ResearchQueue.NQoL_Research_Queue_Patch_1.GetNextFromQueue(System.Collections.Generic.List{Verse.ResearchProjectDef},System.Boolean)">
            <summary></summary>
            <param name="researchQueue"></param>
            <param name="debugWarningOnFail"></param>
            <returns><see langword="null"/> if nothing to start, or the project to try start from the queue</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.ResearchQueue.NQoL_Research_Queue_Patch_1.TryToStartNextAvailableResearchFromQueue(System.Collections.Generic.List{Verse.ResearchProjectDef},System.Boolean)">
            <summary></summary>
            <param name="researchQueue"></param>
            <param name="debugWarningOnFail"></param>
            <returns>True if research was started, false if not</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.NQoL_Research_Tech_Level_Patch_2.Prefix(Verse.ResearchProjectDef,System.Boolean@,Verse.Pawn,System.Boolean@)">
            <summary>This patch is used to remove the finished <paramref name="proj"/> from the research queue and send a letter if the queue becomes empty</summary>
            <param name="proj"></param>
            <param name="doCompletionDialog"></param>
            <param name="researcher"></param>
            <param name="doCompletionLetter"></param>
        </member>
        <member name="M:NQualityOfLife.Progression.NQoL_Research_Tech_Level_Patch_2.Postfix(Verse.Pawn,Verse.ResearchProjectDef)">
            <summary>This project sets the next <see cref="T:Verse.ResearchProjectDef"/> to be researched from the queue || And to progress the tech level of the player faction || Also used to record player legacy tales for finished projects</summary>
            <param name="researcher"></param>
            <param name="proj"></param>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.DoProgression(NQualityOfLife.Types.Ratio,NQualityOfLife.Types.Ratio,System.Boolean,RimWorld.TechLevel@,RimWorld.TechLevel@,System.Boolean)">
            <summary>Calls all the methods needed to progress the tech level</summary>
            <param name="ratioNeeded">The ratio of completed research projects of a level needed to consider that level completed</param>
            <param name="ratioNeededForSkip">The ratio of tech needed to be completed in a tech level 2 tiers ahead to level up</param>
            <param name="allowRegression"></param>
            <param name="oldLevel"></param>
            <param name="newLevel"></param>
            <param name="suppressMessage">Suppress in game notification message about level progress</param>
            <returns>false if there was an issue</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.GetDesiredTechLevel(NQualityOfLife.Types.Ratio,NQualityOfLife.Types.Ratio,System.Boolean)">
            <summary>Calculate the tech level that the colony should have based on the given parameters</summary>
            <param name="ratioNeeded">The ratio of completed research projects of a level needed to consider that level completed</param>
            <param name="ratioNeededForSkip">The ratio of tech needed to be completed in a tech level 2 tiers ahead to level up</param>
            <param name="debug"></param>
            <returns>Desired tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.SetDesiredTechLevel(RimWorld.TechLevel,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set the colony tech level to the given Int</summary>
            <param name="newTechLevel">The Int of the new tech level</param>
            <param name="allowRegression"></param>
            <param name="suppressMessage">Suppress in game message notification</param>
            <param name="debug"></param>
            <returns><see langword="true"/> if level changed, <see langword="false"/> if level was not changed</returns>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.Settings">
            <summary>Home system settings (and some others)</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.Settings.HomeSystemEnabled">
            <summary>Is the system enabled?</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.CompHomeSeparator">
            <summary>ThingComp for doors that can be used to toggle home separation</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility">
            <summary>Pawn homes</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility.HomeData">
            <summary>Contains all the family homes</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.HomeUtility.HomeData.homes">
            <summary>List of all active homes</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility.HomeRoom">
            <summary>Contains data for HomeRooms</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.DeleteAllHomes(Verse.Map)">
            <summary>Delete all homes on the given map, or all homes on all maps</summary>
            <param name="map">The Map to limit the deletion to, if null: delete all</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.PrintHomes(Verse.Map)">
            <summary>Print all the homes of a given map to debug log, or all homes if map is not given</summary>
            <param name="map">Only print homes on this Map, if null: print all homes</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.GetPotentialNewHomeOwners(Verse.Map)">
            <summary>Get all pawns on a given map, who can be home owners that are not already owners</summary>
            <returns>A List of all pawns who can create a home</returns>
            <param name="map">The Map to use as a reference, will try to resolve if null, but should be given if possible</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToFillAllRooms(Verse.Map)">
            <summary>Attempt to fill all homes on the given map, or all homes on all maps</summary>
            <param name="map">Only this map, if null: on all maps</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToFillRooms(NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Attempt to add relatives of home owner to given home</summary>
            <param name="home">Try fill the rooms of this home</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.HomeID(Verse.Pawn)">
            <summary>Get the home id of the home this pawn is an occupant of</summary>
            <param name="pawn">Get the home id of this pawn</param>
            <returns>int?, null if not part of any home</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CanBeAHomeOwner(Verse.Pawn,System.Boolean,System.Boolean)">
            <summary>Is this pawn a valid pawn to be a home owner, same result even if already home owner</summary>
            <param name="pawn">Is this pawn a valid pawn to be a home owner</param>
            <param name="ignoreRelatives">Ignore the relative requirement</param>
            <param name="loversCountAsRelatives">Lovers count as relatives for the relative check</param>
            <returns>true if can be home owner</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToCreateAllHomes(Verse.Map,System.Boolean)">
            <summary>Try to create all valid homes on the given map, or on all maps</summary>
            <param name="map">Specific map to apply the method to, can be null</param>
            <param name="annexRooms">Should we attempt to annex all valid rooms after creation?</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToCreateHome(Verse.Map,System.Boolean,Verse.Room,System.Boolean,System.Boolean)">
            <summary>Try to create a home on the given map origination from a specific room, or any valid room</summary>
            <param name="map">The target map, cannot be null!</param>
            <param name="annexRooms">should we attempt to annex all valid rooms to the home?</param>
            <param name="specificRoom">Create the home starting from this specific room, if null, create in a valid room</param>
            <param name="forceCacheUpdate">Force cache updates?</param>
            <param name="ignoreRelatives"></param>
            <returns>bool true if succeeded in creating a home</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TransferHouseOwnershipFrom(Verse.Pawn,Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="newOwner"></param>
            <param name="home"></param>
            <returns>true if ownership was successfully transferred</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CouldBeAPublicHub(Verse.Room,Verse.Map)">
            <summary>Is the given room likely to be a public hallway that connects to multiple homes or public areas</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsDeadEndRoom(Verse.Room)">
            <summary>true if the given room only connects to one other room, door count doesn't matter, as long as they connect to the same room</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.WouldMergeHomes(Verse.Room,Verse.Map)">
            <summary>Would adding this room to a home make two homes touch? (separated only by 1 door)</summary>
            <param name="room"></param>
            <param name="map"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsValidRoomForAHome(Verse.Room,Verse.Map,System.Boolean,System.Boolean,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary></summary>
            <param name="room"></param>
            <param name="map"></param>
            <param name="mustBeBedroom"></param>
            <param name="simplifiedCheck"></param>
            <param name="isDoorway"></param>
            <param name="isPrison"></param>
            <param name="isProperRoom"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.ValidateAllHomes(Verse.Map)">
            <summary>Validate the data on all the homes on a map, or all homes on all maps. Attempts to fix any issues.</summary>
            <param name="map">The Map where we want to validate, if null: validate all</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.ValidateAllRoomsOfHome(NQualityOfLife.HomeSystem.HomeUtility.Home,Verse.Map)">
            <summary>Validate the data on all the rooms of a given home. Attempts to fix any issues.</summary>
            <param name="home">Validate this home</param>
            <param name="map">The Map where the home is located, should be given if possible.</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.AttemptToAnnexAllRooms(Verse.Map)">
            <summary>Attempt to annex all valid rooms to all homes</summary>
            <param name="map">The Map to affect, or all maps if null</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.AttemptToAnnexRoomsToHome(NQualityOfLife.HomeSystem.HomeUtility.Home,Verse.Map,System.Boolean)">
            <summary>Attempt to annex all valid rooms to a home</summary>
            <param name="home">try to add all valid rooms to this home</param>
            <param name="map"></param>
            <param name="forceCacheUpdate">force update caches?</param>
            <returns>bool of success</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CreateNewRoomData(Verse.Room,System.Boolean)">
            <summary></summary>
            <param name="room"></param>
            <param name="isBedroom"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsPartOfAnyHome(Verse.District)">
            <summary>Is the given room already a part of a home?</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsPartOfAnyHome(Verse.Room,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is the given room already a part of a home?</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf">
            <summary>ThoughtDefs related to family homes</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf.NQoL_SleptInAFamilyHome">
            <summary>The thought given to pawns upon sleeping in their own home</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf.NQoL_JoyActivityInImpressiveLivingRoom">
            <summary>The thought given to pawns after playing in their own living room</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.Unicode(System.Char)">
            <summary>Get the unicode of this <paramref name="character"/> as a <see cref="T:System.String"/></summary>
            <param name="character"></param>
            <returns>An unicode <see cref="T:System.String"/> such as (U+0065)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ToChar(System.Int32,System.Boolean,System.Char)">
            <summary>Returns the corresponding <see cref="T:System.Char"/> for the given <see cref="T:System.Int32"/>, Accepts inputs in the '0 - 9' range! || 10-15 will return the corresponding hex letter</summary>
            <param name="i"><see cref="T:System.Int32"/> in the '0 - 9' range</param>
            <param name="errorOnFail">Log error on fail before returning '<see cref="F:NQualityOfLife.Utils.Common.Chars.emptyChar"/>'?</param>
            <param name="fallBackChar">In case of a failed conversion, use this <see cref="T:System.Char"/></param>
            <returns>'<see cref="T:System.Int32"/> 0 -> <see cref="T:System.Char"/> '0'', '<see cref="T:System.Int32"/> 9 -> <see cref="T:System.Char"/> '9'', '<see cref="T:System.Int32"/> 15 -> <see cref="T:System.Char"/> 'F'', returns '<paramref name="fallBackChar"/>' if input is out of range.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ToInt(System.Char,System.Boolean,System.Int32)">
            <summary>Returns the corresponding <see cref="T:System.Int32"/> for the given <see cref="T:System.Char"/>, Accepts inputs in the '0 - 9' and 'A - F' range!</summary>
            <param name="c"><see cref="T:System.Char"/> in the '0 - 9' range</param>
            <param name="errorOnFail">Log error on fail before returning <paramref name="fallBackInt"/>?</param>
            <param name="fallBackInt"></param>
            <returns>'<see cref="T:System.Char"/> '0' -> <see cref="T:System.Int32"/> 0', '<see cref="T:System.Char"/> '9' -> <see cref="T:System.Int32"/> 9', '<see cref="T:System.Char"/> 'A/a' -> <see cref="T:System.Int32"/> 10', '<see cref="T:System.Char"/> 'F/f' -> <see cref="T:System.Int32"/> 15', returns '<paramref name="fallBackInt"/>' if input is out of range.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsUpper(System.Char)">
            <inheritdoc cref="M:System.Char.IsUpper(System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsAnyOf(System.Char,System.Char[])">
            <summary>Checks if the provided <seealso cref="T:System.Char">character</seealso> is the same as any of the <seealso cref="T:System.Char">characters</seealso> in the array</summary>
            <param name="character">Check if this <see cref="T:System.Char"/> is any of <paramref name="theseCharacters"/></param><param name="theseCharacters"></param>
            <returns><see langword="true"/> if the <paramref name="character"/> is any of <paramref name="theseCharacters"/> || <see langword="false"/> if <paramref name="theseCharacters"/> is <see langword="null"/>, empty, or does not contain the <paramref name="character"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsAnyOf_Internal(System.Char,System.Char[],System.Int32)">
            <summary>Checks if the provided <paramref name="character"/> is the same as any of the <seealso cref="T:System.Char">characters</seealso> in the array</summary>
            <param name="character">Check if this <see cref="T:System.Char"/> is any of <paramref name="theseCharacters"/></param><param name="theseCharacters"></param>
            <param name="arraySize">The known amount of <seealso cref="T:System.Char">characters</seealso> in the array</param>
            <returns><see langword="true"/> if the <paramref name="character"/> is any of <paramref name="theseCharacters"/> || <see langword="false"/> if <paramref name="theseCharacters"/> is <see langword="null"/>, empty, or does not contain the <paramref name="character"/></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsAnyOf_Internal(System.Char,System.Int32,System.Char[])">
            <summary>Checks if the provided <paramref name="character"/> is the same as any of the <seealso cref="T:System.Char">characters</seealso> in the array</summary>
            <param name="character">Check if this <see cref="T:System.Char"/> is any of <paramref name="theseCharacters"/></param><param name="theseCharacters"></param>
            <param name="arraySize">The known amount of <seealso cref="T:System.Char">characters</seealso> in the array</param>
            <returns><see langword="true"/> if the <paramref name="character"/> is any of <paramref name="theseCharacters"/> || <see langword="false"/> if <paramref name="theseCharacters"/> is <see langword="null"/>, empty, or does not contain the <paramref name="character"/></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.IParsable`1">
            <summary>The type '<typeparamref name="T"/>' can be parsed from a <see cref="T:System.String"/></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> that implements <see cref="T:NQualityOfLife.Utils.IParsable`1"/></typeparam>
        </member>
        <member name="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)">
            <summary>Should be able to create a <see langword="new"/> instance of <typeparamref name="T"/> from a <see cref="M:NQualityOfLife.Utils.IParsable`1.ToString"/></summary>
            <param name="text">The <see cref="T:System.String"/> representation of <typeparamref name="T"/> - <see cref="M:NQualityOfLife.Utils.IParsable`1.ToString"/></param>
            <param name="parsed">The <see langword="new"/> instance of <typeparamref name="T"/> that was extracted from the <see cref="T:System.String"/></param>
            <returns><see langword="true"/> if the '<typeparamref name="T"/>' was successfully parsed from the <see cref="T:System.String"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.IParsable`1.ToString">
            <summary>Convert the <typeparamref name="T"/> instance to a <see cref="T:System.String"/> that can be converted back to an identical <typeparamref name="T"/> instance using <see cref="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)"/></summary>
            <returns>a <see cref="T:System.String"/> that the <see cref="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)"/> method can decode back into an identical <typeparamref name="T"/> instance</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.IString">
            <summary>Interface for <see cref="T:System.String"/> wrappers</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IString.Length">
            <inheritdoc cref="P:System.String.Length"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.ToString">
            <summary>Convert the <see cref="T:NQualityOfLife.Utils.IString"/> to <see cref="T:System.String"/></summary>
            <returns><see cref="T:System.String"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.Dot(System.String)">
            <summary>Concats two strings with a dot between them</summary>
            <param name="afterDot">Text after the dot</param>
            <returns>{<see langword="this"/>}.{<paramref name="afterDot"/>}</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Dot(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.Concat(System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.Concat(System.String[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.Deconstruct(System.String@)">
            <summary>Deconstructs the <see cref="T:NQualityOfLife.Utils.IString"/> to <see cref="T:System.String"/>, should give the same <see cref="T:System.String"/> as <see cref="M:NQualityOfLife.Utils.IString.ToString"/></summary>
            <param name="str"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.Colorize(NQualityOfLife.Colors.IColor)">
            <summary></summary>
            <param name="color"></param>
            <returns><see langword="this"/> <see cref="M:NQualityOfLife.Utils.IString.ToString"/> colorized with the given <paramref name="color"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.Colorize(NQualityOfLife.Colors.Hex)">
            <inheritdoc cref="M:NQualityOfLife.Utils.IString.Colorize(NQualityOfLife.Colors.IColor)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.EndsWith_Fast(System.String)">
            <summary>Checks if the <see cref="T:NQualityOfLife.Utils.IString"/> ends with the given sub-string</summary><param name="subString"></param>
            <returns><see langword="false"/> if any input is <see langword="null"/> || <see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Utils.IString"/> ends with '<paramref name="subString"/>'</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.EndsWith_Fast(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.StartsWith_Fast(System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.StartsWith_Fast(System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String,System.String)"/>
        </member>
        <member name="T:NQualityOfLife.Utils.IString`1">
            <summary>A wrapper for strings where the <see cref="T:System.Type"/> is specified</summary>
            <typeparam name="TS"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Utils.IString`1.Dot(`0)">
            <inheritdoc cref="M:NQualityOfLife.Utils.IString.Dot(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString`1.Concat(`0)">
            <inheritdoc cref="M:NQualityOfLife.Utils.IString.Concat(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString`1.Concat(`0[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.IString.Concat(System.String[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IString`1.Deconstruct(`0@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.IString.Deconstruct(System.String@)"/>
        </member>
        <member name="T:NQualityOfLife.Utils.StringExtensions">
            <summary>Useful extension methods for strings</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.TranslateOr(System.String,System.String)">
            <summary>Try translate the given <paramref name="translationKey"/> or return <paramref name="fallback"/> if translation fails</summary>
            <param name="translationKey"></param>
            <param name="fallback"></param>
            <returns><paramref name="translationKey"/> translated or <paramref name="fallback"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstToUpper(System.String,System.Globalization.CultureInfo)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.CapitalizeFirst(System.String,System.Globalization.CultureInfo)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.CapitalizeFirst(System.String,System.Globalization.CultureInfo)">
            <summary>Capitalize the first letter of the input <paramref name="text"/></summary>
            <param name="text">Capitalize the first <see cref="T:System.Char"/> of this <see cref="T:System.String"/></param>
            <param name="cultureInfo">Leave as <see langword="default"/> for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/></param>
            <returns><paramref name="text"/> with the first <see cref="T:System.Char"/> converted to upper case</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is null</exception>
            <remarks>If the input <paramref name="text"/> is empty or the first <see cref="T:System.Char"/> is already upper case, returns it un-changed</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FormatAsString_XML_List(System.String,NQualityOfLife.Utils.Common.FormatMode)">
            <summary>Accepts a <see cref="T:System.String"/> that contains XML '&lt;li&gt;value&lt;/li&gt;' elements.</summary>
            <param name="xmlList">a <see cref="T:System.String"/> made from '&lt;li&gt;value&lt;/li&gt;' elements.</param>
            <param name="formatMode">The format we want to convert the list to</param>
            <returns>The list re-formatted using the selected <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.XMLToList(System.String,System.Boolean)">
            <summary>Accepts a <see cref="T:System.String"/> that contains XML '&lt;li&gt;value&lt;/li&gt;' elements.</summary>
            <param name="xmlList"></param>
            <param name="keepTags">Include the '&lt;li&gt;&lt;/li&gt;' tags around the values in the output list</param>
            <returns>The values of the xml list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IndexOf(System.String,System.Char,System.Int32@)">
            <summary>Get the zero based index of the first occurance of the given <paramref name="character"/> || or -1 if none found.</summary><param name="str"></param><param name="character"></param><param name="stringLength">The Length of the <see cref="T:System.String"/></param><returns>the zero based index of the first occurance of the <paramref name="character"/> || or -1 if not found</returns><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char)">
            <summary>Get the zero based index of the first occurance of the given <paramref name="character"/> || or -1 if none found.</summary><param name="text"></param><param name="character"></param><returns>the zero based index of the first occurance of the <paramref name="character"/> || or -1 if not found</returns><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf_Internal(System.String,System.Char,System.Int32)">
            <summary>Get the zero based index of the first occurance of the given <paramref name="character"/> || or -1 if none found.</summary><param name="text"></param><param name="character"></param>
            <param name="textLength"><paramref name="text"/>.<seealso cref="P:System.String.Length">Length</seealso></param><returns>the zero based index of the first occurance of the <paramref name="character"/> || or -1 if not found</returns><exception cref="T:System.NullReferenceException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32@)">
            <summary>Get the zero based index of the first occurance of the given <paramref name="character"/> || or -1 if none found.</summary><param name="text"></param><param name="character"></param><param name="stringLength">The Length of the <see cref="T:System.String"/></param><returns>the zero based index of the first occurance of the <paramref name="character"/> || or -1 if not found</returns><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.Char,System.Int32@)">
            <summary>Get the zero based index of the last occurance of the given <paramref name="character"/> || or -1 if none found.</summary><param name="text"></param><param name="character"></param><param name="stringLength">The Length of the <see cref="T:System.String"/></param><returns>the zero based index of the last occurance of the <paramref name="character"/> || or -1 if not found</returns><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf_Internal(System.String,System.Char,System.Int32)">
            <summary>Get the zero based index of the last occurance of the given <paramref name="character"/> || or -1 if none found.</summary><param name="text"></param><param name="character"></param><param name="stringLength">The Length of the <see cref="T:System.String"/></param><returns>the zero based index of the last occurance of the <paramref name="character"/> || or -1 if not found</returns><exception cref="T:System.NullReferenceException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <summary>Get the zero based index of the first occurance of the given <paramref name="subString"/> || or -1 if none found.</summary><param name="str"></param><param name="subString"></param><param name="stringLength"></param><param name="comparisonType"></param><returns>the zero based index of the first occurance of the <paramref name="subString"/> || or -1 if not found</returns><exception cref="T:System.ArgumentNullException"/><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.StringComparison)">
            <summary>Get the zero based index of the first occurance of the given <paramref name="subString"/> || or -1 if none found.</summary><param name="str"></param><param name="subString"></param><param name="comparisonType"></param><returns>the zero based index of the first occurance of the <paramref name="subString"/> || or -1 if not found</returns><exception cref="T:System.ArgumentNullException"/><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <summary>Get the zero based index of the first occurance of the given <paramref name="subString"/> || or -1 if none found.</summary><param name="str"></param><param name="subString"></param><param name="stringLength"></param><param name="comparisonType"></param><returns>the zero based index of the first occurance of the <paramref name="subString"/> || or -1 if not found</returns><exception cref="T:System.ArgumentNullException"/><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <summary>Get the zero based index of the last occurance of the given <paramref name="subString"/> || or -1 if none found.</summary><param name="str"></param><param name="subString"></param><param name="stringLength"></param><param name="comparisonType"></param><returns>the zero based index of the last occurance of the <paramref name="subString"/> || or -1 if not found</returns><exception cref="T:System.ArgumentNullException"/><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitAll(System.Collections.Generic.IList{System.String},System.String,System.StringSplitOptions)">
            <summary></summary>
            <param name="strings"></param><param name="options"></param><param name="separator"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitAll(System.Collections.Generic.IList{System.String},System.String[])">
            <summary></summary>
            <param name="strings"></param><param name="separators"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitAll(System.Collections.Generic.IList{System.String},System.StringSplitOptions,System.String[])">
            <summary></summary>
            <param name="strings"></param><param name="options"></param><param name="separators"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Char)">
            <summary>Count matching characters</summary>
            <param name="str"></param>
            <param name="character"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Char,System.Char)">
            <summary>Count matching characters</summary>
            <param name="str"></param>
            <param name="character"></param>
            <param name="or"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Predicate{System.Char})">
            <summary>Count characters matching a condition</summary>
            <param name="str"></param>
            <param name="predicate"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Pow(System.String,System.Int32)">
            <summary>Adds the appropriate notation to the end of the string, such as '^6' or '<see cref="F:NQualityOfLife.Utils.Common.Chars.pow1"/>'</summary>
            <param name="x"></param>
            <param name="toThePower"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Double,System.Char)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Double,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.Char)">
            <summary></summary>
            <param name="num"></param>
            <param name="symbol">The symbol of the unit, such as 'g' 'm' 'Ω' etc</param>
            <returns>The number formatted using the kilo, milli, micro etc prefixes.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.String)">
            <summary></summary>
            <param name="num"></param>
            <param name="symbol">The symbol of the unit, such as 'g' 'm' 'Pa' 'Ω' etc</param>
            <returns>The number formatted using the kilo, milli, micro etc prefixes.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.NewLine(System.String,System.String)">
            <summary>Cancatinates the <paramref name="stringOnNewLine"/> to the existing <paramref name="text"/> if it exists, else returns <paramref name="stringOnNewLine"/></summary>
            <param name="text"></param>
            <param name="stringOnNewLine"></param>
            <returns><paramref name="stringOnNewLine"/> added on a new line after <paramref name="text"/>, or <paramref name="stringOnNewLine"/> if <paramref name="text"/> was <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.Char)">
            <summary>Add the provided <see cref="T:System.Char"/> to the end of <paramref name="string1"/></summary><param name="string1"></param><param name="char1"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> with <paramref name="char1"/> appended to the end of it</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.Char,System.Char)">
            <summary>Add the provided characters to the end of <paramref name="string1"/></summary><param name="string1"></param><param name="char1"></param><param name="char2"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> with <paramref name="char1"/> and <paramref name="char2"/> appended to the end of it</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Dot(System.String,System.String)">
            <summary>Concats 2 strings with a dot between them</summary>
            <param name="text">Text before the dot</param>
            <param name="dotText">Text after the dot</param>
            <returns>{<paramref name="text"/>}.{<paramref name="dotText"/>}</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String)">
            <summary>Concat a <see cref="T:System.String"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String)">
            <summary>Concat a <see cref="T:System.String"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param>
            <param name="other2"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String)">
            <summary>Concat a <see cref="T:System.String"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param>
            <param name="other2"></param>
            <param name="other3"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat a <see cref="T:System.String"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat a string to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param><param name="other5"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat the provided strings to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param><param name="other5"></param><param name="other6"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String[])">
            <summary>Add the provided <paramref name="strings"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="str"></param>
            <param name="strings"></param>
            <returns></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitBy(System.String,System.Int32,System.Int32)">
            <summary>Splits the <see cref="T:System.String"/> into chunks of a specified length</summary>
            <param name="text"></param>
            <param name="chunkLength"></param>
            <param name="textLength">text.Length</param>
            <returns>A list of strings with a length of 'chunkLength'</returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLineBreaks(System.String,System.String)">
            <summary></summary>
            <param name="text"></param>
            <param name="andReplaceWith"></param>
            <returns></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.NullOrEmpty(System.String,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Boolean)">
            <summary>Checks if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></summary>
            <param name="s"><see cref="T:System.String"/></param>
            <param name="treatSymbolsAsValue">Treat the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty symbols</seealso> as if they were the values they represent</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> is <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(NQualityOfLife.Utils.IString,System.Boolean)">
            <summary>Checks if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></summary>
            <param name="s"><see cref="T:System.String"/></param>
            <param name="treatSymbolsAsValue">Treat the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty symbols</seealso> as if they were the values they represent</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> is <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(NQualityOfLife.Utils.IString,System.Int32@,System.Boolean)">
            <summary>Checks if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/> and outputs the <paramref name="length"/> of the input <see cref="T:System.String"/></summary>
            <param name="s"><see cref="T:System.String"/></param>
            <param name="length"></param>
            <param name="treatSymbolsAsValue">Treat the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty symbols</seealso> as if they were the values they represent</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> is <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsEmptySymbol(System.String)">
            <summary>Is the given <see cref="T:System.String"/> the value of any of the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty symbols</seealso></summary>
            <param name="s"></param><returns><see langword="true"/> if the input <see cref="T:System.String"/> is one of the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty symbols</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullSymbol(System.String)">
            <summary>Is the given <see cref="T:System.String"/> the value of any of the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol">null symbols</seealso></summary>
            <param name="s"></param><returns><see langword="true"/> if the input <see cref="T:System.String"/> is one of the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol">null symbols</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Int32@,System.Boolean)">
            <summary>Checks if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/> and outputs the <paramref name="length"/> of the input <see cref="T:System.String"/></summary>
            <param name="s"></param>
            <param name="length">Will be -1 if <see cref="T:System.String"/> is <see langword="null"/>, else the Length of the <see cref="T:System.String"/></param>
            <param name="treatSymbolsAsValue">Treat the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty symbols</seealso> as if they were the values they represent</param>
            <returns><see langword="True"/> if <see cref="T:System.String"/> is <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceLast(System.String,System.Char,System.Char)">
            <summary>Iterates the input <see cref="T:System.String"/> in reverse and replaces the first found <paramref name="oldChar"/> with <paramref name="newChar"/> and returns the modified <see cref="T:System.String"/></summary>
            <param name="text">Input <see cref="T:System.String"/></param>
            <param name="oldChar">Replace last instance of this <see cref="T:System.Char"/> with <paramref name="newChar"/></param>
            <param name="newChar">Replace <paramref name="oldChar"/> with this</param>
            <returns>The input <see cref="T:System.String"/> with the last occurrence of <paramref name="oldChar"/> replaced with <paramref name="newChar"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceLast(System.String,System.Char)">
            <summary>Replaces the last <seealso cref="T:System.Char">character</seealso> of the input <paramref name="text"/> with <paramref name="newChar"/></summary>
            <param name="text"></param>
            <param name="newChar"></param>
            <returns><paramref name="text"/> with the last <see cref="T:System.Char"/> replaced with <paramref name="newChar"/> || or <see cref="F:System.String.Empty"/> (with error) if <paramref name="text"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveFirst(System.String)">
            <summary>Removes the first character from the input <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <returns>The input <see cref="T:System.String"/> with the first letter/<see cref="T:System.Char"/> removed.</returns>
            <remarks>If <paramref name="text"/> is <see langword="null"/> or empty, returns it un-changed</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLast(System.String)">
            <summary>Removes the last character from the input <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <returns>The input <see cref="T:System.String"/> with the last letter/<see cref="T:System.Char"/> removed.</returns>
            <remarks>If <paramref name="text"/> is <see langword="null"/> or empty, returns it un-changed</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char)">
            <summary>Checks if the input <see cref="T:System.String"/> contains the specified <paramref name="character"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the <see cref="T:System.Char"/></param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains the <paramref name="character"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char,System.Int32@)">
            <summary>Checks if the input <see cref="T:System.String"/> contains the specific <paramref name="character"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the char</param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <param name="index">The index of the first found matching <see cref="T:System.Char"/> || or -1 if it was not found</param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains the <paramref name="character"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char,System.Int32@,System.Int32@)">
            <summary>Checks if the input <see cref="T:System.String"/> contains the specific <paramref name="character"/>|| input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the <see cref="T:System.Char"/></param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <param name="index">The index of the first found instance of <paramref name="character"/> || or -1 if it was not found</param>
            <param name="textLength">The <see cref="P:System.String.Length"/> of <paramref name="text"/> || -1 on error</param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains the <paramref name="character"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains_Internal(System.String,System.Char,System.Int32)">
            <summary>Checks if the input <see cref="T:System.String"/> contains the specified <paramref name="character"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the <see cref="T:System.Char"/></param>
            <param name="textLength">text.Length</param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains the <paramref name="character"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.AnyOfContain_Internal(System.String,System.StringComparison,System.String[])">
            <summary>Check if any of the <paramref name="strings"/> contain the <paramref name="text"/></summary>
            <param name="text"></param>
            <param name="stringComparison"></param>
            <param name="strings"></param>
            <returns><see langword="true"/> if any of the given <paramref name="strings"/> contains the <paramref name="text"/><para>will always return <see langword="true"/> if <paramref name="text"/> is <see cref="F:System.String.Empty"/> and <paramref name="strings"/> has at least one non <see langword="null"/> <see cref="T:System.String"/></para></returns>
            <remarks><see langword="null"/> strings in <paramref name="strings"/> are skipped</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.Char[])">
            <summary>Checks if the input <see cref="T:System.String"/> contains ony of the specified <paramref name="characters"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text"></param>
            <param name="characters"></param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains any of the <paramref name="characters"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="characters"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.TrimAll(System.Collections.Generic.IList{System.String},System.Boolean)">
            <summary>Create a copy of the input strings with leading and trailing whitespace removed</summary>
            <param name="strings"></param>
            <param name="removeEmpty"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.CountTill(System.String,System.Int32,System.Predicate{System.Char})">
            <summary>Counts matching characters until the <paramref name="maxCount"/> or end of the <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Matching <see cref="T:System.Char"/> count or <paramref name="maxCount"/> if more matching characters than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.CountTill(System.String,System.Int32,System.Char[])">
            <summary>Counts matching characters until the <paramref name="maxCount"/> or end of the <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="matchChars"></param>
            <returns>Matching <see cref="T:System.Char"/> count or <paramref name="maxCount"/> if more matching characters than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.String[])">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches any of the <seealso cref="T:System.String">strings</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <remarks>Will always return <see langword="true"/> if any of the sub-strings is <see cref="F:System.String.Empty"/>!</remarks>
            <returns><see langword="true"/> if the input <paramref name="text"/> matches or contains any of the provided <seealso cref="T:System.String">strings</seealso>. || If input <paramref name="text"/> or <see cref="T:System.String"/> array are <see langword="null"/> or empty; returns <see langword="false"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.Collections.Generic.IList{System.String},System.String@)">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches any of the <seealso cref="T:System.String">strings</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <param name="firstMatch"></param>
            <returns><see langword="true"/> if the input matches or contains any of the provided <seealso cref="T:System.String">strings</seealso>. || If input <paramref name="text"/> or <see cref="T:System.String"/> array are <see langword="null"/> or empty; returns <see langword="false"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.String@,System.String[])">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches any of the <seealso cref="T:System.String">strings</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <param name="firstMatch">The first match or <see langword="null"/> if there was none</param>
            <returns><see langword="true"/> if the input <paramref name="text"/> matches or contains any of the provided <seealso cref="T:System.String">strings</seealso>. || If input <paramref name="text"/> or <see cref="T:System.String"/> array are <see langword="null"/> or empty; returns <see langword="false"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains_Internal(System.String,System.String,System.Int32,System.StringComparison)">
            <summary>Checks if the <see cref="T:System.String"/> contains the given <paramref name="substring"/></summary>
            <param name="text"></param>
            <param name="substring"></param>
            <param name="textLength">The <see cref="P:System.String.Length"/> of <paramref name="text"/></param>
            <param name="stringComparison"></param>
            <returns><see langword="true"/> if the <paramref name="text"/> contains or matches the <paramref name="substring"/></returns>
            <remarks>Will always return <see langword="true"/> if <paramref name="substring"/> is <see cref="F:System.String.Empty"/>!</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAll(System.String,System.String[])">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches all of the <seealso cref="T:System.String">strings</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if the input matches or contains all of the provided <seealso cref="T:System.String">strings</seealso>. || If input text or <see cref="T:System.String"/> array are <see langword="null"/> or empty; returns <see langword="false"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAll(System.String,System.Char[])">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches all of the <seealso cref="T:System.Char">chars</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains or matches all of the provided <seealso cref="T:System.Char">chars</seealso>. || If input <paramref name="text"/> or <see cref="T:System.Char"/> array are <see langword="null"/> or empty; returns <see langword="false"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.EndsWith_Fast(System.String,System.String)">
            <summary>Checks if the provided <see cref="T:System.String"/> ends with the given sub-string</summary>
            <param name="text"></param><param name="with"></param>
            <returns><see langword="false"/> if any input is <see langword="null"/> || <see langword="true"/> if '<paramref name="text"/>' ends with '<paramref name="with"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String)">
            <summary>Check if the <see cref="T:System.String"/> starts with the given <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="with"></param>
            <returns><see langword="false"/> if any input is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String,System.String)">
            <summary>Check if the <see cref="T:System.String"/> starts with one of the given strings</summary>
            <param name="text"></param>
            <param name="with"></param>
            <param name="or"></param>
            <returns>always <see langword="false"/> if the input <see cref="T:System.String"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbol(System.String)">
            <summary>Returns the last <see cref="T:System.Char"/> of a <see cref="T:System.String"/>, or '\0' if invalid <see cref="T:System.String"/></summary>
            <param name="text">text to check</param>
            <returns>The last <see cref="T:System.Char"/> of the provided <see cref="T:System.String"/> or empty <see cref="T:System.Char"/> ('\0') if text is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char)">
            <summary>Checks if the last symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/></summary>
            <param name="text">text to check</param>
            <param name="lastSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> ends with the provided <see cref="T:System.Char"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char,System.Char)">
            <summary>Checks if the last symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/></summary>
            <param name="text">text to check</param>
            <param name="lastSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <param name="or"></param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> ends with the provided <see cref="T:System.Char"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char,System.Char,System.Char)">
            <summary>Checks if the last symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/></summary>
            <param name="text">text to check</param>
            <param name="lastSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <param name="or"></param>
            <param name="orThis"></param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> ends with the provided <see cref="T:System.Char"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbol(System.String)">
            <summary>Returns the first <see cref="T:System.Char"/> of a <see cref="T:System.String"/>, or '\0' if invalid <see cref="T:System.String"/></summary>
            <param name="text">text to check</param>
            <returns>The first <see cref="T:System.Char"/> of the provided <see cref="T:System.String"/> or empty <see cref="T:System.Char"/> ('\0') if text is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char)">
            <summary>Checks if the first symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></summary>
            <param name="text">text to check - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></param>
            <param name="firstSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> starts with the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char,System.Char)">
            <summary>Checks if the first symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></summary>
            <param name="text">text to check - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></param>
            <param name="firstSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <param name="or"></param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> starts with the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char,System.Char,System.Char)">
            <summary>Checks if the first symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></summary>
            <param name="text">text to check - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></param>
            <param name="firstSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <param name="or"></param>
            <param name="orThis"></param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> starts with the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterLastOrFallback(System.String,System.Char,System.String)">
            <summary>Gets the substring after the last instance of the specified <seealso cref="T:System.Char">character</seealso>.</summary>
            <param name="text"></param>
            <param name="afterThisChar"></param>
            <param name="fallback">The <see cref="T:System.String"/> to return if the sub-string was not found</param>
            <returns>The substring after the last instance of the specified <see cref="T:System.Char"/> or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE<para>if the last <see cref="T:System.Char"/> of <paramref name="text"/> is the specified <see cref="T:System.Char"/>; returns <paramref name="fallback"/></para></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterLast(System.String,System.Char)">
            <summary>Gets the substring after the last instance of the specified <seealso cref="T:System.Char">character</seealso>.</summary>
            <param name="text"></param>
            <param name="afterThisChar">Get the substring after the first instance of this <see cref="T:System.Char"/></param><exception cref="T:System.ArgumentNullException"></exception>
            <returns>The substring after the last instance of the specified <see cref="T:System.Char"/> || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE<para>if the last <see cref="T:System.Char"/> of <paramref name="text"/> is the specified <see cref="T:System.Char"/>; returns <see cref="F:System.String.Empty"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfter(System.String,System.Char)">
            <summary>Gets the substring after the first instance of the specified character. - Excluding the character</summary>
            <param name="text"></param>
            <param name="afterThisChar"></param>
            <returns>The substring after the first found instance of the specified <see cref="T:System.Char"/> || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterOrFallback(System.String,System.Char,System.String)">
            <returns>The substring after the first found instance of the specified <see cref="T:System.Char"/> || or '<paramref name="fallback"/>' if not found</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringAfter(System.String,System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfter_Internal(System.String,System.Int32,System.Int32)">
            <summary>Get the sub-string after the given <paramref name="index"/> - Excluding the <see cref="T:System.Char"/> at the <paramref name="index"/></summary>
            <param name="text"></param><param name="index">Get the sub-string starting after this index || if index is -1, the returned sub-string will start at index 0</param>
            <param name="textLength"><see cref="P:System.String.Length"/> of the input <paramref name="text"/></param>
            <returns>The part of the input <see cref="T:System.String"/> after the given <paramref name="index"/> || or <see cref="F:System.String.Empty"/> if both '<paramref name="index"/>' and <paramref name="textLength"/> are 0 || or <see cref="F:System.String.Empty"/> (with error or <see cref="T:System.ArgumentOutOfRangeException"/>) if out of bounds and <paramref name="text"/> is not <see cref="F:System.String.Empty"/> and <paramref name="index"/> is not 0</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Char[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Char[],System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Char[],System.Int32)">
            <summary>Get all the <seealso cref="T:System.Char">characters</seealso> of the sub-string from start to end until the condition no longer matches or it reaches the end of the input <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="startIndex"></param>
            <param name="matchChars"></param>
            <returns>The sub-string before the first non-matching <see cref="T:System.Char"/> || <see cref="F:System.String.Empty"/> on error or if the input <paramref name="text"/> is empty or if there were no matching characters</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Predicate{System.Char},System.Int32)">
            <summary>Get all the <seealso cref="T:System.Char">characters</seealso> of the sub-string from start to end until the condition no longer matches or it reaches the end of the input <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="predicate"></param>
            <param name="startIndex"></param>
            <returns>The sub-string before the <paramref name="predicate"/> returned <see langword="false"/> || <see cref="F:System.String.Empty"/> on error or if the input <paramref name="text"/> is empty or if there were no matching characters</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBefore(System.String,System.Char)">
            <summary>Gets the the first found sub-string before the first instance of the specified <seealso cref="T:System.Char">character</seealso> - Excluding the <seealso cref="T:System.Char">character</seealso></summary>
            <param name="text"></param>
            <param name="beforeThisChar">Get the sub-string before the first instance of this <see cref="T:System.Char"/></param>
            <returns>The sub-string before the first found instance of the specified <see cref="T:System.Char"/> || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeOrFallback(System.String,System.Char,System.String)">
            <summary>Gets the the first found sub-string before the first instance of the specified <seealso cref="T:System.Char">character</seealso> - Excluding the <seealso cref="T:System.Char">character</seealso> || or <paramref name="fallback"/> if not found</summary>
            <param name="text"></param>
            <param name="beforeThisChar">Try to get the sub-string before the first instance of this <see cref="T:System.Char"/></param>
            <param name="fallback"></param>
            <returns>The sub-string before the first found instance of the specified <see cref="T:System.Char"/> || '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBefore(System.String,System.String)">
            <summary>Get the first found sub-string before the first instance of the given <paramref name="subString"/> in the input <paramref name="text"/> - Excluding the <paramref name="subString"/></summary>
            <param name="text"></param><param name="subString">Get the text before the first instance of this</param>
            <returns>The sub-string before the first found instance of the given <paramref name="subString"/> || '<see cref="F:System.String.Empty"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE<para>Returns <see cref="F:System.String.Empty"/> if: <list type="bullet"><item><paramref name="text"/> <see cref="P:System.String.Length"/> is shorter or equal to <paramref name="subString"/> <see cref="P:System.String.Length"/></item><item><paramref name="text"/> is <see cref="F:System.String.Empty"/></item><item><paramref name="text"/> == <paramref name="subString"/></item><item>The <paramref name="text"/> starts with the <paramref name="subString"/></item></list></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="subString"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeOrFallback(System.String,System.String,System.String)">
            <summary>Get the first found sub-string before the first instance of the given <paramref name="subString"/> in the input <paramref name="text"/> - Excluding the <paramref name="subString"/></summary>
            <param name="text"></param><param name="subString">Get the text before the first instance of this <see cref="T:System.String"/></param>
            <param name="fallback">Return this <see cref="T:System.String"/> instead if no match found</param>
            <returns>The sub-string before the first found instance of the given <paramref name="subString"/> || '<paramref name="fallback"/>' <see cref="T:System.String"/> if not found</returns>
            <remarks>MUST USE RETURN VALUE<para>Returns <paramref name="fallback"/> if: <list type="bullet"><item><paramref name="text"/> <see cref="P:System.String.Length"/> is shorter or equal to <paramref name="subString"/> <see cref="P:System.String.Length"/></item><item><paramref name="text"/> is <see cref="F:System.String.Empty"/></item><item><paramref name="text"/> == <paramref name="subString"/></item><item>The <paramref name="text"/> starts with the <paramref name="subString"/></item></list></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="subString"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBefore(System.String,System.Int32)">
            <summary>Get the part of the input <see cref="T:System.String"/> before a specific <paramref name="index"/> - Excluding the <see cref="T:System.Char"/> at the <paramref name="index"/></summary>
            <param name="text"></param><param name="index">Get all the text before this <paramref name="index"/> || cannot be &lt; 0!</param>
            <returns>The part of the given <see cref="T:System.String"/> before the given <paramref name="index"/> - Excluding the <see cref="T:System.Char"/> at the <paramref name="index"/> || Never <see langword="null"/> || if <paramref name="index"/> == <paramref name="text"/><seealso cref="P:System.String.Length">.Length</seealso> returns <paramref name="text"/> || if <paramref name="index"/> == 0 returns <see cref="F:System.String.Empty"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"/><exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Inclusive(System.String,System.String,System.String,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified <paramref name="start"/> and <paramref name="end"/> strings - Including the <paramref name="start"/> and <paramref name="end"/> strings</summary>
            <param name="text">Input text</param>
            <param name="start"><paramref name="start"/> string of the target substring</param>
            <param name="end"><paramref name="end"/> string of the target substring</param>
            <param name="settings"></param><remarks>MUST USE RETURN VALUE</remarks>
            <returns>The substring starting with "<paramref name="start"/>" and ending with "<paramref name="end"/>" || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.String,System.String,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified <paramref name="start"/> and <paramref name="end"/> strings - Excluding the <paramref name="start"/> and <paramref name="end"/> strings</summary>
            <param name="text">Input text</param>
            <param name="start">The <see cref="T:System.String"/> before the target substring</param>
            <param name="end">The <see cref="T:System.String"/> after the target substring</param>
            <param name="settings"></param>
            <returns>The substring between "<paramref name="start"/>" and "<paramref name="end"/>" || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.String,System.Char,System.StringComparison)">
            <summary>Gets the first sub-string that is inside the specified <paramref name="start"/> <see cref="T:System.String"/> and <paramref name="end"/> <see cref="T:System.Char"/> - Excluding the <paramref name="start"/> <see cref="T:System.String"/> and <paramref name="end"/> <see cref="T:System.Char"/></summary>
            <param name="text">Input text</param>
            <param name="start">The <see cref="T:System.String"/> before the target sub-string</param>
            <param name="end">The <see cref="T:System.Char"/> after the target substring</param>
            <param name="settings"></param>
            <returns>The sub-string after the "<paramref name="start"/>" <see cref="T:System.String"/> and before the '<paramref name="end"/>' <see cref="T:System.Char"/> || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.Int32,System.Char)">
            <summary>Gets the first substring that is inside the specified [ <paramref name="startIndex"/> ] and [ 'end' <see cref="T:System.Char"/> ] - Excluding the end <see cref="T:System.Char"/> and the character at the start index</summary>
            <param name="text">Input text</param>
            <param name="startIndex">The index right before the target substring</param>
            <param name="end">The <see cref="T:System.Char"/> right after the target substring</param>
            <returns>The substring starting after "<paramref name="startIndex"/>" and ending before [ 'end' <see cref="T:System.Char"/> ] || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.Int32,System.String,System.StringComparison)">
            <summary>Gets the first sub-string that is inside the specified <paramref name="startIndex"/> and <paramref name="end"/> <see cref="T:System.String"/> - Excluding the <see cref="T:System.Char"/> at the <paramref name="startIndex"/> and the <paramref name="end"/> <see cref="T:System.String"/></summary>
            <param name="text">Input text</param>
            <param name="startIndex">Start index of the substring</param>
            <param name="end">End <see cref="T:System.String"/> of the substring</param>
            <param name="settings"></param>
            <remarks>MUST USE RETURN VALUE</remarks>
            <returns>The sub-string starting after '<paramref name="startIndex"/>' and ending before "<paramref name="end"/>" || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.String,System.Int32,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified <paramref name="start"/> <see cref="T:System.String"/> and end Index - Excluding the start <see cref="T:System.String"/> and end Index</summary>
            <param name="text">Input text</param>
            <param name="start">The <see cref="T:System.String"/> before the target substring</param>
            <param name="endIndex">The index after the target substring</param>
            <param name="settings"></param>
            <returns>The first found sub-string between "<paramref name="start"/>" and '<paramref name="endIndex"/>' || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Inclusive(System.String,System.Char,System.Char)">
            <summary>Gets the first found sub-string that starts and ends with the specified characters - Including the characters</summary>
            <param name="text">Input text</param>
            <param name="start">Start <see cref="T:System.Char"/> of the substring</param>
            <param name="end">End <see cref="T:System.Char"/> of the substring</param>
            <returns>The first found sub-string starting with '<paramref name="start"/>' and ending with '<paramref name="end"/>' || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.Char,System.Char)">
            <summary>Gets the first found substring that is inside the specified characters - Excluding the characters</summary>
            <param name="text">Input text</param>
            <param name="start">The <see cref="T:System.Char"/> before the start of the substring</param>
            <param name="end">The <see cref="T:System.Char"/> after the end of the substring</param>
            <returns>The substring between the <paramref name="start"/> and <paramref name="end"/> chars || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_FirstSubstringInsideOf_Exclusive(System.String,System.Char,System.Char,System.String)">
            <summary>Replaces the first found sub-string that is inside the specified <seealso cref="T:System.Char">characters</seealso> - Excluding the characters || If no match found, return the input <see cref="T:System.String"/> un-changed</summary>
            <param name="text">Input text</param>
            <param name="startChar">The <see cref="T:System.Char"/> before the start of the substring</param>
            <param name="endChar">The <see cref="T:System.Char"/> after the end of the substring</param>
            <param name="replacement">Replace the substring with this</param>
            <remarks>MUST USE RETURN VALUE</remarks><exception cref="T:System.ArgumentNullException"></exception>
            <returns>A copy of the original <see cref="T:System.String"/> with the first found sub-string between the <paramref name="startChar"/> and <paramref name="endChar"/> replaced || or the original text un-changed if the sub-string is not found || <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol">Null symbol</seealso> if any input is <see langword="null"/> (will error)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceAllCaseInsensitive(System.String,System.String,System.String)">
            <summary>Replaces all occurrences of the specified <see cref="T:System.String"/> (Case insensitive) with a new <see cref="T:System.String"/>.</summary>
            <param name="originalText"></param>
            <param name="stringsToReplace"></param>
            <param name="replacement"></param>
            <returns>The input <see cref="T:System.String"/> with all the substrings replaced</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirstSymbol(System.String,System.Char)">
            <summary>Replace the first <see cref="T:System.Char"/> of the given <see cref="T:System.String"/> with a new character</summary>
            <param name="text"></param><param name="newSymbol"></param><returns>The input <see cref="T:System.String"/> with the first <see cref="T:System.Char"/> swapped</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_FirstSubstringInsideOf_Inclusive(System.String,System.Char,System.Char,System.String)">
            <summary>Replaces the first found substring that starts with "<paramref name="start"/>" and ends with "<paramref name="end"/>" - Including the <paramref name="start"/> and <paramref name="end"/> characters.</summary>
            <param name="text">Input text</param>
            <param name="start">The first <see cref="T:System.Char"/> of the sub-string to replace</param>
            <param name="end">The last <see cref="T:System.Char"/> of the sub-string to replace</param>
            <param name="replacement">Replace the first found sub-string with this.</param>
            <returns>The original <see cref="T:System.String"/> with the first found sub-string replaced || or the original <paramref name="text"/> un-changed if the substring is not found || <see cref="F:System.String.Empty"/> if <paramref name="text"/> is <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE<para>Note: if <paramref name="start"/> and <paramref name="end"/> are both 'a', <paramref name="text"/> is: "baaab" and <paramref name="replacement"/> is: "c" the result will be: "bcab" instead of: "bacab"! This is because the first match is the two back to back 'a's ("b'aa'ab").</para></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_AllSubstringsInsideOf_Inclusive(System.String,System.Char,System.Char,System.String,System.Int16)">
            <summary>Replaces all the found substring that are inside the specified characters - Including the characters</summary>
            <param name="text">Input text</param>
            <param name="start">The first <see cref="T:System.Char"/> of the substring to replace</param>
            <param name="end">The last <see cref="T:System.Char"/> of the substring to replace || Will match the first instance of this <see langword="char"/> after the <paramref name="start"/> <see langword="char"/></param>
            <param name="replacement">Replace all the found substring with this</param>
            <param name="maxIterations">The maximum amount of sub-strings to replace</param><exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <returns>The original <see cref="T:System.String"/> with all the found substrings replaced || or the original <paramref name="text"/> un-changed if none of the substrings were found</returns>
            <remarks>MUST USE RETURN VALUE<para>Note: if <paramref name="start"/> and <paramref name="end"/> are both 'a', <paramref name="text"/> is: "baaab" and <paramref name="replacement"/> is: "c" the result will be: "bcab" instead of: "bacab"! This is because the first match is the two back to back 'a's ("b'aa'ab").</para><para>Will return <see cref="F:System.String.Empty"/> with error if input <paramref name="text"/> is <see langword="null"/></para></remarks><exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="replacement"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_Internal(System.String,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>Replaces a part of the <see cref="T:System.String"/> from start index to end index with a new value - (to = (from + with.Length - 1))</summary>
            <param name="text">Original <see cref="T:System.String"/></param>
            <param name="fromIndex">Replace starting from index</param>
            <param name="toIndex">to index - (from + with.Length - 1)</param>
            <param name="with">New value to be placed starting and ending at the specified indexes</param>
            <param name="textLength">Known Length of <paramref name="text"/>, leave -1 if not known</param>
            <returns>The original <see cref="T:System.String"/> with the specified part replaced || - never <see langword="null"/> (returns <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null symbol</seealso> if input <paramref name="text"/> is <see langword="null"/> (with error logged))</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"/>
            <exception cref="T:System.ArgumentNullException"/>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace(System.String,System.Int32,System.String)">
            <summary>Replace the <seealso cref="T:System.Char">character</seealso> at the specified index with the given substring</summary>
            <param name="text">Text to modify - Cannot be <see langword="null"/>!</param><param name="atIndex">The index of the <seealso cref="T:System.Char">character</seealso> to replace with a <see cref="T:System.String"/></param><param name="with">The <see cref="T:System.String"/> to place at the given index</param>
            <returns>The input <see cref="T:System.String"/> modified with the <seealso cref="T:System.Char">character</seealso> at the given index replaced with the given <see cref="T:System.String"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace(System.String,System.Int32,System.Char)">
            <summary>Replace the <seealso cref="T:System.Char">character</seealso> at the specified index with the given <seealso cref="T:System.Char">character</seealso></summary>
            <param name="text">Text to modify - Cannot be <see langword="null"/>!</param><param name="atIndex">The index of the <seealso cref="T:System.Char">character</seealso> to replace</param><param name="with">The new <seealso cref="T:System.Char">character</seealso> to put at the index</param>
            <returns>The input <see cref="T:System.String"/> modified with the <seealso cref="T:System.Char">character</seealso> at the given index swapped</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveFirst(System.String,System.String)">
            <summary>Removes the first found instance of the given sub-<see cref="T:System.String"/></summary>
            <param name="text"></param><param name="subString">The sub-<see cref="T:System.String"/> to remove</param>
            <returns>The input <see cref="T:System.String"/> with the first occurance of the sub-string removed</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirst(System.String,System.String,System.String)">
            <summary>Replaces the first found instance of '<paramref name="subString"/>' with '<paramref name="with"/>'</summary>
            <param name="text">The original text to modify</param>
            <param name="subString">Replace the first instance of this with '<paramref name="with"/>'</param>
            <param name="with">Replace '<paramref name="subString"/>' with this</param>
            <returns>The original <see cref="T:System.String"/> with the first matching <paramref name="subString"/> replaced || or the original <see cref="T:System.String"/> un-changed if none found.</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLast(System.String,System.String)">
            <summary>Removes the last instance of the given sub-string</summary>
            <param name="text"></param><param name="subString">The sub-string to remove</param><exception cref="T:System.ArgumentNullException"></exception>
            <returns>The input <see cref="T:System.String"/> with the last occurance of the sub-string removed</returns><remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceLast(System.String,System.String,System.String)">
            <summary>Replace the specified substring that is closest to the end of the input <see cref="T:System.String"/> with a new value</summary>
            <param name="text"></param>
            <param name="subString"></param>
            <param name="with"></param>
            <returns><paramref name="text"/> with the last occurance of <paramref name="subString"/> replaced with '<paramref name="with"/>' || or <paramref name="text"/> un-changed if it did not contain any instances of '<paramref name="subString"/>'</returns><remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Redactor">
            <summary>Used for redacting things like personal information from strings</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo(System.String)">
            <summary>Attempts to redact any personal data/information, such as usernames</summary>
            <param name="text"></param>
            <returns>The input <paramref name="text"/> with personal data redacted - Note: is not guaranteed to redact everything!</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo_Linux(System.String)">
            <summary>Attempts to redact any personal data, such as usernames</summary>
            <param name="text"></param>
            <returns>The input text with personal data redacted - Note: is not guaranteed to redact everything!</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo_Windows(System.String)">
            <summary>Attempts to redact any personal data, such as usernames</summary>
            <param name="text"></param>
            <returns>The input text with personal data redacted - Note: is not guaranteed to redact everything!</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Reflection_">
            <summary>Class containing all sorts of utilities and methods for purposes of reflection and dynamic method invocation</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ClearCache">
            <summary>Clear the cache of methods and fields</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_FromString(System.String,System.String,System.Object@,System.Boolean)">
            <summary>Invoke a method or property getter using an input string</summary>
            <param name="invoke">The method or propery getter and its parameters - The return value (if any) is passed as the first param to the 'postInvoke' method (if given)</param>
            <param name="postInvoke">Invoke a secondary method or property getter using the result from the first invoke as the first param</param>
            <param name="firstInvokeResult">The value returned by the method specifeid in 'invoke'</param>
            <param name="allowNonPublic"></param>
            <returns>The value returned by the invoked method or propery, if 'postInvoke' is given the value of it will be returned instead of 'invoke'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_StringForInvoke(System.String)">
            <summary>Check if the string is illegal</summary>
            <param name="myString"></param>
            <returns>true if ok, false if not allowed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ResolveParameters_FromStrings(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Type}@)">
            <summary>Convert a list of strings into the objects / values that they represent</summary>
            <param name="parameters">The parameter inputs strings</param>
            <param name="parsedAs">The types that the input parameters were parsed as</param>
            <returns>The actual values that the input strings represented</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ResolveParameter_FromString(System.String,System.Type@)">
            <summary>Convert a string into the real value it represents. for example and input parameter of 'A' will be parsed as a char 'A'. input of "ABC" will be parsed as a string etc.</summary>
            <param name="parameter">The string representation of a value. "" for strings, '' for chars, f for floats etc..</param>
            <param name="parsedAs">The type that the input was parsed as.</param>
            <returns>The real value that the input string represents</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.GetTypes(System.Object[])">
            <summary>Get the types of the given objects</summary>
            <param name="parameters"></param>
            <returns>An array of the types in order</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.GetMethod(System.String,System.Object[]@,System.Object@,System.Object,System.Object[])">
            <summary>Try get the MethodInfo for the method or property getter matching the given params</summary>
            <param name="nameSpaceDotTypeColonMethod"></param>
            <param name="parametersOut"></param>
            <param name="instanceOut"></param>
            <param name="instance"></param>
            <param name="parameters"></param>
            <returns>The found MethodInfo of the specified method or property or <see langword="null"/> if not found.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Method_WithType(System.String,System.String,System.String,System.Boolean,System.Object[])">
            <summary>Inoke a method or propery getter of the given type with the given params</summary>
            <param name="type"></param>
            <param name="method"></param>
            <param name="defaultNameSpace"></param>
            <param name="allowNonPublic"></param>
            <param name="parameters"></param>
            <returns>The result of the invoked method or property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Method(System.String,System.Object[],System.Boolean)">
            <summary>Invokes a method or propery getter</summary>
            <param name="nameSpaceDotTypeColonMethod"></param>
            <param name="parameters"></param>
            <param name="allowNonPublic"></param>
            <returns>The return of the invoked method or property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.TryResolveTargetType(System.String,System.String@,System.String)">
            <summary>Resolve the type / namespace of the given type</summary>
            <param name="targetType"></param>
            <param name="nameSpaceDotType"></param>
            <param name="defaultNameSpace"></param>
            <returns>True if the target type was valid and successfully resolved</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_Final_String(System.String)">
            <summary>Checks for illegal characters or blacklisted namespaces etc</summary>
            <param name="typeColonMethod"></param>
            <returns>false if the provided method or type is not allowed.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_Method(System.Reflection.MethodInfo,System.Boolean)">
            <summary>Make sure the specified method is allowed</summary>
            <param name="method"></param>
            <param name="allowNonPublic"></param>
            <returns>false if the method is not allowed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_PropertyGet_Static(System.String,System.String,System.String,System.Boolean)">
            <summary>Invoke a static property getter</summary>
            <param name="type">The class containing the static property getter</param>
            <param name="propertyGet">The name of the property getter</param>
            <param name="defaultNameSpace"></param>
            <param name="allowNonPublic"></param>
            <returns>The value returned by the static property getter</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_GetFieldValue(System.String,System.Object,System.String)">
            <summary>Get the value stored in the specified field of the instance (or static field if instance is <see langword="null"/>)</summary>
            <param name="fieldName"></param>
            <param name="instance">Get the non static field from this instance, or static field if instance is <see langword="null"/></param>
            <param name="nameSpaceDotType"></param>
            <returns>The value stored in the field</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_GetFieldValue(System.Type,System.String,System.Object,System.String)">
            <summary>Get the value of the given field from the given instance (or static field if instance is <see langword="null"/>)</summary>
            <param name="type"></param>
            <param name="fieldName">The name of the field</param>
            <param name="instance">Instance class to get the field value of, or <see langword="null"/> if the field is static</param>
            <param name="nameSpaceDotType">NameSpace.Type</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_PropertyGet(System.String,System.Object,System.Boolean)">
            <summary>Invoke a property get of the given instance (or a static property if instance is not given)</summary>
            <param name="typeColonPropertyGet">NameSpace.Type:PropertyGet - If NameSpace not given, will use default</param>
            <param name="instance">Invoke a non static property of this instance, set to <see langword="null"/> if the property is static</param>
            <param name="allowNonPublic">Are non-public property invokes allowed?</param>
            <returns>The returned value of the invoked property getter</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Static(System.Reflection.MethodInfo,System.Object[],System.Boolean)">
            <summary>Invoke a static <paramref name="method"/> or property getter</summary>
            <param name="method">The static <paramref name="method"/> to invoke</param>
            <param name="parameters">The parameters to pass into the <paramref name="method"/>, should be set to null if the <paramref name="method"/> doesnt have any parameters or it is a property getter</param>
            <param name="allowNonPublic">Allow non-public members to be invoked</param>
            <returns>The value returned by the target <paramref name="method"/> or property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke(System.Object,System.Reflection.MethodInfo,System.Object[],System.Boolean)">
            <summary>Invoke the given static or instanced <paramref name="method"/> or param getter of the given <paramref name="instance"/> with the given <paramref name="parameters"/> - <paramref name="instance"/> should be <see langword="null"/> if the method or property is static</summary>
            <param name="instance"><paramref name="instance"/> of the non static class that contains the non static <paramref name="method"/> or property, set to <see langword="null"/> if the <paramref name="method"/> or propery is static</param>
            <param name="method">The name of the <paramref name="method"/> or property getter</param>
            <param name="parameters">The parameters to invoke the <paramref name="method"/> with, or <see langword="null"/> if no params or the <paramref name="method"/> is a property getter - Should be <see langword="null"/> if no params</param>
            <param name="allowNonPublic">Is invoking non public members allowed?</param>
            <returns>The invoke result / The value returned by the target <paramref name="method"/> or property getter - <see langword="void"/> methods will return <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsRecursive(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the given <paramref name="method"/> is recursive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPatchClass(System.Type)">
            <summary>Is the given class a harmony patch?</summary><param name="type"></param><returns>True if the class is a harmony patch</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPrefix(System.Reflection.MethodInfo)">
            <summary>Check if the given method is a harmony Prefix method inside a harmony patch class</summary>
            <param name="method"></param><returns>True if is a harmony Prefix method</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPostfix(System.Reflection.MethodInfo)">
            <summary>Check if the given method is a harmony Prefix method inside a harmony patch class</summary>
            <param name="method"></param><returns>True if is a harmony Postfix method</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetTypes_Safe(System.Reflection.Assembly)">
            <summary>Get <seealso cref="T:System.Type">Types</seealso> from an <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.ReflectionTypeLoadException"/> are handled silently</summary>
            <param name="assembly">the input assembly</param>
            <returns>Array '<see cref="T:System.Type"/>[]' of all the successfully loaded <seealso cref="T:System.Type">Types</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetTypes(System.Reflection.Assembly,System.Boolean)">
            <summary>Get Types from an Assembly, <see cref="T:System.Reflection.ReflectionTypeLoadException"/> are handled silently</summary>
            <param name="assembly">the input assembly</param>
            <param name="alwaysPrintExceptions">Always print <see cref="T:System.Reflection.ReflectionTypeLoadException"/> to log as warnings, even if debug mode is off</param>
            <returns>Array 'Type[]' of all the successfully loaded Types</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary></summary>
            <typeparam name="A"></typeparam>
            <param name="memberInfo"></param>
            <returns><see langword="true"/> if the member has the attribute</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetAttributes_Safe(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
            <summary>Get attributes safely, if an exception occurs, return a partial list / empty list - Never <see langword="null"/></summary>
            <param name="memberInfo">Type, method, field, etc. Whose attributes we want.</param>
            <param name="alwaysPrintExceptions">Always print type load exceptions as warnings. (Normally handled silently)</param>
            <param name="inherit"></param>
            <returns>List&lt;Attribute&gt; - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetMethod_Safe(System.Reflection.Assembly,System.String,System.String,System.Reflection.BindingFlags)">
            <summary>Get the <see cref="T:System.Reflection.MethodInfo"/> with the given name and containing type from the given <paramref name="assembly"/></summary>
            <param name="assembly"></param>
            <param name="declaringTypeFullName">Namespace.Namespace.Type/Namespace.Type</param>
            <param name="methodName"></param>
            <param name="bindingFlags"></param>
            <returns><see cref="T:System.Reflection.MethodInfo"/> of the target method if it was found || <see langword="null"/> if it was not found or there was an error.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetMethod_Safe(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>Try to get the method inside the given type</summary>
            <param name="declaringType"></param>
            <param name="methodName"></param>
            <param name="bindingFlags"></param>
            <returns><see cref="T:System.Reflection.MethodInfo"/> of the given method, or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetField(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>Get the <see cref="T:System.Reflection.FieldInfo"/> of a <see langword="static"/> field inside the given <see cref="T:System.Type"/></summary>
            <param name="containingType"></param>
            <param name="fieldName"></param>
            <param name="bindingFlags"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetFieldValue(System.Object,System.String,System.Reflection.BindingFlags)">
            <summary>Get the non-<see langword="static"/> field value from the provided instance</summary>
            <param name="instance"></param>
            <param name="fieldName"></param>
            <param name="bindingFlags"></param>
            <returns>The value stored in the non-<see langword="static"/> field of the given instance</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetFieldValue(System.Type,System.String,System.Reflection.BindingFlags,System.String)">
            <summary>Get the field value of a <see langword="static"/> field</summary>
            <param name="declaringType">One of: 'declaringType' or 'nameSpaceDotType' must be provided</param>
            <param name="fieldName"></param>
            <param name="bindingFlags"></param>
            <param name="nameSpaceDotType">One of: 'declaringType' or 'nameSpaceDotType' must be provided</param>
            <returns>The value of the specified <see langword="static"/> field</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.SaveFileFixer.SaveFileFixer_RunAction.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Search">
            <summary>Methods for searching for things</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.GetAllPawnsOfFaction(RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param>
            <returns>An <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> of all the pawns (alive or dead) of the given <paramref name="faction"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.GetAllPawnsOfFactionLazy(RimWorld.Faction)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Search.GetAllPawnsOfFaction(RimWorld.Faction)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.ForPawnByName(System.String,RimWorld.Faction,NQualityOfLife.Types.UnOrderedList{Verse.Pawn})">
            <summary>Search for a <see cref="T:Verse.Pawn"/> by name</summary>
            <param name="name"></param>
            <param name="faction"></param>
            <param name="searchSet"></param>
            <returns>The <see cref="T:Verse.Pawn"/> with the given name, or <see langword="null"/> if no matching <see cref="T:Verse.Pawn"/> was found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.Defs.FindDefInAssembly(System.Reflection.Assembly,System.String,System.String@)">
            <summary>Scans the given <paramref name="assembly"/> for any references to the given <paramref name="defName"/></summary>
            <param name="assembly"></param>
            <param name="defName"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.CheckRegionForThing(Verse.Region,Verse.ThingDef,System.Boolean,RimWorld.Faction,System.Boolean,System.Predicate{Verse.Thing})">
            <summary>Search the <paramref name="region"/> for a <see cref="T:Verse.Thing"/> that matches the given parameters</summary>
            <param name="region"></param>
            <param name="thingToFind"></param>
            <param name="findHostiles"></param>
            <param name="myFaction"></param>
            <param name="findTrader"></param>
            <param name="thingValidator"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.Validator(Verse.Thing,Verse.ThingDef,System.Boolean,RimWorld.Faction,System.Boolean,System.Predicate{Verse.Thing})">
            <summary>Is the given thing the thing we are looking for?</summary>
            <param name="thing">the thing we are comparing to the thing wea are looking for</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as null.</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="thingValidator"></param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing, bool next</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForThingInRegionsSpiralAroundLocation(Verse.IntVec3,Verse.Map,Verse.ThingDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RimWorld.Faction,System.Boolean,System.Boolean,System.Predicate{Verse.Thing})">
            <summary>Search for the given thing around surrounding regions</summary>
            <param name="myLocation">Start location of the search.</param>
            <param name="map">The map to search</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as null.</param>
            <param name="findEmptyCell">True if we want to instead find an empty cell.</param>
            <param name="emptyCellMustBeUnroofed">If searching for empty cell, does the cell have to be un-roofed?</param>
            <param name="cellCantBeInMyRegion">If searching for empty cell, does the cell have to be outside the starting region?</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="onlyOurRegion">Check only our region?</param>
            <param name="thingValidator">Custom thing validator if one def is not sufficient</param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForRegionInSpiralAroundLocation(Verse.Region,Verse.Region)">
            <summary></summary>
            <param name="myRegion"></param>
            <param name="otherRegion"></param>
            <returns><see langword="true"/> if the <paramref name="otherRegion"/> is found in the range of the spiral search</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForRegionInSpiralAroundLocation(Verse.Region,System.Predicate{Verse.Region})">
            <summary>Search for a <see cref="T:Verse.Region"/> that matches the <paramref name="predicate"/> in a spiral starting at the given <see cref="T:Verse.Region"/></summary>
            <param name="myRegion"></param>
            <param name="predicate"></param>
            <returns>The first found <see cref="T:Verse.Region"/> that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForThingInRegionsSpiralAroundLocation(Verse.Region,Verse.Map,Verse.ThingDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RimWorld.Faction,System.Boolean,System.Boolean,System.Predicate{Verse.Thing})">
            <summary>Search for the given thing around surrounding regions</summary>
            <param name="myRegion">Start region of the search.</param>
            <param name="map">The map to search</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as null.</param>
            <param name="findEmptyCell">True if we want to instead find an empty cell.</param>
            <param name="emptyCellMustBeUnroofed">If searching for empty cell, does the cell have to be un-roofed?</param>
            <param name="cellCantBeInMyRegion">If searching for empty cell, does the cell have to be outside the starting region?</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="onlyOurRegion">Check only our region?</param>
            <param name="thingValidator">Custom thing validator if one def is not sufficient</param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing</returns>
        </member>
        <member name="F:NQualityOfLife.Utils.Session.onlyMap">
            <summary>The only active <see cref="T:Verse.Map"/>, if there are no maps, or more than one active map, will be <see langword="null"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Session.onlyMapTile">
            <summary>The world map tile of the only active <see cref="T:Verse.Map"/>, if there are no maps, or more than one active map, will be -1</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Sound.PlayOneShot(Verse.SoundDef,Verse.Sound.SoundInfo)">
            <summary>Play a oneshot sound</summary>
            <param name="soundDef"></param>
            <param name="info"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Sound.PlayRejectInput">
            <summary>Play the standard reject input UI sound</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Sound.PlayUISound(Verse.SoundDef,NQualityOfLife.Types.Factor)">
            <summary>Play an UI sound</summary>
            <param name="soundDef"></param>
            <param name="adjustedVolumeFactor">Leave as <see langword="default"/> to use default volume</param>
        </member>
        <member name="P:NQualityOfLife.Utils.Colors.GoodColor">
            <summary>Will give the 'good' color, will differ based on settings. Intended for color blind support etc...</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Colors.BadColor">
            <summary>Will give the 'bad' color, will differ based on settings. Intended for color blind support etc...</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.SetTransparency(NQualityOfLife.Colors.IColorRGBA,NQualityOfLife.Types.Ratio)">
            <summary>1 is fully transparent (see trough) 0 is fully opaque</summary>
            <param name="iColor"></param>
            <param name="transparencyRatio">1 is fully transparent, 0 is opaque</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.SetTransparency(UnityEngine.Color,NQualityOfLife.Types.Ratio)">
            <summary>1 is fully transparent (see trough) 0 is fully opaque</summary>
            <param name="color"></param>
            <param name="transparencyRatio">1 is fully transparent, 0 is opaque</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsFullyTransparent(UnityEngine.Color)">
            <summary></summary>
            <param name="color"></param>
            <returns><see langword="true"/> if the <paramref name="color"/> is fully transparent</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsFullyTransparent(NQualityOfLife.Colors.IColor)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.IsFullyTransparent(UnityEngine.Color)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToColor(System.String)">
            <summary>Converts a hex code such as '#FF1144FF' into a UnityEngine.Color</summary><param name="colorHexCode"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToByte(System.String)">
            <summary>Input must be a string with a length of 2, such as 'F2' or '5F'</summary>
            <param name="hexCode">Must be 'FF', '0A', 'A2', '01', '00' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexToByte(System.ValueTuple{System.Char,System.Char})">
            <summary>Converts the given 2 letter hex code to its byte value</summary>
            <param name="hex">Must be 'FF', 'F0', '1A', '51', 'AB' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexToByte(System.Char,System.Char)">
            <summary>Converts the given 2 letter hex code to its byte value</summary>
            <param name="bigger">Must be 'F', '0', 'A', '1', 'B' etc</param>
            <param name="smaller">Must be 'F', '0', 'A', '1', 'B' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToColor(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte})">
            <summary>Converts RGBA values to a UnityEngine.Color</summary><param name="color"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBToColor(System.ValueTuple{System.Byte,System.Byte,System.Byte})">
            <summary>Converts RGB values to a UnityEngine.Color</summary><param name="color"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexLetterToByte(System.Char,System.Byte)">
            <summary></summary>
            <param name="hexLetter">A single hex letter, from 0 -> 9 -> A -> F</param>
            <param name="pos">Must be 0 or 1</param>
            <returns>The value of the letter for the given position, for example 'F' pos '0' -> '15' and 'F' pos '1' -> '240'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ByteToHexS(System.Byte)">
            <summary>Returns the corresponding hex symbol for the given byte, Accepts inputs in the '0 - 15' range!</summary>
            <param name="b">byte in the '0 - 15' range</param>
            <returns>'0 -> 0', '15 -> F'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ByteToHexCode(System.Byte)">
            <summary>Converts a byte value into its corresponding hex code. Such as: '255 -> FF'</summary>
            <param name="b">byte to convert '255 -> FF'</param>
            <returns>a hex code such as 'FF' 'AB' 'F4' etc</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ByteToHex(System.Byte)">
            <summary>Converts a byte value into its corresponding hex code. Such as: '255 -> FF'</summary>
            <param name="b">byte to convert '255 -> FF'</param>
            <returns>a hex code such as 'FF' 'AB' 'F4' etc</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToRGB(System.String)">
            <summary>Convert a hex color code such as #FF15AB into its RGB components. If the hex code has an Alpha component like in '#FF00AAF6', it will be ignored</summary>
            <param name="hexCode">Valid inputs: '001122', '#112233', '#ff0000f9', 'FF12F0FF'</param>
            <returns> If input is null or empty => (0, 0, 0)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToRGBA(System.String)">
            <summary>Convert a hex color code such as #FF15ABFF into its RGBA components. If the hex code doesn't have an Alpha component like in '#FF15AB', it will be returned as 255. - The input hex code can start with or without '#'</summary>
            <param name="hexCode">Valid inputs: '001122', '#112233', '#ff0000f9', 'FF12F0FF'</param>
            <returns>If input is null or empty => (0, 0, 0, 255)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorToHexCode(UnityEngine.Color)">
            <summary>Converts an UnityEngine.Color into a hex code such as '#FF1144FF'</summary><param name="color"></param><returns>A hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorToHex(UnityEngine.Color)">
            <summary>Converts an UnityEngine.Color into a hex code such as '#FF1144FF'</summary><param name="color"></param><returns>A hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Single,System.Single,System.Single,System.Single)">
            <summary>Converts the given floats to a hex color code. If the input values are above 1f max value will be 255f else max will be 1f</summary>
            <param name="R">Red</param>
            <param name="G">Green</param>
            <param name="B">Blue</param>
            <param name="A">Alpha - Transparency</param>
            <returns>a hex code such as '#FF3300FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHex(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte})">
            <summary></summary><param name="color"></param><returns>a hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte})">
            <summary></summary><param name="color"></param><returns>a hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHex(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Converts the given RGBA values into a hex color code, such as: '#FF5BA6FF'</summary>
            <param name="R"></param>
            <param name="G"></param>
            <param name="B"></param>
            <param name="A">Alpha (Transparency)</param>
            <returns>a hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Converts the given RGBA values into a hex color code, such as: '#FF5BA6FF'</summary>
            <param name="R"></param>
            <param name="G"></param>
            <param name="B"></param>
            <param name="A">Alpha (Transparency)</param>
            <returns>a hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Darken(NQualityOfLife.Colors.Hex,NQualityOfLife.Types.Ratio)">
            <summary>Darkens a hex color code</summary>
            <param name="color"></param>
            <param name="amount"></param>
            <returns>Hex color code such as: '#FF9977FA'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.MutateColor(NQualityOfLife.Colors.Hex,NQualityOfLife.Utils.Colors.MutatorMode)">
            <summary></summary>
            <param name="inputColor"></param>
            <param name="mutatorMode"></param>
            <returns>A hex color code.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorIsTooDark(NQualityOfLife.Colors.Hex)">
            <summary>Returns true if the input hex color is too dark</summary>
            <param name="hex">a hex color like: '#F4A5FF'</param>
            <returns>true if the input hex color is too dark</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorIsTooBland(NQualityOfLife.Colors.Hex)">
            <summary></summary>
            <param name="hex">The input color code. for example: '#FF17A7'</param>
            <returns>True if the given hex color is too 'bland'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Brighten(NQualityOfLife.Types.HexByte)">
            <summary>Brightens the given color channel</summary>
            <param name="b"></param>
            <returns>0 - 255</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.BrightenIfDark(NQualityOfLife.Colors.Hex)">
            <summary>Brightens a hex color code if the color is too dark</summary>
            <param name="color"></param>
            <returns>Hex color code such as: '#FF9977'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.GenerateDeterministicUniqueColor(System.Int32)">
            <summary>Returns a hex code based on the input hash</summary>
            <param name="hash">the seed for the generated color</param>
            <returns>a hex color code such as: '#AF44FF' || or "#000000FF" if failed to generate the color from the hash</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Mods">
            <summary>Data about loaded mods for compatibility and integration</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods._MyMetaData">
            <summary>The instance of my 'ModMetaData'</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Mods.MyMetaData">
            <summary>Get the 'ModMetaData' for the NQoL mod</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutLoadOrder(Verse.ModMetaData,System.String,System.Int32)">
            <summary>Check and warn the user if any mod violates the load order rules</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="loadIndex"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.CheckRules(Verse.ModMetaData,System.String,System.ValueTuple{NQualityOfLife.Utils.Mods.LoadOrderRules,System.String,NQualityOfLife.Utils.Mods.IssueSeverity,System.String},System.Int32)">
            <summary>Check and warn the user if any mod violates the load order rules</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="ruleIn"></param>
            <param name="modLoadIndex"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutCompatibleVersion(Verse.ModMetaData,System.String)">
            <summary>Check the mod version of a mod to the known working version (for compatibility reasons)</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.TestVersionAndWarn(Verse.Mod,System.String,System.String)">
            <summary>Check the mod version of a mod to the known working version (for compatibility reasons)</summary>
            <param name="mod"></param>
            <param name="testedModVersion"></param>
            <param name="backupTestedModVersion"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(Verse.ModMetaData,System.String)">
            <summary>Check the mod for any suspicious or harmful things such as error supression</summary>
            <param name="modMetaData">Check this mod for sus stuff</param>
            <param name="modPackageId">Fallback identifier for finding the mod</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.GetHandleFromPackageID(System.String,System.Boolean)">
            <summary>Get the Mod associated with the given packageid</summary>
            <param name="packageID"></param>
            <param name="errorOnFail"></param>
            <returns>Mod</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(System.IO.DirectoryInfo,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan the assemblies of the given mod / root folder for potentially un-wanted stuff.</summary>
            <param name="modRootFolder"></param>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan the nested types of the given type for unwanted stuff</summary>
            <param name="type">Type whose nested classes to scan</param>
            <param name="assembly">The assembly that the type is from</param>
            <param name="fromMod">The mod where the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan all the types of the given assembly for potentially unwanted harmony patches etc...</summary>
            <param name="assembly">Assembly to scan</param>
            <param name="fromMod">The mod that the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Type[],System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan the given types and their nested types for un-wanted stuff</summary>
            <param name="types">The types to check</param>
            <param name="assembly">The parent assembly of the given types</param>
            <param name="fromMod">The parent mod of the types / assembly</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusType(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Checks if the given type (class) or any of its nested classes are an error supression harmony patch, or other potentially un-wanted thing.</summary>
            <param name="type">The type to check (and its nested classes)</param>
            <param name="assembly">The assembly that contanis the type</param>
            <param name="fromMod">The mod that the assembly and type are from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusType_ErrorSuppression(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Print a waring if the given type is an error suppressing harmony patch.</summary>
            <param name="type">The type to test</param>
            <param name="assembly"></param>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMethods_AnyDestructivePrefix(System.Type,System.Reflection.MethodInfo@,System.String@)">
            <summary>Checks if any of the method in the given type are destructive prefixes.</summary>
            <param name="type">The type whose methods we want to check.</param>
            <param name="susMethod">The detected sus method or null if none found.</param>
            <param name="reason">The reason why the detected method is 'sus'.</param>
            <returns>true if any of the methods in the specified type are destructive prefixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMethods_AnyDestructivePrefix(System.Reflection.MethodInfo[],System.Reflection.MethodInfo@,System.String@)">
            <summary>Checks if any of the method in the given array are destructive prefixes.</summary>
            <param name="methods">The array of methods to check.</param>
            <param name="susMethod">The detected sus method or null if none found.</param>
            <param name="reason">The reason why the detected method is 'sus'.</param>
            <returns>true if any of the given methods is a destructive prefix</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssembly(System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan all the types in the given assembly for error supression etc...</summary>
            <param name="assembly">Assembly to scan</param>
            <param name="fromMod">The mod that the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssemblies(Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scans the assemblies of the given mod for error supression or other things that are potentially concerning.</summary>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssemblies(System.Reflection.Assembly[],Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scans the given assemblies for error supression or other things that are potentially concerning.</summary>
            <param name="assemblies">Assemblies to scan</param>
            <param name="fromMod">The mod that the assemblies are from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scans the assemblies of the given mod for error supression or other things that are potentially concerning.</summary>
            <param name="mod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutOutdated(Verse.Mod,System.String)">
            <summary>Warn the user if the given mod is not updated for the current game version</summary>
            <param name="mod"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutOutdated(Verse.ModMetaData,System.String)">
            <summary>Warn the user if the given mod is not updated for the current game version</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.ModMetaData)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.Mod)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.ModContentPack)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.BiotechActive">
            <summary>Is the Biotech DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.IdeologyActive">
            <summary>Is the Ideology DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.RoyaltyActive">
            <summary>Is the Royalty DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.AnomalyActive">
            <summary>Is the Anomaly DLC active?</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.IncidentUtils.Artillery.ArtilleryStrike(Verse.Map,System.Int32,RimWorld.Direction8Way,NQualityOfLife.Types.UnOrderedList{Verse.ThingDef})">
            <summary></summary>
            <param name="map"></param>
            <param name="shells">How many shells to launch</param>
            <param name="fromDirection">The direction where the shells will fly from</param>
            <param name="allowedProjectiles">The list of allowed shells || if null select a random shell from all available shells</param>
        </member>
        <member name="M:NQualityOfLife.Utils.IncidentUtils.Artillery.NuclearStrike(System.Int32,RimWorld.Planet.GlobalTargetInfo,System.Single)">
            <summary>Launch a rimatomics ICBM at the specified target</summary>
            <param name="launchTile"></param>
            <param name="target"></param>
            <param name="warheadYield"></param>
        </member>
        <member name="T:NQualityOfLife.Utils.IComplexNumber`3">
            <summary>Inteface for numbers that have a maginitude and angle</summary>
            <typeparam name="TReal"></typeparam>
            <typeparam name="TImaginary"></typeparam>
            <typeparam name="TMagnitude"></typeparam>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.Magnitude">
            <summary>The magnitude <typeparamref name="TMagnitude"/> of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt; when in polar form</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.AngleDeg">
            <summary>The angle of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt; in <see cref="T:NQualityOfLife.Units.Degrees"/> when in polar form</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.AngleRad">
            <summary>The angle of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt; in <see cref="T:NQualityOfLife.Units.Radians"/> when in polar form</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.RealPart">
            <summary>The real part <typeparamref name="TReal"/> of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt;</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.ImaginaryPart">
            <summary>The imaginary part <typeparamref name="TImaginary"/> of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt;</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.IComplexNumber`3.EqualsExact(NQualityOfLife.Utils.IComplexNumber{`0,`1,`2})">
            <summary></summary><param name="other"></param><returns><see langword="true"/> if the <see cref="T:System.Single"/> values are exactly the same, to the bit level.</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Math">
            <inheritdoc cref="T:System.Math"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.PI">
            <inheritdoc cref="F:System.Math.PI"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.PI_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.PI"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Atan(System.Single)">
            <summary>Get the angle in <see cref="T:NQualityOfLife.Units.Radians"/> whose tangent is the given '<paramref name="tangent"/>'</summary>
            <param name="tangent"></param>
            <returns>Angle in <see cref="T:NQualityOfLife.Units.Radians"/> whose tangent is the given '<paramref name="tangent"/>'</returns>
            <inheritdoc cref="M:System.Math.Atan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Atan(System.Double)">
            <summary>Get the angle in <see cref="T:NQualityOfLife.Units.Radians"/> whose tangent is the given '<paramref name="tangent"/>'</summary>
            <param name="tangent"></param>
            <returns>Angle in <see cref="T:NQualityOfLife.Units.Radians"/> whose tangent is the given '<paramref name="tangent"/>'</returns>
            <inheritdoc cref="M:System.Math.Atan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Atan(System.Single,System.Single)">
            <inheritdoc cref="M:System.Math.Atan2(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sin(NQualityOfLife.Units.Radians)">
            <inheritdoc cref="M:System.Math.Sin(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Cos(NQualityOfLife.Units.Radians)">
            <inheritdoc cref="M:System.Math.Cos(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Tan(NQualityOfLife.Units.Radians)">
            <inheritdoc cref="M:System.Math.Tan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sin(NQualityOfLife.Units.Degrees)">
            <inheritdoc cref="M:System.Math.Sin(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Cos(NQualityOfLife.Units.Degrees)">
            <inheritdoc cref="M:System.Math.Cos(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Tan(NQualityOfLife.Units.Degrees)">
            <inheritdoc cref="M:System.Math.Tan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sin(NQualityOfLife.Units.IAngle)">
            <inheritdoc cref="M:System.Math.Sin(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Cos(NQualityOfLife.Units.IAngle)">
            <inheritdoc cref="M:System.Math.Cos(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Tan(NQualityOfLife.Units.IAngle)">
            <inheritdoc cref="M:System.Math.Tan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeDegrees(NQualityOfLife.Units.Degrees)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.Normalize"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeDegreesSigned(NQualityOfLife.Units.Degrees)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.NormalizeSigned"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeRadians(NQualityOfLife.Units.Radians)">
            <inheritdoc cref="M:NQualityOfLife.Units.Radians.Normalize"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeRadiansSigned(NQualityOfLife.Units.Radians)">
            <inheritdoc cref="M:NQualityOfLife.Units.Radians.NormalizeSigned"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeDegrees(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.Normalize"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeDegreesSigned(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.NormalizeSigned"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeRadians(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Radians.Normalize"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeRadiansSigned(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Radians.NormalizeSigned"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sqrt(NQualityOfLife.Types.IFloat)">
            <inheritdoc cref="M:System.Math.Sqrt(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sqrt(System.Single)">
            <summary>Get the square root of a number</summary>
            <param name="value">Get the square root of this value</param>
            <returns>The square root of the input number</returns>
            <inheritdoc cref="M:System.Math.Sqrt(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Double,System.Double)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Single,System.Single)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Double,System.Int32)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Single,System.Int32)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Get the expected value of Y at the given X</summary>
            <param name="from_X">X before target_X</param><param name="from_Y">Y value at from_X</param><param name="to_X">X after target_X</param><param name="to_Y">Y value at to_X</param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at target_X</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
            <summary>Get the expected value of Y at the given X</summary>
            <param name="from">The point before target_X</param><param name="to">The point after target_X</param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at target_X</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(NQualityOfLife.Geometry.Point2D,NQualityOfLife.Geometry.Point2D,System.Single)">
            <summary>Get the expected value of Y at the given X</summary>
            <param name="from">The point before target_X</param><param name="to">The point after target_X</param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at target_X</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Single,Verse.FloatRange)">
            <summary></summary>
            <param name="num"></param><param name="range"></param>
            <returns><see langword="true"/> if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Single,System.ValueTuple{System.Single,System.Single})">
            <summary></summary>
            <param name="num"></param><param name="range"></param>
            <returns><see langword="true"/> if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Contains(System.ValueTuple{System.Single,System.Single},System.Single)">
            <summary></summary>
            <param name="range"></param><param name="num"></param>
            <returns><see langword="true"/> if the given number is inside the min and max range, inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Includes(System.ValueTuple{System.Single,System.Single},System.Single)">
            <summary></summary>
            <param name="range"></param><param name="num"></param>
            <returns><see langword="true"/> if the given number is inside the min and max range, inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Contains_Inclusive(Verse.IntRange,System.Int32)">
            <summary></summary>
            <param name="range"></param>
            <param name="number"></param>
            <returns><see langword="true"/> if the given number is within the range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Int32,Verse.IntRange)">
            <summary></summary>
            <param name="num"></param>
            <param name="range"></param>
            <returns><see langword="true"/> if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeExclusive(System.Int32,Verse.IntRange)">
            <summary></summary>
            <param name="num"></param>
            <param name="range"></param>
            <returns><see langword="true"/> if the given number is within the given range - Exclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Int32,System.Int32,System.Int32)">
            <summary></summary>
            <param name="num"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns><see langword="true"/> if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeExclusive(System.Int32,System.Int32,System.Int32)">
            <summary></summary>
            <param name="num"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns><see langword="true"/> if the given number is within the given range - Exclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.RoundToInt(System.Single)">
            <summary>Round the <paramref name="number"/> to the closest <see cref="T:System.Int32"/></summary>
            <param name="number"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <returns>The <paramref name="number"/> rounded to the closest <see cref="T:System.Int32"/></returns>
            <inheritdoc cref="M:System.Math.Round(System.Decimal,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.RoundToInt(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.RoundToInt(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Round(System.Single)">
            <inheritdoc cref="M:System.Math.Round(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Even(System.Int32)">
            <summary></summary><param name="num"></param>
            <returns><see langword="true"/> if the input <paramref name="num"/> is even</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Odd(System.Int32)">
            <summary></summary><param name="num"></param>
            <returns><see langword="true"/> if the input <paramref name="num"/> is odd</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.TallerOf(UnityEngine.Rect,UnityEngine.Rect)">
            <summary></summary>
            <param name="rect"></param>
            <param name="otherRect"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(UnityEngine.Rect,UnityEngine.Rect)">
            <summary></summary>
            <param name="rect"></param>
            <param name="otherRect"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Byte,System.Byte)">
            <summary>Returns the larger <see cref="T:System.Byte"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the two <see cref="T:System.Byte"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Byte,System.Byte)">
            <summary>Returns the smaller <see cref="T:System.Byte"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the two <see cref="T:System.Byte"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Single,System.Single)">
            <summary>Returns the larger <see cref="T:System.Single"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the two <see cref="T:System.Single"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Max(System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.LargerOf(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Single,System.Single)">
            <summary>Returns the smaller <see cref="T:System.Single"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the two <see cref="T:System.Single"/> values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Min(System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.SmallerOf(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)">
            <summary>Returns the larger <see cref="T:System.Int32"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the two <seealso cref="T:System.Int32">integer</seealso> values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Max(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Int64,System.Int64)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Int64,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Int32,System.Int32)">
            <summary>Returns the smaller <see cref="T:System.Int32"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the two <seealso cref="T:System.Int32">integer</seealso> values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Min(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.SmallerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Byte,System.Byte,System.Byte)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>A <see cref="T:System.Byte"/> &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Int32,System.Byte,System.Byte)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>A <see cref="T:System.Int32"/> &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>an <see cref="T:System.Int32"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampToRange(System.Single,Verse.FloatRange)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampToRange(System.Single,System.ValueTuple{System.Single,System.Single})">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>A <see cref="T:System.Single"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Double,System.Double,System.Double)">
            <returns>A <see cref="T:System.Double"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Double,System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Double,System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single)">
            <summary>Clamps the number to 0f-1f inclusive</summary>
            <param name="value"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,System.Single)">
            <summary>Clamps the <paramref name="value"/> to <paramref name="min"/>~<paramref name="max"/> inclusive || <paramref name="min"/> and <paramref name="max"/> must be &gt;= 0 and &lt;= 1</summary>
            <param name="value"></param>
            <param name="min">must be &gt;= 0 and &lt;= 1</param>
            <param name="max">must be &gt;= 0 and &lt;= 1</param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/> in the specified range</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,NQualityOfLife.Types.Ratio,NQualityOfLife.Types.Ratio)">
            <returns>a <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/> in the specified range</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Double,NQualityOfLife.Types.Ratio,NQualityOfLife.Types.Ratio)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,NQualityOfLife.Types.Ratio,NQualityOfLife.Types.Ratio)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,NQualityOfLife.Types.Ratio)">
            <returns>a <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/> in the specified range</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,NQualityOfLife.Types.Ratio,System.Single)">
            <returns>a <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/> in the specified range</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualTo(System.Single,System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualTo(System.Double,System.Double,System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Double,System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Single,System.Single,System.Single)">
            <summary></summary><param name="f"></param><param name="ff"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <paramref name="f"/> is approximately equal to <paramref name="ff"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Double,System.Single,System.Single)">
            <summary></summary><param name="d"></param><param name="f"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <paramref name="d"/> is approximately equal to <paramref name="f"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Single,System.Double,System.Single)">
            <summary></summary><param name="d"></param><param name="f"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <paramref name="f"/> is approximately equal to <paramref name="d"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Double,System.Double,System.Double)">
            <summary></summary><param name="dl"></param><param name="dr"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <paramref name="dl"/> is approximately equal to <paramref name="dr"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsExact(System.Single,System.Single)">
            <summary></summary><param name="f"></param><param name="ff"></param>
            <returns><see langword="true"/> if the two <see cref="T:System.Single"/> values are exactly equal, down to the bit level</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Int32)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) value</returns>
            <remarks>y = |x|</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Single)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) <see cref="T:System.Single"/> value</returns><remarks>y = |x|</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Double)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) value</returns><remarks>y = |x|</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.CountHexTiles(System.Int32)">
            <summary></summary>
            <param name="distance"></param>
            <returns>The count of hex tiles in the given radius/distance from the center hex tile</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.CountHexTilesDonut(System.Int32)">
            <summary></summary>
            <param name="distance"></param>
            <returns>The count of hex tiles in a donut pattern for the given distance from the center</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SyncSeedAndIterations">
            <summary>Sync the NQoL <see cref="T:NQualityOfLife.Utils.Rand"/> seed and iterations with the <see cref="T:Verse.Rand"/> ones.<para>This could be useful to ensure multiplayer compatiblity etc.</para></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="predicate"></param>
            <returns><see langword="default"/> if no element (<typeparamref name="T"/>) is found that satisfies the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="sourceIList"></param>
            <param name="predicate"></param>
            <returns><see langword="default"/> if none of the elements in the set satisfy the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhereOrFallback``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhereOrFallback``1(System.Collections.Generic.IList{``0},System.Predicate{``0},``0)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Selects a random item <typeparamref name="T"/> from the <paramref name="set"/>, or returns <paramref name="fallback"/> if the <paramref name="set"/> is <see langword="null"/> or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this <paramref name="set"/> if it is not <see langword="null"/> or empty, else return the <paramref name="fallback"/></param>
            <param name="fallback">Return this if the <paramref name="set"/> is <see langword="null"/> or empty</param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/> or <paramref name="fallback"/> if <paramref name="set"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.List{``0},``0)">
            <summary>Selects a random item <typeparamref name="T"/> from the <paramref name="set"/>, or returns <paramref name="fallback"/> if the <paramref name="set"/> is <see langword="null"/> or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this <paramref name="set"/> if it is not <see langword="null"/> or empty, else return the <paramref name="fallback"/></param>
            <param name="fallback">Return this if the <paramref name="set"/> is <see langword="null"/> or empty</param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/> or <paramref name="fallback"/> if <paramref name="set"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Selects a random item <typeparamref name="T"/> from the <paramref name="set"/>, or returns <paramref name="fallback"/> if the <paramref name="set"/> is <see langword="null"/> or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this <paramref name="set"/> if it is not <see langword="null"/> or empty, else return the <paramref name="fallback"/></param>
            <param name="fallback">Return this if the <paramref name="set"/> is <see langword="null"/> or empty</param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/> || or <paramref name="fallback"/> if <paramref name="set"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSetWhere``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandomSet``1(System.Collections.Generic.ICollection{``0},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSet``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>if <paramref name="sourceSet" /> is smaller or equal to <paramref name="maxItemsToGet" />, returns a copy of the <paramref name="sourceSet" /> || else creates a new list with random members from the <paramref name="sourceSet" /></summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="maxItemsToGet"></param>
            <returns>A <see langword="new"/> list with randomly selected items from the <paramref name="sourceSet" /></returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.NullReferenceException"/> If <paramref name="sourceSet" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSet``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>If source list is smaller or equal to maxItemsToGet, returns a copy of the source list || else creates a new list with random members from the source list</summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="maxItemsToGet"></param>
            <returns>A <see langword="new"/> list with randomly selected items from the source list</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.NullReferenceException"/> If <paramref name="sourceSet" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.RemoveRandom``1(System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.RemoveRandom_Internal``1(System.Collections.Generic.IList{``0},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.RemoveRandom_Internal``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Removes a random item from the list</summary>
            <typeparam name="T"></typeparam>
            <param name="set"></param><param name="setSize"></param>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.NullReferenceException"/> If <paramref name="set" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1">
            <summary></summary>
            <typeparam name="E"></typeparam>
            <returns>A random value of the provided <see cref="T:System.Enum"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Select a random element '<typeparamref name="T"/>' from the <paramref name="set"/> || An empty or <see langword="null"/> <paramref name="set"/> may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/> || or the <see langword="default"/> value of <typeparamref name="T"/> on error, such as if the input <paramref name="set"/> is empty</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(``0[])">
            <summary>Select a random element <typeparamref name="T"/> from the <paramref name="set"/> || a <see langword="null"/> or empty <paramref name="set"/> may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.IList{``0})">
            <summary>Select a random element <typeparamref name="T"/> from the <paramref name="set"/> || a <see langword="null"/> or empty <paramref name="set"/> may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.List{``0})">
            <summary>Select a random element <typeparamref name="T"/> from the <paramref name="set"/> || a <see langword="null"/> or empty <paramref name="set"/> may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom_Internal``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Select a random element <typeparamref name="T"/> from the <paramref name="set"/> || An empty <paramref name="set"/> will error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <param name="setSize">The known size of the list</param>
            <returns>A random item (<typeparamref name="T"/>) from the <paramref name="set" /> || will return <see langword="default"/> on error</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentOutOfRangeException"/> If <paramref name="setSize" /> is &lt;= 0</remarks>
            <exception cref="T:System.ArgumentNullException"/><exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="P:NQualityOfLife.Utils.Rand.Value">
            <summary>Random value between 0.0 and 1.0 inclusive</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.Range(System.Int32,System.Int32)">
            <summary>Get a random <see cref="T:System.Int32"/> that is >= <paramref name="minInclusive"/> &amp;&amp; &lt;= <paramref name="maxInclusive"/></summary>
            <param name="minInclusive"></param>
            <param name="maxInclusive"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefGen.GiveHash``1(Verse.Def)">
            <summary>Give the <paramref name="def"/> an unique shortHash, trying to give a hash to a def that already has it will error!</summary>
            <typeparam name="D"></typeparam>
            <param name="def"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefGen.FreeHash``1(Verse.Def)">
            <summary>Remove the hash of the given <paramref name="def"/> from the list of taken hashes, Should only be done when removing the def from the database</summary>
            <typeparam name="D"></typeparam>
            <param name="def"></param>
            <returns><see langword="true"/> if the hash was successfully removed, a failure will log an error and return <see langword="false"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading">
            <summary>Multithreading and async task utils</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.debug">
            <summary>Debug threading</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading.Root_Shutdown_Patch">
            <summary>Used to clean up any threads that could still be running</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading.ShutdownHandler">
            <summary>Handles cleaning up any threads that could cause the game to fail to close correctly</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.ShutdownHandler.GetIsShuttingDown">
            <summary>Returns <see langword="true"/> if the game is currently in the process of shutting down</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.ShutdownHandler.IsShuttingDown">
            <summary>Is the game is currently in the process of shutting down?</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.ShutdownHandler.TriggerShutdown">
            <summary>Stop all threads</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading.BackgroundWorker">
            <summary>Manages backroud threads and tasks</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._thread">
            <summary>The backround worker <see cref="T:System.Threading.Thread"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._running">
            <summary>The state of the <see cref="F:NQualityOfLife.Utils.Threading.BackgroundWorker._thread"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.BackgroundWorker.Start">
            <summary>Start the backround worker until its stopped with <see cref="M:NQualityOfLife.Utils.Threading.BackgroundWorker.Stop"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.BackgroundWorker.Stop">
            <summary>Stop the <see cref="F:NQualityOfLife.Utils.Threading.BackgroundWorker._thread"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._stopwatch">
            <summary>Used to get the time spent in the <see cref="M:NQualityOfLife.Utils.Threading.BackgroundWorker.WorkLoop"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.BackgroundWorker.WorkLoop">
            <summary>The work we are performing in the backround <see cref="F:NQualityOfLife.Utils.Threading.BackgroundWorker._thread"/></summary>
            <returns>The amount of <see cref="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds"/> spent in the <see cref="M:NQualityOfLife.Utils.Threading.BackgroundWorker.WorkLoop"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.StartTask(System.Action)">
            <inheritdoc cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>
            <summary></summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Ratio)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Types.Ratio)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@)"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Ratio)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Types.Ratio,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomHalf(NQualityOfLife.Geometry.Rectangle)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.BottomHalf(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomPart(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Types.Ratio)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.BottomPart(UnityEngine.Rect,NQualityOfLife.Types.Ratio)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopHalf(NQualityOfLife.Geometry.Rectangle)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.TopHalf(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopPart(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Types.Ratio)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.TopPart(UnityEngine.Rect,NQualityOfLife.Types.Ratio)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftPart(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Types.Ratio)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.LeftPart(UnityEngine.Rect,NQualityOfLife.Types.Ratio)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightPart(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Types.Ratio)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.RightPart(UnityEngine.Rect,NQualityOfLife.Types.Ratio)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftHalf(NQualityOfLife.Geometry.Rectangle)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.LeftHalf(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightHalf(NQualityOfLife.Geometry.Rectangle)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.RightHalf(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,UnityEngine.Color)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="color"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,System.String)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="additionalInfoString"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(NQualityOfLife.Geometry.Rectangle,System.Nullable{UnityEngine.Color},System.String,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,System.Nullable{UnityEngine.Color},System.String,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,System.Nullable{UnityEngine.Color},System.String,System.Boolean,System.Boolean)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="color"></param>
            <param name="additionalInfoString">Additional info to show on hover</param>
            <param name="stable"></param>
            <param name="debugMouse"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,NQualityOfLife.Colors.IColor,System.String,System.Boolean,System.Boolean)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="iColor"></param>
            <param name="additionalInfoString">Additional info to show on hover</param>
            <param name="stable"></param>
            <param name="debugMouse"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect)">
            <summary>Split the rect into the left and right halfs</summary>
            <param name="rect"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Types.Ratio)">
            <summary>Splits the input <paramref name="rect"/> into two parts</summary>
            <param name="rect">Original <paramref name="rect"/> to split</param><param name="left">The left part of the original <paramref name="rect"/></param><param name="right">The right part of the original <paramref name="rect"/></param>
            <param name="rightSideRatio">The size of the right side <paramref name="rect"/> (Ratio) 0.5f means an equal split</param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Splits the input rect into two equal parts</summary>
            <param name="rect">Original rect to split</param><param name="left">The left half of the original rect</param><param name="right">The right half of the original <paramref name="rect"/></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Splits the input <paramref name="rect"/> into two equal parts</summary>
            <param name="rect">Original <paramref name="rect"/> to split</param><param name="top">The top half of the original <paramref name="rect"/></param><param name="bottom">The bottom half of the original rect</param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Types.Ratio,System.Boolean)">
            <summary>Splits the input <paramref name="rect"/> into two parts</summary>
            <param name="rect">Original <paramref name="rect"/> to split</param><param name="top">The left part of the original <paramref name="rect"/></param><param name="bottom">The right part of the original <paramref name="rect"/></param>
            <param name="bottomRatio">The size of the bottom half <paramref name="rect"/> (Ratio) 0.5f means an equal split</param>
            <param name="debug"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomHalf(UnityEngine.Rect)">
            <summary>Gets the bottom half of the <paramref name="rect"/></summary>
            <param name="rect"></param>
            <returns>The bottom 50% of the given <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomPart(UnityEngine.Rect,NQualityOfLife.Types.Ratio)">
            <summary>Gets the bottom part of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the bottom?</param>
            <returns>The bottom part of the original <paramref name="rect"/> with a height of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopHalf(UnityEngine.Rect)">
            <summary>Gets the top half of the <paramref name="rect"/></summary>
            <param name="rect"></param>
            <returns>The top 50% of the given <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopPart(UnityEngine.Rect,NQualityOfLife.Types.Ratio)">
            <summary>Gets the top part of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the top?</param>
            <returns>The top part of the original <paramref name="rect"/> with a height of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightHalf(UnityEngine.Rect)">
            <summary>Gets the right half of the given <paramref name="rect"/></summary>
            <param name="rect"></param>
            <returns>The right half of the original <paramref name="rect"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightSide(UnityEngine.Rect,NQualityOfLife.Types.Ratio)">
            <summary>Gets the right side of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the right side?</param>
            <returns>The right side of the original <paramref name="rect"/> with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightPart(UnityEngine.Rect,NQualityOfLife.Types.Ratio)">
            <summary>Gets the right side of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the right side?</param>
            <returns>The right side of the original <paramref name="rect"/> with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftHalf(UnityEngine.Rect)">
            <summary>Gets the left half of the given <paramref name="rect"/></summary>
            <param name="rect"></param>
            <returns>The left half of the original <paramref name="rect"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftSide(UnityEngine.Rect,NQualityOfLife.Types.Ratio)">
            <summary>Gets the left side of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the left side?</param>
            <returns>The left side of the original <paramref name="rect"/> with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftPart(UnityEngine.Rect,NQualityOfLife.Types.Ratio)">
            <summary>Gets the left side of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the left side?</param>
            <returns>The left side of the original <paramref name="rect"/> with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftBottomCorner(UnityEngine.Rect)">
            <summary>Get the bottom left corner of the <paramref name="rect"/> (in screen coordinates)</summary>
            <param name="rect"></param>
            <returns>The left bottom corner of the <paramref name="rect"/> (in screen coordinates)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(UnityEngine.Vector2,UnityEngine.Rect)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.IsInside(NQualityOfLife.Geometry.Point2D,UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(System.ValueTuple{System.Single,System.Single},UnityEngine.Rect)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.IsInside(NQualityOfLife.Geometry.Point2D,UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(NQualityOfLife.Geometry.Point2D,UnityEngine.Rect)">
            <summary>Is this point inside the given rect?</summary>
            <param name="point"></param><param name="rect"></param>
            <returns><see langword="true"/> if the point is inside the rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.OnScreen(UnityEngine.Rect,NQualityOfLife.Types.Vector2Float,System.Boolean)">
            <summary></summary><param name="rect"></param>
            <param name="debug"></param>
            <param name="positionOffset"></param>
            <returns><see langword="true"/> if the input rect is partly or fully visible on screen (Assuming the rect is drawn) / in bounds of the screen </returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.OnScreen(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Types.Vector2Float,System.Boolean)">
            <summary></summary><param name="rect"></param>
            <param name="debug"></param>
            <param name="positionOffset"></param>
            <returns><see langword="true"/> if the input rect is partly or fully visible on screen (Assuming the rect is drawn) / in bounds of the screen </returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.FullyOnScreen(NQualityOfLife.Geometry.Rectangle)">
            <summary>Is the input rect fully inside the bounds of the screen?</summary>
            <param name="rect"></param><returns><see langword="true"/> if the input rect is fully inside the bounds of the screen</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.RectExtensions.FullScreenRect">
            <summary>Gets a Rect that is the size, shape and position of the screen</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.ContainsOrOverlaps(UnityEngine.Rect,UnityEngine.Rect,NQualityOfLife.Types.Vector2Float,System.Boolean)">
            <summary></summary>
            <param name="rect"></param><param name="innerRect"></param>
            <param name="positionOffset"></param>
            <param name="debug"></param>
            <returns><see langword="true"/> if the rects fully or partly overlap each other</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.FullyContains(UnityEngine.Rect,UnityEngine.Rect)">
            <summary>Does this Rect fully contain innerRect?</summary>
            <param name="rect"></param><param name="innerRect"></param>
            <returns><see langword="true"/> if all parts of innerRect are inside this rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.InnerSquare(UnityEngine.Rect)">
            <summary>Get a square rect fitted inside the input rect</summary>
            <param name="rect"></param>
            <returns>Square</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Squeeze(UnityEngine.Rect,System.Single)">
            <summary>Reduces the height of the Rect, anchoring position on the center</summary>
            <param name="rect"></param><param name="amount">pixels</param>
            <returns>The input rect squeezed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SqueezeHorizontal(UnityEngine.Rect,UnityEngine.Rect,UnityEngine.Rect)">
            <summary>Gets a rect between the given two</summary>
            <param name="rect"></param>
            <param name="left">The left part of the rect</param>
            <param name="right">The right part of the rect</param>
            <returns>Rect between the left and right parts</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Squeeze(UnityEngine.Rect,NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Geometry.Rectangle)">
            <summary>Gets a rect between the given two</summary>
            <param name="rect"></param>
            <param name="top">The top part of the rect</param>
            <param name="bottom">The bottom part of the rect</param>
            <returns>Rect fitted between the <paramref name="top"/> and <paramref name="bottom"/> parts</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Segment(UnityEngine.Rect,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Single,System.Single,System.Boolean)">
            <summary>Segments the given rect into 3 parts</summary>
            <param name="rect"></param>
            <param name="top"></param>
            <param name="middle"></param>
            <param name="bottom"></param>
            <param name="topHeightPixels"></param>
            <param name="bottomHeightPixels"></param>
            <param name="debug">Draw colored debug rectangles</param>
        </member>
        <member name="T:NQualityOfLife.Utils.DefExtensions">
            <summary>Def extension utils</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.HasOnCameraSubSounds(Verse.SoundDef)">
            <summary>Can this sound be played without a source thing on a map?</summary>
            <param name="soundDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsGrave(Verse.ThingDef)">
            <summary>Is the given def a grave? (or sarchophigy)</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsChair(Verse.ThingDef)">
            <summary>Is the given def a chair used for comfort?</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsLamp(Verse.ThingDef)">
            <summary>Is the given def a lamp?</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsFurniture(Verse.ThingDef)">
            <summary>Is the given def a furniture item?</summary>
            <param name="thingDef"></param>
            <returns>True if chair, table, bed, etc..</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsSpot(Verse.ThingDef,System.Boolean,System.Boolean)">
            <summary>Is the given def a spot, for the purposes of the spot tab, minification or research changes?</summary>
            <param name="thingDef"></param>
            <param name="allowBlueprints"></param>
            <param name="allowFrames"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.CanBeCreatedByPlayer(Verse.ThingDef,System.Boolean)">
            <summary>Can the given thing be created by the player? (crafted / built)</summary>
            <param name="thingDef"></param>
            <param name="searchIndirectRecipesIfNeeded">Check recipe defs if result was inconclusive? - This could be relatively slow!</param>
            <returns>True if the thing can be crafted or built by the player, false if not.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsInstantlyPlaceable(Verse.ThingDef)">
            <summary>Can this thing be placed without requiring a pawn to build it?</summary>
            <param name="thingDef">Thing we are testing.</param>
            <returns>True if can be placed instantly without needing a pawn to work on it, else false. also returns false if thing is not a building.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.UsesNoMaterialsToMake(Verse.ThingDef)">
            <summary>Note: Returns false for things that are not buildable by the player!</summary>
            <param name="thingDef"></param>
            <returns>True if thing uses no materials to build. Returns false for things that cannot be built or crafted.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsWall(Verse.ThingDef)">
            <summary>Check if the given def is a wall</summary>
            <param name="thingDef"></param>
            <returns>True if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.ShouldBeAbleToMinify(Verse.ThingDef)">
            <summary>Is this thing something that should logically (or for gameplay reasons) be able to be moved?</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.ShouldNeverBeAbleToMinify(Verse.ThingDef)">
            <summary>Checks if the thing is something that should logically or for gameplay resons not be able to be minified</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.CanMinify(Verse.ThingDef)">
            <summary>Is the given thing a valid minifiable thing?</summary>
            <param name="thingDef"></param>
            <returns>True if minifiable and valid</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsUnderground(Verse.ThingDef)">
            <summary>Is the given thing 'underground'</summary>
            <param name="thingDef"></param>
            <returns>True if the thing is partly or fully buried or underground</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.ThingExtensions">
            <summary>Thing def utils WIP</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.IsDeadEndResearch(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns><see langword="true"/> if the <paramref name="researchProjectDef"/> has no children</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.PartOfMainTree(Verse.ResearchProjectDef)">
            <summary>Is <see langword="this"/> <see cref="T:Verse.ResearchProjectDef"/> part of the main progression path?</summary>
            <param name="researchProjectDef"></param>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:Verse.ResearchProjectDef"/> is a pre-requisite of the ship research</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.IsRootResearch(Verse.ResearchProjectDef)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <returns><see langword="true"/> if the <paramref name="researchProjectDef"/> has no parents</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.IsLinearResearchPath(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns>True if this research leads to exactly 1 other research</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.DirectChildren(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns>The projects that require the given project to be completed first</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.DirectChildrenList(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <param name="inlcudeVisible"></param>
            <returns>The projects that require the given project to be completed first</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.AllPrerequisites(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Never null</summary>
            <param name="researchProjectDef"></param>
            <param name="includeNonHidden"></param>
            <param name="includeHidden"></param>
            <param name="sameTabOnly"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.AllPrerequisitesLazy(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ThingExtensions.AllPrerequisites(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.IsQuarantineBed(RimWorld.Building_Bed,System.Boolean)">
            <summary>Check if the bed is a quarantine bed (disease spread system)</summary>
            <param name="bed"></param>
            <param name="bedIsKnownToBeMedical"></param>
            <returns><see langword="true"/> if the <paramref name="bed"/> is a medical bed set to be a quarantine bed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.MakeThing(Verse.ThingDef)">
            <summary>Make a new Thing of the given def</summary>
            <param name="def"></param>
            <returns>The newly created Thing</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.NameWithFactionColor(RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param>
            <returns>The player facing name colored with the color of the faction (the color of their icon / base icons)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrFriendlyFaction(Verse.Thing,Verse.Thing)">
            <summary></summary>
            <param name="thing"></param><param name="other"></param>
            <returns>always false if either faction is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrAllyFaction(RimWorld.Faction,RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param><param name="other"></param>
            <returns>always <see langword="false"/> if either faction is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrFriendlyFaction(RimWorld.Faction,RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param><param name="other"></param>
            <returns>always false if either faction is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.IEnumerable{RimWorld.Apparel},Verse.BodyPartRecord)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.List{RimWorld.Apparel},Verse.BodyPartRecord,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.List{RimWorld.Apparel},Verse.BodyPartRecord)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.List{RimWorld.Apparel},Verse.BodyPartRecord,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.List{RimWorld.Apparel},Verse.BodyPartRecord,System.Int32@)">
            <summary>Get all the <see cref="T:RimWorld.Apparel"/> that is covering the given body part</summary>
            <param name="apparel"></param>
            <param name="bodyPart"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetRegion(Verse.Thing,Verse.Map,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValuesFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="stat4"></param>
            <param name="stat5"></param>
            <param name="stat6"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValuesFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="stat4"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.ZoneExtensions">
            <summary>Zone extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTemperature(Verse.IntVec3,Verse.Map)">
            <summary>Get the cell temperature</summary>
            <param name="loc"></param>
            <param name="map"></param>
            <returns>Temperature in Celsius</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.UsesOutdoorTemperature(Verse.IntVec3,Verse.Map)">
            <summary>Does the given cell use the outdoor map temperature</summary><param name="loc"></param><param name="map"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.IsPolluted(Verse.IntVec3,Verse.Map)">
            <summary></summary><param name="c"></param><param name="map"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover(Verse.Map,Verse.IntVec3)">
            <summary>Get the cover at the cell</summary><param name="c"></param><param name="map"></param><returns>null if no cover at '<paramref name="c"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover(Verse.IntVec3,Verse.Map)">
            <summary>Get the cover at the cell</summary><param name="c"></param><param name="map"></param><returns>null if no cover at '<paramref name="c"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetCover_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Get the cover at the cell</summary>
            <param name="c"></param><param name="map"></param>
            <param name="mapSize"></param>
            <returns>null if no cover at '<paramref name="c"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged(Verse.Thing,Verse.Map)">
            <summary></summary>
            <param name="thing"></param><param name="map"></param>
            <returns>True if the fog grid is fogged at thing</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged(Verse.IntVec3,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.Fogged_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary></summary>
            <param name="c"></param><param name="map"></param><param name="mapSize"></param>
            <returns><see langword="true"/> if the fog grid is fogged at <paramref name="c"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Roofed(Verse.IntVec3,Verse.Map,Verse.RoofDef@)">
            <summary>Returns true if GetRoof is null</summary>
            <param name="c"></param><param name="map"></param><param name="roofDef"></param>
            <returns>True if the cell has a roof - Use GetRoof if you need to get the def anyways</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Roofed(Verse.IntVec3,Verse.Map)">
            <summary>Returns true if GetRoof is null</summary>
            <param name="c"></param><param name="map"></param>
            <returns>True if the cell has a roof - Use GetRoof if you need to get the def anyways</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Get the roof def from the roof grid</summary>
            <param name="c"></param><param name="map"></param>
            <param name="mapSize"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof(Verse.IntVec3,Verse.Map)">
            <summary>Get the roof def from the roof grid</summary>
            <param name="c"></param><param name="map"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain(Verse.Map,Verse.IntVec3)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain(Verse.IntVec3,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Gets the terrain def directly from the terrainGrid - Normally non <see langword="null"/></summary>
            <param name="map"></param><param name="mapSize"></param><param name="c"></param>
            <returns>The terrainGrid <see cref="T:Verse.TerrainDef"/> at <paramref name="c"/> - Normally non <see langword="null"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt(Verse.Map,Verse.IntVec3)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt_Internal(Verse.Map,Verse.IntVec3,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt(Verse.IntVec3,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt_Internal(Verse.Map,Verse.IntVec3,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt_Internal(Verse.Map,Verse.IntVec3,Verse.IntVec3)">
            <summary>Gets the terrain def directly from the terrainGrid - Normally non-<see langword="null"/></summary>
            <param name="map"></param><param name="at"></param>
            <param name="mapSize"></param>
            <returns>The terrainGrid <see cref="T:Verse.TerrainDef"/> at '<paramref name="at"/>' - Normally non-<see langword="null"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3,Verse.MapInfo)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapInfo"></param><returns>c.z * mapInfo.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3,Verse.Map)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="map"></param><returns>c.z * map.info.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.Map,Verse.IntVec3)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="map"></param><returns>c.z * map.info.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3,Verse.IntVec3)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapSize"></param><returns>c.z * mapSize.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3,System.Int32)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapSizeX"></param><returns>c.z * mapSizeX + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RegionAt(Verse.Map,Verse.IntVec3,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RegionAt(Verse.IntVec3,Verse.Map,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion(Verse.IntVec3,Verse.Map,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion(Verse.IntVec3,Verse.Map,Verse.IntVec3,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3,Verse.RegionType)">
            <summary>Get the <see cref="T:Verse.Region"/> at the given <paramref name="cell"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <param name="allowedRegionTypes"></param>
            <returns>The <see cref="T:Verse.Region"/> at the <paramref name="cell"/>, or <see langword="null"/> if out of bounds or not valid type</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_InternalDirect(Verse.IntVec3,Verse.Map,Verse.IntVec3,Verse.RegionType)">
            <summary>Get the <see cref="T:Verse.Region"/> at the given <paramref name="cell"/> || the <paramref name="cell"/> must be in bounds of the <paramref name="map"/> or this method will <see langword="throw"/> an <see cref="T:System.Exception"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <param name="allowedRegionTypes"></param>
            <returns>The <see cref="T:Verse.Region"/> at the <paramref name="cell"/>, or <see langword="null"/> if not valid type</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetZone(Verse.IntVec3,Verse.Map)">
            <summary>Get the <see cref="T:Verse.Zone"/> at the specified <paramref name="cell"/></summary>
            <param name="cell"></param><param name="map"></param>
            <returns>The <see cref="T:Verse.Zone"/> on the <paramref name="cell"/> or <see langword="null"/> if there is no zone on the <paramref name="cell"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstPawn(Verse.IntVec3,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstPawn_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstPawn_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <returns>The first found <see cref="T:Verse.Thing"/> of type <see cref="T:Verse.Pawn"/> at the <paramref name="cell"/> || or <see langword="null"/> if there are no pawns at the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWhere(Verse.IntVec3,Verse.Map,System.Predicate{Verse.Thing})">
            <returns>The first <see cref="T:Verse.Thing"/> that is found on the <paramref name="cell"/> that passes the <paramref name="validator"/> or <see langword="null"/> if none found</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing_Internal(Verse.IntVec3,Verse.Map,Verse.ThingDef,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing(Verse.IntVec3,Verse.Map,Verse.ThingDef)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing_Internal(Verse.IntVec3,Verse.Map,Verse.ThingDef,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing_Internal(Verse.IntVec3,Verse.Map,Verse.ThingDef,Verse.IntVec3)">
            <summary></summary>
            <param name="cell"></param><param name="map"></param><param name="ofDef"></param>
            <param name="mapSize"></param>
            <returns>The first found <see cref="T:Verse.Thing"/> of the provided <see cref="T:Verse.ThingDef"/> on the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstBed(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first found thing of type <see cref="T:RimWorld.Building_Bed"/> at the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstBuilding(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first found thing of type <see cref="T:Verse.Building"/> at the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing``1(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first <see cref="T:Verse.Thing"/> of type <typeparamref name="T"/> that is found on the <paramref name="cell"/> || <see langword="null"/> if none found on the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWithComp``1(Verse.IntVec3,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWithComp``1(Verse.IntVec3,Verse.Map,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWithComp``1(Verse.IntVec3,Verse.Map,``0@)">
            <summary></summary>
            <typeparam name="TC"></typeparam>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="comp"></param>
            <returns>The first found <see cref="T:Verse.ThingWithComps"/> with the specified <see cref="T:Verse.ThingComp"/> type || or <see langword="null"/> if none found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingListAt(Verse.Map,Verse.IntVec3)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList(Verse.IntVec3,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Get the things at the specified cell</summary>
            <param name="c"></param><param name="map"></param><param name="mapSize"></param>
            <returns><see cref="T:Verse.Thing"/> list || not <see langword="null"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InvalidOrZero(Verse.IntVec3)">
            <summary>Is the <paramref name="cell"/> <see cref="F:Verse.IntVec3.Invalid"/>/out of bounds or 0 (0 is bottom left corner of the map)</summary><param name="cell"></param><returns><see langword="true"/> if is invalid or zero</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CanZone(Verse.IntVec3,Verse.Map)">
            <summary>Can the cell be zoned right now?</summary>
            <param name="c"></param><param name="map"></param>
            <returns><see langword="true"/> if the cell can be zoned</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CanZone_Internal(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Can the cell be zoned right now?</summary>
            <param name="c"></param><param name="map"></param>
            <param name="mapSize"></param>
            <returns><see langword="true"/> if the cell can be zoned</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Neighbors(Verse.District)">
            <summary></summary>
            <param name="district"></param>
            <returns>a read only <see cref="T:NQualityOfLife.Types.HashList`1"/> of all the <see cref="T:Verse.District"/>s that border the given <paramref name="district"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Neighbors(Verse.Region)">
            <summary></summary>
            <param name="region"></param>
            <returns>a read only <see cref="T:NQualityOfLife.Types.HashList`1"/> of all the <see cref="T:Verse.Region"/>s that border the given <paramref name="region"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InBounds(Verse.IntVec3,Verse.IntVec3)">
            <summary>Is the given <paramref name="cell"/> in bounds of the <see cref="T:Verse.Map"/> (size)</summary><param name="cell"></param><param name="mapSize"></param><returns><see langword="true"/> if in bounds</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InNoZoneEdgeArea(Verse.IntVec3,Verse.IntVec3)">
            <summary>Is the cell too close to the map edge to allow zoning</summary>
            <param name="c"></param><param name="mapSize"></param>
            <returns>True if too close to edge</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InNoZoneEdgeArea(Verse.IntVec3,Verse.Map)">
            <summary>Is the cell too close to the map edge to allow zoning</summary>
            <param name="c"></param><param name="map"></param>
            <returns>True if too close to edge</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CloseToEdge(Verse.IntVec3,Verse.IntVec3,System.Int32)">
            <summary></summary>
            <param name="c"></param>
            <param name="mapSize"></param>
            <param name="edgeDist"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.OnEdge(Verse.IntVec3,Verse.IntVec3,RimWorld.Direction8Way@)">
            <summary>Is this <paramref name="cell"/> right on the edge of the map?</summary>
            <param name="cell">Cell</param><param name="mapSize">Map.Size</param>
            <param name="dir">The map edge (or corner) of the <paramref name="cell"/>, or <see cref="F:RimWorld.Direction8Way.Invalid"/> if not on any edge</param>
            <returns><see langword="true"/> if the <paramref name="cell"/> is right on the edge of the <see cref="T:Verse.Map"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.OnEdge(Verse.IntVec3,Verse.IntVec3)">
            <summary>Is this cell right on the edge of the map?</summary>
            <param name="c">Cell</param><param name="mapSize">Map.Size</param>
            <returns><see langword="true"/> if the cell is right on the edge of the map || also returns <see langword="true"/> if out of bounds</returns>
            <remarks>Also returns <see langword="true"/> if out of bounds!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.DirectionAwayFrom(Verse.IntVec3,Verse.IntVec3,System.Boolean)">
            <summary>Get the direction from one cell to another, if 'from' and 'to' are the same, or one of them is 'IntVec3.Invalid', returns 'Direction8Way.Invalid'</summary>
            <param name="from">Direction 'from' this cell away 'awayFrom'</param><param name="awayFrom">Direction 'from' cell away from cell 'awayFrom'</param>
            <param name="errorOnInvalidInput">Log error if one of the input cells is 'IntVec3.Invalid' - Set to false if invalid cells are to be expected in normal operation.</param>
            <returns>Direction8Way of the direction, or 'Direction8Way.Invalid'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.DirectionTo(Verse.IntVec3,Verse.IntVec3,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.DirectionTo(Verse.IntVec3,Verse.IntVec3,NQualityOfLife.Units.Degrees@,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.DirectionTo(Verse.IntVec3,Verse.IntVec3,NQualityOfLife.Units.Degrees@,System.Boolean,System.Boolean)">
            <summary>Get the direction from one cell to another, if 'from' and 'to' are the same, or one of them is 'IntVec3.Invalid', returns 'Direction8Way.Invalid'</summary>
            <param name="from">Direction 'from' this cell towards 'to'</param><param name="to">Direction 'from' cell towards 'to'</param>
            <param name="degrees"></param>
            <param name="errorOnInvalidInput">Log error if one of the input cells is 'IntVec3.Invalid' - Set to false if invalid cells are to be expected in normal operation.</param>
            <param name="debug"></param>
            <returns>Direction8Way of the direction, or 'Direction8Way.Invalid'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.ToCardinal(RimWorld.Direction8Way)">
            <summary>Ensures Direction8Way is cardinal - Chooses closest random cardinal if direction is not cardinal</summary>
            <param name="direction8Way"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.ToCardinal_Rot4(RimWorld.Direction8Way)">
            <summary>Converts Direction8Way to Rot4 - Chooses closest random cardinal if direction is not cardinal</summary>
            <param name="direction8Way"></param>
            <returns>The Rot4 equivalent of the given Direction8Way</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.Thing,System.Int32@,Verse.Map)">
            <summary>Gets all the valid cardinal cells for the given thing</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>A list of all the cardinals in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.Thing,Verse.Map,System.Int32@)">
            <summary>Gets all the valid cardinal cells for the given thing</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>A list of all the cardinals in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.IntVec3,Verse.Map,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide Map.Size for better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.IntVec3,Verse.IntVec3,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="mapSize">Provide for better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.Thing,System.Int32@,Verse.Map)">
            <summary>Gets all the valid cardinal cells for the given <paramref name="thing"/>'s position</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>An array of the 4 cardinals from the given thing's position (or less if on map edge)</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.Thing,Verse.Map,System.Int32@)">
            <summary>Gets all the valid cardinal cells for the given thing</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>An array of the 4 cardinals from the given thing's position (or less if on map edge)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide Map.Size for better performance if this method is called multiple times for the same map</param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3,Verse.Map,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide Map.Size for better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3,Verse.IntVec3,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="mapSize">For better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbourCells(Verse.Thing,Verse.Map)">
            <summary></summary>
            <param name="t"></param>
            <param name="map">The map of <paramref name="t"/>, provide it here if it is already known</param>
            <returns>All the cells directly bordering the given thing, The size of the <see cref="T:Verse.Thing"/> is taken into account</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbourCells(Verse.Thing)">
            <summary></summary>
            <param name="t"></param>
            <returns>All cells next to <paramref name="t"/> including corners that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCells(Verse.Thing)">
            <summary>Get all the cells that the given <see cref="T:Verse.Thing"/> occupies</summary>
            <param name="t"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbours(Verse.IntVec3,Verse.Map)">
            <summary>Get all valid neighbouring cells of the given cell</summary>
            <param name="cell"></param><param name="map">used for Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbours(Verse.IntVec3,Verse.IntVec3)">
            <summary>Get all valid neighbouring cells of the given <paramref name="cell"/> thar are in bounds of the map</summary>
            <param name="cell"></param><param name="mapSize">Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighboursArray(Verse.IntVec3,Verse.IntVec3)">
            <summary>Get all valid neighbouring cells of the given <paramref name="cell"/> including corners</summary>
            <param name="cell"></param><param name="mapSize">Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.North(Verse.IntVec3)">
            <summary>Get the cell to the north of the given <paramref name="cell"/></summary>
            <param name="cell"></param><returns></returns>
            <remarks>Input and output cells are not validated in any way!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.South(Verse.IntVec3)">
            <summary>Get the cell to the south of the given <paramref name="cell"/></summary>
            <param name="cell"></param><returns></returns><remarks>Input and output cells are not validated in any way!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.East(Verse.IntVec3)">
            <summary>Get the cell to the east of the given <paramref name="cell"/></summary>
            <param name="cell"></param><returns></returns><remarks>Input and output cells are not validated in any way!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.West(Verse.IntVec3)">
            <summary>Get the cell to the west of the given <paramref name="cell"/></summary>
            <param name="cell"></param><returns></returns><remarks>Input and output cells are not validated in any way!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CloserAxisIsX(Verse.IntVec3,Verse.IntVec3)">
            <summary></summary>
            <param name="from"></param><param name="to"></param>
            <returns><see langword="true"/> if x axis is closer than y, <see langword="null"/> if equal</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Opposite(RimWorld.Direction8Way)">
            <summary>Get the opposite direction of the given direction</summary>
            <param name="direction8Way"></param>
            <returns>'<see cref="F:RimWorld.Direction8Way.North"/> -> <see cref="F:RimWorld.Direction8Way.South"/>' etc</returns>
            <remarks>Will return <see cref="F:RimWorld.Direction8Way.Invalid"/> if the input <paramref name="direction8Way"/> is <see cref="F:RimWorld.Direction8Way.Invalid"/><para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RotateClockwise(RimWorld.Direction8Way)">
            <summary></summary>
            <param name="direction8Way"></param>
            <returns>The input rotation rotated, if input is '<see cref="F:RimWorld.Direction8Way.Invalid"/>' -> returns '<see cref="F:RimWorld.Direction8Way.Invalid"/>'</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RotateCounterClockwise(RimWorld.Direction8Way)">
            <summary></summary>
            <param name="direction8Way"></param>
            <returns>The input rotation rotated, if input is '<see cref="F:RimWorld.Direction8Way.Invalid"/>' -> returns '<see cref="F:RimWorld.Direction8Way.Invalid"/>'</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbourInDirection(Verse.IntVec3,RimWorld.Direction8Way,System.Boolean,System.Nullable{System.Boolean})">
            <summary>Gets the cell in the specified direction from the current cell - The returned cell could be out of bounds!</summary>
            <param name="cell"></param><param name="direction"></param>
            <param name="onlyCardinals">Only return cardinals</param><param name="preferXOverZOrRandom">Cardinal preference</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RandomCellInRadiusWhere(Verse.IntVec3,System.Single,System.Predicate{Verse.IntVec3})">
            <summary></summary>
            <param name="root"></param>
            <param name="radius"></param>
            <param name="predicate"></param>
            <returns>A random cell in the given <paramref name="radius"/> that satisfies the <paramref name="predicate"/>, or <see cref="F:Verse.IntVec3.Invalid"/> if none found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CanWanderTo(Verse.Pawn,Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="cell"></param>
            <param name="map"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> can wander to the given <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.SoilStability(Verse.Region,Verse.Map)">
            <summary>Gets the soil stability of a given region (terrain affordance) 0f is 100% water, 1f is max soil stability</summary>
            <param name="region"></param><param name="map"></param>
            <returns>0f-1f as a ratio of soil stability</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.LogParamExtensions">
            <summary>Methods used for easier debug log message creation</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.Diagnostics.Stopwatch)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.Int64)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.Int64)">
            <summary>Format the given <paramref name="timerTicks"/>(<see cref="T:System.Int64"/>) or <see cref="T:System.Diagnostics.Stopwatch"/> as time</summary>
            <param name="timerTicks"></param>
            <returns>A <see cref="T:System.String"/> formatted according to the scale of the time</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.Diagnostics.Stopwatch)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.DateTime)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.DateTime)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.DateTime)">
            <summary>Formats the given date in the format: 'DD.MM.YYYY' or 'DD.MM.YYYY - Time'</summary>
            <param name="dateTime"></param>
            <returns>'DD.MM.YYYY' if <see cref="P:System.DateTime.TimeOfDay"/> is not specified || else 'DD.MM.YYYY - Time'</returns>
            <remarks>If you only ever want to display the calendar date, you can use: '<see cref="M:NQualityOfLife.Utils.Common.FormatDate(System.DateTime)"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String,System.String)">
            <summary>Returns <paramref name="s1"/> if it is not <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso>, else returns <paramref name="s2"/><seealso cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String)">.OrNull()</seealso></summary>
            <param name="s1">primary string</param><param name="s2">back up string</param>
            <returns>Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String)">
            <summary>Returns the input <see cref="T:System.String"/> if it is not <see langword="null"/> or empty || else returns a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty</seealso> symbol</summary>
            <returns>the input <see cref="T:System.String"/>, a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null symbol</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty symbol</seealso> - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Nullable{System.Char})">
            <summary>Returns the input <see cref="T:System.Char"/> if it is not <see langword="null"/> or empty || else returns a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty</seealso> symbol</summary>
            <returns>the input <see cref="T:System.Char"/> as a <see cref="T:System.String"/>, a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">null symbol</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">empty symbol</seealso> - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(System.String,``0)">
            <summary>Never null</summary>
            <typeparam name="T2"></typeparam>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns>t1 if it is not null or empty, else t2.OrNull() - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0,System.Object)">
            <summary>Never null</summary>
            <typeparam name="T1"></typeparam>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns>The input as a string if its not null else: t2.OrNull() - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.Details(System.Type)">
            <summary></summary>
            <param name="type"></param>
            <returns>A <see cref="T:System.String"/> with all the detailed information about the given <see cref="T:System.Type"/></returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="type" /> is <see langword="null"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.Details(System.Char)">
            <summary></summary>
            <param name="character"></param>
            <returns>A <see cref="T:System.String"/> with all the detailed information about the given <see cref="T:System.Char"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(RimWorld.TechLevel)">
            <summary></summary>
            <param name="techLevel"></param>
            <returns>The value translated</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)">
            <summary>The generic 'OrNull' method || Never <see langword="null"/></summary>
            <typeparam name="T"></typeparam><param name="classOrStruct"></param>
            <returns>The input converted to a <see cref="T:System.String"/>, or a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.nullSymbol">null symbol</seealso> <see cref="T:System.String"/> || Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam(System.String,System.String)">
            <summary>Format the string in a method parameter format, intended to be used in log messages</summary><param name="t"></param><param name="paramName"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(``0,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(``0,System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(``0,System.String,System.String,System.String)">
            <summary>Generic method for formatting objects for log messages</summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="type"></param>
            <param name="paramName"></param>
            <param name="listType"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.List{``0},System.String,System.String,System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="type">The type of <typeparamref name="T"/>. if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(``0[],System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the array</typeparam>
            <param name="array">The array</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <returns>The input array formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(``0[],System.String,System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the array</typeparam>
            <param name="array">The array</param>
            <param name="type">The type of T. if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <returns>The input array formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(NQualityOfLife.Types.IListInterface{``0},System.String,System.String,System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="type">The type of T. if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(NQualityOfLife.Types.OrderedList{``0},System.String,System.String,System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="type">The type of T. if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(NQualityOfLife.Types.UnOrderedList{``0},System.String,System.String,System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="type">The type of T. if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.ICollection{``0},System.String,System.String,System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="type">The type of T. if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.IList{``0},System.String,System.String,System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="type">The type of T. if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.EventExtensions">
            <summary>Extension methods for unity events</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Undo(UnityEngine.Event)">
            <summary>Returns true if the user is pressing contol z, and consumes the event - Does not consume non undo events</summary>
            <param name="event">The event is consumed if it is an undo event</param>
            <returns>True if pressing control + Z, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ReDo(UnityEngine.Event)">
            <summary>Returns true if the user is pressing contol y, and consumes the event - Does not consume non redo events</summary>
            <param name="event">The event is consumed if it is a redo event</param>
            <returns>True if pressing control + Y, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Escape(UnityEngine.Event)">
            <summary></summary>
            <param name="event"></param>
            <returns>True if escape is pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlAlt(UnityEngine.Event)">
            <summary></summary>
            <param name="event"></param>
            <returns><see langword="true"/> if control and alt are pressed at the same time or the 'ALT GR' button is pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.MiddleClickPress(UnityEngine.Event)">
            <summary></summary>
            <param name="event"></param>
            <returns><see langword="true"/> if the given <paramref name="event"/> is a <see cref="F:UnityEngine.EventType.MouseDown"/> with the scroll wheel / middle mouse button</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftAltOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Shift and Alt pressed?</summary><param name="keyCombination"></param><returns>True if shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlAltOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Control and Alt pressed?</summary><param name="keyCombination"></param><returns>True if control and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShiftOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Control and Shift pressed?</summary><param name="keyCombination"></param><returns>True if control and shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Shift pressed?</summary><param name="keyCombination"></param><returns>True if shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Control pressed?</summary><param name="keyCombination"></param><returns>True if control pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.AltOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Alt pressed?</summary><param name="keyCombination"></param><returns>True if alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftAlt(NQualityOfLife.Types.KeyCombination)">
            <summary>Shift and Alt pressed?</summary><param name="keyCombination"></param><returns>True if shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShiftAlt(NQualityOfLife.Types.KeyCombination)">
            <summary>Control, Shift and Alt pressed?</summary><param name="keyCombination"></param><returns>True if control, shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlAlt(NQualityOfLife.Types.KeyCombination)">
            <summary>Control and Alt pressed?</summary><param name="keyCombination"></param><returns>True if control and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShift(NQualityOfLife.Types.KeyCombination)">
            <summary>Control and Shift pressed?</summary><param name="keyCombination"></param><returns>True if control and shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Shift(NQualityOfLife.Types.KeyCombination)">
            <summary>Shift pressed?</summary><param name="keyCombination"></param><returns>True if shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Control(NQualityOfLife.Types.KeyCombination)">
            <summary>Control pressed?</summary><param name="keyCombination"></param><returns>True if control pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Alt(NQualityOfLife.Types.KeyCombination)">
            <summary>Alt pressed?</summary><param name="keyCombination"></param><returns>True if alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.None(NQualityOfLife.Types.KeyCombination)">
            <summary>No modifier keys pressed?</summary><param name="keyCombination"></param><returns>True if none of the modifier keys are pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ModifierKeys(UnityEngine.Event)">
            <summary>Get the held modifier keys (shift, control, alt)</summary>
            <param name="event"></param>
            <returns>The key combination of the held modifier keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ModifierKeys(UnityEngine.Event,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>Get the held modifier keys (shift, control, alt)</summary>
            <param name="event"></param>
            <param name="control"></param>
            <param name="alt"></param>
            <param name="shift"></param>
            <returns>The key combination of the held modifier keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollUp(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll up event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (positive float)</param>
            <returns>True if event is scroll up</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollWheel(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (positive float for up, negative for down)</param>
            <returns>True if event is scroll up or down</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollDown(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll down event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (negative float)</param>
            <returns>True if event is scroll down</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.AnyMouseButtonPress(UnityEngine.Event)">
            <summary></summary><param name="ev"></param>
            <returns>True if any of the 3 main mouse buttons are clicked (L, R, M)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.LeftClickPress(UnityEngine.Event)">
            <summary></summary><param name="event"></param>
            <returns>True when left click is pressed</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.PawnExtensions">
            <summary>Pawn extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetOrAddHediffIf(Verse.Pawn_HealthTracker,Verse.HediffDef,Verse.Hediff@,Verse.HediffDef,System.Boolean)">
            <summary>Add or get the <paramref name="hediffDefToAddOrGet"/> to/from the <see cref="T:Verse.Pawn"/> if they do not have the '<paramref name="ifDoesNotHave"/>' <see cref="T:Verse.HediffDef"/></summary>
            <param name="healthTracker"></param>
            <param name="hediffDefToAddOrGet">Add or get this <see cref="T:Verse.Hediff"/></param>
            <param name="hediffBlack"></param>
            <param name="ifDoesNotHave">Do not add <paramref name="hediffDefToAddOrGet"/> if the <see cref="T:Verse.Pawn"/> has this hediff || remove <paramref name="hediffDefToAddOrGet"/> if the <see cref="T:Verse.Pawn"/> has both and <paramref name="removeIfHasBoth"/> is <see langword="true"/></param>
            <param name="removeIfHasBoth">Remove the <paramref name="hediffDefToAddOrGet"/> from the <see cref="T:Verse.Pawn"/> if it exists and they also have the '<paramref name="ifDoesNotHave"/>' <see cref="T:Verse.HediffDef"/></param>
            <returns>The existing or added <see cref="T:Verse.Hediff"/> or <see langword="null"/> if it did not exist and was not added or was removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetLordOf(Verse.AI.Group.LordManager,Verse.Pawn)">
            <summary></summary>
            <param name="lordManager"></param>
            <param name="pawn"></param><exception cref="T:System.ArgumentNullException"></exception>
            <returns>The <see cref="T:Verse.AI.Group.Lord"/> that the given <paramref name="pawn"/> is a member of || <see langword="null"/> if the <paramref name="pawn"/> is not a member of any of the lords in the given <paramref name="lordManager"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetFactionlessLord(Verse.Pawn,Verse.Map)">
            <summary>Returns the factionless <see cref="T:Verse.AI.Group.Lord"/> of the given <paramref name="pawn"/> || or <see langword="null"/> if the <paramref name="pawn"/> is not a member of any lord <see cref="T:Verse.AI.Group.Lord"/> or the <see cref="T:Verse.AI.Group.Lord"/> has a <see cref="T:RimWorld.Faction"/></summary>
            <param name="pawn"></param><param name="map"></param><exception cref="T:System.ArgumentNullException"></exception>
            <returns>The <see cref="T:Verse.AI.Group.Lord"/> of the <paramref name="pawn"/> if the <see cref="T:RimWorld.Faction"/> of the <see cref="T:Verse.AI.Group.Lord"/> is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetFactionLord(Verse.Pawn,RimWorld.Faction,Verse.Map)">
            <summary>Returns the <see cref="T:Verse.AI.Group.Lord"/> of the given <paramref name="pawn"/> if the <paramref name="faction"/> of the <see cref="T:Verse.AI.Group.Lord"/> matches || or <see langword="null"/> if no <see cref="T:Verse.AI.Group.Lord"/> or the <see cref="T:Verse.AI.Group.Lord"/> has a different or <see langword="null"/> <see cref="T:RimWorld.Faction"/></summary>
            <param name="pawn"></param><param name="faction"></param><param name="map"></param>
            <returns>The <see cref="T:Verse.AI.Group.Lord"/> of the <paramref name="pawn"/> if the <see cref="T:RimWorld.Faction"/> of the <see cref="T:Verse.AI.Group.Lord"/> is the same as the provided <paramref name="faction"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Starving(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param><exception cref="T:System.ArgumentNullException"></exception>
            <returns><see langword="true"/> if the given <paramref name="pawn"/> has a food need and the food need level is &lt;= 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast(Verse.HediffSet,Verse.HediffDef,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast(System.Collections.Generic.List{Verse.Hediff},Verse.HediffDef,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast(System.Collections.Generic.List{Verse.Hediff},Verse.HediffDef,System.Boolean)">
            <summary></summary>
            <param name="hediffs"></param>
            <param name="def"></param>
            <param name="mustBeVisible"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.DraftIfCan(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>True if pawn was drafted or was already drafted</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsNightOwl(Verse.Pawn)">
            <summary>Null checks included</summary>
            <param name="pawn"></param>
            <returns>true if has NightOwl trait</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsBrawler(Verse.Pawn)">
            <summary>Null checks included</summary>
            <param name="pawn"></param>
            <returns>true if has brawler trait</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasTrait(Verse.Pawn,RimWorld.TraitDef)">
            <summary>Null checks included</summary>
            <param name="pawn"></param>
            <param name="trait"></param>
            <returns>true if has specified trait - returns false if trait is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasAWeapon(Verse.Pawn)">
            <summary>Is this pawn equipped with a weapon?</summary>
            <param name="pawn">this pawn</param>
            <returns>true if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.CapableOfViolence(Verse.Pawn)">
            <summary>Is <see langword="this"/> <paramref name="pawn"/> capable of violence?</summary>
            <param name="pawn">this <see cref="T:Verse.Pawn"/></param>
            <returns><see langword="true"/> if yes</returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPregnant(Verse.Pawn)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPregnant(Verse.Pawn,Verse.Hediff@)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <param name="pregnancyHediff"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Pregnancy(Verse.Pawn)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsRelatedTo(Verse.Pawn,Verse.Pawn)">
            <summary>Check if this pawn is blood related to other pawn</summary>
            <param name="thisPawn">Is this pawn related to otherPawn</param>
            <param name="otherPawn">The pawn to check</param>
            <returns><see langword="true"/> if is blood related</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsHomeOwner(Verse.Pawn)">
            <summary>Check if the pawn is currently a home owner</summary>
            <param name="pawn">The pawn to check</param>
            <returns>bool, true if is home owner</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Home(Verse.Pawn)">
            <summary>Get the home of this pawn</summary>
            <param name="pawn">Get home of this pawn</param>
            <returns>bool = true if found the home. and the Home or (false, null)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsRelatedToAnyHomeOwner(Verse.Pawn)">
            <summary>Is this pawn related to any home owner</summary>
            <param name="pawn">Is this pawn related to any home owner</param>
            <returns>true if is related</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsOccupantOf(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is this pawn an occupant of the given home</summary>
            <param name="pawn">Is this pawn an occupant of the given home</param>
            <param name="home">The home to check</param>
            <returns>true if is an occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsLoverOfAnyOccupant(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home,System.Boolean)">
            <summary>Is this pawn a lover of any occupant in the given home</summary>
            <param name="pawn">Is this pawn a lover of any occupant in the given home</param>
            <param name="home">The home to check</param>
            <param name="forceUpdateCache">Update cache</param>
            <returns>true if is lover of any occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPetOfFamily(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is this pawn a bonded animal of a family member</summary>
            <param name="pawn">Is this pawn a bonded animal of a family member</param>
            <param name="home">The home to check</param>
            <returns>true if is pet of any occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.MyLoverHasAHome(Verse.Pawn)">
            <summary>Is my lover a home owner or living in a home</summary>
            <param name="pawn">Me</param>
            <returns>true if lover has home</returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasLoveRelationWith(Verse.Pawn,Verse.Pawn)">
            <summary>Is the given pawn my lover</summary>
            <param name="pawn">Me</param>
            <param name="lover">Is this pawn my lover</param>
            <returns><see langword="true"/> if the given pawn is lover of this pawn</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasALoverOnMap(Verse.Pawn,Verse.Pawn@,System.Boolean,Verse.Map)">
            <summary>Is my lover on the same map as me</summary>
            <param name="pawn">Is my lover on the same map as me</param>
            <param name="lover">The lover that was found, if method returns false => null</param>
            <param name="sortByCommitment">Sort the list of lovers if exists and more than 1</param>
            <param name="map">This map, or my map if null</param>
            <returns>true if lover is on map</returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.SortByCommitment(System.Collections.Generic.List{RimWorld.DirectPawnRelation},Verse.Pawn)">
            <summary>This is / should be the same as the sort logic in: <see cref="M:RimWorld.SpouseRelationUtility.GetLoveRelations(Verse.Pawn,System.Boolean,System.Boolean)"/></summary>
            <param name="loveRelations"></param>
            <param name="pawn"></param>
        </member>
        <member name="T:NQualityOfLife.Utils.ListExtensions">
            <summary>Extension methods for different kinds of lists and collections</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OrderBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OrderByDescending``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>Get the total value from the input <paramref name="values"/> using the given <paramref name="valueGetter"/></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="valueGetter">Extracts the value from the <typeparamref name="T"/></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OfType``1(System.Collections.IEnumerable)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <returns><see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> of all the items in <paramref name="values"/> that are of the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OfType``2(System.Collections.Generic.IEnumerable{``1})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TB"></typeparam>
            <param name="values"></param>
            <returns><see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> of all the items in the input list of <typeparamref name="TB"/> that are of the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})">
            <summary>Makes a <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</seealso> of the given <paramref name="list"/></summary>
            <typeparam name="T"></typeparam><param name="list">The list to copy</param>
            <returns>A <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">(shallow) copy</seealso> of the original <paramref name="list"/> as a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the same items in the same order || Never <see langword="null"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Copy``1(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Copy``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Make a <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</seealso> of the <see cref="T:System.Collections.Generic.Dictionary`2"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.KeyValuePair{``0,``1})">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Makes a <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</seealso> of the <paramref name="list"/> starting at the given index</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="startingFrom"></param>
            <param name="count"></param>
            <returns>A <see langword="new"/> list with the elements from the input list starting at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.IList{``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TL"></typeparam>
            <param name="iList"></param>
            <returns>A <see langword="new"/> list of type <typeparamref name="TL"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.List{``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.IList{``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.IList{``1})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TL"></typeparam>
            <param name="iList"></param>
            <returns>A <see langword="new"/> list of type <typeparamref name="TL"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(``0[])">
            <summary>Makes a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the <paramref name="array"/></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the same items in the same order as the source <paramref name="array"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Makes a copy of the list</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <returns>A copy of the original list</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Count how many items in the <paramref name="iList"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountAllWhere``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.List{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary>Count how many items in the <paramref name="list"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountAllWhere``1(System.Collections.Generic.IReadOnlyList{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IReadOnlyList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IReadOnlyList{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Get the count of items in the collection, tries to use the best count method or property available for the input type</summary>
            <typeparam name="T"></typeparam><param name="list"></param><returns>How many items are in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>/<see cref="T:System.Collections.Generic.ICollection`1"/>/<see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountAllWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Count how many items in the list match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Count how many items in the <paramref name="list"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(``0[],System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount. || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the <paramref name="maxCount"/> or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Matching element count or <paramref name="maxCount"/> if more matching elements than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount. || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill_Internal``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0},System.Int32)">
            <summary>Counts matching items until the <paramref name="maxCount"/> or the end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting || must be greater than 0</param>
            <param name="predicate"></param>
            <param name="knownSize">The total size of the list</param>
            <returns>Matching element count or <paramref name="maxCount"/> if more matching elements than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.List{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the <paramref name="maxCount"/> or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or <paramref name="maxCount"/> if more elements than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAllWhereLazy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FindAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Select``3(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IList{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>Transform the values (<typeparamref name="T"/>) in the input <paramref name="list"/> from '<typeparamref name="T"/>' to '<typeparamref name="TN"/>' using the given <paramref name="func"/>(<typeparamref name="T"/> => <typeparamref name="TN"/>)</summary>
            <typeparam name="T">Input <paramref name="list"/> contained type</typeparam>
            <typeparam name="TN">Output list contained type</typeparam>
            <typeparam name="TL">The <see cref="T:System.Type"/> of the returned <see cref="T:System.Collections.IList"/> that contains the transformed '<typeparamref name="TN"/>' values</typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns>A <see langword="new"/> <typeparamref name="TL"/> with the values that the <paramref name="func"/> transformed from the input <paramref name="list"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IList{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.TransformLazy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <returns><see cref="T:System.Collections.IEnumerable"/> <typeparamref name="TN"/> with the values that the <paramref name="func"/> transformed from the input <paramref name="list"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IList{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IDictionary{``0,``1},System.Func{``0,``2})">
            <summary>Transform the keys (<typeparamref name="K"/>) of the <paramref name="dict"/> to a new type or value (<typeparamref name="NK"/>)</summary>
            <typeparam name="K">Key</typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="NK">New Key</typeparam>
            <param name="dict"></param>
            <param name="func"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.Dictionary`2"/> with the type of the keys changed from '<typeparamref name="K"/>' to '<typeparamref name="NK"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IDictionary{``0,``1},System.Func{``1,``2})">
            <summary>Transform the values (<typeparamref name="T"/>) of the <paramref name="dict"/> to a new type or value (<typeparamref name="NT"/>)</summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="NT"></typeparam>
            <param name="dict"></param>
            <param name="func"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.Dictionary`2"/> with the type of the values changed from '<typeparamref name="T"/>' to '<typeparamref name="NT"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>Transform the input <paramref name="list"/> from a list of '<typeparamref name="T"/>' to a list of '<typeparamref name="TN"/>' using the given <paramref name="func"/></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the values in the input <paramref name="list"/></typeparam>
            <typeparam name="TN">The <see cref="T:System.Type"/> of the values in the <paramref name="list"/> after the transform</typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> containing all the transormed '<typeparamref name="TN"/>' values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Where``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with all the members from the input <paramref name="list"/> that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.WhereLazy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Lazily filter the input elements</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAllWhere_ToArray``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="toArray"></param>
            <param name="predicate"></param>
            <returns>A <see langword="new"/> array with all the members from the input list that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> of all the items (<typeparamref name="T"/>) in the input <paramref name="list"/> that match the given <paramref name="predicate"/>(<typeparamref name="T"/>)</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param><exception cref="T:System.ArgumentNullException"></exception>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with all the members (<typeparamref name="T"/>) from the input <paramref name="list"/> (<typeparamref name="T"/>) that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with all the members from the input list that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with all the members from the input <paramref name="list"/> that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="where"></param>
            <returns>The matching input elements to a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToReadOnlyListWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Types.IReadOnlyListInterface`1"/> from the <paramref name="values"/> that match the <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="predicate"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.IReadOnlyListInterface`1"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToDictionaryFrom``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1})">
            <summary></summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="TV"></typeparam>
            <param name="keys"></param>
            <param name="values"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Split``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0}@,System.Collections.Generic.IList{``0}@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="evens"></param>
            <param name="odds"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.EvensToList``1(System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OddsToList``1(System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the predicate || The <see cref="T:System.Int32"/> in the predicate is the index of the item</summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="where">Func&lt;<typeparamref name="T"/> item, <see cref="T:System.Int32"/> index, <see cref="T:System.Boolean"/> mathes&gt;</param>
            <returns>The matching input elements to a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="count">the count of elements</param>
            <returns>The input elements to a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where"></param>
            <returns>The matching input elements to a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.Dictionary{``0,``1}.KeyCollection,System.Int32@)">
            <summary>Copies all the keys to a <see langword="new"/> list</summary>
            <typeparam name="K">Keys</typeparam>
            <typeparam name="V">Values</typeparam>
            <param name="keyCollection"></param>
            <param name="count"></param>
            <returns>A <see langword="new"/> list of the keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns <see langword="true"/> if the collection is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="iEnumerable"></param>
            <returns><see langword="true"/> if the collection is <see langword="null"/> or has no items</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(``0[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(``0[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(``0[])">
            <summary>Returns <see langword="true"/> if the array is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="array"></param>
            <returns><see langword="true"/> if the array is <see langword="null"/> or has a Length of 0</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>Returns <see langword="true"/> if the <paramref name="list"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="count">How many items the <paramref name="list"/> has, <see langword="null"/> <paramref name="list"/> will return 0 here</param>
            <returns><see langword="true"/> if the <paramref name="list"/> is <see langword="null"/> or has a Count of 0</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.List{``0},System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(``0[],System.Int32@)">
            <summary>Returns <see langword="true"/> if the array is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="array"></param>
            <param name="count">The amount of items || 0 if the <paramref name="array"/> is <see langword="null"/></param>
            <returns><see langword="true"/> if the array is <see langword="null"/> or has a Length of 0</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0},System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.List{``0})">
            <summary>Returns <see langword="true"/> if the <paramref name="list"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if the list is <see langword="null"/> or has a <see cref="P:System.Collections.Generic.List`1.Count"/> of 0</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.List{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>Returns <see langword="true"/> if the <paramref name="list"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if the list is <see langword="null"/> or has a Count of 0</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(NQualityOfLife.Types.IListInterface{``0})">
            <summary>Returns <see langword="true"/> if the <paramref name="list"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if the <paramref name="list"/> is <see langword="null"/> or has a Count of 0</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(NQualityOfLife.Types.IListInterface{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(NQualityOfLife.Types.IListInterface{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Returns <see langword="true"/> if the <paramref name="dictionary"/> is <see langword="null"/> or empty</summary><typeparam name="K">Key</typeparam><typeparam name="V">Value</typeparam><param name="dictionary"></param>
            <returns><see langword="true"/> if the <paramref name="dictionary"/> is <see langword="null"/> or has a Count of 0</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(``0[])">
            <summary></summary><typeparam name="T"></typeparam><param name="array"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IEnumerable{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="enumerable"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="iList"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary></summary><typeparam name="T"></typeparam><param name="iList"></param>
            <param name="count"></param>
            <returns><see langword="true"/> if the <paramref name="iList"/> is <see langword="not"/> <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.List{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IEnumerable{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Check if the <paramref name="dictionary"/> is non <see langword="null"/> and contains at least one item</summary><typeparam name="K"></typeparam><typeparam name="V"></typeparam><param name="dictionary"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary>Check if the <paramref name="list"/> contains any items that satisfy the <paramref name="predicate"/></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item that satisfies the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Check if the <paramref name="list"/> contains any items that satisfy the <paramref name="predicate"/></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item that satisfies the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.All``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Checks if all the elements in the <paramref name="list"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <remarks>An empty <paramref name="list"/> will always return <see langword="true"/>!</remarks>
            <returns><see langword="true"/> if all elements in the <paramref name="list"/> satisfy the condition || An empty <paramref name="list"/> will always return <see langword="true"/>!</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetTypeWithHighestValueInDictionary``1(System.Collections.Generic.IDictionary{``0,System.UInt16},System.UInt16@)">
            <summary>Returns the <typeparamref name="T"/> instance with the highest value in the input <paramref name="dictionary"/></summary>
            <typeparam name="T"></typeparam>
            <param name="dictionary"></param>
            <param name="highestFoundValue">The highest value</param>
            <returns>The instance of <typeparamref name="T"/> with the highest value in the <paramref name="dictionary"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IncrementOrAdd``1(System.Collections.Generic.IDictionary{``0,System.UInt16},``0,System.UInt16,System.UInt16)">
            <summary>Increments the existing value or adds the <paramref name="startValue"/> if there was no existing value for the given <paramref name="key"/> (<typeparamref name="K"/>)</summary>
            <typeparam name="K"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="startValue">Set the value to this if there was no value for the <paramref name="key"/></param>
            <param name="incrementBy">Increment the existing value by this amount</param>
            <returns>The existing value (<see cref="T:System.UInt16"/>) incremented || or the <paramref name="startValue"/> if there was no existing value || returns <paramref name="startValue"/> on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IncrementOrAddTuple``1(System.Collections.Generic.IDictionary{``0,System.ValueTuple{System.Int32,System.Int32}},``0,System.Byte,System.ValueTuple{System.Int32,System.Int32},System.Int32)">
            <summary>Increment the existing value of a tuple item or add the <paramref name="startValues"/> for the given <paramref name="key"/></summary>
            <typeparam name="K">The key of the tuple <paramref name="dictionary"/></typeparam>
            <param name="dictionary">A <see cref="T:System.Collections.Generic.IDictionary`2"/> of tuples</param>
            <param name="key"></param>
            <param name="itemIndex">The zero based index of the tuple item</param>
            <param name="startValues">If the <paramref name="key"/> doesn't exist in the <paramref name="dictionary"/> add it with this value</param>
            <param name="incrementBy">Increment the existing value of a tuple item if the <paramref name="key"/> for it already exists</param>
            <returns>The tuple values of the give <paramref name="key"/> after incrementing or adding it to the <paramref name="dictionary"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IncrementOrAddTuple``1(System.Collections.Generic.IDictionary{``0,System.ValueTuple{System.UInt16,System.UInt16}},``0,System.Byte,System.ValueTuple{System.UInt16,System.UInt16},System.UInt16)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IncrementOrAddTuple``1(System.Collections.Generic.IDictionary{``0,System.ValueTuple{System.Int32,System.Int32}},``0,System.Byte,System.ValueTuple{System.Int32,System.Int32},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IncrementOrAdd``1(System.Collections.Generic.IDictionary{``0,System.Int32},``0,System.Int32,System.Int32)">
            <summary>Increments the existing value (<see cref="T:System.Int32"/>) or adds the <paramref name="startValue"/> if there was no existing value for the <paramref name="key"/> (<typeparamref name="K"/>)</summary>
            <typeparam name="K"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="startValue">Set the value to this if there was no value for the <paramref name="key"/></param>
            <param name="incrementBy">Increment the existing value by this amount</param>
            <returns>The existing value incremented, or the <paramref name="startValue"/> if there was no existing value</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>returns <paramref name="startValue"/> on error</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Adds the new item only if it doesn't already exist in the <paramref name="dictionary"/></summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns><see langword="true"/> if the <paramref name="key"/>/<paramref name="value"/> was added || <see langword="false"/> if the <paramref name="key"/> already existed in the <paramref name="dictionary"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>Add the given items to the <paramref name="iList"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="range"></param>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Add``1(System.Collections.Generic.IList{``0},``0[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>Adds the new items that don't already exist in the list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="range"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Adds the new items only if they don't already exist in the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="range"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Adds the new item only if it doesn't already exist in the list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.NotSupportedException"></exception>
            <returns><see langword="true"/> if the <paramref name="value"/> was added to the <paramref name="list"/> || <see langword="false"/> if it was not added || <see langword="false"/> on error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},System.Collections.Generic.KeyValuePair{``0,``1})">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="value"></param><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},``0,``1)">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},System.ValueTuple{``0,``1},System.Boolean)">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
            <param name="kIsKey"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},System.ValueTuple{``0,``1})">
            <summary>Add the given <paramref name="value"/> tuple to the <paramref name="list"/> of tuples</summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="value"></param><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SetOrAddValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.SetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Set the <paramref name="value"/> of an existing entry || or add new entry with the provided <paramref name="value"/> if there was no existing entry</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="value">The new <paramref name="value"/> for the <paramref name="key"/> to set</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetAndSetSafe``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,``1@)">
            <summary>Gets the existing value (<typeparamref name="V"/>) from the <paramref name="dictionary"/> and writes the <paramref name="newValue"/> (<typeparamref name="V"/>)</summary>
            <typeparam name="K">The type of the keys</typeparam><typeparam name="V">The type of the values</typeparam>
            <param name="dictionary"></param>
            <param name="key">Get the old value (<typeparamref name="V"/>) of this key (<typeparamref name="K"/>), and set a <paramref name="newValue"/></param>
            <param name="newValue">The<paramref name="newValue"/> to add or set</param>
            <param name="oldValue">The old value if it was found, || or <see langword="default"/> value of <typeparamref name="V"/> if there was no old value || will never be <see langword="null"/> if method returned <see langword="true"/> (Unless the dictionary contains <see langword="null"/> values)</param>
            <returns><see langword="true"/> if existing value (<typeparamref name="V"/>) was in the <paramref name="dictionary"/>, || <see langword="false"/> if it was added now || returns <see langword="false"/> on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Gets the value (<typeparamref name="V"/>) from the <paramref name="dictionary"/> || or adds the provided <paramref name="value"/> (<typeparamref name="V"/>) if there was no existing value (<typeparamref name="V"/>) for the <paramref name="key"/> (<typeparamref name="K"/>)</summary>
            <typeparam name="K">The type of the keys</typeparam><typeparam name="V">The type of the values</typeparam>
            <param name="dictionary">The <paramref name="dictionary"/> that we are getting or adding the value from</param>
            <param name="key">The <paramref name="key"/> whose value to add or get</param>
            <param name="value">The new <paramref name="value"/> to add if there is no existing value</param>
            <returns>The existing value (<typeparamref name="V"/>) if it exists || or the provided <paramref name="value"/> (<typeparamref name="V"/>) if there was no existing value (<typeparamref name="V"/>) for the <paramref name="key"/> (<typeparamref name="K"/>) || returns the new <paramref name="value"/> on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Merge``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})">
            <summary>Add the contents of all the <paramref name="otherLists"/> (<typeparamref name="TL"/>) to <paramref name="list"/> and return <paramref name="list"/></summary>
            <typeparam name="TL"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="otherLists"></param>
            <returns>a <see langword="new"/> <paramref name="list"/> of <see cref="T:System.Type"/> '<typeparamref name="TL"/>' after all the <paramref name="otherLists"/> containing '<typeparamref name="TL"/>' have been added to it</returns>
            <remarks><paramref name="list"/> is mutated</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.MergeLazy``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})">
            <remarks>Iterates lazily</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Merge``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.MergeLazy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <remarks>Iterates lazily</remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Merge``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.MergeLazy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <remarks>Iterates lazily</remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Merge``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Merge``2(``0,System.Collections.Generic.IList{``1})">
            <summary>Merges the contents of the <paramref name="otherList"/> (<typeparamref name="T"/>) to this <paramref name="list"/> (<typeparamref name="TL"/>)</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TL"></typeparam>
            <param name="list"></param>
            <param name="otherList"></param>
            <returns>The input <paramref name="list"/> (<typeparamref name="TL"/>) after the merge</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks><paramref name="list"/> is mutated</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Merge``1(NQualityOfLife.Types.HashList{``0},System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Merge``2(``0,System.Collections.Generic.IList{``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(NQualityOfLife.Types.UnOrderedList{System.ValueTuple{``0,``1}})">
            <summary>Gets the first items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> with the first items (<typeparamref name="T"/>) from the input <paramref name="tupleList"/> (<typeparamref name="T"/>, <typeparamref name="B"/>) - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(NQualityOfLife.Types.UnOrderedList{System.ValueTuple{``0,``1}})">
            <summary>Gets the second items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> with the second items (<typeparamref name="B"/>) from the input <paramref name="tupleList"/> (<typeparamref name="T"/>, <typeparamref name="B"/>) - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(NQualityOfLife.Types.OrderedList{System.ValueTuple{``0,``1}})">
            <summary>Gets the first items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A new list with the first items from the input tuple list - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(NQualityOfLife.Types.OrderedList{System.ValueTuple{``0,``1}})">
            <summary>Gets the second items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.OrderedList`1"/> with the first items (<typeparamref name="T"/>) from the input <paramref name="tupleList"/> (<typeparamref name="T"/>, <typeparamref name="B"/>) - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})">
            <summary>Gets the first items (<typeparamref name="T"/>) in a tuple list (<typeparamref name="T"/>, <typeparamref name="B"/>)</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the first items (<typeparamref name="T"/>) from the input tuple list (<typeparamref name="T"/>, <typeparamref name="B"/>) - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(System.Collections.Generic.List{System.ValueTuple{``0,``1}})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})">
            <summary>Gets the second items (<typeparamref name="B"/>) in a tuple list (<typeparamref name="T"/>, <typeparamref name="B"/>)</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the second items from the input tuple list - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(System.Collections.Generic.List{System.ValueTuple{``0,``1}})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct``1(System.Collections.Generic.KeyValuePair{``0,System.UInt16},``0@,System.UInt16@)">
            <summary>KeyValuePair deconstruct for a generic key and ushort</summary>
            <typeparam name="K"></typeparam><param name="tuple"></param><param name="key"></param><param name="value"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>KeyValuePair deconstruct for a generic key and value</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam><param name="tuple"></param><param name="key"></param><param name="value"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},System.ValueTuple{``0,``1}@)">
            <summary>KeyValuePair deconstruct for a generic key and value</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam><param name="tuple"></param><param name="pair"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Remove``1(System.Collections.Generic.ICollection{``0},``0,System.Int32)">
            <summary>Remove the specified <paramref name="amount"/> of the <paramref name="item"/> || or until there are none left.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="item"></param>
            <param name="amount">The amount of items to remove.</param>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Remove``1(System.Collections.Generic.IList{``0},``0,System.Int32,System.Boolean)">
            <summary>Remove the specified <paramref name="amount"/> of the <paramref name="item"/> || or until there are none left.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="item"></param>
            <param name="amount">The amount of items to remove.</param>
            <param name="removeLastFirst">set to <see langword="true"/> to iterate the list in reverse instead</param>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAll``1(``0[],``0)">
            <summary>Remove all the instances of the given <paramref name="item"/></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="item"></param>
            <returns>A <see langword="new"/> array with all instances of the specified <paramref name="item"/> (<typeparamref name="T"/>) removed</returns>
            <remarks>MUST USE RETURN VALUE<para>Order of elements is preserved</para></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAll``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Remove all the instances of the given <paramref name="item"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iListRef"></param>
            <param name="item"></param>
            <returns>The amount of items removed</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveLastSafe``1(System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns><see langword="true"/> if there was something to remove || <see langword="false"/> if the <paramref name="list"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveLast``1(System.Collections.Generic.IList{``0})">
            <summary>Remove the last element from the <paramref name="list"/> - a <see langword="null"/> or empty list will cause an exception</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveLast``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Remove the last found instance of the given <paramref name="item"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="item"></param>
            <returns><see langword="true"/> if the <paramref name="item"/> was found and removed</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetItemAtIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Last``1(System.Collections.Generic.IList{``0})">
            <summary>Get the last item of the list - Will error if the list is null or empty!</summary>
            <typeparam name="T"></typeparam><param name="list"></param>
            <returns>The last item in the list</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.First``1(System.Collections.Generic.IList{``0})">
            <summary>Get the last item of the list - Will error if the list is null or empty!</summary>
            <typeparam name="T"></typeparam><param name="list"></param>
            <returns>The last item in the list</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrFallBack``1(``0[],System.Predicate{``0},``0)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param><param name="predicate"></param><param name="fallback"></param>
            <returns>The first found thing that matches the <paramref name="predicate"/>, or <paramref name="fallback"/> if none</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrFallBack``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param><param name="predicate"></param><param name="fallback"></param>
            <returns>The first found thing that matches the <paramref name="predicate"/>, or <paramref name="fallback"/> if none</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(``0[],System.Predicate{``0})">
            <summary>First match in the array or the '<see langword="default"/>' value of the type '<typeparamref name="T"/>'</summary>
            <typeparam name="T"></typeparam><param name="array"></param><param name="predicate"></param>
            <returns>The first found thing that matches the predicate, or <see langword="default"/> if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <returns>The first found thing that matches the <paramref name="predicate" />, or <see langword="default"/> if none</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list" /> is <see langword="null"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Get the index of the first found match in the <paramref name="list"/> || or -1 if there were no matches</summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <returns>The index of the first found thing that matches the <paramref name="predicate" />, or -1 if none</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list" /> or <paramref name="predicate" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="match"></param>
            <returns>The index of the first found thing that equals the given item, or -1 if none</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list" /> is <see langword="null"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The index of the last found thing that matches the <paramref name="predicate" />, or -1 if none</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list" /> or <paramref name="predicate" /> is <see langword="null"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastIndexOf``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Get the index of the last instance of the given <paramref name="match"/> (<typeparamref name="T"/>) in the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="match"></param>
            <returns>The index of the last found instance of the given item (<typeparamref name="T"/>) || or -1 if none found</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where"></param>
            <returns>The input <paramref name="list"/> with the matching items removed || Not a copy of the input <paramref name="list"/>!</returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Predicate{System.ValueTuple{``0,``1}})">
            <summary>Remove all entries that match the given <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="where"></param>
            <returns>The amount of entries removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Predicate{``1})">
            <summary>Remove all entries that have a value that matches the given <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="where"></param>
            <returns>The amount of entries removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Predicate{``0})">
            <summary>Remove all entries that have a key that matches the given <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="where"></param>
            <returns>The amount of entries removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetTypeWithMostDuplicates``1(System.Collections.Generic.IList{``0},System.UInt16@)">
            <summary>Returns the <typeparamref name="T"/> instance with the highest number of duplicates in the input <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="instancesFoundInList">How many of the most common type were found</param>
            <returns>The instance of <typeparamref name="T"/> with the most appearances in the <paramref name="list"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountDuplicatesInAList``1(System.Collections.Generic.IList{``0})">
            <summary>Count how many times each item appears in the <paramref name="list"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="list">Count duplicates in this list</param>
            <returns>a <see langword="new"/> <see cref="T:System.Collections.Generic.Dictionary`2"/> of instances of <typeparamref name="T"/> and how many of them were in the original <paramref name="list"/>.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates_ToList``1(System.Collections.Generic.IList{``0})">
            <summary>Remove duplicates so that only one of each item is on the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns>A copy of the <paramref name="list"/> with duplicates removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary>Remove duplicates so that only one of each item is on the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="removeLastFirst">set to <see langword="true"/> to iterate in reverse</param>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllInstancesWithDuplicates``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary>Removes all instances of the items that have any duplicates in the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="removeLastFirst">set to <see langword="true"/> to iterate in reverse</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean},System.Boolean)">
            <summary>Remove all duplicate items from the <paramref name="list"/> using the given <paramref name="equalityComparer"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="equalityComparer">Should return <see langword="true"/> if the two <typeparamref name="T"/> instances are equal</param>
            <param name="removeLastFirst">set to <see langword="true"/> to iterate the <paramref name="list"/> in reverse instead</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyOf``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the <paramref name="list"/> contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if any of the elements are in both lists. || <see langword="false"/> if either list is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyOf``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>Checks if the <paramref name="list"/> contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if any of the elements are in both lists. || <see langword="false"/> if any of the inputs is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AnyWhere``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item that satisfies the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AnyWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item that satisfies the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Checks if the <paramref name="list"/> contains any elements that satisfy the <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if any of the elements satisfy the <paramref name="predicate"/> || Always <see langword="false"/> if <paramref name="list"/> is <see langword="null"/> or empty</returns>
            <exception cref="T:System.ArgumentNullException">predicate is null</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyWhere``1(``0[],System.Predicate{``0})">
            <summary>Checks if the <paramref name="array"/> contains any elements that satisfy the <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if any of the elements satisfy the <paramref name="predicate"/> || Always <see langword="false"/> if the <paramref name="array"/> is <see langword="null"/> or empty</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyOf``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},``0@)">
            <summary>Checks if the list contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <param name="firstMatch">The item in the <paramref name="list"/> that caused the method to return <see langword="true"/> || or <see langword="default"/> value of <typeparamref name="T"/></param>
            <returns><see langword="true"/> if any of the elements are in both lists. || <see langword="false"/> if either list is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyOf(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String@)">
            <summary>Checks if the <paramref name="list"/> contains any of the elements in the second list.</summary>
            <param name="list"></param>
            <param name="ofThese"></param>
            <param name="firstMatch">The item in the <paramref name="list"/> that caused the method to return <see langword="true"/> || or <see langword="null"/> if none found</param>
            <returns><see langword="true"/> if any of the elements are in both lists.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf(System.Int32,System.Collections.Generic.IList{System.Int32})">
            <summary>Check if <paramref name="value"/> is equal to any of the values in the given list</summary>
            <param name="value"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if the <paramref name="value"/> is any <paramref name="ofThese"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if the <paramref name="value"/> is any <paramref name="ofThese"/> || Returns <see langword="false"/> if any input is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,``0,``0)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,System.Collections.Generic.IList{``0})"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,``0[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,System.Collections.Generic.IList{``0})"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf_Internal``1(``0,System.Int32,``0[])">
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.IndexOutOfRangeException"></exception>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,``0[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <inheritdoc cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAllOf``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>Checks if the first <paramref name="list"/> contains all the provided items</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if <paramref name="list"/> contains all <paramref name="ofThese"/> || <see langword="false"/> if <paramref name="list"/> or <paramref name="ofThese"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAllOf``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the <paramref name="list"/> contains all the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if <paramref name="list"/> contains all <paramref name="ofThese"/> || <see langword="false"/> if <paramref name="list"/> or <paramref name="ofThese"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAllOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the first list contains all the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.RoomExtensions">
            <summary>Room extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Neighbours(Verse.Room,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Get neighbouring rooms of a given room - Never null</summary>
            <param name="room">Get the neighbouring rooms of this room</param>
            <param name="forceCacheUpdate">Force update neighbour cache?</param>
            <param name="canPassHomeSeparators">do doors with an enabled home separator act like walls?</param>
            <param name="treatAirlocksAsDoors"></param>
            <param name="gameTicksNow"></param>
            <returns>List District of the given room's neighbouring rooms (not doorways) - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Cells(Verse.Region,System.Int32@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RoomExtensions.Cells_Internal(Verse.Region,System.Int32@,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Cells_Internal(Verse.Region,System.Int32@,Verse.Map,Verse.IntVec3)">
            <summary>Get the list of cells for the <paramref name="region"/> directly from the region grid</summary>
            <param name="region"></param>
            <param name="cellCount"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <returns>a read only <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> || Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.WallsAndCells_Internal(Verse.Region,Verse.IntVec3,System.Int32@,Verse.Map)">
            <summary></summary>
            <param name="myRegion"></param>
            <param name="mapSize"></param>
            <param name="wallCellsCount"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetThingsOfType``1(Verse.Room)">
            <summary>Not null</summary>
            <typeparam name="T"></typeparam>
            <param name="room"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetThingsOfType``1(Verse.Room,System.Int32@)">
            <summary>Not null</summary>
            <typeparam name="T"></typeparam>
            <param name="room"></param><param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Debug(System.Collections.Generic.IList{Verse.IntVec3},UnityEngine.Color,UnityEngine.Color)">
            <summary>Draw the cells with a gradient</summary>
            <param name="cells"></param>
            <param name="startColor"></param>
            <param name="endColor"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHomeID(Verse.Room,System.Boolean)">
            <summary>Get the id of the home that a room belongs to</summary>
            <param name="room">Get the id of the home that this room belongs to</param>
            <param name="skipIsPartOfHomeCheck">Skip check if we know that the room is part of a home</param>
            <returns>The id of the home that the room belongs to, or null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHome(Verse.Room)">
            <summary>Get the home that a room belongs to</summary>
            <param name="room">Get the home that this room belongs to</param>
            <returns>The home and a bool of true if it was found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHomeOwner(Verse.Room)">
            <summary>Get the pawn who is the owner of the home that the room belongs to, returns null if failed</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.DoorWays(Verse.Room)">
            <summary>Get the doorway <seealso cref="T:Verse.Region">regions</seealso> of the given <paramref name="room"/></summary>
            <param name="room">The room whose door ways we want to get.</param>
            <returns>A list of <see cref="T:Verse.Region"/>s</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Doors(Verse.Room,Verse.Map)">
            <summary>Get the <seealso cref="T:RimWorld.Building_Door">doors</seealso> from all neighbouring districts of the given <paramref name="room"/> || If you don't need the '<see cref="T:Verse.Thing"/>' use '<see cref="M:NQualityOfLife.Utils.RoomExtensions.DoorWays(Verse.Room)"/>' instead</summary>
            <param name="room">The room whose door ways we want to get.</param>
            <param name="map">Will be taken from room.Map if null, provide it if possible.</param>
            <returns>A list of Things (doors)</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenWorkshopItem_Changelog(System.String)">
            <summary>Open the changelog tab of the given workshop item in the web browser</summary>
            <param name="publishedFieldID"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenWorkshopItem(System.String)">
            <summary>Open the workshop page of the given workshop item in the web browser</summary>
            <param name="publishedFieldID"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenURL(NQualityOfLife.Types.URL)">
            <summary>Open the given URL in the browser - Displays on screen and log message, and plays sound.</summary>
            <param name="url">The URL of the web page to open in the web browser</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.CallsMethod(HarmonyLib.CodeInstruction,System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="method"></param>
            <returns>True if the instruction calls the given method - if the method is null, will log an error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.ReplaceWithMethodCall(HarmonyLib.CodeInstruction,System.Reflection.MethodInfo)">
            <summary>Replace the given <paramref name="instruction"/> with a method call to the <paramref name="replacementMethod"/></summary>
            <param name="instruction"></param>
            <param name="replacementMethod"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.XML.Patch.RemoveDef``1(``0)">
            <summary>Remove the given <see cref="T:Verse.Def"/> from the game</summary>
            <typeparam name="TDef">The type of the def</typeparam>
            <param name="def">The def to remove</param>
            <returns><see langword="true"/> if the <see cref="T:Verse.Def"/> was successfully removed from the <see cref="T:Verse.DefDatabase`1"/></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Log">
            <summary>Utils for logging errors and warnings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.totalErrors">
            <summary>the total amount of calls to <see cref="M:NQualityOfLife.Utils.Log.ErrorFinal``2(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets,``0)"/> / <see cref="M:NQualityOfLife.Utils.Log.ErrorOnceFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Int32,System.Boolean,Verse.LookTargets)"/> since startup</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.totalWarnings">
            <summary>the total amount of calls to <see cref="M:NQualityOfLife.Utils.Log.WarningFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)"/> / <see cref="M:NQualityOfLife.Utils.Log.WarningOnceFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Int32,System.Boolean,Verse.LookTargets)"/> since startup</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Log.Strings">
            <summary>Commonly used strings</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.RemoveColorTagsRegex(System.String)">
            <summary>Strips color tags</summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ExceptionInfo(System.Exception)">
            <summary>Formats an <see cref="T:System.Exception"/> for display</summary>
            <param name="exception"></param>
            <returns>a <see cref="T:System.String"/> with information about the <paramref name="exception"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ErrorOnce(System.Exception,Verse.LookTargets)">
            <summary>Log exception once with method resolve mode '(...)' and visible id</summary><param name="exception"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageOnChange(System.String,System.String,System.Type,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log a message if the message has changed</summary><param name="message"></param>
            <param name="method"></param><param name="type"></param><param name="methodName"></param>
            <param name="logMode"></param>
            <param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageOnChange(System.String,System.Type,System.String)">
            <summary>Log a message if the message has changed</summary><param name="message"></param><param name="type"></param><param name="methodName"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Message(System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log a message with no method info</summary>
            <param name="message"></param>
            <param name="logMode"></param>
            <param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,System.String,Verse.LookTargets)">
            <summary>Log a warning with the method details and <paramref name="lookTargets"/></summary><param name="message"></param><param name="method"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,NQualityOfLife.Utils.Log.LogMode,System.String,Verse.LookTargets)">
            <summary>Log a warning with the given <paramref name="logMode"/> - Logs method name by default using the '(omit)' resolve mode</summary><param name="message"></param><param name="logMode"></param><param name="method"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets,System.String)">
            <summary>Log warning message with <paramref name="lookTargets"/> and visible method name</summary><param name="message"></param><param name="logMode"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param><param name="method"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String)">
            <summary>Log a warning with message only</summary><param name="message"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log a warning with the given method info</summary><param name="message"></param><param name="method">The method info or mode</param><param name="logMode"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null``1(System.String,System.String,System.String,``0,Verse.LookTargets)">
            <summary>Logs a <see langword="null"/> error and returns the specified value</summary>
            <param name="nullThing">nameof</param>
            <param name="nullThing2"></param><param name="t">nameof(t)</param>
            <param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param><param name="method"></param>
            <returns><typeparamref name="T"/> specified value or <see langword="default"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null``1(System.String,System.String,``0,Verse.LookTargets)">
            <summary>Logs a <see langword="null"/> error and returns <see langword="default"/> or specified value</summary>
            <param name="nullThing">nameof</param><param name="t">nameof(t)</param>
            <param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param><param name="method"></param>
            <returns><typeparamref name="T"/> <see langword="default"/> value or given value <paramref name="t"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,Verse.LookTargets,System.String)">
            <summary>Logs a <see langword="null"/> error and returns <see langword="false"/><para>The default message is: $"'{t}' is '{Common.Strings.nullSymbol}'!"</para></summary>
            <param name="t">nameof(t)</param><param name="method"></param>
            <param name="customMessage">Override the default message ($"'{t}' is '{Common.Strings.nullSymbol}'!")</param>
            <param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param><returns><see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,Verse.LookTargets,System.String)">
            <summary>Logs a <see langword="null"/> error and returns <see langword="false"/><para>The default message is: $"'{t1}' or '{t2}' is '{Common.Strings.nullSymbol}'!"</para></summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="method"></param>
            <param name="customMessage">Override the default message ($"'{t1}' or '{t2}' is '{Common.Strings.nullSymbol}'!")</param>
            <param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param><returns><see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.String,Verse.LookTargets,System.String)">
            <summary>Logs a <see langword="null"/> error and returns <see langword="false"/><para>The default message is: $"'{t1}', '{t2}' or '{t3}' is '{Common.Strings.nullSymbol}'!"</para></summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="t3"></param><param name="method"></param>
            <param name="customMessage">Override the default message ($"'{t1}', '{t2}' or '{t3}' is '{Common.Strings.nullSymbol}'!")</param><param name="lookTargets"></param><returns><see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.String,System.String,Verse.LookTargets,System.String)">
            <summary>Logs a <see langword="null"/> error and returns <see langword="false"/><para>The default message is: $"'{t1}', '{t2}', '{t3}' or '{t4}' is '{Common.Strings.nullSymbol}'!"</para></summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="t3"></param><param name="t4"></param><param name="method"></param>
            <param name="customMessage">Override the default message ($"'{t1}', '{t2}', '{t3}' or '{t4}' is '{Common.Strings.nullSymbol}'!")</param>
            <param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param><returns><see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput``1(System.String,System.String,``0)">
            <summary>Log an error and return the <see langword="default"/> value of the specified type</summary>
            <typeparam name="R"></typeparam>
            <param name="parameter"></param>
            <param name="method"></param>
            <param name="ret"></param>
            <returns><see langword="default"/> value of '<typeparamref name="R"/>' usually <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error(System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log an error without including the method name or params</summary><param name="message"></param><param name="logMode"></param><param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log error with the given method info</summary><param name="message"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error``1(``0,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log <see cref="T:System.Exception"/> with method name and params</summary><param name="exception"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets"></param><returns>The <see cref="T:System.Exception"/> that was logged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error``1(System.String,``0,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log <see cref="T:System.Exception"/> with a message and method name and params</summary><param name="message"></param><param name="exception"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets"></param><returns>The <see cref="T:System.Exception"/> that was logged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.GetLogTypeTagString(NQualityOfLife.Utils.Log.LogMode,System.String)">
            <summary></summary>
            <param name="logMode"></param>
            <param name="tag"></param>
            <returns>"- QA -" or "[E] - QA -" or "-" or "[E] -" etc</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ResolveMethodInfo(System.String,System.Byte,System.Boolean)">
            <summary>Input can be <see langword="null"/></summary>
            <param name="methodToResolve"></param>
            <param name="offsetStackFrames"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.FixColorTagParity(System.String,System.Byte,System.Boolean@,System.Boolean,System.Boolean)">
            <summary>Calling Utils.Log.Error can cause an infinite loop!</summary>
            <param name="text"></param>
            <param name="attempts"></param>
            <param name="error"></param>
            <param name="skipNullCheck"></param>
            <param name="skipHasColorTagsCheck"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ColorizeHashTagNumber(System.String)">
            <summary>Colorize the first found '#256' type <see cref="T:System.String"/></summary>
            <param name="inputString"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Settings">
            <summary>Global settings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Settings.DebugMode">
            <summary>global debug mode bool</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Settings.profile">
            <summary>The currently active setting profile, This will be constant after startup</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Common">
            <summary>Common utility methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AppendAction(System.Action,System.Action)">
            <summary></summary>
            <param name="firstAction"></param>
            <param name="secondAction"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Action"/> that is a combination of the <paramref name="firstAction"/> and <paramref name="secondAction"/> || or <paramref name="secondAction"/> directly if <paramref name="firstAction"/> is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.RatioToColor(System.Single,System.Boolean,System.Single)">
            <summary></summary>
            <param name="ratio"></param>
            <param name="highIsBad"></param>
            <param name="alwaysGoodOrBadAbove"></param>
            <returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.RatioToColor(NQualityOfLife.Types.Ratio,System.Boolean,System.Single)">
            <summary></summary>
            <param name="ratio"></param>
            <param name="highIsBad"></param>
            <param name="alwaysGoodOrBadAbove"></param>
            <returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IsNullOrEmpty``1(System.Nullable{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.TryParse(System.Char,System.Int32@)">
            <summary></summary>
            <param name="c">character</param><param name="i"></param>
            <returns><see langword="true"/> if successfully parsed the <see cref="T:System.Char"/> to <see cref="T:System.Int32"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.TryParse(System.Int32,System.Char@)">
            <summary></summary>
            <param name="c">character</param><param name="i"></param>
            <returns><see langword="true"/> if successfully parsed the <see cref="T:System.Int32"/> to <see cref="T:System.Char"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0)">
            <summary>Method for un-setting <seealso cref="T:System.FlagsAttribute">flags</seealso> in an <see cref="T:System.Enum"/></summary>
            <typeparam name="TEnum"></typeparam>
            <param name="mode"></param>
            <param name="flags">The <seealso cref="T:System.FlagsAttribute">flags</seealso> to un-set</param>
            <returns><see cref="T:System.UInt64"/> of the new value <para>to convert it back to <typeparamref name="TEnum"/> you can do something like this: '<paramref name="mode"/> = (<typeparamref name="TEnum"/>)<paramref name="mode"/>.UnsetFlagsGeneric(<typeparamref name="TEnum"/>.SomeFlag)'</para></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.Chars">
            <summary><see cref="T:System.Char"/> constants etc</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.micro">
            <summary>'u' with the tail</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.nullSymbol">
            <summary>Used to represent a <see langword="null"/> value</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.emptySymbol">
            <summary>Symbol for representing an empty <see cref="T:System.String"/> or <see cref="T:System.Collections.Generic.ICollection`1"/>, 'ε' - looks like an inverted 3 or fancy E</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.emptyChar">
            <summary>Kind of like the <see langword="null"/> value for <see cref="T:System.Char"/>s</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatDate(System.DateTime)">
            <summary>Formats the given date in the format: DD.MM.YYYY</summary>
            <param name="dateTime"></param>
            <returns>DD.MM.YYYY <see cref="T:System.String"/></returns>
            <remarks>If you want to include a specific time of day; use: '<see cref="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.DateTime)"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.ReverseFormatDate(System.String)">
            <summary>Gets the <see cref="T:System.DateTime"/> from a: DD.MM.YYYY / DD:MM:YYYY <see cref="T:System.String"/></summary>
            <param name="dateString">a date <see cref="T:System.String"/> formatted as: DD.MM.YYYY or DD:MM:YYYY</param>
            <returns><see cref="T:System.DateTime"/> from the DD.MM.YYYY <see cref="T:System.String"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.Strings">
            <summary>Commonly used strings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.redacted">
            <summary>Used to replace user names or other sensitive info from log messages etc..</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.nullSymbol">
            <summary>Used to represent a null value in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">
            <summary>Used to represent a null value in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">
            <summary>Used to represent an empty string in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.emptySymbolForceLowerCase">
            <summary>Used to represent an empty string in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.newLine">
            <summary>The new line symbol string for the current Environment/OS</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Common.Strings.WalkingDots">
            <summary>Get a <see cref="T:System.String"/> of dots that iterates trought '.' -> '..' -> '...' and repeats at a constant rate<para>Intended to be used in loading animations for async tasks</para></summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.IFormatMode`1">
            <summary>Interface for formatting the given <see cref="T:System.Type"/> <typeparamref name="T"/> instance to a <see cref="T:System.String"/></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> that implements <see cref="T:NQualityOfLife.Utils.Common.IFormatMode`1"/></typeparam>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.DisplayFormatFor(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary>Format <typeparamref name="T"/> according to the <paramref name="displayMode"/> - <see cref="F:NQualityOfLife.Utils.Common.DisplayMode.Default"/> should use <see cref="M:System.Object.ToString"/></summary>
            <param name="displayMode"></param>
            <returns>The formatted <see cref="T:System.String"/> representation of <typeparamref name="T"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.ToStringShortName">
            <summary></summary>
            <returns>A <see cref="T:System.String"/> that is the 'short name' representation of <typeparamref name="T"/></returns>
            <remarks>For example <see cref="T:System.IO.DirectoryInfo"/> may return <see cref="P:System.IO.DirectoryInfo.Name"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.ToStringLongName">
            <summary></summary>
            <returns>A <see cref="T:System.String"/> that is the 'long name' representation of <typeparamref name="T"/></returns>
            <remarks>For example <see cref="T:System.IO.DirectoryInfo"/> may return <see cref="P:System.IO.DirectoryInfo.FullName"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.ToStringID">
            <summary>Get an identifier <see cref="T:System.String"/> for <see langword="this"/> <typeparamref name="T"/></summary>
            <returns>An unique id <see cref="T:System.String"/> of this <typeparamref name="T"/> instance</returns>
            <remarks>Can be for example the <see langword="nameof"/>(<typeparamref name="T"/>) + <see cref="M:System.Object.GetHashCode"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.FormatMode">
            <summary>The way that the a collection should be formatted</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.VerticalWithLines">
            <summary><list type="table"><listheader></listheader><item><term></term> a</item><item><term></term> b</item><item><term></term> c</item></list></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.HorizontalWithCommas">
            <summary>a, b, c</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.VerticalNumbered">
            <summary><list type="number"><listheader></listheader><item>a</item><item>b</item><item>c</item></list></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.HorizontalWithArrows">
            <summary>a -> b -> c</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.VerticalLineBreakOnly">
            <summary><list type=""><listheader></listheader><item>a</item><item>b</item><item>c</item></list></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.HorizontalWithPipes">
            <summary>a | b | c</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.VerticalNumberedIndex0">
            <summary><list type=""><listheader></listheader><item>0. a</item><item>1. b</item><item>2. c</item></list></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.Default">
            <summary>ToString()</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.ShortName">
            <summary>A short identifier/name of the item</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.LongName">
            <summary>Display a long / full name string</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.LabelIfPossible">
            <summary>Display the user facing label if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.IDIfPossible">
            <summary>Display the unique id of the item if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.UseDeterministicColors">
            <summary>Should the string be colored before appending it to the final result?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.Default">
            <summary>ToString()</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.ShortName">
            <summary>A short identifier/name of the item</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.LongName">
            <summary>Display a long / full name string</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.LabelIfPossible">
            <summary>Display the user facing label if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.IDIfPossible">
            <summary>Display the unique id of the item if possible</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatAsString``1(System.Collections.Generic.IList{``0},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})">
            <summary>Format the <paramref name="list"/> as a <see cref="T:System.String"/> using the provided <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/> and <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="formatMode"></param>
            <param name="displayMode"></param>
            <param name="specialFormatter"></param>
            <param name="specialSuffixMaker"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatAsString``2(System.Collections.Generic.IDictionary{``0,``1},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags)">
            <summary>Format the <paramref name="dictionary"/> as a <see cref="T:System.String"/> using the provided <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/> and <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="formatMode"></param>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatItemString``1(System.String,``0,System.Text.StringBuilder@,System.Boolean,System.UInt32@,System.String,System.String,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="displayedString"></param>
            <param name="item"></param>
            <param name="builder"></param>
            <param name="useNumber"></param>
            <param name="c"></param>
            <param name="lineStart"></param>
            <param name="lineEnd"></param>
            <param name="displayMode"></param>
            <param name="specialSuffix"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.DisplayFormatFor``1(``0,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String})">
            <summary>Format the item to a <see cref="T:System.String"/> according to the given <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/> or <paramref name="specialFormatter"/></summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="displayMode"></param>
            <param name="specialFormatter">Use this <see cref="T:System.Func`2"/> to specify how <typeparamref name="T"/> is formatted, or leave <see langword="null"/> to use the best found formatter</param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Resolve">
            <summary>Resolve invalid or null values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.MapIsNullAfterResolve``1(Verse.Map,Verse.Map@,``0,System.String,System.String)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="t">Use this thing to find map if available</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.IsNullAfterResolve(Verse.Map,Verse.Map@,System.String,System.String)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.MapIsNullAfterResolve(Verse.Map,Verse.Map@,System.String,System.String,System.Byte)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
            <param name="offsetFrames"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.NullMap``1(``0)">
            <summary>Try to find current map</summary>
            <returns>Map or null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.IdentifierInfo.FindContentSource(System.Type)">
            <summary></summary>
            <param name="type"></param>
            <returns>The packageId of the mod that the <paramref name="type"/> was found in || or <see langword="null"/> if it was not found</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Mouse_">
            <summary>values related to the mouse pointer</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Mouse_.positionOnUIRatio">
            <summary>y1f is the top of the screen, x1f is the right side of the screen</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Mouse_.IsNearWidgetsOrLetters">
            <summary>true if yes, always false if game is unfocused</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Mouse_.IsNearWidgetsOrLettersUpdate">
            <summary>Is the mouse pointer near the widgets or letter stack?</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.IfPlayer.PlayerCanSeeNow(Verse.Thing,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Get.IfPlayer.CanSeeNow(Verse.Thing,Verse.Map)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.IfPlayer.CanSeeNow(Verse.Thing,Verse.Map)">
            <summary></summary>
            <param name="thing"></param>
            <param name="currentMap"></param>
            <returns><see langword="true"/> if the <paramref name="thing"/> is on the <see cref="T:Verse.Map"/> that the player is currently looking at, and is not fogged or otherwise hidden</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Colony">
            <summary>values related to the colony</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Room_.Contains">
            <summary>Get room contents</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.ContainsFood(Verse.Room,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns>bool, true if contains food</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.ContainsFood(Verse.District,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns>bool, true if contains food</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.Food(Verse.District,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns>bool, true if contains food</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Room_.My">
            <summary>myRoom's x</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.My.Neighbours(Verse.District,System.Boolean,System.Boolean,System.Collections.Generic.HashSet{Verse.District},System.Boolean,System.Boolean,System.Int32,System.Byte,System.Boolean)">
            <summary>Get the neighbouring rooms of a room</summary>
            <param name="myRoom">The room whose neighbours we want to find</param>
            <param name="ignoreAirlocks">treat airlocks like a single door ISSUE: doesn't correctly return all rooms if this is enabled</param>
            <param name="ignoreRooms">Ignore these rooms</param>
            <param name="returnFirst">Return the first found neighbour instead of all of them</param>
            <param name="forceCacheUpdate">Force the method to recalculate, instead of using saved values</param>
            <param name="canPassHomeSeparators">Allow the search to return rooms behind home system home separator doors / do doors with an enabled home separator act like walls?</param>
            <param name="gameTicksNow"></param>
            <param name="maxRecursion"></param>
            <param name="debug"></param>
            <returns>List District of the given room's neighbouring rooms (not doorways) - Never null</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.My.FindEndOfDoorChain(Verse.District,Verse.District,System.Byte,System.Collections.Generic.HashSet{Verse.District})">
            <summary>Finds the room at the end of a chain of back to back doors</summary>
            <param name="startRoom">The room where firstDoor connects</param>
            <param name="firstDoor">The door in startRoom at the start of the door chain</param>
            <param name="maxIterations">Log error and give up after this many iterations of recursion</param>
            <param name="checkedDistricts"></param>
            <returns>The room at the end of the chain, that is not the starting room or null</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Best.MedicalCarePolicy">
            <summary>Methods for getting best medical care policy</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Best.MedicalCarePolicy.ForThisPawn(Verse.Map,Verse.Pawn,System.Boolean)">
            <summary>Get the best medical care policy for the given pawn</summary>
            <returns>bool foundValidPolicy, MedicalCareCategory policy</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="pawnToAssign">The Pawn we want to get the policy for</param>
            <param name="forPrisoners"></param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Best.Area_">
            <summary>Get best Area for...</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Best.Area_.ForThisPawn(Verse.Map,Verse.Pawn,System.Boolean,System.Boolean)">
            <summary>Get the best area restriction for a given pawn</summary>
            <returns>Verse.Area of the best fit for the given pawn</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="pawnToAssign">The Pawn we want to get the Area for</param>
            <param name="slave">is the pawn known to be a slave?</param>
            <param name="skipValidation">Skip the checks for "playerSettings", "SupportsAllowedAreas" and "RespectsAllowedArea" because we already checked them</param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Relations">
            <summary>Get Pawn Relation info</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Relations.LoverPairsOnMap(Verse.Map,System.Boolean)">
            <summary>Get the count of lovers on the map</summary>
            <returns>count of lovers, and count of lovers assigned to double beds</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="mustBeAssignedToSameBed">Do we only count lovers if they are assigned to the same bed?</param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Skills">
            <summary>Get pawn skills</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Skills.AverageOf">
            <summary>Get average skills of </summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Skills.AverageOf.AssignedTo(Verse.Map,Verse.WorkTypeDef,RimWorld.SkillDef,Verse.Pawn)">
            <summary>Get the average skill of pawns assigned to work type</summary>
            <param name="map">The map to get the average from</param>
            <param name="workType">The work-type that the pawns need to be assigned to</param>
            <param name="skill">The skill to get</param>
            <param name="ignorePawn">Do not include this pawn</param>
            <returns>float of the average skill level</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.Clear">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Utils.Get.Pawn_.Triage"/> instance</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Get.Pawn_.Triage.Item(RimWorld.Faction)">
            <summary></summary>
            <param name="forFaction"></param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns">
            <summary>Saved list of the top pawns who need treatment</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.priorityPawn">
            <summary>The first top priority pawn</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.secondPawn">
            <summary>The second priority pawn</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.thirdPawn">
            <summary>The third priority pawn</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.AddPawn(Verse.Pawn,System.Single)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="timeTillDeathForThisPawn"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> was added to any position in the triage, <see langword="false"/> if they were not added</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.RemovePawn(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.TriageUtils">
            <summary>Utilities for determining medical treatment priority</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.DeadlyHediffs(Verse.Pawn)">
            <summary>Get all the hediffs that can cause the pawn to die</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.TimeTillDeathForTriage(Verse.Pawn,RimWorld.Faction,System.Boolean)">
            <summary>Method for estimating time till death in hours for tendable hediffs like bleeding</summary>
            <param name="pawn">Estimate time till death for this pawn</param>
            <param name="hasHediffsNeedingTend"></param>
            <param name="saveTriageForFaction">Leave as <see langword="default"/> unless you know what you are doing</param>
            <returns><see langword="float"/> of time left in hours or <see cref="F:System.Single.MaxValue"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.TimeTillDeath(Verse.Pawn,System.Boolean,RimWorld.Faction)">
            <summary>Method for estimating time till death in hours</summary>
            <param name="pawn">Estimate time till death for this pawn</param>
            <param name="hasHediffsNeedingTendOrStarving">Skip check for hediffs if we already know</param>
            <param name="saveTriageForFaction">Leave as <see langword="default"/> unless you know what you are doing</param>
            <returns><see langword="float"/> of time left in hours or <see cref="F:System.Single.MaxValue"/></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.WithBest">
            <summary>Utilities for getting the pawn with the best value of something</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.WithBest.Stat(Verse.Map,RimWorld.StatDef,Verse.WorkTypeDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Method for getting the pawn with the best stat</summary>
            <param name="map">The map to check for pawns, if null, will try to find map</param>
            <param name="greaterIsBetter"> larger values are better</param>
            <param name="stat"> the StatDef to check</param>
            <param name="mustBeCapable"> Return the best pawn that is capable?</param>
            <param name="mustBeAwake"> Get the best pawn from the pawns that are awake?</param>
            <param name="workType"> The pawn must be assigned to the relevant work-type to be considered, if set to null, will not be considered</param>
            <param name="mustNotBeOccupied"> Don't return pawns that are currently operating? </param>
            <param name="postProcess"> postProcess for GetStatValue()</param>
            <param name="forceGetFresh"></param>
            <returns>Pawn bestPawn and float statValue</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.TechLevel_">
            <summary>Utilities for getting tech-level related values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.Color(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="finished"></param>
            <param name="locked"></param>
            <returns>The color for the current state of this research</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.ColorHex(RimWorld.TechLevel,System.Boolean)">
            <summary>Gets the color associated with the provided tech level.</summary>
            <param name="techLevel"></param>
            <param name="noErrorOnInvalid"></param>
            <returns>UnityEngine.Color for the tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.OfFaction(RimWorld.Faction)">
            <summary>Method for getting the research level of a specified faction</summary>
            <param name="faction">The faction to check</param>
            <returns>the tech level of the faction</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.OfPlayer">
            <summary>Get the current player tech level</summary>
            <returns>the tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.ResearchStats(RimWorld.TechLevel,System.Boolean)">
            <summary>
            Retrieves statistics about completed research projects, including the number of completed projects,
            the total number of research projects, and the number of projects completed at a specific research level.
            </summary>
            <param name="checkLevelCompletion_Level">The research level to check for completed projects.</param>
            <param name="debug"></param>
            <returns>
            A tuple containing:
            - The highest level of research achieved.
            - The count of completed projects.
            - The total count of research projects.
            - The count of completed projects at the specified research level.
            - The total count of projects at the specified research level.
            - The count of completed projects at the next research level.
            - The total count of projects at the next research level.
            </returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_PrintSettings">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_PrintSettings.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_PreviewSound">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_PreviewSound.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Doc">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Doc.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Trade">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Trade.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_TryCreate_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_TryCreate_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_TryFillRooms_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_TryFillRooms_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_PrintHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_PrintHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_AnnexRooms_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_AnnexRooms_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_ValidateHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_ValidateHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_DeleteHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_DeleteHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.TechLevel_">
            <summary>Utilities for setting tech level values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.TechLevel_.OfPlayer(RimWorld.TechLevel,System.Boolean)">
            <summary>Sets the player factions tech level to the provided level</summary>
            <param name="newTechLevel">The research level to set</param>
            <param name="debug"></param>
        </member>
        <member name="M:NQualityOfLife.QA.SelfScan.ScanTranslations(System.Diagnostics.Stopwatch@)">
            <summary>Scans the mod translation files for any issues</summary>
        </member>
        <member name="M:NQualityOfLife.QA.SelfScan.TestAllMyTypes(System.Boolean,System.Diagnostics.Stopwatch)">
            <summary>Scans all the classes and methods of this mod to make sure everything is ready for a public release</summary>
            <param name="getTodoList"></param>
            <param name="translationScanTime"></param>
        </member>
        <member name="T:NQualityOfLife.Attributes.CustomWithDateAttribute">
            <summary>Abstract attribute that has <see cref="T:System.DateTime"/> data</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.RecursiveAttribute">
            <summary>The method is <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#recursive">recursive</see> on itself directly, or trough other methods</summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.RecursiveAttribute.#ctor">
            <summary>The method calls itself / Is <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#recursive">recursive</see> on itself</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.LazyAttribute">
            <summary>The method returns a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#lazy">lazy</see> <see cref="T:System.Collections.Generic.IEnumerable`1"/> and/or enumerates the inputs <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#lazy">lazily</see><para>The opposite of <see cref="T:NQualityOfLife.Attributes.EagerAttribute"/></para></summary>
            <remarks>All methods that have an input <see cref="T:System.Collections.Generic.IEnumerable`1"/> or return an <see cref="T:System.Collections.Generic.IEnumerable`1"/> should have <seealso cref="T:NQualityOfLife.Attributes.LazyAttribute">this attribute</seealso>or the <see cref="T:NQualityOfLife.Attributes.EagerAttribute"/> to clarify the behaviour</remarks>
        </member>
        <member name="T:NQualityOfLife.Attributes.EagerAttribute">
            <summary>The method <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#eager">eagerly</see> <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#iteration">iterates</see> any input <see cref="T:System.Collections.Generic.IEnumerable`1"/> or the output is not a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#lazy">lazy</see> <see cref="T:System.Collections.Generic.IEnumerable`1"/><para>The opposite of <see cref="T:NQualityOfLife.Attributes.LazyAttribute"/></para></summary>
            <remarks>Should only be applied to <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#eager">eager</see> methods that have an input <see cref="T:System.Collections.Generic.IEnumerable`1"/> parameter or return a <see cref="T:System.Collections.Generic.IEnumerable`1"/> because methods that do not input or output a <see cref="T:System.Collections.Generic.IEnumerable`1"/> are known to be <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#eager">eager</see></remarks>
        </member>
        <member name="T:NQualityOfLife.Attributes.ExperimentalAttribute">
            <summary>Marks a method or class as experimental, Meaning it is still in development and could be unstable or un-optimized.</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ThreadSafeAttribute">
            <summary>The method can be safely used with async tasks and multithreading</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.MustUseReturnAttribute">
            <summary>The return value must be used!</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.PureIshAttribute">
            <summary>The return value must be used, and the methed doesn't have side effects - Error logging/throwing is allowed in case of internal errors, or the input is obviously invalid</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ImpureAttribute">
            <summary>The method has side effects or the return is not always the same for the same inputs<para>For example all <see cref="T:NQualityOfLife.Utils.Rand"/> methods are generally <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#impure">impure</see></para><para>The opposite of <see cref="T:System.Diagnostics.Contracts.PureAttribute"/></para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.MutatesAttribute">
            <summary>The specified parameters are <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#mutation">mutated</see> by the method</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.MutatedAttribute">
            <summary>The specified parameter is <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#mutation">mutated</see> by the method</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.TestedAttribute">
            <summary>The relevant feature was tested in game and confirmed to work as designed.</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.AuthorsAttribute">
            <summary>Information about when the member was modifed and by whom</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.AliasAttribute">
            <summary>The method is identical to another method with a different name</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ImplicitOperatorAttribute">
            <summary>Implicit operators should be marked with this attribute</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.InterfaceForAttribute">
            <summary>The method is used to make calling another method easier<para>For example it is the public member that then calls internal methods</para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ToDoAttribute">
            <summary>Attribute for keeping track of things that need to be done</summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.ToDoAttribute.#ctor(System.String,System.UInt16,System.Byte,System.Byte,System.Boolean)">
            <summary></summary>
            <param name="toDo"></param>
            <param name="critical"></param>
            <param name="deadLine_year">Deadline year</param><param name="deadLine_month">Deadline month</param><param name="deadLine_day">Deadline day</param>
        </member>
        <member name="M:NQualityOfLife.Attributes.ToDoAttribute.#ctor(System.String,System.Boolean,System.UInt16,System.Byte,System.Byte)">
            <summary></summary>
            <param name="toDo"></param>
            <param name="critical"></param>
            <param name="deadLine_year">Deadline year</param><param name="deadLine_month">Deadline month</param><param name="deadLine_day">Deadline day</param>
        </member>
        <member name="T:NQualityOfLife.Attributes.PatchIfEnabledAttribute">
            <summary>Used on harmony patch classes to conditionally apply the patches<para>Should only be applied to classes with a <see cref="T:HarmonyLib.HarmonyPatch"/> attribute</para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.UnusedAttribute">
            <summary>The member is not used for anything at the moment but might be in the future</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.HasQATesterAttribute">
            <summary>This method has a QA tester to ensure functionality and or performance</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.UsedInQATesterAttribute">
            <summary>The method is used to verify the results of a QA test<para>for this reason all methods with the <see cref="T:NQualityOfLife.Attributes.UsedInQATesterAttribute"/> should have a QA tester of their own</para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.RequiresModAttribute">
            <summary>Indicates that the method or class requires some other mod to be running in order to work</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ExcludeFromAnalyzerXMLAttribute">
            <summary>The method or class should not be included in the Analyzer.xml file<para>This should be done if the class or method doesn't do any computations during run time or the method causes the analyzer to break</para></summary>
        </member>
        <member name="P:NQualityOfLife.Physics.Universe.TotalMass">
            <summary>The total mass contained in the universe</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.count">
            <summary>The variable where the patch specific count is stored. (optional)</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.done">
            <summary>The patch to apply after this one succeedes. (optional)</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.error">
            <summary>The patch to apply if this one fails. (optional)</summary>
        </member>
        <member name="T:NQualityOfLife.XML.Remove">
            <summary>Removes all matching nodes</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathedWithValue.value">
            <summary>The xml to add or replace etc</summary>
        </member>
        <member name="M:NQualityOfLife.World.PlayerLegacyTracker.RecordNewEvent(RimWorld.TaleDef,Verse.Pawn,Verse.ResearchProjectDef,RimWorld.TechLevel)">
            <summary></summary>
            <param name="taleDef"></param>
            <param name="pawn"></param>
            <param name="researchProject"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:NQualityOfLife.World.PlayerLegacyTracker.RecordNewEvent(RimWorld.TaleDef,Verse.Pawn,Verse.ResearchProjectDef)">
            <summary></summary>
            <param name="taleDef"></param>
            <param name="pawn"></param>
            <param name="researchProject"></param>
        </member>
        <member name="F:NQualityOfLife.World.LegacyEventData.renoun">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.World.LegacyEventData.infamy">
            <summary></summary>
        </member>
        <member name="M:NQualityOfLife.World.GoodWillUtility.RelevantEvents(RimWorld.Faction,System.Boolean)">
            <summary></summary>
            <param name="faction"></param>
            <param name="onlySpecificToThisFaction">Ignore events that affect all factions?</param>
            <returns></returns>
        </member>
        <member name="F:NQualityOfLife.World.Utils_.Tile_.TileCount">
            <summary>The total number of tiles on the planet map</summary>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.DistanceTo(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldObject,RimWorld.Planet.WorldGrid,System.UInt16)">
            <summary></summary>
            <param name="myLocation"></param><param name="destination"></param>
            <param name="worldGrid"></param><param name="maxDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.DistanceTo(System.Int32,System.Int32,RimWorld.Planet.WorldGrid,System.UInt16)">
            <summary></summary>
            <param name="myLocation"></param><param name="destination"></param>
            <param name="worldGrid"></param><param name="maxDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(System.Int32,System.Int32,RimWorld.Planet.WorldGrid)">
            <summary>Get the tile neighbouring this tile in the direction of the other tile</summary>
            <param name="rootTile"></param>
            <param name="otherTile"></param>
            <param name="worldGrid"></param>
            <returns>The tile id of the Neighbouring tile || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(System.Int32,RimWorld.Direction8Way,RimWorld.Planet.WorldGrid)">
            <summary>Get the tile neighbouring this tile in the given direction</summary>
            <param name="rootTile"></param>
            <param name="direction"></param>
            <param name="worldGrid"></param>
            <returns>The tile id of the Neighbouring tile in the given direction || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.IsConnectedByRoad(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldObject,System.Collections.Generic.List{System.ValueTuple{System.Int32,System.Collections.Generic.List{RimWorld.Planet.Tile.RoadLink}}},System.ValueTuple{System.Int32,System.Int32}@,System.ValueTuple{RimWorld.RoadDef,System.Int32,System.Int32}@,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="worldObject"></param>
            <param name="other"></param>
            <param name="roadTilesOut"></param>
            <param name="roadHasBreakBetweenTiles">will always be (-1, -1) if road is not connected at all or doesn't have gaps</param>
            <param name="bottleNeck"></param>
            <param name="worldGrid"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.ClosestTileWithRoad(System.Int32,System.Int32@,System.Collections.Generic.ICollection{System.Int32})">
            <summary></summary>
            <param name="rootTile"></param>
            <param name="distanceToTile"></param>
            <param name="excludeTiles"></param>
            <returns>-1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.HasRoad(RimWorld.Planet.Tile)">
            <summary></summary><param name="tile"></param>
            <returns>True if the given tile has any roads on it</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldGrid,System.Int32)">
            <summary></summary>
            <param name="settlement"></param>
            <param name="worldGrid"></param>
            <param name="radius"></param>
            <returns>1f - 7f</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(System.Int32,RimWorld.Planet.WorldGrid,System.Int32)">
            <summary></summary>
            <param name="tile"></param>
            <param name="worldGrid"></param>
            <param name="radius"></param>
            <returns>1f - ?f</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.GetCloseTileToSettle(System.Int32,System.Int16@,RimWorld.Planet.WorldGrid,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Boolean,System.Int32,System.Int32)">
            <summary></summary>
            <param name="rootTileId"></param>
            <param name="distanceToTile"></param>
            <param name="worldGrid"></param>
            <param name="forFaction"></param>
            <param name="forFactionFactionExtensions"></param>
            <param name="distanceReducesDesirability"></param>
            <param name="minDistanceBetweenSettlements"></param>
            <param name="maxDistanceApprox"></param>
            <returns>-1 if none found</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileSettleDesirability(System.Int32,NQualityOfLife.Types.Factor,System.Collections.Generic.HashSet{System.Int32},RimWorld.Planet.WorldGrid,RimWorld.Planet.Tile,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Int32)">
            <summary></summary>
            <param name="tileId"></param>
            <param name="minimumScore">Return zero early and skip expensive checks if we know the score is not what we want</param>
            <param name="allOccupiedTiles"></param>
            <param name="worldGrid"></param>
            <param name="tile"></param>
            <param name="forFaction"></param>
            <param name="forFactionFactionExtensions"></param>
            <param name="minDistanceBetweenSettlements"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.MakeWarTorn(RimWorld.Planet.Tile,System.Int32,RimWorld.Planet.WorldGrid)">
            <summary>Try making the tile war torn</summary>
            <param name="tile"></param><param name="tileId"></param>
            <param name="worldGrid"></param>
            <returns>True if was made war torn, false if was already war torn.</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TryMakeUrban(RimWorld.Planet.Tile,System.Int32,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="tile"></param>
            <param name="tileId"></param>
            <param name="worldGrid"></param>
            <returns>True if the tile was changed to urban || False if was already urban or cannot make urban</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileFertilityFactor(System.Int32,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="tile"></param>
            <param name="worldGrid"></param>
            <returns>0f - ?f (-1f on error)</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileFertilityFactor(RimWorld.Planet.Tile,System.Int32)">
            <summary></summary>
            <param name="tile"></param>
            <param name="tileId"></param>
            <returns>0f - ?f (-1f on error)</returns>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToSettleBaseValue">
            <summary>The base resource cost to build a new settlement on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToAttack">
            <summary>The base resource cost to perform an attack another settlement on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToDevelopFarmLand">
            <summary>The base resource cost to develop a tile into farmland</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToBuildRoad">
            <summary>The base resource cost to build or upgrade a road on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToDevelopUrban">
            <summary>The base resource cost to develop a tile into urban</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.closeSettlementsMax">
            <summary>The maximum amount of close by settlements to save for fast lookup</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.minimumPopulationToAttack">
            <summary>The minimum population required to be able to perform an attack on another settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.tickInterval">
            <summary>The base tick interval of this comp</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.tickInterval_Population">
            <summary>The base population growth tick interval</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginalOwner">
            <summary>Get the original owner / creator faction of this settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.originalOwner">
            <summary>The original owner / creator faction of this settlement</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginalName">
            <summary>Get the original name of this settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.originalName">
            <summary>The original name of this settlement</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.Faction">
            <summary>The current owner faction of this settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.localTilePopulationCapCached">
            <summary>The maximum population that this settlement can currently hold</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.populationDensityRatio">
            <summary>1 means there is no more room for the population to grow, 0 means there are no people</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.localFertilityCached">
            <summary>Should be 0~1 - Can go above 1</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.attackDesire">
            <summary>The momentary desire to attack near by hostile bases.</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginallyFoundedYear">
            <summary>Get the game year that this base was created - Bases that existed at the game start get a random year before the game start date</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.originallyFoundedYear">
            <summary>The game year that this base was created - Bases that existed at the game start get a random year before the game start date</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.FailedToFindEnemyInARowCounter">
            <summary>Get how many times this base has tried to attack a near by settlement but found nothing to attack - also known as the peace score</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.failedToFindEnemyInARowCounter">
            <summary>How many times this base has tried to attack a near by settlement but found nothing to attack - also known as the peace score</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.Isolated">
            <summary>Get if this settlement is isolated from other settlements - This is used to stop isolated bases from ticking in some cases</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.iAmIsolated">
            <summary>If this settlement is isolated from other settlements - This is used to stop isolated bases from ticking in some cases</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanBeAttacked">
            <summary>Are other settlements allowed to attack this settlement?</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.canBeAttacked">
            <summary>Are other settlements allowed to attack this settlement?</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanAttackEver">
            <summary>Can this settlement ever attack anyone</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.canAttackEver">
            <summary>Can this settlement ever attack anyone</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanAttackNow">
            <summary>Get if this settlement can attack another settlement at this moment</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.canAttackNow">
            <summary>If this settlement can attack another settlement at this moment</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.PostMapGenerate">
            <summary>Triggers when a local map is generated - We disable attacking to prevent strange issues while the player is visiting the map</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.PostMyMapRemoved">
            <summary>Triggers when a local map is deleted - We restore the settings when the player leaves</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.AttackDesire">
            <summary>Calculate the momentary desire for this settlement to attack nearby hostile settlements</summary>
            <returns>attackDesire</returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.GetPopulationCapForTile(System.Int32,NQualityOfLife.Types.Factor,NQualityOfLife.Types.Factor,RimWorld.Planet.Tile,System.Int32)">
            <summary></summary>
            <param name="tileId"></param>
            <param name="populationSoftCap"></param>
            <param name="hardCap"></param>
            <param name="tile"></param>
            <param name="radius">At what radius do we take tiles into account</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.UpdateLocalExpansionDesire">
            <summary>Update the value of 'localExpansionDesireCached'</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.UpdateCachedFertility">
            <summary>Update the value of 'localFertilityCached'</summary>
            <returns>the new value of 'localFertilityCached'</returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.TryTransferStuff(NQualityOfLife.World.NQoL_World_Object_Comp,NQualityOfLife.World.NQoL_World_Object_Comp,RimWorld.Faction,RimWorld.Faction)">
            <summary>Try to trade resources or population between friendly faction bases</summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="fromFaction"></param>
            <param name="toFaction"></param>
            <returns>True if successfully transferred something</returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.DoBattleSim(NQualityOfLife.Types.Factor,RimWorld.TechLevel,NQualityOfLife.Types.Factor@,NQualityOfLife.World.NQoL_World_Object_Comp.BattleGoal@,NQualityOfLife.Types.Factor,RimWorld.TechLevel,NQualityOfLife.Types.Factor@,RimWorld.Planet.Hilliness,NQualityOfLife.Types.Ratio@,RimWorld.Faction,RimWorld.Faction,RimWorld.BiomeDef,NQualityOfLife.World.NQoL_World_Object_Comp)">
            <summary></summary>
            <param name="attackers"></param>
            <param name="attackerTechLevel"></param>
            <param name="attackerCasualties"></param>
            <param name="battleGoal"></param>
            <param name="defenders"></param>
            <param name="defenderTechLevel"></param>
            <param name="defenderCasualties"></param>
            <param name="hilliness"></param>
            <param name="attackSuccessChance"></param>
            <param name="attackerFaction"></param>
            <param name="defenderFaction"></param>
            <param name="biome">The biome where the battle takes place</param>
            <param name="defenderComp"></param>
            <returns>True if attackers won the battle</returns>
        </member>
        <member name="T:NQualityOfLife.World.NQoL_WorldComp">
            <summary>The world comp for managing faction relations on a given world</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_WorldComp.strongestFaction">
            <summary>Is the world project stuff enabled?</summary>
        </member>
        <member name="T:NQualityOfLife.World.NQoL_Faction_Population_Display_Patch_2">
            <summary>Extends the alternating grey box/line to match the extended height of the interact areas etc</summary>
        </member>
        <member name="T:NQualityOfLife.World.FactionRelationUtility">
            <summary>Utilities for adjusting faction relations</summary>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.ChangeGoodwill(RimWorld.Faction,RimWorld.Faction,System.Int32,System.String,System.Boolean)">
            <summary>Change the goodwill between two faction by a given value</summary>
            <param name="faction">faction 1</param>
            <param name="other">faction 2</param>
            <param name="goodwillChange">how much to change the goodwill by</param>
            <param name="translatedReasonString">The reason for the goowill change</param>
            <param name="sendLetter"></param>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.CalculateFactionExpansionDesire(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>Calculate a faction's desire to expand it's settlement count</summary>
            <param name="faction">The faction who's expansion desire we are calculating</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns>float in a range of 0f-1f</returns>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.CalculateTruceDesire(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>Calculate a faction's general desire to make peace with other factions</summary>
            <param name="faction">The faction who's truce desire we are calculating</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns>float in a range of 0f-1f</returns>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.AttemptATruceWithAllHostileFactions(RimWorld.Faction)">
            <summary>The given faction will attempt to truce with all other factions, based on truce desire and other factors</summary>
            <param name="faction">The faction who's attempting truce</param>
            <returns>true if truce is agreed upon</returns>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.ConditionalSurrender(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>The given faction will attempt to surrender to other factions</summary>
            <param name="surrenderingFaction">The faction who's trying to surrender</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns>true if the given faction's surrender is accepted</returns>
        </member>
        <member name="M:NQualityOfLife.World.Get_.SettlementCount(RimWorld.Faction)">
            <summary>Get the count of the settlements of the given faction</summary>
            <param name="faction"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.UI_.NQoL_Better_Recipe_Icons_Patch.AddIconIfNull_Postfix(Verse.ThingDef,Verse.RecipeDef)">
            <summary></summary>
            <param name="__result"></param>
            <param name="__instance"></param>
            <returns></returns>
            <remarks>When testing, and in QA build, press and hold control alt, then open the menu you are testing</remarks>
        </member>
        <member name="T:NQualityOfLife.UI_.ArchitectButtonOrganizer.Action_Reset_Arch">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.ArchitectButtonOrganizer.Action_Reset_Arch.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.ArchitectButtonOrganizer.NQoL_MainTabWindow_Architect_Patch_1.UpdateCacheAndWriteSettings(System.Collections.Generic.List{RimWorld.ArchitectCategoryTab}@,RimWorld.QuickSearchWidget,RimWorld.MainTabWindow_Architect,NQualityOfLife.Settings.SettingProfile,System.Boolean)">
            <summary>Refresh the architect menu to use the new order of the tabs</summary>
            <param name="___desPanelsCached"></param>
            <param name="___quickSearchWidget"></param>
            <param name="__instance"></param>
            <param name="profile"></param>
            <param name="writeSettings"></param>
        </member>
        <member name="M:NQualityOfLife.UI_.ArchitectButtonOrganizer.NQoL_MainTabWindow_Architect_Patch_1.SwapPositions(System.Collections.Generic.List{RimWorld.ArchitectCategoryTab}@,RimWorld.QuickSearchWidget,RimWorld.MainTabWindow_Architect)">
            <summary>Swap the positions of the <see cref="F:NQualityOfLife.UI_.ArchitectButtonOrganizer.NQoL_MainTabWindow_Architect_Patch_1.swapStartDef"/> and <see cref="F:NQualityOfLife.UI_.ArchitectButtonOrganizer.NQoL_MainTabWindow_Architect_Patch_1.swapEndDef"/></summary>
            <param name="___desPanelsCached"></param>
            <param name="___quickSearchWidget"></param>
            <param name="__instance"></param>
        </member>
        <member name="T:NQualityOfLife.UI_.MainButtonOrganizer.Action_Reset_MainButtons">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.MainButtonOrganizer.Action_Reset_MainButtons.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.HyperLinks.BetterLinkIcons">
            <summary>Makes research projects have an icon, rather than the blank icon</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Drops">
            <summary>______Drops______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Caused_By">
            <summary>______Caused By______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Sources">
            <summary>______Sources______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_MadeAt">
            <summary>______Made At______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Creates">
            <summary>______Creates______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Complications">
            <summary>______Complications______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Affects_Part">
            <summary>______Affects Part______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Health_Conditions">
            <summary>______Health Conditions______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Health_Capacity">
            <summary>______Affects Capacity______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Health_Cured_By">
            <summary>______Cured By______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Health_Cures_Hediff">
            <summary>______Cures Affliction______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Affected_By">
            <summary>______Affected By______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Contains">
            <summary>______Contains______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Used_By">
            <summary>______Used By______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Requires">
            <summary>______Requires______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Unlocked_With">
            <summary>______Unlocked With______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Unlocks">
            <summary>______Unlocks______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_REDACTED">
            <summary>REDACTED</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.CreateCapacityLinks(Verse.BodyPartDef)">
            <summary></summary>
            <param name="bodyPartDef"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.CreateCrossLink(Verse.Def,Verse.Def,System.Boolean)">
            <summary></summary>
            <param name="linkToThisDef"></param>
            <param name="fromThisDef"></param>
            <param name="allowDuplicates"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.UI_.CompProperties_ExtraGizmos">
            <summary>Xml properties for extra gizmos</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.CompProperties_ExtraGizmos.#ctor">
            <summary>The gizmo class these properties belong to</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.CompExtraGizmos">
            <summary>Extra gizmos class</summary>
        </member>
        <member name="P:NQualityOfLife.UI_.CompExtraGizmos.Props">
            <summary>Use the xml defined properties</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.CompExtraGizmos.CompGetGizmosExtra">
            <summary>IEnumerable containing all the extra gizmos</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.AllThingsAre(System.Collections.Generic.List{System.Object})">
            <summary></summary>
            <param name="list"></param>
            <returns>The <see cref="T:Verse.ThingDef"/> that all the objects in the <paramref name="list"/> are || or <see langword="null"/> if not all the objects are the same <see cref="T:Verse.ThingDef"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.IsSimilar(Verse.Thing,Verse.Thing,Verse.ThingDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="thing"></param>
            <param name="selection"></param>
            <param name="orDef"></param>
            <param name="allMinifiedThings"></param>
            <param name="mustBeSameStuff"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.DesignateMultiCell(System.Collections.Generic.IEnumerable{Verse.IntVec3})">
            <summary></summary>
            <param name="cells"></param><exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.SelectAllSimilarThingsOnCell(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.GetAllSimilarThingsOnCell(Verse.IntVec3,Verse.Map,System.Int32@)">
            <summary>Never null</summary>
            <param name="cell"></param><param name="map"></param><param name="count"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.GizmoJumpToJobTarget(Verse.Pawn)">
            <summary></summary>
            <param name="workerPawn"></param>
            <returns>a <see langword="new"/> <see cref="T:Verse.Command_Action"/> that shows information about the current job target of the <paramref name="workerPawn"/> || <see langword="null"/> if there is no job info available</returns>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.TradeWithBestNegotiator(Verse.Map)">
            <summary>Gizmo to select the best available trader on the map</summary>
            <param name="map"></param>
            <returns>The gizmo</returns>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.SurgeryWithBestSurgeon(Verse.Map)">
            <summary>Gizmo to select the best available surgeon on the map</summary>
            <param name="map"></param>
            <returns>The gizmo</returns>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.GizmoJumpToPawn(Verse.Pawn,System.String,System.String)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="description"></param>
            <param name="iconPath"></param>
            <returns>A <see langword="new"/> <see cref="T:Verse.Command_Action"/> that when clicked will select and jump to <paramref name="pawn"/></returns>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.NQoL_Minification_ErrorFix_Patch.Prefix(System.SByte)">
            <summary>Stops doors from ticking if un installed, this fixes some errors</summary>
            <param name="___mapIndexOrState"></param>
            <returns>False if should not tick</returns>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.MassPatcher.AddMass(Verse.ThingDef,System.Boolean)">
            <summary>Dynamically add a proper mass value to the def - Will error if the def already has a defined mass!</summary>
            <param name="thingDef">The def that needs a mass value</param>
            <param name="debug"></param>
            <returns>True if successful</returns>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.MassPatcher.Validate(Verse.ThingDef,System.Boolean)">
            <summary>Checks if the Def is valid</summary>
            <param name="thingDef"></param>
            <param name="skipMassValidation"></param>
            <returns>False if the def has config errors</returns>
        </member>
        <member name="T:NQualityOfLife.Plants.Plant_NoRest">
            <summary>Plant sub class for disabling rest period</summary>
        </member>
        <member name="P:NQualityOfLife.Plants.Plant_NoRest.Resting">
            <summary>Resting = always false</summary>
        </member>
        <member name="F:NQualityOfLife.Infestation.Settings.maxInsectLightLevel">
            <summary>float 0f - 1f</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Spot">
            <summary>The parent of all NQoL spots</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Trader_Spot">
            <summary>Spot that designates trader chillSpot</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Drop_Spot">
            <summary>Spot that designates drop pod delivery location</summary>
        </member>
        <member name="T:NQualityOfLife.TraitExtensions">
            <summary>Extra values for traits, used in various NQoL systems</summary>
        </member>
        <member name="F:NQualityOfLife.TraitExtensions.isBad">
            <summary>Is this a negative trait? affects calculations</summary>
        </member>
        <member name="F:NQualityOfLife.TraitExtensions.germResistanceOffset">
            <summary>float of germ resistance offset caused by the trait expects positive values between 0.25 and 0</summary>
        </member>
        <member name="M:NQualityOfLife.TraitExtensions.ConfigErrors">
            <summary>Validate and give errors for invalid config values in xml</summary>
        </member>
        <member name="T:NQualityOfLife.AutoAssign.NQoLAction_AutoAssign_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.NQoLAction_AutoAssign_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.AutoAssign.Settings">
            <summary>Local Settings</summary>
        </member>
        <member name="F:NQualityOfLife.AutoAssign.Settings.debugMode">
            <summary>local debug mode bool</summary>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.TimeTableSetter.GetMostPopularActivityForHourForMap(Verse.Map,System.SByte,System.Boolean,RimWorld.TraitDef)">
            <summary></summary>
            <param name="map"></param>
            <param name="hour"></param>
            <param name="forSlaves"></param>
            <param name="forPawnsWithTrait"></param>
            <returns>The most popular activity for the given <paramref name="hour"/> on the given <paramref name="map"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.TimeTableSetter.AutoSetTimeTable(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <returns><see langword="true"/> if the timetable was successfully set, else <see langword="false"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.TimeTableSetter.AutoSetNightOwlSleep(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="true"/> if <paramref name="pawn"/> timetable was changed, else <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.GetRelevantMapPawns(Verse.Map,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="map"></param>
            <param name="forSlaves"></param>
            <param name="forPrisoners"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.GetBestDrugPolicyForPawn(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.GetBestFoodPolicyForPawn(Verse.Pawn,System.Boolean,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="forPrisoners"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartOutfitSetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartDrugPolicySetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartReadingPolicySetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary>Set the pawn reading policy to the most popular reading policy on the map</summary>
            <param name="pawn"></param>
            <param name="forSlaves">un-used</param>
            <param name="map"></param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartFoodPolicySetter(Verse.Pawn,System.Boolean,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="forPrisoners"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.ThreatResponseSetter.SmartThreatResponseSetter(Verse.Pawn)">
            <summary>Set HostilityResponseMode to attack if capable of violence</summary>
            <param name="pawn">Set for this pawn</param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.MedicalCareSetter.SmartMedicalCareSetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary>Set the default medical care policy based on what other pawns are set to</summary>
            <param name="pawn"></param>
            <param name="forPrisoners"></param>
            <param name="map"></param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.WorkSetter.PawnIsAboveAverageAtWorkRelatedSkill(Verse.Pawn,Verse.WorkTypeDef,RimWorld.SkillDef,System.Boolean,Verse.Map)">
            <summary>Is the given Pawn above average in the work related skill?</summary>
            <param name="pawn">This pawn</param>
            <param name="work">The work</param>
            <param name="skill">The skill relevant to the work</param>
            <param name="gameStart"></param>
            <param name="map"></param>
            <returns>True if pawn has above average skill compared to other pawns assigned to the WorkType on the map</returns>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.WorkSetter.EnableWorkIfAboveAverageSkill(Verse.Pawn,Verse.WorkTypeDef,RimWorld.SkillDef,System.Boolean,Verse.Map)">
            <summary>Set the work type to active and set priority if pawn is above average in skill at the work type compared to the other pawns on the map.</summary>
            <param name="pawn"></param>
            <param name="work"></param>
            <param name="skill"></param>
            <param name="gameStart"></param>
            <param name="map"></param>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo">
            <summary>Place worker for preventing placing adjacent to something</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.preventPlacingNextToType">
            <summary>Prevent placing next to thing of this type</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.allowTouchingCorners">
            <summary>Are corners allowed to touch?</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.checkForBlueprintsAndFrames">
            <summary>Check for unfinished versions of the thing</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.errorMessageString">
            <summary>The message to display if placement is not allowed</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.warningOnly">
            <summary>Only do a warning message, instead of preventing placement - Used with other comps and stuff</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for preventing placing adjacent to something</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed">
            <summary>Place worker for preventing bed cramming</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed.#ctor">
            <summary>Place worker for preventing bed cramming</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed_Warning">
            <summary>Place worker for warning about bed cramming debuffs</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed_Warning.#ctor">
            <summary>Place worker for warning about bed cramming debuffs</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_Hang_From_Roof">
            <summary>Place worker for hanging things from roofs</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_Hang_From_Roof.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for hanging things from roofs</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall">
            <summary>Place worker for placing things on walls</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall.mustFaceEmptyTile">
            <summary>There has to be an empty tile in front</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for placing things on walls</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach">
            <summary>Place worker for placing things on walls, facing an empty tile</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach.#ctor">
            <summary>Place worker for placing things on walls, facing an empty tile</summary>
        </member>
        <member name="T:NQualityOfLife.HarmonyPatches">
            <summary>Apply harmony patches based on settings</summary>
        </member>
    </members>
</doc>
