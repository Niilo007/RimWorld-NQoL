<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NQualityOfLife</name>
    </assembly>
    <members>
        <member name="T:NQualityOfLife.Types.Grid`1">
            <summary>Represents a two dimensional grid containing '<typeparamref name="TE"/>'s</summary>
            <typeparam name="TE"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.Grid`1.#ctor(System.Int32,System.Int32)">
            <summary>Create a <see cref="T:NQualityOfLife.Types.Grid`1"/> with the size '<paramref name="sizeX"/>, <paramref name="sizeY"/>'</summary>
            <param name="sizeX"></param>
            <param name="sizeY"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sizeX"/> or <paramref name="sizeY"/> is &lt;= 0</exception>
        </member>
        <member name="P:NQualityOfLife.Types.Grid`1.Count">
            <summary>Get the total amount of '<typeparamref name="TE"/>'s stored in the grid</summary>
        </member>
        <member name="P:NQualityOfLife.Types.Grid`1.X">
            <summary>Get the 'X' dimension size of the <see cref="T:NQualityOfLife.Types.Grid`1"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.Grid`1.Y">
            <summary>Get the 'Y' dimension size of the <see cref="T:NQualityOfLife.Types.Grid`1"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.Grid`1.Size">
            <summary>Get the size of the <see cref="T:NQualityOfLife.Types.Grid`1"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.Grid`1.Item(System.Int32)">
            <summary>Get an item from the <see cref="T:NQualityOfLife.Types.Grid`1"/> using a one dimensional <paramref name="index"/></summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:NQualityOfLife.Types.Grid`1.Item(System.ValueTuple{System.Int32,System.Int32})">
            <inheritdoc cref="P:NQualityOfLife.Types.Grid`1.Item(System.Int32,System.Int32)"/>
        </member>
        <member name="P:NQualityOfLife.Types.Grid`1.Item(System.Int32,System.Int32)">
            <summary>Get or set the '<typeparamref name="TE"/>' at the given <paramref name="x"/>, <paramref name="y"/> coordinates of the <see cref="T:NQualityOfLife.Types.Grid`1"/></summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>The '<typeparamref name="TE"/>' at '<paramref name="x"/>, <paramref name="y"/>' or <see langword="default"/> value of '<typeparamref name="TE"/>' if the given coordinate is empty</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Grid`1.Clear">
            <summary>Clear (remove) all the '<typeparamref name="TE"/>'s from the <see cref="T:NQualityOfLife.Types.Grid`1"/></summary>
        </member>
        <member name="T:NQualityOfLife.Types.StaticCache`2">
            <summary>Used to build a static cache of values '<typeparamref name="V"/>' for a list of keys '<typeparamref name="K"/>' for fast lookup when the values are needed multiple times</summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="F:NQualityOfLife.Types.StaticCache`2._populator">
            <summary>The <see cref="T:System.Func`1"/> that creates/populates the cache</summary>
        </member>
        <member name="F:NQualityOfLife.Types.StaticCache`2._getSingle">
            <summary>The <see cref="T:System.Func`1"/> for getting the value of a single item</summary>
        </member>
        <member name="F:NQualityOfLife.Types.StaticCache`2._getSingleFromSource">
            <summary>The <see cref="T:System.Func`3"></see> for getting the value of a single item using a source list</summary>
        </member>
        <member name="F:NQualityOfLife.Types.StaticCache`2._source">
            <summary>A source <see cref="T:System.Collections.Generic.List`1"/> for populating the cache</summary>
        </member>
        <member name="F:NQualityOfLife.Types.StaticCache`2.locked">
            <summary>When <see langword="true"/>, the cache cannot be initialized or cleared</summary>
            <remarks>If the cache is locked, not initialized, and has a 'get single' <see cref="T:System.Func`1"/>; gets the value without populating the cache</remarks>
        </member>
        <member name="F:NQualityOfLife.Types.StaticCache`2.Initialized">
            <summary>Has the cache been populated?</summary>
        </member>
        <member name="F:NQualityOfLife.Types.StaticCache`2._cache">
            <summary>The actual cached data</summary>
        </member>
        <member name="M:NQualityOfLife.Types.StaticCache`2.#ctor(System.Func{System.Collections.Generic.Dictionary{`0,`1}},System.Func{`0,`1})">
            <summary></summary>
            <param name="populator">returns the fully built cache data dictionary</param>
            <param name="getSingle"></param>
        </member>
        <member name="P:NQualityOfLife.Types.StaticCache`2.Item(`0)">
            <summary>Get the cached value '<typeparamref name="V"/>' for the '<typeparamref name="K"/>'</summary>
            <param name="key"></param>
            <returns>The '<typeparamref name="V"/>' corresponding to the given '<typeparamref name="K"/>' from the cache</returns>
            <remarks>If the cache is <see cref="F:NQualityOfLife.Types.StaticCache`2.locked"/> and not <see cref="F:NQualityOfLife.Types.StaticCache`2.Initialized"/> and the 'get single' function exists; get the value '<typeparamref name="V"/>' using the function</remarks>
            <exception cref="T:System.InvalidOperationException">The cache is not <see cref="F:NQualityOfLife.Types.StaticCache`2.Initialized"/> or is locked and doesnt have a get single function</exception>
        </member>
        <member name="M:NQualityOfLife.Types.StaticCache`2.Initialize">
            <summary>Populate the cache using the provided populator functions</summary>
            <exception cref="T:System.InvalidOperationException">The cache is <see cref="F:NQualityOfLife.Types.StaticCache`2.locked"/> or already <see cref="F:NQualityOfLife.Types.StaticCache`2.Initialized"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.StaticCache`2.Clear">
            <summary>Clear the cached data when it is no longer needed</summary>
            <exception cref="T:System.InvalidOperationException">Tried to clear the cache while it is locked</exception>
        </member>
        <member name="T:NQualityOfLife.Types.IDictionaryInterface`2">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <remarks>Extends <see cref="T:System.Collections.Generic.IDictionary`2"/>
            <para>Implements <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IDictionaryInterface`2.Add(System.ValueTuple{`0,`1}@)">
            <summary>Add the given <paramref name="pair"/>.key and <paramref name="pair"/>.value as a new pair</summary>
            <param name="pair"></param>
            <inheritdoc cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)"/>
        </member>
        <member name="T:NQualityOfLife.Types.HashList`1">
            <summary><see cref="T:NQualityOfLife.Types.HashList`1"/> is a 'hash list' or 'dictionary list'. It is essentially a combination of a <see cref="T:System.Collections.Generic.List`1"/> and a <see cref="T:System.Collections.Generic.HashSet`1"/>.</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.HashList`1.ContainsAll(System.Collections.Generic.IList{`0})">
            <summary>Check of <see langword="this"/> <see cref="T:NQualityOfLife.Types.HashList`1"/> contains all the items of '<paramref name="ofTheseList"/>'</summary><param name="ofTheseList"></param>
            <returns><see langword="true"/> if this <see cref="T:NQualityOfLife.Types.HashList`1"/> contains all the items in the given <see cref="T:System.Collections.Generic.IList`1"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="ofTheseList"/> is <see langword="null"/></exception><remarks>Duplicates in the <paramref name="ofTheseList"/> will be ignored as <see cref="T:NQualityOfLife.Types.HashList`1"/> can only contain one of each item</remarks>
            <inheritdoc cref="M:NQualityOfLife.Types.OrderedList`1.ContainsAll(System.Collections.Generic.IList{`0})"/>
        </member>
        <member name="T:NQualityOfLife.Types.IFormattableCollection`1">
            <summary>Represents a <see cref="T:System.Collections.Generic.ICollection`1"/> that can be formatted into a specified <see cref="T:System.String"/> format</summary>
            <typeparam name="T"></typeparam>
            <remarks><para>Implements <see cref="T:NQualityOfLife.Utils.Common.IFormatMode"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IFormattableCollection`1.FormatAsString(NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags)">
            <summary>Format the <see cref="T:NQualityOfLife.Types.IFormattableCollection`1"/> as a <see cref="T:System.String"/> according to the given <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/> and <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/></summary>
            <param name="formatMode"></param>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IFormattableCollection`1.FormatAsString(NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{`0,System.String})">
            <summary>Format the <see cref="T:NQualityOfLife.Types.IFormattableCollection`1"/> as a <see cref="T:System.String"/> according to the given <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/> and <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/></summary>
            <param name="formatMode"></param>
            <param name="displayMode"></param>
            <param name="specialFormatter"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Types.INullableCollection">
            <summary>Represents a collection that may be <see langword="null"/> and/or empty
            <para>with a <see cref="M:NQualityOfLife.Types.INullableCollection.Any"/> method</para></summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.INullableCollection.Any">
            <summary>Check of <see langword="this"/> <see cref="T:NQualityOfLife.Types.INullableCollection"/> contains any items</summary>
            <returns><see langword="true"/> if the <see cref="T:NQualityOfLife.Types.INullableCollection"/> has any items</returns>
        </member>
        <member name="T:NQualityOfLife.Types.ISimpleList">
            <summary>Represents a simple list of values</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.INullableCollection"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.ISimpleList.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="T:NQualityOfLife.Types.ISimpleList`1">
            <summary>Represents a simple list of values '<typeparamref name="T"/>'</summary>
            <typeparam name="T"></typeparam>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.ISimpleList"/> &lt;- <see cref="T:NQualityOfLife.Types.INullableCollection"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.IListInterface`1">
            <summary>Interface for lists and other collections</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.IListInterface`1.Size">
            <summary>The size / <see cref="P:System.Collections.Generic.ICollection`1.Count"/> of the list</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Transform``1(System.Converter{`0,``0})">
            <summary>Transform the contents of the list to a new type '<typeparamref name="TNew"/>'</summary>
            <typeparam name="TNew">The new <see cref="T:System.Type"/> of the list contents || Can also be the same as <typeparamref name="T"/> if you want to only modify the items but not change their <see cref="T:System.Type"/></typeparam>
            <param name="func">The function to apply to all the items of the list</param>
            <returns>A <see langword="new"/> list of <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' with the contents transformed by the given <paramref name="func"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.SelectRandomSet(System.Int32)">
            <summary></summary>
            <param name="maxItemsToGet"></param>
            <remarks>If <paramref name="maxItemsToGet"/> is greater or equal to the item count of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/>; will return a copy of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/></remarks>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with randomly selected items from <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/></returns><exception cref="T:System.IndexOutOfRangeException"><paramref name="maxItemsToGet"/> is &lt;= 0</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.SetInternalData(System.Collections.Generic.ICollection{`0})">
            <summary>Set the internal <paramref name="data"/> of <see langword="this"/> list to the given values</summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">List is read only</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.CountAllWhere(System.Predicate{`0})">
            <summary>Count how many items on the list match the <paramref name="predicate" /></summary>
            <param name="predicate"></param><returns>The count of items that matched the <paramref name="predicate" /></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.CountTill(System.Int32,System.Predicate{`0})">
            <summary>Count all the matching items until the <paramref name="maxCount" /> or the end of the list</summary>
            <param name="maxCount"></param>
            <param name="predicate"></param><returns>The count of items that matched the <paramref name="predicate" /></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Remove(`0@,System.Int32,System.Boolean)">
            <summary>Remove the specified <paramref name="amount" /> of the <paramref name="item" /> '<typeparamref name="T"/>', or until there are none left.</summary>
            <param name="item">Remove occurrences of this item</param>
            <param name="amount">The max amount of items to remove.
            <para>Must be &gt;= 1</para></param>
            <param name="lastFoundFirst">Set to <see langword="true"/> to remove the <b>last</b> found <paramref name="item"/> first
            <para>Set to <see langword="false"/> to remove <b>first</b> found <paramref name="item"/> instead</para></param>
            <returns>The actual amount of items removed as an <see cref="T:System.Int32"/></returns>
            <exception cref="T:System.InvalidOperationException">List is read only</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="amount"/> is &lt;= 0</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.RemoveLast(`0@)">
            <summary>Remove the <b>last</b> found instance of the given <paramref name="item"/> '<typeparamref name="T"/>' from the list</summary>
            <param name="item">The item '<typeparamref name="T"/>' to remove</param>
            <exception cref="T:System.InvalidOperationException">List is read only</exception>
            <returns><see langword="true"/> if the <paramref name="item"/> '<typeparamref name="T"/>' was found and removed, else <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.RemoveFirstWhere(System.Predicate{`0})">
            <summary>Remove the <b>first</b> item '<typeparamref name="T"/>' that matches the given <see cref="T:System.Predicate`1"/></summary>
            <param name="where"></param>
            <returns><see langword="true"/> if an item was found and removed, else <see langword="false"/></returns>
            <exception cref="T:System.InvalidOperationException">List is read only</exception>
            <exception cref="T:System.ArgumentNullException">'<paramref name="where"/>' <see cref="T:System.Predicate`1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.RemoveAll(`0@)">
            <summary>Remove <b>all</b> the occurrences of the given <paramref name="item"/> '<typeparamref name="T"/>'</summary>
            <param name="item">The item '<typeparamref name="T"/>' to remove</param>
            <exception cref="T:System.InvalidOperationException">List is read only</exception>
            <returns>The amount of items removed as an <see cref="T:System.Int32"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.RemoveAllWhere(System.Predicate{`0})">
            <summary>Remove <b>all</b> items '<typeparamref name="T"/>' that match the given '<paramref name="where"/>' <see cref="T:System.Predicate`1"/></summary>
            <param name="where">Remove all items that match this <see cref="T:System.Predicate`1"/></param>
            <returns>The amount of items removed as an <see cref="T:System.Int32"/></returns>
            <exception cref="T:System.InvalidOperationException">>List is read only</exception>
            <exception cref="T:System.ArgumentNullException">'<paramref name="where"/>' <see cref="T:System.Predicate`1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ToArray">
            <summary>Create an array from the items of the list</summary>
            <returns>A <see langword="new"/> array of '<typeparamref name="T"/>' that contains <b>all</b> the elements of the <see cref="T:NQualityOfLife.Types.IListInterface`1"/></returns>
            <remarks>Should never <see langword="throw"/> or <see langword="return"/> <see langword="null"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ToArray(System.Int32,System.Int32)">
            <summary></summary>
            <param name="startingFrom">Add the items to the <see langword="new"/> array starting at this index inside the <see cref="T:NQualityOfLife.Types.IListInterface`1"/>
            <para>Must be &gt;= 0</para></param>
            <param name="count">How many items to add to the array
            <para>Must be &gt;= 1</para>
            <para>This will be the size of the returned array</para></param>
            <returns>A <see langword="new"/> array of '<typeparamref name="T"/>' with the items from <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/>, starting at <paramref name="startingFrom">the given index</paramref> inside the <see cref="T:NQualityOfLife.Types.IListInterface`1"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startingFrom"/> is &lt; 0 or past the end of the <see cref="T:NQualityOfLife.Types.IListInterface`1"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is &lt;= 0 or past the end of the <see cref="T:NQualityOfLife.Types.IListInterface`1"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ToList">
            <summary>Make a <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</seealso> of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> as a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></summary>
            <returns>A <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</seealso> of the original <see cref="T:NQualityOfLife.Types.IListInterface`1">list</see> as a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the same items in the same order. Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Last">
            <summary>Get the <b>last</b> item '<typeparamref name="T"/>' of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/></summary><returns></returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:NQualityOfLife.Types.IListInterface`1"/> is empty</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.First">
            <summary>Get the <b>first</b> item '<typeparamref name="T"/>' of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/></summary><returns></returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:NQualityOfLife.Types.IListInterface`1"/> is empty</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.FirstIndexOf(`0@)">
            <summary>Get the index of the <b>first</b> occurrence of the given <paramref name="item"/> '<typeparamref name="T"/>'</summary><param name="item"></param>
            <returns>the zero based index of the <b>first</b> occurrence of the <paramref name="item"/>, or -1 if the item was not found in the list</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.LastIndexOf(`0@)">
            <summary>Get the index of the <b>last</b> occurrence of the given <paramref name="item"/> '<typeparamref name="T"/>'</summary><param name="item"></param>
            <returns>the zero based index of the <b>last</b> occurrence of the <paramref name="item"/>, or -1 if the item was not found in the list</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.FirstIndexOf(System.Predicate{`0})">
            <summary>Get the index of the <b>first</b> found match in the list, or -1 if there were no matches</summary>
            <param name="predicate"></param>
            <returns>The index of the <b>first</b> found thing that matches the <paramref name="predicate"/>, or -1 if none</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.LastIndexOf(System.Predicate{`0})">
            <summary>Get the index of the <b>last</b> found match in the list, or -1 if there were no matches</summary>
            <param name="predicate"></param>
            <returns>The index of the <b>last</b> found thing that matches the <paramref name="predicate"/>, or -1 if none</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.FirstOrFallBack(System.Predicate{`0},`0@)">
            <summary>Return the <b>first</b> item '<typeparamref name="T"/>' that matches the given <paramref name="predicate"/>, or <paramref name="fallback"/> if none found</summary>
            <param name="predicate"></param>
            <param name="fallback"></param>
            <returns>The <b>first</b> item '<typeparamref name="T"/>' that matched the <paramref name="predicate"/>, or <paramref name="fallback"/> if none did</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.LastOrFallBack(System.Predicate{`0},`0@)">
            <summary>Return the <b>last</b> item '<typeparamref name="T"/>' that matches the given <paramref name="predicate"/>, or <paramref name="fallback"/> if none found</summary>
            <param name="predicate">Used to select the matching item '<typeparamref name="T"/>'</param>
            <param name="fallback">Returned if no item matched the <paramref name="predicate"/></param>
            <returns>The <b>last</b> item '<typeparamref name="T"/>' that matched the <paramref name="predicate"/>, or <paramref name="fallback"/> if none did</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Find(System.Predicate{`0},System.Func{`0,`0,`0})">
            <summary>Filter the items of the list using the <see cref="T:System.Predicate`1"/> and then find the best matching item using the <see cref="T:System.Func`3"/></summary>
            <param name="where">Filter the possible items using this <see cref="T:System.Predicate`1"/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="where"/> or <paramref name="betterMatch"/> is <see langword="null"/></exception>
            <param name="betterMatch">In the <see cref="T:System.Func`3"/><para><typeparamref name="T"/>1 is the best item found so far</para><para><typeparamref name="T"/>2 is the next item in the list that we are comparing against the best found item.</para><para><typeparamref name="T"/>Result is the item that is a better match from the given two</para></param>
            <returns>The item '<typeparamref name="T"/>' that matched the <see cref="T:System.Predicate`1"/> and was the best match according to the given <see cref="T:System.Func`3"/>
            <para>Or <see langword="default"/> value of '<typeparamref name="T"/>' if the list has no items, none of the items passed the <see cref="T:System.Predicate`1"/> or <see langword="default"/> '<typeparamref name="T"/>' was the best matching item</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Find(System.Func{`0,`0,`0})">
            <summary>Find the best matching item from the list</summary>
            <exception cref="T:System.ArgumentNullException">'<paramref name="betterMatch"/>' <see cref="T:System.Func`3"/> is <see langword="null"/></exception>
            <param name="betterMatch">In the <see cref="T:System.Func`3"/><para><typeparamref name="T"/>1 is the best item found so far</para><para><typeparamref name="T"/>2 is the next item in the list that we are comparing against the best found item.</para><para><typeparamref name="T"/>Result is the item that is a better match from the given two</para></param>
            <returns>The item '<typeparamref name="T"/>' that was the best match according to the given <see cref="T:System.Func`3"/>
            <para>Or <see langword="default"/> '<typeparamref name="T"/>' if there were no items in the list or <see langword="default"/> '<typeparamref name="T"/>' was the best matching item</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Add(`0)">
            <summary>Add the given <paramref name="item"/> to the <b>end</b> of the list</summary>
            <param name="item"></param>
            <exception cref="T:System.InvalidOperationException">The list is read only</exception>
            <returns><see langword="true"/> if the <paramref name="item"/> '<typeparamref name="T"/>' was successfully added</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.AddSafe(`0@)">
            <summary>Add the value only if it doesn't already exist in the <see cref="T:NQualityOfLife.Types.IListInterface`1"/></summary>
            <param name="value">The item to add</param>
            <returns><see langword="true"/> if the item was added. || <see langword="false"/> if the item was not added</returns>
            <exception cref="T:System.InvalidOperationException">List is read only</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.AddRange(System.Collections.Generic.IList{`0})">
            <summary>Add the given <paramref name="range"/> to the end of the list</summary>
            <param name="range"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="range"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">List is read only</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterface`1.AddRange(System.Collections.Generic.IList{`0})"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Insert(System.Int32,`0)">
            <summary>Insert the <paramref name="item"/> '<typeparamref name="T"/>' at the given <paramref name="index"/></summary>
            <param name="index">Must be &gt;= 0 and &lt;= <see cref="P:NQualityOfLife.Types.IListInterface`1.Size">Size</see></param>
            <param name="item"></param>
            <remarks>Inserting at <paramref name="index"/> == <see cref="P:NQualityOfLife.Types.IListInterface`1.Size">Size</see> will be equal to <see cref="M:NQualityOfLife.Types.IListInterface`1.Add(`0)"/>
            <para>The <paramref name="item"/> is inserted before the existing item of the given <paramref name="index"/> if any</para>
            <para><see cref="M:NQualityOfLife.Types.IListInterface`1.LastIndexOf(`0@)"/> of <paramref name="item"/> will give <paramref name="index"/> after the insert</para></remarks>
            <exception cref="T:System.InvalidOperationException">List is read only</exception>
            <inheritdoc cref="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAll(`0[])">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterface`1.ContainsAll(System.Collections.Generic.IList{`0})"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAll(System.Collections.Generic.IList{`0})">
            <summary>Check of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains <b>all</b> the items of '<paramref name="ofTheseList"/>'</summary><param name="ofTheseList"></param>
            <returns><see langword="true"/> if this <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains <b>all</b> the items in the given <see cref="T:System.Collections.Generic.IList`1"/> (<paramref name="ofTheseList"/>) || Will always return <see langword="false"/> if the <paramref name="ofTheseList"/> has more items than <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="ofTheseList"/> is <see langword="null"/></exception><remarks>Note that if the <paramref name="ofTheseList"/> has more items than <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> this method will always return <see langword="false"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAny(`0[])">
            <summary>Check if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains <b>any</b> of the given items</summary>
            <param name="ofThese"></param><exception cref="T:System.ArgumentNullException"><paramref name="ofThese"/> is <see langword="null"/></exception>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains <b>any</b> of the given items</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAny(System.Collections.Generic.IList{`0},`0@)">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterface`1.ContainsAny(`0[])"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.ContainsAnyWhere(System.Predicate{`0})">
            <summary>Check if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains <b>any</b> item that matches the <paramref name="predicate"/></summary>
            <param name="predicate"></param><exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IListInterface`1"/> contains <b>any</b> items that matches the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Copy">
            <summary>Make a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</see> of the list</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.Copy(System.Int32,System.Int32)">
            <summary>Makes a copy of the list starting at the given index</summary>
            <param name="startingFrom">Start copying the list from this index</param>
            <param name="count">How many items to get at the maximum</param>
            <returns>A copy of the original list starting at the given index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startingFrom"/> or <paramref name="count"/> is invalid</exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterface`1.CopyWhere(System.Predicate{`0})">
            <summary>Make a <see langword="new"/> list from the given collection where the items satisfy the <paramref name="where"/> <see cref="T:System.Predicate`1"/></summary>
            <param name="where"></param>
            <returns>The matching input elements to a <see langword="new"/> list</returns>
            <exception cref="T:System.ArgumentNullException">'<paramref name="where"/>' is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Types.IListInterfaceData`2">
            <summary>Extension to the base IListInterface, Specifies the type of the internal data list</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TInternalDataList">The type of the internal list that stores the data</typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.IListInterfaceData`2.InternalData">
            <summary>The data stored inside the IListInterface</summary>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceData`2.ToList``1(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterfaceType`2.ToList``1(System.Int32,System.Int32)"/>
        </member>
        <member name="T:NQualityOfLife.Types.IListInterfaceType`2">
            <summary>Extension to the base IListInterface, Specifies the type of the list</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TListType">The type of the list that implements this interface</typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.Copy">
            <summary>Make a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</see> of the list</summary>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.Copy(System.Int32,System.Int32)">
            <summary>Makes a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</see> of the list starting at the given index</summary>
            <param name="startingFrom">Start copying the list from this index</param>
            <param name="count">How many items to get at the maximum</param>
            <returns>A <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</see> of the original list starting at the given index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.CopyWhere(System.Predicate{`0})">
            <summary>Make a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</see> of this list from the given collection <paramref name="where"/> the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <param name="where"></param>
            <returns>The matching input elements to a <see langword="new"/> list</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="where"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(`0[],System.Int32)">
            <summary>Copy <b>all</b> the elements of <see langword="this"/> list into the <paramref name="array"/> starting at the given <paramref name="arrayIndex"/></summary>
            <param name="array">The array where the values are copied to
            <para><see cref="T:NQualityOfLife.Attributes.MutatedAttribute">Mutated</see></para></param>
            <param name="arrayIndex">The index in the <paramref name="array"/> where the first item of <see langword="this"/> list is copied to
            <para>Must be &gt;= 0</para></param>
            <remarks><see cref="T:NQualityOfLife.Attributes.MutatesAttribute">Mutates</see> <paramref name="array"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/></exception>
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(`0[],System.Int32,System.Int32)">
            <param name="array">The array where the values are copied to
            <para><see cref="T:NQualityOfLife.Attributes.MutatedAttribute">Mutated</see></para></param>
            <param name="arrayIndex">The index in the <paramref name="array"/> where the first item of <see langword="this"/> list is copied to
            <para>Must be &gt;= 0</para></param>
            <param name="count">How many items to copy into the <paramref name="array"/>
            <para>Must be &gt;= 1</para></param>
            <summary>Copy the <b>given amount</b> of elements of <see langword="this"/> list into the <paramref name="array"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <param name="array">The array where the values are copied to
            <para><see cref="T:NQualityOfLife.Attributes.MutatedAttribute">Mutated</see></para></param>
            <param name="arrayIndex">The index in the <paramref name="array"/> where the first copied item of <see langword="this"/> list is copied to
            <para>Must be &gt;= 0</para></param>
            <param name="count">How many items to copy into the <paramref name="array"/>
            <para>Must be &gt;= 1</para></param>
            <param name="startingFrom">Start copying items from the source list at this index
            <para>Must be &gt;= 0</para></param>
            <summary>Copy the <b>given amount</b> of elements of <see langword="this"/> list <b>after the given index</b> into the <paramref name="array"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(`0[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(System.Int32,`0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(System.Int32,`0[],System.Int32)">
            <summary>Copy <b>all</b> the elements <b>after the given index</b> of <see langword="this"/> list into the <paramref name="array"/></summary>
            <param name="arrayIndex">The index in the <paramref name="array"/> where the first copied item of <see langword="this"/> list is copied to
            <para>Must be &gt;= 0</para></param>
            <param name="array">The array where the values are copied to
            <para><see cref="T:NQualityOfLife.Attributes.MutatedAttribute">Mutated</see></para></param>
            <param name="startingFrom">Start copying items from the source list at this index
            <para>Must be &gt;= 0</para></param>
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.ToList``1">
            <summary>Make a <see langword="new"/> list from the contents of this list in a different list type</summary>
            <typeparam name="TList"></typeparam>
            <returns>The newly created list</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.ToList``1(System.Int32,System.Int32)">
            <summary></summary>
            <typeparam name="TList"></typeparam>
            <param name="startingFrom"></param>
            <param name="count"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.IListInterfaceType`2.SelectRandomSet(System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterface`1.SelectRandomSet(System.Int32)"/>
        </member>
        <member name="T:NQualityOfLife.Types.IListInterface`3">
            <summary></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> contained by the <see cref="T:NQualityOfLife.Types.IListInterface`3">list</see></typeparam>
            <typeparam name="TListType"></typeparam>
            <typeparam name="TInternalDataList"></typeparam>
        </member>
        <member name="T:NQualityOfLife.Types.IReadOnlyListInterface`1">
            <summary>Extends <see cref="T:System.Collections.Generic.IReadOnlyList`1"/></summary>
            <typeparam name="T"></typeparam>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IInterface"/>
            <para>Extends <see cref="T:System.Collections.Generic.IReadOnlyList`1"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.IReadOnlyListInterface`1.SetReadOnly">
            <summary>Sets the list to read only and returns itself as a <see cref="T:NQualityOfLife.Types.IReadOnlyListInterface`1"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.IReadOnlyListInterface`1.AsReadOnly">
            <summary>Get a reference to the list as a <see cref="T:NQualityOfLife.Types.IReadOnlyListInterface`1"/> || should not mutate the list</summary>
        </member>
        <member name="P:NQualityOfLife.Types.IReadOnlyListInterface`1.IsReadOnly">
            <summary>Is <see langword="this"/> list currently read only?</summary>
        </member>
        <member name="T:NQualityOfLife.Types.OrderedList`1">
            <summary><see cref="T:NQualityOfLife.Types.OrderedList`1"/> is a <see cref="T:System.Collections.Generic.List`1"/> that implements <see cref="T:NQualityOfLife.Types.IListInterface`3"/> and explicitly preserves item order</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.#ctor(System.String)">
            <summary>Create a <see langword="new"/> empty <see cref="T:NQualityOfLife.Types.OrderedList`1"/></summary>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.#ctor(System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Types.OrderedList`1.#ctor(System.String)"/>
            <param name="readOnly">Specify if the list is read only</param>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.#ctor(System.Int32,System.Boolean)">
            <summary>Create a <see langword="new"/> empty <see cref="T:NQualityOfLife.Types.OrderedList`1"/> with an <paramref name="initialCapacity"/></summary>
            <param name="initialCapacity">The initial capacity of the list - (not the max size)</param>
            <param name="readOnly">Specify if the list is read only</param>
        </member>
        <member name="P:NQualityOfLife.Types.OrderedList`1.Item(System.Int32)">
            <summary></summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.Clear">
            <summary>Clear all the data</summary>
            <exception cref="T:System.InvalidOperationException">The list is read only</exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.Add(`0)">
            <summary>Add the given <paramref name="item"/> to the <b>end</b> of the <see cref="T:NQualityOfLife.Types.OrderedList`1"/> list</summary>
            <param name="item"></param>
            <exception cref="T:System.InvalidOperationException">The list is read only</exception>
            <returns><see langword="true"/> if the <paramref name="item"/> '<typeparamref name="T"/>' was successfully added</returns>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.Remove(`0)">
            <summary>Remove the first found instance of the given <paramref name="item"/></summary>
            <param name="item"></param>
            <returns><see langword="true"/> if the <paramref name="item"/> was successfully removed.</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.RemoveAt(System.Int32)">
            <summary>Remove the item at the given <paramref name="index"/> from the list</summary>
            <param name="index">Remove the item at this <paramref name="index"/> || Must be above -1 and below the size of the list</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.IndexOf(`0)">
            <summary>Get the index of the <b>first</b> occurrence of the given <paramref name="item"/> '<typeparamref name="T"/>'</summary><param name="item"></param>
            <returns>the zero based index of the <b>first</b> occurrence of the <paramref name="item"/>, or -1 if the item was not found in the list</returns>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.CopyTo(System.Array,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Types.IListInterfaceType`2.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.OrderedList`1.Transform``1(System.Converter{`0,``0})">
            <summary></summary>
            <typeparam name="TN"></typeparam>
            <param name="func"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.OrderedList`1"/> from the <paramref name="func"/> results</returns>
        </member>
        <member name="T:NQualityOfLife.Types.ITreeNode`3">
            <summary></summary>
            <typeparam name="TNode">The type of the node that implements <see langword="this"/> interface</typeparam>
            <typeparam name="TData">The type of the data that <see langword="this"/> node contains</typeparam>
            <typeparam name="TTree">The type of the tree that contains <see langword="this"/> node</typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Parent">
            <summary>The parent of <see langword="this"/> <typeparamref name="TNode"/> - If <see langword="null"/>, the node is the root of the <typeparamref name="TTree"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Tree">
            <summary>Get the <typeparamref name="TTree"/> that contains <see langword="this"/> <typeparamref name="TNode"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Children">
            <summary>Get the direct child nodes of <see langword="this"/> <typeparamref name="TNode"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Depth">
            <summary>The depth of the node in the tree, where 0 is the root node</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Data">
            <summary>Get or set the data '<typeparamref name="TData"/>' that <see langword="this"/> <typeparamref name="TNode"/> contains</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Root">
            <summary>The root node of the tree, The root node does not have a parent || Calling <see langword="this"/> on the root node will return <see langword="null"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.SubRoot">
            <summary>The root node of <see langword="this"/> sub tree || or Root if <see langword="this"/> is not a sub tree || Calling <see langword="this"/> on the root node will return <see langword="null"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITreeNode`3.Path">
            <summary>The string representation of the branch ending with <see langword="this"/> node</summary>
        </member>
        <member name="M:NQualityOfLife.Types.ITreeNode`3.DataFormatted``1(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Types.ITreeNode`3.Add(`1@)">
            <summary>Add a <see langword="new"/> child node to <see langword="this"/> node with the given data</summary>
            <param name="newDataNode"></param>
            <returns>The newly added <typeparamref name="TNode"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.ITreeNode`3.Add(`0)">
            <summary>Add the given node to the child nodes of this node</summary>
            <param name="item"></param>
        </member>
        <member name="M:NQualityOfLife.Types.ITreeNode`3.DataFormatted(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary></summary>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Types.ITree`3">
            <summary></summary>
            <typeparam name="TNode">The type of the node that <see langword="this"/> tree is made from</typeparam>
            <typeparam name="TTree">The type of the tree that implements <see langword="this"/> interface</typeparam>
            <typeparam name="TData">The type of the data that <see langword="this"/> tree can contain</typeparam>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.Root">
            <summary>The root node of the tree, The root node does not have a parent</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.LocalRoot">
            <summary>The node where <see langword="this"/> tree starts inside a parent tree || or Root if <see langword="this"/> tree is not a sub tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.Count">
            <summary>The total nodes in the tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.Depth">
            <summary>The max depth of the tree, where 0 is only the root node</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.AllNodes">
            <summary>Get all the nodes that are a part of the tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.ParentTree">
            <summary>The parent tree of a sub tree || or <see langword="null"/> if this is not a sub tree</summary>
        </member>
        <member name="P:NQualityOfLife.Types.ITree`3.IsSubTree">
            <summary>Is this tree a sub tree / branch of another tree?</summary>
        </member>
        <member name="M:NQualityOfLife.Types.ITree`3.IsSubTreeOf(`2@)">
            <summary>Is this tree a sub tree / branch of the given tree?</summary>
            <param name="tree"></param><returns></returns>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.rootNode">
            <summary>The <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> that is the root of this <see cref="T:NQualityOfLife.Types.Tree`1"/></summary>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.#ctor">
            <summary>Create a tree with an empty root node</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.#ctor(NQualityOfLife.Types.Tree{`0}.Node)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Tree`1"/> that starts at the given '<paramref name="root"/>' <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></summary>
            <param name="root"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.#ctor(`0)">
            <inheritdoc cref="M:NQualityOfLife.Types.Tree`1.#ctor(NQualityOfLife.Types.Tree{`0}.Node)"/>
            <param name="rootData">Create the <see cref="T:NQualityOfLife.Types.Tree`1"/> with a <see langword="new"/> root <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> that contains this data '<typeparamref name="TD"/>'</param>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.Node.containedData_">
            <summary>The data that is linked / represented by this node</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.Node.parent_">
            <summary>The direct parent <seealso cref="T:NQualityOfLife.Types.Tree`1.Node">node</seealso> of <see langword="this"/> <seealso cref="T:NQualityOfLife.Types.Tree`1.Node">node</seealso>, or <see langword="null"/> if <see langword="this"/> <seealso cref="T:NQualityOfLife.Types.Tree`1.Node">node</seealso> is the root of a <seealso cref="T:NQualityOfLife.Types.Tree`1">tree</seealso></summary>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.Node.tree_">
            <summary>The <see cref="T:NQualityOfLife.Types.Tree`1"/> that <see langword="this"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> is a part of</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Tree`1.Node.children_">
            <summary>The direct child nodes of this <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></summary>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.Node.#ctor(NQualityOfLife.Types.Tree{`0})">
            <summary>Create an empty root node for the <paramref name="tree"/></summary>
            <param name="tree"></param>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.Node.#ctor(NQualityOfLife.Types.Tree{`0}.Node)">
            <summary>Create a <see langword="new"/> empty <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> as a child of the '<paramref name="parent"/>' <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></summary>
            <param name="parent"></param>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.Node.#ctor(`0@)">
            <summary>Create a <see langword="new"/> parentless <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> that contains the given <paramref name="data"/></summary>
            <remarks>When creating a <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> using this constructor, the <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> must be manually added to a parent <see cref="T:NQualityOfLife.Types.Tree`1"/> / <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></remarks>
            <param name="data">The data '<typeparamref name="TD"/>' contained in <see langword="this"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></param>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.Node.#ctor(NQualityOfLife.Types.Tree{`0}.Node,`0@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> as a child of the '<paramref name="parent"/>' <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></summary>
            <param name="parent">The parent <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> of <see langword="this"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></param>
            <param name="data">The data '<typeparamref name="TD"/>' contained in <see langword="this"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></param>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.Node.#ctor(NQualityOfLife.Types.Tree{`0}.Node,`0,System.Collections.Generic.IList{NQualityOfLife.Types.Tree{`0}.Node})">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> as a child of the '<paramref name="parent"/>' <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></summary>
            <param name="parent">The parent <see cref="T:NQualityOfLife.Types.Tree`1.Node"/> of <see langword="this"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></param>
            <param name="data">The data '<typeparamref name="TD"/>' contained in <see langword="this"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></param>
            <param name="childNodes">The children of <see langword="this"/> <see cref="T:NQualityOfLife.Types.Tree`1.Node"/></param>
        </member>
        <member name="M:NQualityOfLife.Types.Tree`1.Node.#ctor(NQualityOfLife.Types.Tree{`0}.Node,`0,NQualityOfLife.Types.IReadOnlyListInterface{NQualityOfLife.Types.Tree{`0}.Node})">
            <inheritdoc cref="M:NQualityOfLife.Types.Tree`1.Node.#ctor(NQualityOfLife.Types.Tree{`0}.Node,`0,System.Collections.Generic.IList{NQualityOfLife.Types.Tree{`0}.Node})"/>
        </member>
        <member name="P:NQualityOfLife.Types.Tree`1.Node.Item(System.Int32)">
            <summary>Get a direct child of this node by index</summary>
            <param name="index"></param><returns>One of the direct child nodes</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:NQualityOfLife.Types.Tree`1.Node.Count">
            <summary>Get how many direct child nodes this node has</summary>
        </member>
        <member name="T:NQualityOfLife.Types.Direction">
            <summary><see cref="T:NQualityOfLife.Types.Direction"/> is a vector with a <see cref="P:NQualityOfLife.Types.Direction.Magnitude"/> of 1f</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Direction.#ctor(System.Single,System.Single,System.Single,System.Boolean,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="normalized">Are the <paramref name="x"/> and <paramref name="y"/> values already normalized?</param>
            <param name="allowZeroVector">Allow a zero <see cref="T:NQualityOfLife.Types.Direction"/> vector to be created?</param>
            <param name="skipValidate"></param>
            <exception cref="T:System.ArgumentException"></exception>
            <inheritdoc cref="T:NQualityOfLife.Types.Direction"/>
        </member>
        <member name="M:NQualityOfLife.Types.Direction.#ctor(System.Single,System.Single,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Types.Direction.#ctor(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Direction.#ctor(System.Single,System.Single)">
            <summary>Create a <see langword="new"/> 2D <see cref="T:NQualityOfLife.Types.Direction"/> vector
            <para>The given <paramref name="x"/> and <paramref name="y"/> will be normalized to create the <see cref="T:NQualityOfLife.Types.Direction"/> vector</para></summary>
            <param name="x"></param>
            <param name="y"></param>
            <inheritdoc cref="M:NQualityOfLife.Types.Direction.#ctor(System.Single,System.Single,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Direction.#ctor(System.Single,System.Single,System.Single)">
            <summary>Create a <see langword="new"/> 3D <see cref="T:NQualityOfLife.Types.Direction"/> vector
            <para>The given <paramref name="x"/>, <paramref name="y"/> and <paramref name="z"/> will be normalized to create the <see cref="T:NQualityOfLife.Types.Direction"/> vector</para></summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <inheritdoc cref="M:NQualityOfLife.Types.Direction.#ctor(System.Single,System.Single,System.Single,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:NQualityOfLife.Types.Direction.AsAngle">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Atan(System.Single,System.Single)"/>
            <summary></summary>
        </member>
        <member name="M:NQualityOfLife.Types.Direction.op_Multiply(NQualityOfLife.Types.Direction@,NQualityOfLife.Units.Newton@)">
            <summary>Multiply a <see cref="T:NQualityOfLife.Types.Direction"/> with a <seealso cref="T:NQualityOfLife.Units.Newton">scalar force</seealso> to get a <see cref="T:NQualityOfLife.Units.Force"/> vector</summary>
            <param name="direction">The <see cref="T:NQualityOfLife.Types.Direction"/> vector of the <see cref="T:NQualityOfLife.Units.Force"/></param>
            <param name="scalarForce">The scalar value of the <see cref="T:NQualityOfLife.Units.Force"/> vector</param>
            <returns>A <see cref="T:NQualityOfLife.Units.Force"/> vector with a magnitude of <paramref name="scalarForce"/> and a <see cref="T:NQualityOfLife.Types.Direction"/> of <paramref name="direction"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Direction.op_Multiply(NQualityOfLife.Units.Newton@,NQualityOfLife.Types.Direction@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Direction.op_Multiply(NQualityOfLife.Types.Direction@,NQualityOfLife.Units.Newton@)"/>
        </member>
        <member name="T:NQualityOfLife.Types.Factor">
            <summary>A positive <see cref="T:System.Single"/> value</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Factor.MinValue">
            <summary>The smallest valid value for a <see cref="T:NQualityOfLife.Types.Factor"/></summary>
        </member>
        <member name="F:NQualityOfLife.Types.Factor.MaxValue">
            <summary>The largest valid value for a <see cref="T:NQualityOfLife.Types.Factor"/></summary>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.#ctor(System.Single)">
            <summary>The input float must be positive or the constructor will <see langword="throw"/> a <see cref="T:System.ArgumentOutOfRangeException"/></summary>
            <param name="factor"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:NQualityOfLife.Types.Factor.Value">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="P:NQualityOfLife.Types.IFloat.Value"/>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.NQualityOfLife#Types#IMath{NQualityOfLife#Types#Factor}#Abs">
            <summary></summary>
            <returns>this <see cref="T:NQualityOfLife.Types.Factor"/> un-changed</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <remarks>Trying to get the Abs() with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Implicit(System.Single)~NQualityOfLife.Types.Factor">
            <inheritdoc cref="M:NQualityOfLife.Types.Factor.#ctor(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor@,System.UInt32)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="rightInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(System.UInt32,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="leftInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor@,System.UInt16)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="rightInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(System.UInt16,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="leftInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor@,System.Int32)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="rightInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(System.Int32,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="leftInteger"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Ratio@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="ratio"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="ratio"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(System.Single,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="number"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Multiply(NQualityOfLife.Types.Factor@,System.Single)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="factor"></param><param name="number"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Division(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Division(System.Single,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Division(NQualityOfLife.Types.Factor@,System.Single)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(NQualityOfLife.Types.Factor@,System.Single)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="number"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(System.Single,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="number"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(NQualityOfLife.Types.Factor@,System.UInt32)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(System.UInt32,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(NQualityOfLife.Types.Factor@,System.UInt16)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Addition(System.UInt16,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Subtraction(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="right"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Subtraction(NQualityOfLife.Types.Factor@,System.Single)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="left"></param><param name="number"></param><returns></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.op_Subtraction(System.Single,NQualityOfLife.Types.Factor@)">
            <summary>Trying to do math with an <see cref="F:NQualityOfLife.Types.Factor.Invalid"/> <see cref="T:NQualityOfLife.Types.Factor"/> will <see langword="throw"/> a <see cref="T:System.InvalidOperationException"/></summary>
            <param name="number"></param><param name="right"></param><returns>A <see cref="T:System.Single"/> from the operation <paramref name="number"/> - <paramref name="right"/></returns><exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.LargerOf(NQualityOfLife.Types.Factor@)">
            <summary>Returns the larger value</summary><param name="otherValue"></param><returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Factor.TryParse(System.String,NQualityOfLife.Types.Factor@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)"></inheritdoc>
        </member>
        <member name="T:NQualityOfLife.Types.Nibble">
            <summary>The <see cref="T:NQualityOfLife.Types.Nibble"/> represents a half <see cref="T:System.Byte"/>, or 1 <see cref="T:NQualityOfLife.Types.HexByte"/> letter, such as 'F'
            <para>In binary, it is 4 bits: '0000', '0001', '0010', '1111' etc. this means that the <see cref="T:NQualityOfLife.Types.Nibble"/> has 16 (4^2) possible states. These states are usually represented with a <seealso href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</seealso> letter/number</para></summary>
        </member>
        <member name="F:NQualityOfLife.Types.Nibble.MinValue">
            <summary>The smallest value that a <see cref="T:NQualityOfLife.Types.Nibble"/> can represent - 0 - 0x00</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Nibble.MaxValue">
            <summary>The maximum value that a <see cref="T:NQualityOfLife.Types.Nibble"/> can represent - 15 - 0x0F</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Nibble.LengthBits">
            <summary>The number of bits in the <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <inheritdoc cref="F:NQualityOfLife.Core.Constants.Primitives.BitsInNibble"/>
        </member>
        <member name="F:NQualityOfLife.Types.Nibble._val">
            <summary>The value of <see langword="this"/> <see cref="T:NQualityOfLife.Types.Nibble"/> stored as a <see cref="T:System.Byte"/></summary>
            <remarks>Has to be &gt;= 0 and &lt;= 15 or something has gone terribly wrong</remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Create a <see cref="T:NQualityOfLife.Types.Nibble"/> by setting the internal bits using the <see cref="T:System.Boolean"/> parameters</summary>
            <param name="b0">The leftmost / most significant bit ('B___')</param>
            <param name="b1">The second from the left bit ('_B__')</param>
            <param name="b2">The third from the left bit ('__B_')</param>
            <param name="b3">The rightmost / least significant bit ('___B')</param>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.#ctor(System.Int32)">
            <summary></summary>
            <param name="numericValue">Has to be &gt;= 0 and &lt;= 15 or a <see cref="T:System.ArgumentOutOfRangeException"/> will be thrown</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="numericValue"/> is &lt; 0 or &gt; 15</exception>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.#ctor(System.Char)">
            <summary>Create a <see cref="T:NQualityOfLife.Types.Nibble"/> from the value represented by the given <seealso href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</seealso> <see cref="T:System.Char"/></summary>
            <param name="hexChar">The <seealso href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</seealso> letter or number 0~15 and A~F<para>Upper and lower case letters are both accepted</para><para><see cref="T:System.ArgumentOutOfRangeException"/> may be thrown on an invalid input</para></param>
            <remarks>Upper and lower case letters are both accepted as the <paramref name="hexChar"/></remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="hexChar"/> is not one of the valid <seealso href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</seealso> <see cref="T:System.Char"/>s</exception>
        </member>
        <member name="P:NQualityOfLife.Types.Nibble.Item(System.Int32)">
            <summary>Get the value of the bit at the given <paramref name="index"/></summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:NQualityOfLife.Types.Nibble.Length">
            <summary>The number of bits in the <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.Nibble.HexChar">
            <summary>Returns the corresponding hex symbol for the given <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <returns>'((<see cref="T:NQualityOfLife.Types.Nibble"/>)0) -> ((<see cref="T:System.Char"/>)'0')', '((<see cref="T:NQualityOfLife.Types.Nibble"/>)15) -> ((<see cref="T:System.Char"/>)'F')'</returns>
            <remarks>Letters are returned in upper case
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
            <exception cref="T:NQualityOfLife.Exceptions.InternalDataException">The <see cref="F:NQualityOfLife.Types.Nibble._val"/> field of <see langword="this"/> <see cref="T:NQualityOfLife.Types.Nibble"/> has an invalid value! - This should not be possible.</exception>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.GetHashCode">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.ValueType.GetHashCode"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_BitwiseAnd(NQualityOfLife.Types.Nibble@,NQualityOfLife.Types.Nibble@)">
            <summary>Perform a bitwise <b><i>AND</i></b> operation on the <paramref name="left"/> and <paramref name="right"/> <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <param name="left"></param><param name="right"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.Nibble"/> with the resulting value</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_BitwiseOr(NQualityOfLife.Types.Nibble@,NQualityOfLife.Types.Nibble@)">
            <summary>Perform a bitwise <b><i>OR</i></b> operation on the <paramref name="left"/> and <paramref name="right"/> <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <param name="left"></param><param name="right"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.Nibble"/> with the resulting value</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_ExclusiveOr(NQualityOfLife.Types.Nibble@,NQualityOfLife.Types.Nibble@)">
            <summary>Perform a bitwise <b><i>XOR</i></b> operation on the <paramref name="left"/> and <paramref name="right"/> <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <param name="left"></param><param name="right"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.Nibble"/> with the resulting value</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_OnesComplement(NQualityOfLife.Types.Nibble@)">
            <summary>Perform a bitwise <b><i>NOT</i></b> operation on the <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <param name="nibble"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.Nibble"/> with the resulting value</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns><see langword="true"/> if the <paramref name="obj"/> <see langword="is"/> <see cref="T:NQualityOfLife.Types.Nibble"/> and has the same value</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.Equals(System.Char)">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.op_Equality(System.Char,NQualityOfLife.Types.Nibble@)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_Equality(System.Char,NQualityOfLife.Types.Nibble@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see langword="true"/> if the given <see cref="T:System.Char"/> equals the <seealso href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</seealso> <see cref="T:System.Char"/> representation of the <see cref="T:NQualityOfLife.Types.Nibble"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_Inequality(System.Char,NQualityOfLife.Types.Nibble@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see langword="true"/> if the <see cref="T:System.Char"/> differs from the current <seealso href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</seealso> <see cref="T:System.Char"/> representation of the <see cref="T:NQualityOfLife.Types.Nibble"/>
            <para><see langword="false"/> if the given <see cref="T:System.Char"/> equals the <seealso href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</seealso> <see cref="T:System.Char"/> representation of the <see cref="T:NQualityOfLife.Types.Nibble"/></para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_Equality(NQualityOfLife.Types.Nibble@,System.Char)">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.op_Equality(System.Char,NQualityOfLife.Types.Nibble@)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_Inequality(NQualityOfLife.Types.Nibble@,System.Char)">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.op_Inequality(System.Char,NQualityOfLife.Types.Nibble@)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.NewWithValue(System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.#ctor(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.NewWithValue(System.Byte@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.#ctor(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.NewWithValue(System.Char@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.#ctor(System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_Explicit(System.Int32)~NQualityOfLife.Types.Nibble">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.#ctor(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_Explicit(System.Byte)~NQualityOfLife.Types.Nibble">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.#ctor(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Nibble.op_Explicit(System.Char)~NQualityOfLife.Types.Nibble">
            <inheritdoc cref="M:NQualityOfLife.Types.Nibble.#ctor(System.Char)"/>
        </member>
        <member name="T:NQualityOfLife.Types.Percentage">
            <summary>Represents a <see cref="T:System.Single"/> value as a <see cref="T:NQualityOfLife.Types.Percentage"/>, a <see cref="T:System.Single"/> of '1f' is 100% when casting, comparing or adding</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Percentage.Hundread">
            <summary>100% == 1f</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Percentage.Zero">
            <summary>0% == 0f</summary>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(System.Single,System.Single)">
            <summary>Creates a <see cref="T:NQualityOfLife.Types.Percentage"/> - of/max</summary>
            <param name="of"></param>
            <param name="max">Max value</param>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(System.Double,System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Types.Percentage.#ctor(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Percentage.#ctor(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(NQualityOfLife.Units.ITemperatureAdditional@,NQualityOfLife.Units.ITemperatureAdditional@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Percentage.#ctor(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Types.Percentage.#ctor(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(System.SByte)">
            <inheritdoc cref="M:NQualityOfLife.Types.Percentage.#ctor(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(System.Int32)">
            <summary>Create a <see cref="T:NQualityOfLife.Types.Percentage"/> where the given integer type value is the % value
            <para><paramref name="percentage"/> 100 == 100% == 1<seealso cref="T:System.Single">f</seealso> == <see cref="F:NQualityOfLife.Types.Ratio.One"/></para></summary>
            <param name="percentage"></param>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(NQualityOfLife.Types.Ratio@)">
            <summary>Convert the <paramref name="ratio"/> into <see cref="T:NQualityOfLife.Types.Percentage"/><para><see cref="F:NQualityOfLife.Types.Ratio.One"/> == 1<seealso cref="T:System.Single">f</seealso> == 100%</para></summary>
            <param name="ratio"></param>
            <remarks>Use <see cref="M:NQualityOfLife.Types.Percentage.#ctor(System.Single)"/> unless precision is not important!</remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(NQualityOfLife.Types.Percentage@)">
            <summary><see langword="new"/> <see cref="T:NQualityOfLife.Types.Percentage"/> equal to the given <paramref name="percentage"/></summary>
            <param name="percentage"></param>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Types.Percentage.#ctor(NQualityOfLife.Types.Ratio@)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.#ctor(System.Single)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Types.Percentage.#ctor(NQualityOfLife.Types.Ratio@)"/>
        </member>
        <member name="P:NQualityOfLife.Types.Percentage.PercentageValue">
            <summary>The value of <see langword="this"/> <see cref="T:NQualityOfLife.Types.Percentage"/> as a <see cref="T:System.Single"/>
            <para>Where 100% == 100f</para>
            </summary>
            <returns>The value as a <see cref="T:NQualityOfLife.Types.Percentage"/> value</returns>
        </member>
        <member name="P:NQualityOfLife.Types.Percentage.Value">
            <summary>The value of <see langword="this"/> <see cref="T:NQualityOfLife.Types.Percentage"/> as a <see cref="T:System.Single"/>
            <para>Where 100% == 1f</para></summary>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.ToString">
            <summary></summary>
            <returns>The <see cref="T:NQualityOfLife.Types.Percentage"/> as a <see cref="T:System.String"/> -> 34% for example</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.Inverse(System.Single)">
            <summary></summary>
            <param name="max"></param>
            <returns><paramref name="max"/> - <see langword="this"/> <see cref="T:NQualityOfLife.Types.Percentage"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.RoundToInt">
            <summary></summary>
            <returns>The percentage as an <see cref="T:System.Int32"/> (0~100)</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Addition(System.Single,NQualityOfLife.Types.Percentage@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Subtraction(System.Single,NQualityOfLife.Types.Percentage@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Multiply(System.Single,NQualityOfLife.Types.Percentage@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Division(System.Single,NQualityOfLife.Types.Percentage@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Multiply(NQualityOfLife.Types.Percentage@,NQualityOfLife.Types.Factor@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Multiply(NQualityOfLife.Types.Percentage@,NQualityOfLife.Types.Ratio@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Division(NQualityOfLife.Types.Percentage@,NQualityOfLife.Types.Factor@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Division(NQualityOfLife.Types.Percentage@,NQualityOfLife.Types.Ratio@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Percentage.op_Explicit(NQualityOfLife.Types.Percentage@)~NQualityOfLife.Types.Ratio">
            <summary>Converts a Percentage with a value between: 0f~100f to a ratio: 0f~1f</summary>
            <param name="percentage"></param>
        </member>
        <member name="T:NQualityOfLife.Types.Ratio">
            <summary>A <see cref="T:System.Single"/> value between 0 and 1 - the value is stored in a <see cref="T:System.Byte"/>, so some precision is lost.</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Ratio.toFloatConversion">
            <summary><see cref="T:System.Single"/> == <see cref="F:NQualityOfLife.Types.Ratio.__internalValue"/> * <see cref="F:NQualityOfLife.Types.Ratio.toFloatConversion"/> ~= 0.00392..</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Ratio.MinNonZero">
            <summary>The smallest non-<seealso cref="F:NQualityOfLife.Types.Ratio.Zero">zero</seealso> value that the <see cref="T:NQualityOfLife.Types.Ratio"/> can represent</summary>
            <remarks><para>~= 0.00392..</para>Same idea as <see cref="F:System.Single.Epsilon"/></remarks>
        </member>
        <member name="F:NQualityOfLife.Types.Ratio.Zero">
            <summary>The minimum/smallest value that a <see cref="T:NQualityOfLife.Types.Ratio"/> can represent</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Ratio.Min">
            <inheritdoc cref="F:NQualityOfLife.Types.Ratio.Zero"/>
        </member>
        <member name="F:NQualityOfLife.Types.Ratio.One">
            <summary>The maximum/largest value that a <see cref="T:NQualityOfLife.Types.Ratio"/> can represent</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Ratio.Max">
            <inheritdoc cref="F:NQualityOfLife.Types.Ratio.One"/>
        </member>
        <member name="F:NQualityOfLife.Types.Ratio.Half">
            <summary>Half of the maximum/largest value that a <see cref="T:NQualityOfLife.Types.Ratio"/> can represent ~= 0.50196..</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Ratio.__internalValue">
            <inheritdoc cref="F:NQualityOfLife.Types.Ratio.toFloatConversion"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Single,System.Single)">
            <summary>Create a ratio from a <paramref name="value"/> and the max value</summary>
            <param name="value"></param>
            <param name="ofMax">The max value</param>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Single)">
            <summary>Allowed values are 1f to 0f</summary>
            <param name="ratio">Allowed values are 1f to 0f</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.#ctor(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Int32)">
            <summary>Allowed values are 0 or 1</summary>
            <param name="ratio">Allowed values are 0 or 1</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Boolean)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> with either min or max value</summary>
            <param name="max"><see langword="true"/> for max <see cref="T:NQualityOfLife.Types.Ratio"/>, <see langword="false"/> for min <see cref="T:NQualityOfLife.Types.Ratio"/></param>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.#ctor(System.Byte)">
            <summary>Set the internal value directly 0~255</summary>
            <param name="value">0~255 - 0~1</param>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.Ratio.IsMax">
            <summary></summary>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.Ratio"/> is 1f</returns>
        </member>
        <member name="P:NQualityOfLife.Types.Ratio.IsMin">
            <summary></summary>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.Ratio"/> is 0f</returns>
        </member>
        <member name="P:NQualityOfLife.Types.Ratio.Inverse">
            <summary>1f - <see langword="this"/> <see cref="T:NQualityOfLife.Types.Ratio"/></summary>
            <remarks><see langword="this"/>.<see cref="T:NQualityOfLife.Types.Ratio"/> + <see langword="this"/>.<see cref="P:NQualityOfLife.Types.Ratio.Inverse"/> == 1f</remarks>
        </member>
        <member name="P:NQualityOfLife.Types.Ratio.ByteValue">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="P:NQualityOfLife.Types.IByteImmutable.ByteValue"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_GreaterThan(System.Single,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="leftFloat"></param><param name="rightRatio"></param>
            <returns>Always <see langword="true"/> if <paramref name="leftFloat"/> > 1f<para>Always <see langword="false"/> if <paramref name="leftFloat"/> &lt;= 0</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_GreaterThanOrEqual(System.Single,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="leftFloat"></param><param name="rightRatio"></param>
            <returns><see langword="true"/> if any: <list type="bullet"><item><paramref name="leftFloat"/> is >= 1f</item><item><paramref name="leftFloat"/> >= <paramref name="rightRatio"/></item></list>Never <see langword="true"/> if: <list type="bullet"><item><paramref name="leftFloat"/> &lt; 0f</item></list></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_LessThanOrEqual(System.Single,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="leftFloat"></param><param name="rightRatio"></param>
            <returns><see langword="true"/> if any: <list type="bullet"><item><paramref name="leftFloat"/> is &lt;= 0f</item><item><paramref name="leftFloat"/> &lt;= <paramref name="rightRatio"/></item></list>Never <see langword="true"/> if: <list type="bullet"><item><paramref name="leftFloat"/> > 1f</item></list></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_GreaterThan(NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary></summary><param name="ratio"></param><param name="rightInteger"></param>
            <returns>Always <see langword="false"/> if <paramref name="rightInteger"/> >= 1<para>Always <see langword="true"/> if <paramref name="rightInteger"/> &lt; 0</para><para><see langword="true"/> if <paramref name="ratio"/> &gt; 0 and <paramref name="rightInteger"/> == 0</para><para><see langword="false"/> if <paramref name="ratio"/> == 0 and <paramref name="rightInteger"/> == 0</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_LessThan(NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary></summary><param name="ratio"></param><param name="rightInteger"></param>
            <returns>Always <see langword="true"/> if <paramref name="rightInteger"/> > 1</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_GreaterThanOrEqual(NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary></summary><param name="ratio"></param><param name="rightInteger"></param>
            <returns>Always <see langword="false"/> if <paramref name="rightInteger"/> > 1<para>Always <see langword="true"/> if <paramref name="rightInteger"/> &lt;= 0</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_LessThanOrEqual(NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary></summary><param name="ratio"></param><param name="rightInteger"></param>
            <returns>Always <see langword="true"/> if <paramref name="rightInteger"/> > 1<para><see langword="true"/> if <paramref name="ratio"/> == 0 and <paramref name="rightInteger"/> &lt;= 0</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_GreaterThan(System.Int32,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="leftInteger"></param><param name="rightRatio"></param>
            <returns>Always <see langword="true"/> if <paramref name="leftInteger"/> is > 1</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_LessThan(System.Int32,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="leftInteger"></param><param name="rightRatio"></param>
            <returns>Always <see langword="true"/> if <paramref name="leftInteger"/> &lt; 0</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_GreaterThanOrEqual(System.Int32,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="leftInteger"></param><param name="rightRatio"></param>
            <returns><see langword="true"/> if the <paramref name="leftInteger"/> is >= <paramref name="rightRatio"/><para>Always <see langword="true"/> if <paramref name="leftInteger"/> >= 1</para></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_LessThanOrEqual(System.Int32,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="leftInteger"></param><param name="rightRatio"></param>
            <returns><see langword="true"/> if <paramref name="leftInteger"/> &lt;= <paramref name="rightRatio"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Multiply(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <summary>Multpily the two <see cref="T:NQualityOfLife.Types.Ratio"/>s</summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> that is the result of multiplying the two ratios</returns>
            <remarks>The returned <see cref="T:NQualityOfLife.Types.Ratio"/> is always &lt;= to the larger of the input ratios</remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Multiply(NQualityOfLife.Types.Ratio@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.op_Multiply(System.Single,NQualityOfLife.Types.Ratio@)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Multiply(System.Single,NQualityOfLife.Types.Ratio@)">
            <summary>Multiply the given <see cref="T:System.Single"/> by the <see cref="T:NQualityOfLife.Types.Ratio"/></summary>
            <param name="fIn"></param><param name="ratio"></param>
            <returns><paramref name="fIn"/> * <paramref name="ratio"/></returns>
            <remarks>Where |<see langword="return"/> <see cref="T:System.Single"/>| &lt;= |<paramref name="fIn"/>|
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Subtraction(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns>The result of the subtraction as a <see cref="T:System.Single"/></returns>
            <remarks>Because the operation can be negative; the result type is a <see cref="T:System.Single"/><para>The returned <see cref="T:System.Single"/> is always &lt;= 1f and >= -1f</para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Addition(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns>The sum of the two <see cref="T:NQualityOfLife.Types.Ratio"/>s as <see cref="T:NQualityOfLife.Types.Factor"/></returns>
            <remarks>Because the operation is always positive, but can be more than the max value of <see cref="T:NQualityOfLife.Types.Ratio"/>; the result type is a <see cref="T:NQualityOfLife.Types.Factor"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Addition(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns>The sum of the two positive values as <see cref="T:NQualityOfLife.Types.Factor"/></returns>
            <remarks>Because the operation is always positive, but can be more than the max value of <see cref="T:NQualityOfLife.Types.Ratio"/>; the result type is a <see cref="T:NQualityOfLife.Types.Factor"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Equality(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see langword="true"/> if the internal <see cref="T:System.Byte"/> values of the <see cref="T:NQualityOfLife.Types.Ratio"/>s are equal</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Inequality(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see langword="false"/> if the internal <see cref="T:System.Byte"/> values of the <see cref="T:NQualityOfLife.Types.Ratio"/>s are equal</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Equality(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Factor@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.EqualsApprox(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Equality(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.EqualsApprox(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Equality(NQualityOfLife.Types.Ratio@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.EqualsApprox(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Equality(System.Single,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.EqualsApprox(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Equality(NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary></summary>
            <param name="ratio">Compare this <see cref="T:NQualityOfLife.Types.Ratio"/> to the given <see cref="T:System.Int32"/></param><param name="numInteger">Compare this <see cref="T:System.Int32"/> to the <see cref="T:NQualityOfLife.Types.Ratio"/></param>
            <returns><see langword="true"/> if <paramref name="ratio"/> is <see cref="F:NQualityOfLife.Types.Ratio.Max"/> and <paramref name="numInteger"/> is 1
            <para>Or <paramref name="ratio"/> is <see cref="F:NQualityOfLife.Types.Ratio.Min"/> and <paramref name="numInteger"/> is 0</para>
            <para>Never <see langword="true"/> if: <list type="bullet"><item><paramref name="numInteger"/> > 1 or &lt; 0</item></list></para></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Inequality(NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary></summary><param name="ratio">Compare this <see cref="T:NQualityOfLife.Types.Ratio"/> to the given <see cref="T:System.Int32"/></param><param name="numInteger">Compare this <see cref="T:System.Int32"/> to the <see cref="T:NQualityOfLife.Types.Ratio"/></param>
            <returns><see langword="false"/> if <paramref name="ratio"/> is <see cref="F:NQualityOfLife.Types.Ratio.Zero"/> and <paramref name="numInteger"/> is 0
            <para>Or <paramref name="ratio"/> is <see cref="F:NQualityOfLife.Types.Ratio.One"/> and <paramref name="numInteger"/> is 1</para>
            <para>Always <see langword="true"/> if: <list type="bullet"><item><paramref name="numInteger"/> > 1 or &lt; 0</item></list></para></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Equality(System.Int32,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.op_Equality(NQualityOfLife.Types.Ratio@,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio.op_Inequality(System.Int32,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Ratio.op_Inequality(NQualityOfLife.Types.Ratio@,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio2.#ctor(UnityEngine.Vector2@)">
            <summary></summary>
            <param name="vector2"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Ratio2.#ctor(System.Single,System.Single)">
            <summary></summary>
            <param name="x"></param>
            <param name="y"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.Element.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns><see langword="true"/> if the two <see cref="T:NQualityOfLife.Types.Element"/>s are the same atomic number, isotope is ignored</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Element.Equals(NQualityOfLife.Types.Element)">
            <inheritdoc cref="M:NQualityOfLife.Types.Element.Equals(System.Object)"/>
        </member>
        <member name="M:NQualityOfLife.Types.Atom.Equals(System.Object)">
            <summary></summary>
            <param name="obj"></param>
            <returns><see langword="true"/> if the two <see cref="T:NQualityOfLife.Types.Atom"/> are the same atomic number and isotope</returns>
        </member>
        <member name="M:NQualityOfLife.Types.Atom.op_Equality(NQualityOfLife.Types.Atom@,NQualityOfLife.Types.Atom@)">
            <summary></summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Types.Atom.Equals(System.Object)"/>
        </member>
        <member name="F:NQualityOfLife.Types.PeriodicTable.Elements.ElementSymbols">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.Types.PeriodicTable.elements">
            <summary>The data is structured [row][column] and is 0 indexed!
            <para>There also are no gaps in the array, so the first row has a <see cref="P:System.Array.Length"/> of 2 with 'H' and 'He'</para></summary>
        </member>
        <member name="M:NQualityOfLife.Types.PeriodicTable.ElementByAtomicNumber(System.UInt16)">
            <summary>Get an <see cref="T:NQualityOfLife.Types.Element"/> from the periodic table using an <paramref name="atomicNumber"/> | Valid numbers are 1~118</summary>
            <param name="atomicNumber">1~118</param>
            <returns>The <see cref="T:NQualityOfLife.Types.Element"/> that has the given <paramref name="atomicNumber"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid atomic number</exception>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Types.PeriodicTable.GetElementRow(System.Byte)">
            <summary>Get the row (period) of elements from the periodic table</summary>
            <param name="row">1~7</param>
            <returns>The given row (period) of the table</returns>
        </member>
        <member name="T:NQualityOfLife.Types.IVector`1">
            <summary>A vector composed of the specified type '<typeparamref name="T"/>'</summary>
            <typeparam name="T">The type of the vector</typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.IVector`1.Magnitude">
            <summary>The magnitude '<typeparamref name="T"/>' of the <see cref="T:NQualityOfLife.Types.IVector`1"/></summary>
        </member>
        <member name="P:NQualityOfLife.Types.IVector`1.Normalized">
            <summary>Normalize the <see cref="T:NQualityOfLife.Types.IVector`1"/> and return it as a <see cref="T:NQualityOfLife.Types.Direction"/></summary>
        </member>
        <member name="T:NQualityOfLife.Types.IVector2`1">
            <summary>a two dimensional vector composed of the specified type '<typeparamref name="T"/>'</summary>
            <typeparam name="T">The type of the vector</typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IVector`1"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IVector2`1.Deconstruct(`0@,`0@)">
            <summary>Get the X and Y components of the 2D vector</summary>
            <param name="x">The X component of the vector</param>
            <param name="y">The Y component of the vector</param>
        </member>
        <member name="T:NQualityOfLife.Types.Vector2Float">
            <summary>A generic vector composed of two floats</summary>
            <remarks>Used to represent sizes of shapes, offsets of positions and other two dimensinal vectors
            <para>Implements <see cref="T:NQualityOfLife.Types.IVector2`1"/> where 'T' is <see cref="T:System.Single"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Vector2Float.#ctor(System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Types.Vector2Float"/>
        </member>
        <member name="M:NQualityOfLife.Types.Vector2Float.#ctor(NQualityOfLife.Types.Vector2Float@)">
            <inheritdoc cref="M:NQualityOfLife.Types.Vector2Float.#ctor(System.Single,System.Single)"/>
        </member>
        <member name="T:NQualityOfLife.Types.IVector3`1">
            <summary>a 3 dimensional vector composed of the specified type</summary>
            <typeparam name="T">The type of the vector</typeparam>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IVector`1"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IVector3`1.Deconstruct(`0@,`0@,`0@)">
            <summary>Get the X, Y and Z components of the 3D vector</summary>
            <param name="x">The X component of the vector</param>
            <param name="y">The Y component of the vector</param>
            <param name="z">The Z component of the vector</param>
        </member>
        <member name="T:NQualityOfLife.Types.Vector3Float">
            <summary>A generic vector composed of three floats</summary>
            <remarks>Used to represent offsets of positions and other three dimensinal vectors
            <para>Implements <see cref="T:NQualityOfLife.Types.IVector3`1"/> where 'T' is <see cref="T:System.Single"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.Vector3Float.#ctor(System.Single,System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Types.Vector3Float"/>
        </member>
        <member name="M:NQualityOfLife.Types.Vector3Float.#ctor(System.ValueTuple{System.Single,System.Single,System.Single}@)">
            <inheritdoc cref="T:NQualityOfLife.Types.Vector3Float"/>
        </member>
        <member name="M:NQualityOfLife.Types.Vector3Float.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Types.Vector3Float"/>
        </member>
        <member name="T:NQualityOfLife.Types.URL">
            <summary>Represents a web page <see cref="T:NQualityOfLife.Types.URL"/></summary>
        </member>
        <member name="F:NQualityOfLife.Types.URL.__url">
            <summary>The internal <see cref="T:System.String"/> representation of <see langword="this"/> <see cref="T:NQualityOfLife.Types.URL"/></summary>
        </member>
        <member name="M:NQualityOfLife.Types.URL.System#Collections#IEnumerable#GetEnumerator">
            <summary></summary>
            <returns>The <see cref="T:NQualityOfLife.Types.URL"/> as a <see cref="T:System.String"/></returns>
        </member>
        <member name="M:NQualityOfLife.Types.BasePairDictionary`2.Add(`0,`1)">
            <summary>Add the given <paramref name="key"/> and <paramref name="value"/> as a new pair</summary>
            <param name="key"></param>
            <param name="value"></param>
            <inheritdoc cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)"/>
        </member>
        <member name="M:NQualityOfLife.Types.BasePairDictionary`2.Add(System.ValueTuple{`0,`1}@)">
            <inheritdoc cref="M:NQualityOfLife.Types.BasePairDictionary`2.Add(`0,`1)"/>
        </member>
        <member name="M:NQualityOfLife.Types.BasePairDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Add the given <paramref name="pair"/> to the <see cref="T:NQualityOfLife.Types.PairDictionary`2"/></summary>
            <param name="pair"></param>
            <inheritdoc cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)"/>
        </member>
        <member name="M:NQualityOfLife.Types.BasePairDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Check if the <see cref="T:NQualityOfLife.Types.PairDictionary`2"/> contains the given <paramref name="pair"/></summary>
            <param name="pair"></param>
            <returns></returns>
            <remarks>The order of the types in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/> does not matter</remarks>
        </member>
        <member name="M:NQualityOfLife.Types.BasePairDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Remove the <paramref name="pair"/> from the <see cref="T:NQualityOfLife.Types.PairDictionary`2"/></summary>
            <param name="pair"></param>
            <returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.InternalDataException"></exception>
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:NQualityOfLife.Types.PairDictionary`2.Add(`1,`0)">
            <inheritdoc cref="M:NQualityOfLife.Types.BasePairDictionary`2.Add(`0,`1)"/>
        </member>
        <member name="M:NQualityOfLife.Types.PairDictionary`2.Add(System.Collections.Generic.KeyValuePair{`1,`0})">
            <inheritdoc cref="M:NQualityOfLife.Types.BasePairDictionary`2.Add(`0,`1)"/>
        </member>
        <member name="M:NQualityOfLife.Types.PairDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`1,`0})">
            <inheritdoc cref="M:NQualityOfLife.Types.BasePairDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})"/>
        </member>
        <member name="M:NQualityOfLife.Types.PairDictionary`2.ContainsKey(`1)">
            <inheritdoc cref="M:NQualityOfLife.Types.BasePairDictionary`2.ContainsKey(`0)"/>
        </member>
        <member name="M:NQualityOfLife.Types.PairDictionary`2.Remove(`1)">
            <inheritdoc cref="M:NQualityOfLife.Types.BasePairDictionary`2.Remove(`0)"/>
        </member>
        <member name="M:NQualityOfLife.Types.PairDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`1,`0})">
            <inheritdoc cref="M:NQualityOfLife.Types.BasePairDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})"/>
        </member>
        <member name="M:NQualityOfLife.Types.PairDictionary`2.TryGetValue(`1,`0@)">
            <inheritdoc cref="M:NQualityOfLife.Types.BasePairDictionary`2.TryGetValue(`0,`1@)"/>
        </member>
        <member name="T:NQualityOfLife.Types.PairDictionary`1">
            <inheritdoc cref="T:NQualityOfLife.Types.PairDictionary`2"/>
            <summary>A <see cref="T:NQualityOfLife.Types.PairDictionary`2"/> where the keys and values are both of the same <see cref="T:System.Type"/> '<typeparamref name="KV"/>'</summary>
            <typeparam name="KV"></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.UnOrderedList`1.Remove(`0)">
            <summary>Remove the given <paramref name="item"/>, || (The last item on the list will replace the given items index, unless the given index is the last item)</summary>
            <param name="item"></param><exception cref="T:System.InvalidOperationException"></exception>
            <returns><see langword="true"/> if the <paramref name="item"/> was successfully removed.</returns>
        </member>
        <member name="M:NQualityOfLife.Types.UnOrderedList`1.RemoveAt(System.Int32)">
            <summary>Remove the item at the given index from the list. || (the last item on the list will be moved to this index, unless the given index is the last item)</summary>
            <param name="index"></param><exception cref="T:System.InvalidOperationException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:NQualityOfLife.Types.IInterface">
            <summary>Parent <see langword="interface"/> for all interfaces in <see cref="N:NQualityOfLife"/></summary>
        </member>
        <member name="T:NQualityOfLife.Types.KeyCombination">
            <summary>Keyboard modifier key <seealso cref="T:System.FlagsAttribute">flags</seealso></summary>
        </member>
        <member name="T:NQualityOfLife.Types.MouseButtons">
            <summary>Generic <seealso cref="T:System.FlagsAttribute">flags</seealso> for representing mouse buttons</summary>
        </member>
        <member name="F:NQualityOfLife.Types.MouseButtons.Left">
            <summary>Left mouse button</summary>
        </member>
        <member name="F:NQualityOfLife.Types.MouseButtons.Middle">
            <summary>The middle mouse button, usually pressing down on the scroll wheel</summary>
        </member>
        <member name="F:NQualityOfLife.Types.MouseButtons.Right">
            <summary>Right mouse button</summary>
        </member>
        <member name="T:NQualityOfLife.Types.Month">
            <summary>Simple <see cref="T:System.Byte"/> <see langword="enum"/> for months, can be used in place of <see cref="T:System.Byte"/> in places such as the <see cref="T:NQualityOfLife.Attributes.AuthorsAttribute"/> or where ever a month is used as on input</summary>
            <remarks>1-based indexing where 1 is <see cref="F:NQualityOfLife.Types.Month.January">January</see> and 12 is <see cref="F:NQualityOfLife.Types.Month.December">December</see></remarks>
        </member>
        <member name="F:NQualityOfLife.Types.Month.Undefined">
            <summary>0 - Undefined</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.January">
            <summary>1 - January - Tammikuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.February">
            <summary>2 - February - Helmikuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.March">
            <summary>3 - March - Maaliskuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.April">
            <summary>4 - April - Huhtikuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.May">
            <summary>5 - May - Toukokuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.June">
            <summary>6 - June - Keskuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.July">
            <summary>7 - July - Heinkuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.August">
            <summary>8 - August - Elokuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.September">
            <summary>9 - September - Syyskuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.October">
            <summary>10 - October - Lokakuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.November">
            <summary>10 - November - Marraskuu</summary>
        </member>
        <member name="F:NQualityOfLife.Types.Month.December">
            <summary>12 - December - Joulukuu</summary>
        </member>
        <member name="T:NQualityOfLife.Types.WeekDay">
            <summary>Simple <see cref="T:System.Byte"/> <see langword="enum"/> for week days, can be used in place of <see cref="T:System.Byte"/> in places where a week day is used as on input</summary>
            <remarks>1-based indexing where 1 is <see cref="F:NQualityOfLife.Types.WeekDay.Monday">Monday</see> and 7 is <see cref="F:NQualityOfLife.Types.WeekDay.Sunday">Sunday</see></remarks>
        </member>
        <member name="F:NQualityOfLife.Types.WeekDay.Undefined">
            <summary>0 - Undefined</summary>
        </member>
        <member name="F:NQualityOfLife.Types.WeekDay.Monday">
            <summary>1 - Monday - Maanantai</summary>
        </member>
        <member name="F:NQualityOfLife.Types.WeekDay.Tuesday">
            <summary>2 - Tuesday - Tiistai</summary>
        </member>
        <member name="F:NQualityOfLife.Types.WeekDay.Wednesday">
            <summary>3 - Wednesday - Keskiviikko</summary>
        </member>
        <member name="F:NQualityOfLife.Types.WeekDay.Thursday">
            <summary>4 - Thursday - Torstai</summary>
        </member>
        <member name="F:NQualityOfLife.Types.WeekDay.Friday">
            <summary>5 - Friday - Perjantai</summary>
        </member>
        <member name="F:NQualityOfLife.Types.WeekDay.Saturday">
            <summary>6 - Saturday - Lauantai</summary>
        </member>
        <member name="F:NQualityOfLife.Types.WeekDay.Sunday">
            <summary>7 - Sunday - Sunnuntai</summary>
        </member>
        <member name="T:NQualityOfLife.Types.INewWithValue`2">
            <summary>Allows for creating <see langword="new"/> instances of '<typeparamref name="TN"/>' through <see langword="interface"/> methods using a given value '<typeparamref name="TV"/>'</summary>
            <typeparam name="TN">The implementing <see cref="T:System.Type"/> '<typeparamref name="TN"/>'</typeparam>
            <typeparam name="TV">The value used to create a <see langword="new"/> '<typeparamref name="TN"/>'</typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.INewWithValue`2.NewWithValue(`1@)">
            <summary>Creates a <see langword="new"/> instance of '<typeparamref name="TN"/>' with the given <paramref name="value"/> '<typeparamref name="TV"/>'</summary>
            <param name="value">The value '<typeparamref name="TV"/>' used to create the <see langword="new"/> '<typeparamref name="TN"/>'</param>
            <returns>a <see langword="new"/> instance of '<typeparamref name="TN"/>' that is equal to the provided <paramref name="value"/> '<typeparamref name="TV"/>'</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.INewWithValue`2"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.ICopy`1">
            <remarks>Implements <see cref="T:System.ICloneable"/>
            <para>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
            <inheritdoc cref="T:System.ICloneable"/>
            <summary></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> '<typeparamref name="T"/>' that implements <see cref="T:NQualityOfLife.Types.ICopy`1"/></typeparam>
        </member>
        <member name="M:NQualityOfLife.Types.ICopy`1.DeepCopy">
            <summary>Make a <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#deep-copy">deep copy</seealso> of <see langword="this"/> <see cref="T:NQualityOfLife.Types.ICopy`1"/> '<typeparamref name="T"/>'</summary>
            <returns>a <see langword="new"/> instance of '<typeparamref name="T"/>' that is an exact copy of the original</returns>
        </member>
        <member name="T:NQualityOfLife.Types.ICoordinateContext">
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.ICoordinateContextVertical">
            <summary>The implementing <see cref="T:System.Object"/> has a <see cref="P:NQualityOfLife.Types.ICoordinateContextVertical.Height">height</see> and has a <see cref="M:NQualityOfLife.Types.ICoordinateContextVertical.TopPoint(NQualityOfLife.Types.CoordinateContext)">top most</see> and <see cref="M:NQualityOfLife.Types.ICoordinateContextVertical.BottomPoint(NQualityOfLife.Types.CoordinateContext)">bottom most</see> point</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.ICoordinateContext"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.ICoordinateContextVertical.Height">
            <summary>The vertical height of the <see cref="T:System.Object"/></summary>
            <returns>The vertical distance between the <see cref="M:NQualityOfLife.Types.ICoordinateContextVertical.TopPoint(NQualityOfLife.Types.CoordinateContext)">top</see> and <see cref="M:NQualityOfLife.Types.ICoordinateContextVertical.BottomPoint(NQualityOfLife.Types.CoordinateContext)">bottom</see> points</returns>
            <remarks>Returned values should be &gt;= 0f
            <para>Defined in <see cref="T:NQualityOfLife.Types.ICoordinateContextVertical"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.ICoordinateContextVertical.TopPoint(NQualityOfLife.Types.CoordinateContext)">
            <summary>Get one of the points that define <see langword="this"/>, ensuring that the returned <see cref="T:NQualityOfLife.Geometry.Point2D"/> is the top most point</summary>
            <param name="coordinateContext"></param>
            <returns>The point <see langword="this"/> that is the top most point</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.ICoordinateContextVertical"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.ICoordinateContextVertical.BottomPoint(NQualityOfLife.Types.CoordinateContext)">
            <summary>Get one of the points that define <see langword="this"/>, ensuring that the returned <see cref="T:NQualityOfLife.Geometry.Point2D"/> is the bottom most point</summary>
            <param name="coordinateContext"></param>
            <returns>The point <see langword="this"/> that is the bottom most point</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.ICoordinateContextVertical"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.ICoordinateContextHorizontal">
            <summary>The implementing <see cref="T:System.Object"/> has a <see cref="P:NQualityOfLife.Types.ICoordinateContextHorizontal.Width">width</see> and has a <see cref="M:NQualityOfLife.Types.ICoordinateContextHorizontal.LeftPoint(NQualityOfLife.Types.CoordinateContext)">left most</see> and <see cref="M:NQualityOfLife.Types.ICoordinateContextHorizontal.RightPoint(NQualityOfLife.Types.CoordinateContext)">right most</see> point</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.ICoordinateContext"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.ICoordinateContextHorizontal.Width">
            <summary>The horizontal width of the <see cref="T:System.Object"/></summary>
            <returns>The horizontal distance between the <see cref="M:NQualityOfLife.Types.ICoordinateContextHorizontal.LeftPoint(NQualityOfLife.Types.CoordinateContext)">left</see> and <see cref="M:NQualityOfLife.Types.ICoordinateContextHorizontal.RightPoint(NQualityOfLife.Types.CoordinateContext)">right</see> points</returns>
            <remarks>Returned values should be &gt;= 0f
            <para>Defined in <see cref="T:NQualityOfLife.Types.ICoordinateContextHorizontal"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.ICoordinateContextHorizontal.LeftPoint(NQualityOfLife.Types.CoordinateContext)">
            <summary>Get one of the points that define <see langword="this"/>, ensuring that the returned <see cref="T:NQualityOfLife.Geometry.Point2D"/> is the left most point</summary>
            <param name="coordinateContext"></param>
            <returns>The point <see langword="this"/> that is the left most point</returns>
            <exception cref="T:System.NotImplementedException">The given <paramref name="coordinateContext"/> is not implemented</exception>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.ICoordinateContextHorizontal"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.ICoordinateContextHorizontal.RightPoint(NQualityOfLife.Types.CoordinateContext)">
            <summary>Get one of the points that define <see langword="this"/>, ensuring that the returned <see cref="T:NQualityOfLife.Geometry.Point2D"/> is the right most point</summary>
            <param name="coordinateContext"></param>
            <returns>The point <see langword="this"/> that is the right most point</returns>
            <exception cref="T:System.NotImplementedException">The given <paramref name="coordinateContext"/> is not implemented</exception>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.ICoordinateContextHorizontal"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.ICoordinateContextPolygon">
            <summary>The implementing <see cref="T:System.Object"/> is a <see cref="T:NQualityOfLife.Geometry.IPolygon"/> that has a <see cref="P:NQualityOfLife.Types.ICoordinateContextHorizontal.Width">width</see>, <see cref="P:NQualityOfLife.Types.ICoordinateContextVertical.Height">height</see> and has a <see cref="M:NQualityOfLife.Types.ICoordinateContextHorizontal.LeftPoint(NQualityOfLife.Types.CoordinateContext)">left most</see>, <see cref="M:NQualityOfLife.Types.ICoordinateContextHorizontal.RightPoint(NQualityOfLife.Types.CoordinateContext)">right most</see>, <see cref="M:NQualityOfLife.Types.ICoordinateContextVertical.TopPoint(NQualityOfLife.Types.CoordinateContext)">top most</see> and <see cref="M:NQualityOfLife.Types.ICoordinateContextVertical.BottomPoint(NQualityOfLife.Types.CoordinateContext)">bottom most</see> points</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.ICoordinateContextVertical"/>, <see cref="T:NQualityOfLife.Types.ICoordinateContextHorizontal"/>, <see cref="T:NQualityOfLife.Geometry.IPolygon"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.Geometry.IPolygon"/>
            <inheritdoc cref="T:NQualityOfLife.Types.ICoordinateContextVertical"/>
            <inheritdoc cref="T:NQualityOfLife.Types.ICoordinateContextHorizontal"/>
        </member>
        <member name="T:NQualityOfLife.Types.ICoordinateContextCompareHorizontal`1">
            <summary>Supports comparing the horizontal position of <see langword="this"/> to instances of '<typeparamref name="T"/>'</summary>
            <remarks>Supports comparing in the X direction (<see cref="T:NQualityOfLife.Types.ICoordinateContextCompareHorizontal`1">Horizontal</see>)
            <para>Extends <see cref="T:NQualityOfLife.Types.ICoordinateContext"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.ICoordinateContextCompareHorizontal`1.IsToTheLeftOf(`0@,NQualityOfLife.Types.CoordinateContext)">
            <summary></summary>
            <param name="other"></param>
            <param name="coordinateContext"></param>
            <returns><see langword="true"/> if <see langword="this"/> <i>IsToTheLeftOf</i> <paramref name="other"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.ICoordinateContextCompareHorizontal`1.IsToTheRightOf(`0@,NQualityOfLife.Types.CoordinateContext)">
            <summary></summary>
            <param name="other"></param>
            <param name="coordinateContext"></param>
            <returns><see langword="true"/> if <see langword="this"/> <i>IsToTheRightOf</i> <paramref name="other"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Types.ICoordinateContextCompareVertical`1">
            <summary>Supports comparing the vertical position of <see langword="this"/> to instances of '<typeparamref name="T"/>'</summary>
            <remarks>Supports comparing in the Y direction (<see cref="T:NQualityOfLife.Types.ICoordinateContextCompareVertical`1">Vertical</see>)
            <para>Extends <see cref="T:NQualityOfLife.Types.ICoordinateContext"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.ICoordinateContextCompareVertical`1.IsBelow(`0@,NQualityOfLife.Types.CoordinateContext)">
            <summary></summary>
            <param name="other"></param>
            <param name="coordinateContext"></param>
            <returns><see langword="true"/> if <see langword="this"/> is below <paramref name="other"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Types.ICoordinateContextCompareVertical`1.IsAbove(`0@,NQualityOfLife.Types.CoordinateContext)">
            <summary></summary>
            <param name="other"></param>
            <param name="coordinateContext"></param>
            <returns><see langword="true"/> if <see langword="this"/> is above <paramref name="other"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Types.ICoordinateContextCompare`1">
            <summary>Supports comparing the position of <see langword="this"/> to instances of '<typeparamref name="T"/>'</summary>
            <remarks>Supports comparing in the X and Y directions (<see cref="T:NQualityOfLife.Types.ICoordinateContextCompareHorizontal`1">Horizontal</see> and <see cref="T:NQualityOfLife.Types.ICoordinateContextCompareVertical`1">Vertical</see>)
            <para>Extends <see cref="T:NQualityOfLife.Types.ICoordinateContextCompareVertical`1"/>, <see cref="T:NQualityOfLife.Types.ICoordinateContextCompareHorizontal`1"/> &lt;- <see cref="T:NQualityOfLife.Types.ICoordinateContext"/></para></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.CoordinateContext">
            <summary><see cref="T:System.FlagsAttribute">Flags</see> <see cref="T:System.Enum"/> for establishing the coordinate system in use</summary>
        </member>
        <member name="F:NQualityOfLife.Types.CoordinateContext.ZeroDegreesIsUpFlag__">
            <summary></summary><remarks>0b_0010_0000</remarks>
        </member>
        <member name="F:NQualityOfLife.Types.CoordinateContext.ZeroDegreesIsDownFlag__">
            <summary></summary><remarks>0b_0100_0000</remarks>
        </member>
        <member name="F:NQualityOfLife.Types.CoordinateContext.ZeroDegreesIsLeftFlag__">
            <summary></summary><remarks>0b_1000_0000</remarks>
        </member>
        <member name="F:NQualityOfLife.Types.CoordinateContext.ZeroDegreesIsRightFlag__">
            <summary></summary><remarks>0b_0110_0000</remarks>
        </member>
        <member name="F:NQualityOfLife.Types.CoordinateContext.__UndefinedAngleContext1">
            <summary></summary><remarks>0b_1010_0000</remarks>
        </member>
        <member name="F:NQualityOfLife.Types.CoordinateContext.__UndefinedAngleContext2">
            <summary></summary><remarks>0b_1100_0000</remarks>
        </member>
        <member name="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace">
            <summary>(x, y) where (0, 0) is the top left corner of the monitor and (+x, +y) approaches the bottom right corner
            <para>+y is down on the screen -y is towards the top</para><para>+x is towards the right side of the screen, -x is towards the left</para>
            <para>Angles follow the standard unit circle angles (toward the right side of the screen is 0 degrees) and positve angles rotate counter clockwise</para>
            <para>Meaning negative angles rotate clockwise</para></summary>
        </member>
        <member name="F:NQualityOfLife.Types.CoordinateContext.WindowsPresentationFoundation">
            <inheritdoc cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/>
            <remarks>Same as <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.ICastable`1">
            <summary>The <see cref="T:System.Type"/> can be cast to '<typeparamref name="T"/>' <see langword="explicit"/>ly or <see langword="implicit"/>ly</summary>
            <typeparam name="T">The resulting <see cref="T:System.Type"/> of the cast</typeparam>
            <remarks><see cref="T:NQualityOfLife.Types.ICastable`1"/> types should implement <see langword="implicit"/> and or <see langword="explicit"/> cast <see langword="operator"/>s matching the given <see cref="T:System.Type"/> '<typeparamref name="T"/>'<para>Such as: <code>public static explicit operator ThermalConductivity(in ThermalResistivity resist) => resist.Inverse;</code></para>
            <para>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.ICastable`1.CastTo">
            <summary>Cast <see langword="this"/> <see cref="T:NQualityOfLife.Types.ICastable`1"/> to '<typeparamref name="T"/>'</summary>
            <returns><see langword="this"/> <see cref="T:NQualityOfLife.Types.ICastable`1"/> casted to '<typeparamref name="T"/>'</returns>
            <remarks>It is recommended to implement this <see langword="interface"/> method explicitly, unless the implementing type only has one type of <see cref="T:NQualityOfLife.Types.ICastable`1"/> and there is a reason to have it visible</remarks>
        </member>
        <member name="T:NQualityOfLife.Types.ICastableFrom`2">
            <summary>Specifies that the type '<typeparamref name="TQ"/>' can be created by a cast from '<typeparamref name="TF"/>'</summary>
            <typeparam name="TQ">The result <see cref="T:System.Type"/> '<typeparamref name="TQ"/>' of the cast</typeparam>
            <typeparam name="TF">The source value for the cast</typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.INewWithValue`2"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.Types.INewWithValue`2"/>
        </member>
        <member name="T:NQualityOfLife.Types.IFunc`2">
            <summary>Defines a function that returns an output <typeparamref name="TQ"/> for the given input <typeparamref name="TI"/></summary>
            <typeparam name="TI">Function input <see cref="T:System.Type"/></typeparam>
            <typeparam name="TQ">Function output <see cref="T:System.Type"/></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.IFunc`2.Item(`0@)">
            <summary>Get the value '<typeparamref name="TQ"/>' for the given <paramref name="input"/> '<typeparamref name="TI"/>'</summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Types.IInverse`2">
            <summary>A pair of values that are the inverse of each other
            <para>For example '<see cref="T:NQualityOfLife.Units.Second"/>' and '<see cref="T:NQualityOfLife.Units.Hertz"/>'</para></summary>
            <typeparam name="TA"><typeparamref name="TA"/> == 1/<typeparamref name="TB"/> | <typeparamref name="TA"/> == <typeparamref name="TB"/>^-1</typeparam><typeparam name="TB"><typeparamref name="TB"/> == 1/<typeparamref name="TA"/> | <typeparamref name="TB"/> == <typeparamref name="TA"/>^-1</typeparam>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.ICastable`1"/>, <see cref="T:NQualityOfLife.Types.ICastableFrom`2"/>, <see cref="T:NQualityOfLife.Units.ISolveFor`1"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.IInverse`2.Inverse">
            <summary>1/<typeparamref name="TA"/> == <typeparamref name="TB"/></summary>
        </member>
        <member name="T:NQualityOfLife.Types.IFloat">
            <summary>Interface for <see cref="T:System.Single"/>-like types that are used for math</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/>
            <para>Implements <see cref="T:System.IComparable`1"/>, <see cref="T:System.IEquatable`1"/> where 'T' is <see cref="T:System.Single"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.IFloat.Value">
            <summary>The value of this <see cref="T:NQualityOfLife.Types.IFloat"/> when converted to <see cref="T:System.Single"/> || For example <see cref="T:NQualityOfLife.Types.Percentage"/> of 100% will return 1f</summary>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IFloat"/></remarks>
            <returns>The <see cref="T:System.Single"/> value that <see langword="this"/> <see cref="T:NQualityOfLife.Types.IFloat"/> instance represents</returns>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat.Equals(System.Single,System.Single)">
            <summary></summary><param name="other"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IFloat"/> is approximately equal to the given <see cref="T:System.Single"/></returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IFloat"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat.EqualsApprox(System.Single,System.Single)">
            <summary></summary><param name="other"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Types.IFloat"/> is approximately equal to the given <see cref="T:System.Single"/></returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IFloat"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat.EqualsExact(System.Single)">
            <summary></summary><param name="other"></param><returns><see langword="true"/> if the <see cref="T:System.Single"/> values are exactly the same, to the bit level.</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IFloat"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat.CompareTo(System.Single)">
            <remarks><code>CompareTo(float other) => other == this.Value ? 0 : (other > this.Value ? -1 : 1);</code> 
            <para><remarks>Defined in <see cref="T:NQualityOfLife.Types.IFloat"/></remarks></para></remarks>
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="T:NQualityOfLife.Types.IFloat`1">
            <summary>Provides methods for comparing instances of '<typeparamref name="TF"/>' to each other and to <see cref="T:System.Single"/> s
            <para>As well as creating <see langword="new"/> instances of '<typeparamref name="TF"/>' using a provided '<see cref="T:System.Single"/>' value</para></summary>
            <typeparam name="TF"><see cref="T:System.Single"/> like <see cref="T:System.Type"/></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IFloat"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/>
            <para>Implements <see cref="T:NQualityOfLife.Types.INewWithValue`2"/> where 'TV' is <see cref="T:System.Single"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat`1.Equals(`0@,System.Single)">
            <summary></summary>
            <param name="other"></param>
            <param name="epsilon">How much the values can deviate to still be considered equal</param>
            <returns><see langword="true"/> if the two instances of <typeparamref name="TF"/> are equal within the given <paramref name="epsilon"/></returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IFloat`1"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat`1.EqualsApprox(`0@,System.Single)">
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IFloat`1"/></remarks>
            <inheritdoc cref="M:NQualityOfLife.Types.IFloat`1.Equals(`0@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Types.IFloat`1.EqualsExact(`0@)">
            <summary></summary><param name="other"></param>
            <returns><see langword="true"/> if the <see cref="T:System.Single"/> values are exactly the same, to the bit level.</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IFloat`1"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.IFormattableFloat">
            <summary>Defines formatting methods for <see cref="T:System.Single"/>-like values</summary>
            <remarks>Implements <see cref="T:System.IFormattable"/>
            <para>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IFormattableFloat.ToStringTwoDecimals">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringTwoDecimals(System.Single)"/>
            <summary></summary>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Types.IRatio">
            <summary>The <see cref="T:System.Type"/> is equivelant to a <see cref="T:System.Single"/> in a 0~1 range</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IFloat"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.IRandom`1">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.IRandom`1.GetRandom">
            <summary>Create a <see langword="new"/> instance of '<typeparamref name="T"/>' with a random value/values</summary>
        </member>
        <member name="T:NQualityOfLife.Types.IMath">
            <summary>Provides basic math operations for <see cref="T:System.Single"/>-like values</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IFloat"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/>
            <para>Implements <see cref="T:System.IComparable`1"/> where 'T' is <see cref="T:System.Single"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMath.Clamp(System.Single,System.Single)">
            <summary>Clamp <see langword="this"/> <see cref="T:NQualityOfLife.Types.IMath"/> inclusive</summary>
            <param name="min"></param><param name="max"></param>
            <returns>a <see cref="T:System.Single"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMath"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMath.LargerOf(System.Single)">
            <summary>Returns the larger <see cref="T:System.Single"/> value</summary>
            <param name="other"></param>
            <returns>The larger of the two <see cref="T:System.Single"/> values</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMath"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMath.SmallerOf(System.Single)">
            <summary>Returns the smaller <see cref="T:System.Single"/> value</summary>
            <param name="other"></param>
            <returns>The smaller of the two <see cref="T:System.Single"/> values</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMath"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMath.RoundToInt">
            <summary>Round <see langword="this"/> <see cref="T:NQualityOfLife.Types.IMath"/> to the closest <see cref="T:System.Int32"/></summary>
            <returns><see cref="T:System.Int32"/> that is closest to the value of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IMath"/></returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMath"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.IMath`1">
            <summary>Provides math operations to the implementing <see cref="T:System.Type"/> '<typeparamref name="T"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> '<typeparamref name="T"/>' that implements <see cref="T:NQualityOfLife.Types.IMath`1"/></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IMath"/> &lt;- <see cref="T:NQualityOfLife.Types.IFloat"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.Clamp(`0@,`0@)">
            <summary>Clamp <see langword="this"/> <see cref="T:NQualityOfLife.Types.IMath`1"/> inclusive</summary>
            <param name="min">The minimum returned value '<typeparamref name="T"/>'</param><param name="max"></param>
            <returns>'<typeparamref name="T"/>' that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="min"/> or <paramref name="max"/> is <see langword="null"/></exception>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMath`1"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.Abs">
            <summary>|<typeparamref name="T"/>|</summary>
            <returns>The absolute (non negative) value of <see langword="this"/> '<typeparamref name="T"/>'</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMath`1"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.SmallerOf(`0@)">
            <summary>Returns the smaller value</summary>
            <param name="other"></param>
            <returns>The smaller of the two '<typeparamref name="T"/>' values</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMath`1"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMath`1.LargerOf(`0@)">
            <summary>Returns the larger value</summary>
            <param name="other"></param>
            <returns>The larger of the two '<typeparamref name="T"/>' values</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMath`1"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.IMathRatio`1">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IMath`1"/> &lt;- <see cref="T:NQualityOfLife.Types.IMath"/> &lt;- <see cref="T:NQualityOfLife.Types.IFloat"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMathRatio`1.ClampRatio(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <summary>Clamp the value into a <see cref="T:NQualityOfLife.Types.Ratio"/></summary><param name="min"></param><param name="max"></param>
            <returns><paramref name="min"/>, <paramref name="max"/> or a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/></returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMathRatio`1"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Types.IMathRatio`1.ClampRatio">
            <summary>Clamp the value into a <see cref="T:NQualityOfLife.Types.Ratio"/></summary>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/></returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Types.IMathRatio`1"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Types.IByteImmutable">
            <summary>The implementing <see cref="T:System.Type"/> is <see cref="T:System.IEquatable`1"/> with <see cref="T:System.Byte"/></summary>
            <remarks>Implements <see cref="T:System.IEquatable`1"/>, <see cref="T:System.IComparable`1"/> where 'T' is <see cref="T:System.Byte"/>
            <para>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Types.IByteImmutable.ByteValue">
            <summary><see langword="get"/> the <see cref="T:System.Byte"/> value of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IByteImmutable"/></summary>
        </member>
        <member name="T:NQualityOfLife.Types.IByte">
            <remarks><para>Extends <see cref="T:NQualityOfLife.Types.IByteImmutable"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
            <inheritdoc cref="T:NQualityOfLife.Types.IByteImmutable"/>
        </member>
        <member name="P:NQualityOfLife.Types.IByte.ByteValue">
            <summary><see langword="get"/> or <see langword="set"/> the <see cref="T:System.Byte"/> value of <see langword="this"/> <see cref="T:NQualityOfLife.Types.IByte"/></summary>
        </member>
        <member name="T:NQualityOfLife.Types.StaticFieldInfo`1">
            <summary><see cref="T:System.Reflection.FieldInfo"/> of a <see langword="static"/> field</summary>
        </member>
        <member name="M:NQualityOfLife.Types.StaticFieldInfo`1.GetValue">
            <summary>Get the value of the <see langword="static"/> field</summary>
            <returns>an <see cref="T:System.Object"/> that contains the value of the <see langword="static"/> field</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <inheritdoc cref="M:System.Reflection.FieldInfo.GetValue(System.Object)"/>
        </member>
        <member name="M:NQualityOfLife.Types.StaticFieldInfo`1.SetValue(`0@)">
            <summary>Set the value of the <see langword="static"/> field to the <paramref name="newValue"/></summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <inheritdoc cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)"/>
        </member>
        <member name="T:NQualityOfLife.Types.StaticFieldInfo">
            <inheritdoc cref="T:NQualityOfLife.Types.StaticFieldInfo`1"/>
        </member>
        <member name="M:NQualityOfLife.Types.StaticFieldInfo.GetValue">
            <inheritdoc cref="M:NQualityOfLife.Types.StaticFieldInfo`1.GetValue"/>
        </member>
        <member name="M:NQualityOfLife.Types.StaticFieldInfo.SetValue(System.Object@)">
            <inheritdoc cref="M:NQualityOfLife.Types.StaticFieldInfo`1.SetValue(`0@)"/>
        </member>
        <member name="T:NQualityOfLife.Types.StaticConstructorInfo">
            <summary>Represents a <see langword="static"/> <see cref="T:System.Reflection.ConstructorInfo"/> (cctor)</summary>
        </member>
        <member name="M:NQualityOfLife.Types.StaticConstructorInfo.Run">
            <summary>Run the static constructor, will not do anything if it has already ran</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.IShapeCollection2D.Contains(NQualityOfLife.Geometry.Point2D@)">
            <summary></summary>
            <param name="point2D"></param>
            <returns><see langword="true"/> if the <see cref="T:NQualityOfLife.Geometry.IShapeCollection2D"/> contains the given <paramref name="point2D"/></returns>
        </member>
        <member name="T:NQualityOfLife.Geometry.IImmutableGeometry2D">
            <summary>Represents a 2D geometric shape with position and size properties.
            <para>Provides access to corners, bounds, and methods for containment and distance calculation.</para>
            <para><see cref="T:NQualityOfLife.Geometry.IImmutableGeometry2D"/> is the top level <see langword="interface"/> for <b>2D</b> shapes</para></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Geometry.IImmutableGeometry"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Height">
            <summary><see langword="get"/> the maximum vertical height of the shape</summary>
            <remarks>Should not be negative, but can be 0</remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Width">
            <summary><see langword="get"/> the maximum horizontal width of the shape</summary>
            <remarks>Should not be negative, but can be 0</remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">
            <summary>The reference position of the shape.
            <para>By default, this is usually the same as <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Middle">Middle</see> (the geometric center of the shape),</para>
            <para>except in cases such as <see cref="T:NQualityOfLife.Geometry.ISquare"/> and <see cref="T:NQualityOfLife.Geometry.IRectangle"/>, where it may
            represent the top-left corner for compatibility with Unity or other frameworks.</para>
            <para>It is recommended to always use <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Middle">Middle</see> for shapes where the two are the same</para><para>If the <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">Position</see> differs from the <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Middle">Middle</see>, the implementing member should clearly document what the <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">Position</see> represents</para>
            <para>If <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">Position</see> == <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Middle">Middle</see>, implement <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">Position</see> <see langword="explicit"/>ly</para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Middle">
            <summary>The central point of the shape, i.e., the geometric center.
            <para>In most shapes, this is the same as <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">Position</see></para>
            <para>For shapes like <see cref="T:NQualityOfLife.Geometry.ISquare"/> and <see cref="T:NQualityOfLife.Geometry.IRectangle"/>, <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">Position</see> may be offset
            (e.g., top-left corner) for framework compatibility, but <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Middle">Middle</see> always represents the true center.</para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.X">
            <summary><see langword="get"/> the <b>X</b> coordinate of the <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">Position</see></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Y">
            <summary><see langword="get"/> the <b>Y</b> coordinate of the <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position">Position</see></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.XMax">
            <summary><see langword="get"/> the <i>Maximum</i> <b>X</b> coordinate of the shape's bounds.</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.XMin">
            <summary><see langword="get"/> the <i>Minimum</i> <b>X</b> coordinate of the shape's bounds.</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.YMax">
            <summary><see langword="get"/> the <i>Maximum</i> <b>Y</b> coordinate of the shape's bounds.</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IImmutableGeometry2D.YMin">
            <summary><see langword="get"/> the <i>Minimum</i> <b>Y</b> coordinate of the shape's bounds.</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Contains(NQualityOfLife.Geometry.Point2D@)">
            <summary>Determines if the given point is contained within the shape.</summary>
            <param name="point">The point to check.</param>
            <returns><see langword="true"/> if this <see cref="T:NQualityOfLife.Geometry.IGeometry2D"/> contains the given <paramref name="point"/>; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Contains(NQualityOfLife.Geometry.IPoint2D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Contains(NQualityOfLife.Geometry.Point2D@)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="point"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Deconstruct(System.Single@,System.Single@)">
            <summary>Deconstructs the shape's position into <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.X"/> and <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Y"/> coordinates.</summary>
            <param name="x">Output <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.X"/> coordinate.</param>
            <param name="y">Output <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Y"/> coordinate.</param>
        </member>
        <member name="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Distance(NQualityOfLife.Geometry.Point2D@)">
            <summary>Calculates the <seealso href="https://en.wikipedia.org/wiki/Euclidean_geometry">Euclidean distance</seealso> from this shape's <see cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Middle">Middle</see> to another <see cref="T:NQualityOfLife.Geometry.IPoint2D"/></summary>
            <param name="other">The other point.</param>
            <returns>The distance as a <see cref="T:System.Single"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Distance(NQualityOfLife.Geometry.IPoint2D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Distance(NQualityOfLife.Geometry.Point2D@)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Geometry.IGeometry2D">
            <summary>Represents a 2D geometric shape with position and size properties.
            <para>Provides access to corners, bounds, and methods for containment and distance calculation.</para>
            <para><see cref="T:NQualityOfLife.Geometry.IGeometry2D"/> is the top level <see langword="interface"/> for <b>mutable</b> 2D shapes</para></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Geometry.IImmutableGeometry2D"/> &lt;- <see cref="T:NQualityOfLife.Geometry.IImmutableGeometry"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.Geometry.IImmutableGeometry2D"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.Position">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Position"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.Middle">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Middle"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.X">
            <remarks><see langword="set"/> Should affect the <see cref="P:NQualityOfLife.Geometry.Point2D.X">X</see> component of the <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Position">Position</see></remarks>
            <inheritdoc cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.X"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.Y">
            <remarks><see langword="set"/> Should affect the <see cref="P:NQualityOfLife.Geometry.Point2D.Y">Y</see> component of the <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Position">Position</see></remarks>
            <inheritdoc cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.Y"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.XMax">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.XMax"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.XMin">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.XMin"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.YMax">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.YMax"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry2D.YMin">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IImmutableGeometry2D.YMin"/>
        </member>
        <member name="T:NQualityOfLife.Geometry.IPolygon">
            <summary>Represents a two-dimensional polygonal shape with straight edges and vertices.
            Implements <see cref="T:NQualityOfLife.Geometry.IGeometry2D"/> for position and geometric utilities.</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Geometry.IGeometry2D"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPolygon.Perimeter">
            <summary>Get the perimeter of the <see cref="T:NQualityOfLife.Geometry.IPolygon"/><para>This is the total length of all the <see cref="P:NQualityOfLife.Geometry.IPolygon.Edges"/></para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPolygon.Area">
            <summary>The total geometric area of the <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.
            <para>Calculated based on the vertices and edges of the <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.</para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPolygon.Edges">
            <summary>The edges (sides) of the <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> as line segments.
            <para>Each edge connects two consecutive vertices.</para></summary>
            <returns>An array of <see cref="T:NQualityOfLife.Geometry.Line2D"/> representing all edges of the <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.</returns>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPolygon.Vertices">
            <summary>The vertices (corner points) of the <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> in order.
            <para>Also referred to as <see cref="P:NQualityOfLife.Geometry.IPolygon.Corners"/>.</para></summary>
            <returns>An array of <see cref="T:NQualityOfLife.Geometry.Point2D"/>s representing all vertices of the <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.</returns>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPolygon.Corners">
            <summary>The corners of the <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.
            <para>Equivalent to <see cref="P:NQualityOfLife.Geometry.IPolygon.Vertices"/>; used interchangeably depending on context.</para></summary>
            <returns>An array of <see cref="T:NQualityOfLife.Geometry.Point2D"/>s representing the corners of the <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPolygon.Rotate(NQualityOfLife.Units.Degrees@)">
            <summary>Returns a <see langword="new"/> <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> rotated by the specified angle around its <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> point.</summary>
            <param name="degrees">The rotation angle in degrees. Positive values rotate clockwise.</param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.IPolygon"/> representing the rotated <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPolygon.FullyContains(NQualityOfLife.Geometry.IPolygon@)">
            <summary>Determines whether this <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> completely contains another <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.
            <para>Returns <see langword="true"/> only if all vertices of the other <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> are strictly inside this <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.</para></summary>
            <param name="other">The <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> to check for containment.</param>
            <returns><see langword="true"/> if this <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> fully contains the other <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPolygon.ContainsOrOverlaps(NQualityOfLife.Geometry.IPolygon@)">
            <summary>Determines whether this <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> contains or overlaps another <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.
            <para>Returns <see langword="true"/> if any part of the other <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> lies inside or along the edges of this <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>.</para></summary>
            <param name="other">The <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> to check for containment or overlap.</param>
            <returns><see langword="true"/> if this <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso> contains or overlaps the other <seealso cref="T:NQualityOfLife.Geometry.IPolygon">polygon</seealso>; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Area">
            <summary>The area of the 3D shape</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Volume">
            <summary>The volume of the 3D shape</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Position">
            <summary>The point in the middle of the 3D shape. or the position of the point.</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Middle">
            <summary>The point in the middle of the 3D shape. or the position of the point.</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IGeometry3D.Corners">
            <summary></summary>
            <remarks>Should return an empty array in case of shapes with no corners, such as <see cref="T:NQualityOfLife.Geometry.Sphere"/>s</remarks>
        </member>
        <member name="M:NQualityOfLife.Geometry.IGeometry3D.Contains(NQualityOfLife.Geometry.IPoint3D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Contains(NQualityOfLife.Geometry.IPoint2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IGeometry3D.Distance(NQualityOfLife.Geometry.IPoint3D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IImmutableGeometry2D.Distance(NQualityOfLife.Geometry.IPoint2D@)"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine3D.A">
            <inheritdoc cref="P:NQualityOfLife.Geometry.ILine2D.A"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine3D.B">
            <inheritdoc cref="P:NQualityOfLife.Geometry.ILine2D.B"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine3D.Middle">
            <summary>The midpoint between A and B</summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine3D.Length">
            <summary>The Length between A and B</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine3D.Contains(NQualityOfLife.Geometry.Point3D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine3D.Contains(NQualityOfLife.Geometry.IPoint3D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.IPoint2D@)"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint3D.X">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPoint2D.X"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint3D.Y">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPoint2D.Y"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint3D.Position">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPoint2D.Position"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.Distance(NQualityOfLife.Geometry.IPoint3D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.IPoint2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.Distance(NQualityOfLife.Geometry.Point3D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.SumOf(NQualityOfLife.Geometry.Point3D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.Point2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.AverageOf(NQualityOfLife.Geometry.Point3D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.Point2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.SumOf(NQualityOfLife.Geometry.IPoint3D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.IPoint2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.AverageOf(NQualityOfLife.Geometry.IPoint3D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.IPoint2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.NewLine(NQualityOfLife.Geometry.Point3D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.NewLine(NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint3D.DirectionTo(NQualityOfLife.Geometry.Point3D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.DirectionTo(NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="T:NQualityOfLife.Geometry.ILine2D">
            <summary>A two dimensional straight line</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Geometry.IImmutableGeometry"/>, <see cref="T:NQualityOfLife.SGUI.IUniversalDraw"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine2D.A">
            <summary>The '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point / start of the line</summary>
            <returns>The '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point of the <see cref="T:NQualityOfLife.Geometry.ILine2D"/></returns>
            <remarks>This <see langword="set"/> should only affect the '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point, unless it <i><b>must</b></i> affect both due to some constraint of the implementing shape
            <para>In such special cases, the <see langword="set"/> action should do the least possible change to the '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point while following any constraints imposed by the implementing shape</para>
            <para>Behaviour should be clearly documented in these cases</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine2D.B">
            <summary>The '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point / end of the line</summary>
            <returns>The '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point of the <see cref="T:NQualityOfLife.Geometry.ILine2D"/></returns>
            <remarks>This <see langword="set"/> should only affect the '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point, unless it <i><b>must</b></i> affect both due to some constraint of the implementing shape
            <para>In such special cases, the <see langword="set"/> action should do the least possible change to the '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point while following any constraints imposed by the implementing shape</para>
            <para>Behaviour should be clearly documented in these cases</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine2D.Middle">
            <summary>The midpoint between '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' and '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>'</summary>
            <remarks>Setting this property using <see langword="set"/> should move the entire line such that the angle and distance between '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' and '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' is preserved</remarks>
            <returns>The <see cref="T:NQualityOfLife.Geometry.Point2D"/> in the middle of the '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' and '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' points as a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="P:NQualityOfLife.Geometry.ILine2D.Length">
            <summary>The Length of the line / distance between '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' and '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>'</summary>
            <remarks>Returned values should be &gt;= 0f
            <para>Defined in <see cref="T:NQualityOfLife.Geometry.ILine2D"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Deconstruct(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <summary>Deconstruct <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.ILine2D"/> into it's two points</summary>
            <param name="a">'<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point of the line</param>
            <param name="b">'<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point of the line</param>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.Point2D@)">
            <summary></summary><param name="point"></param>
            <returns><see langword="true"/> if the given point is any point on the line</returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Geometry.ILine2D"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.IPoint2D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.ILine2D.Contains(NQualityOfLife.Geometry.Point2D@)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="point"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.SetAngleAroundA(NQualityOfLife.Units.Degrees@)">
            <summary>Set the angle such that the '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point of the line stays in the same position</summary>
            <param name="degrees"></param><returns>A <see langword="new"/> line that has the same '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.SetAngleAroundB(NQualityOfLife.Units.Degrees@)">
            <summary>Set the angle such that the '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point of the line stays in the same position</summary>
            <param name="degrees"></param><returns>A <see langword="new"/> line that has the same '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.RotateAroundA(NQualityOfLife.Units.Degrees@)">
            <summary>Rotate the line such that the '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point of the line stays in the same position</summary>
            <param name="degrees"></param><returns>A <see langword="new"/> line that has the same '<see cref="P:NQualityOfLife.Geometry.ILine2D.A">A</see>' point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.RotateAroundB(NQualityOfLife.Units.Degrees@)">
            <summary>Rotate the line such that the '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point of the line stays in the same position</summary>
            <param name="degrees"></param><returns>A <see langword="new"/> line that has the same '<see cref="P:NQualityOfLife.Geometry.ILine2D.B">B</see>' point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.ILine2D.RotatedAroundMiddle(NQualityOfLife.Units.Degrees@)">
            <summary></summary>
            <param name="degrees"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> that has the same <see cref="P:NQualityOfLife.Geometry.ILine2D.Middle">Middle</see> and <see cref="P:NQualityOfLife.Geometry.ILine2D.Length">Length</see> as <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.ILine2D"/>, but rotated by the given <see cref="T:NQualityOfLife.Units.Degrees"/></returns>
        </member>
        <member name="T:NQualityOfLife.Geometry.Line2D">
            <inheritdoc cref="T:NQualityOfLife.Geometry.ILine2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Line2D.#ctor(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Line2D"/>
            <summary></summary>
            <param name="start">The '<see cref="P:NQualityOfLife.Geometry.Line2D.A">A</see>' point of the <see cref="T:NQualityOfLife.Geometry.Line2D"/></param>
            <param name="end">The '<see cref="P:NQualityOfLife.Geometry.Line2D.B">B</see>' point of the <see cref="T:NQualityOfLife.Geometry.Line2D"/></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Line2D.#ctor(NQualityOfLife.Geometry.Line2D@)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Line2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Line2D.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Line2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Line2D.#ctor(NQualityOfLife.Geometry.Point2D@,System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Line2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Line2D.#ctor(UnityEngine.Vector2@,UnityEngine.Vector2@)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Line2D"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Line2D.IsVertical">
            <summary></summary>
            <returns><see langword="true"/> if the <see cref="T:NQualityOfLife.Geometry.Line2D"/> can be safely casted to a <see cref="T:NQualityOfLife.Geometry.VerticalLine"/></returns>
        </member>
        <member name="P:NQualityOfLife.Geometry.Line2D.IsHorizontal">
            <summary></summary>
            <returns><see langword="true"/> if the <see cref="T:NQualityOfLife.Geometry.Line2D"/> can be safely casted to a <see cref="T:NQualityOfLife.Geometry.HorizontalLine"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Line2D.op_Addition(NQualityOfLife.Geometry.Line2D@,NQualityOfLife.Types.Vector2Float@)">
            <summary></summary>
            <param name="line"></param>
            <param name="positionOffset"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> where the <see cref="P:NQualityOfLife.Geometry.Line2D.A"/> and <see cref="P:NQualityOfLife.Geometry.Line2D.B"/> points have both been moved by the given <paramref name="positionOffset"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Line2D.op_Subtraction(NQualityOfLife.Geometry.Line2D@,NQualityOfLife.Types.Vector2Float@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Line2D.op_Addition(NQualityOfLife.Geometry.Line2D@,NQualityOfLife.Types.Vector2Float@)"/>
        </member>
        <member name="T:NQualityOfLife.Geometry.HorizontalLine">
            <summary>The <see cref="T:NQualityOfLife.Geometry.HorizontalLine"/> is composed of two points that have the same y coordinate</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.#ctor(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.#ctor(NQualityOfLife.Geometry.Line2D@)">
            <summary></summary>
            <param name="line"></param>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary></summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.#ctor(NQualityOfLife.Geometry.Point2D@,System.Single,System.Single)">
            <summary></summary>
            <param name="start"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="P:NQualityOfLife.Geometry.HorizontalLine.Y">
            <summary><see langword="set"/> or <see langword="get"/> the current vertical position of <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.HorizontalLine"/></summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.LeftPoint(NQualityOfLife.Types.CoordinateContext)">
            <summary>Get one of the points that define <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.HorizontalLine"/>, ensuring that the returned <see cref="T:NQualityOfLife.Geometry.Point2D"/> is the left most point</summary>
            <param name="coordinateContext"></param>
            <returns><see cref="P:NQualityOfLife.Geometry.HorizontalLine.A"/> or <see cref="P:NQualityOfLife.Geometry.HorizontalLine.B"/> depending on which one is the left most point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.RightPoint(NQualityOfLife.Types.CoordinateContext)">
            <summary>Get one of the points that define <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.HorizontalLine"/>, ensuring that the returned <see cref="T:NQualityOfLife.Geometry.Point2D"/> is the right most point</summary>
            <param name="coordinateContext"></param>
            <returns><see cref="P:NQualityOfLife.Geometry.HorizontalLine.A"/> or <see cref="P:NQualityOfLife.Geometry.HorizontalLine.B"/> depending on which one is the right most point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.op_Explicit(NQualityOfLife.Geometry.Line2D@)~NQualityOfLife.Geometry.HorizontalLine">
            <inheritdoc cref="M:NQualityOfLife.Geometry.HorizontalLine.#ctor(NQualityOfLife.Geometry.Line2D@)"/>
            <summary></summary>
            <param name="horizontalLine"></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.MovedBy(NQualityOfLife.Types.Vector2Float@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.HorizontalLine.op_Addition(NQualityOfLife.Geometry.HorizontalLine@,NQualityOfLife.Types.Vector2Float@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.MovedBy(System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.HorizontalLine.op_Addition(NQualityOfLife.Geometry.HorizontalLine@,NQualityOfLife.Types.Vector2Float@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.op_Addition(NQualityOfLife.Geometry.HorizontalLine@,NQualityOfLife.Types.Vector2Float@)">
            <summary></summary>
            <param name="line"></param>
            <param name="positionOffset"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.HorizontalLine"/> where the <see cref="P:NQualityOfLife.Geometry.HorizontalLine.A"/> and <see cref="P:NQualityOfLife.Geometry.HorizontalLine.B"/> points have both been moved by the given <paramref name="positionOffset"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.HorizontalLine.op_Subtraction(NQualityOfLife.Geometry.HorizontalLine@,NQualityOfLife.Types.Vector2Float@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.HorizontalLine.op_Addition(NQualityOfLife.Geometry.HorizontalLine@,NQualityOfLife.Types.Vector2Float@)"/>
        </member>
        <member name="T:NQualityOfLife.Geometry.VerticalLine">
            <summary>The <see cref="T:NQualityOfLife.Geometry.VerticalLine"/> is composed of two points that have the same x coordinate</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.VerticalLine.#ctor(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.VerticalLine.#ctor(NQualityOfLife.Geometry.Line2D@)">
            <summary></summary>
            <param name="line"></param>
            <exception cref="T:System.InvalidCastException">cannot cast a non horizontal <see cref="T:NQualityOfLife.Geometry.Line2D"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.VerticalLine.TopPoint(NQualityOfLife.Types.CoordinateContext)">
            <summary>Get one of the points that define <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.VerticalLine"/>, ensuring that the returned <see cref="T:NQualityOfLife.Geometry.Point2D"/> is the top most point</summary>
            <param name="coordinateContext"></param>
            <returns><see cref="P:NQualityOfLife.Geometry.VerticalLine.A"/> or <see cref="P:NQualityOfLife.Geometry.VerticalLine.B"/> depending on which one is the top most point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.VerticalLine.BottomPoint(NQualityOfLife.Types.CoordinateContext)">
            <summary>Get one of the points that define <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.VerticalLine"/>, ensuring that the returned <see cref="T:NQualityOfLife.Geometry.Point2D"/> is the bottom most point</summary>
            <param name="coordinateContext"></param>
            <returns><see cref="P:NQualityOfLife.Geometry.VerticalLine.A"/> or <see cref="P:NQualityOfLife.Geometry.VerticalLine.B"/> depending on which one is the bottom most point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.VerticalLine.op_Explicit(NQualityOfLife.Geometry.Line2D@)~NQualityOfLife.Geometry.VerticalLine">
            <inheritdoc cref="M:NQualityOfLife.Geometry.VerticalLine.#ctor(NQualityOfLife.Geometry.Line2D@)"/>
            <summary></summary><param name="verticalLine"></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.VerticalLine.op_Addition(NQualityOfLife.Geometry.VerticalLine@,NQualityOfLife.Types.Vector2Float@)">
            <summary></summary>
            <param name="line"></param>
            <param name="positionOffset"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.VerticalLine"/> where the <see cref="P:NQualityOfLife.Geometry.VerticalLine.A"/> and <see cref="P:NQualityOfLife.Geometry.VerticalLine.B"/> points have both been moved by the given <paramref name="positionOffset"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.VerticalLine.op_Subtraction(NQualityOfLife.Geometry.VerticalLine@,NQualityOfLife.Types.Vector2Float@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.VerticalLine.op_Addition(NQualityOfLife.Geometry.VerticalLine@,NQualityOfLife.Types.Vector2Float@)"/>
        </member>
        <member name="T:NQualityOfLife.Geometry.IPoint2D">
            <summary>Represents a point in 2D space, usually representing a point on the screen</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Geometry.IGeometry2D"/>, <see cref="T:NQualityOfLife.Types.IVector2`1"/> where 'T' is <see cref="T:System.Single"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint2D.X">
            <summary>The X (Horizontal) position of the point, The meaning of the coordinates may depend on the <see cref="T:NQualityOfLife.Types.CoordinateContext"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint2D.Y">
            <summary>The Y (Vertical) position of the point, The meaning of the coordinates may depend on the <see cref="T:NQualityOfLife.Types.CoordinateContext"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IPoint2D.Position">
            <summary>A <see cref="T:NQualityOfLife.Geometry.Point2D"/> representation of <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IPoint2D"/></summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.IPoint2D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.Point2D@)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Distance(NQualityOfLife.Geometry.Point2D@)">
            <summary>Get the distance to another point</summary><param name="other"></param>
            <returns>The <see href="https://en.wikipedia.org/wiki/Euclidean_geometry">euclidean</see> distance from <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IPoint2D"/> to the given <paramref name="other"/> <see cref="T:NQualityOfLife.Geometry.IPoint2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.Point2D[])">
            <summary>Sum all positions</summary><param name="others"></param>
            <returns><see cref="T:NQualityOfLife.Geometry.Point2D"/> with a position that is the sum of all the positions of the given points</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="others"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.IPoint2D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.Point2D[])"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="others"/> is <see langword="null"/> or one of the points inside it is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.Point2D[])">
            <summary>The average position of all the given points</summary><param name="others"></param>
            <returns><see cref="T:NQualityOfLife.Geometry.Point2D"/> with a position that is the average of all the positions of the given points</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="others"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.IPoint2D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.AverageOf(NQualityOfLife.Geometry.Point2D[])"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="others"/> is <see langword="null"/> or one of the points inside it is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.NewLine(NQualityOfLife.Geometry.Point2D@)">
            <summary>Create a <see langword="new"/> line from the given points</summary><param name="endPoint">The <see cref="P:NQualityOfLife.Geometry.Line2D.B">B</see> point of the <see cref="T:NQualityOfLife.Geometry.Line2D"/></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> starting at <see langword="this"/> point and ending with the given other point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.NewLine(NQualityOfLife.Geometry.Point2D@,System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> that starts at <see langword="this"/> point and ends with a point in the direction of the given point, and with the given length</summary>
            <param name="endPointDirection"></param>
            <param name="distance"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> with a <see cref="P:NQualityOfLife.Geometry.Line2D.Length">Length</see> equal to <paramref name="distance"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Point(NQualityOfLife.Geometry.Point2D@,System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> in the direction of the given point, and with the given <paramref name="distance"/> from <see langword="this"/> point</summary>
            <param name="endPointDirection"></param>
            <param name="distance"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Point(NQualityOfLife.Units.Degrees@,System.Single)">
            <summary>Get a <see langword="new"/> point that is at the given <paramref name="angle"/> and <paramref name="distance"/> from <see langword="this"/> point</summary>
            <param name="angle"></param>
            <param name="distance"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.MidPoint(NQualityOfLife.Geometry.Point2D@)">
            <summary>Get the mid point between two points</summary><param name="other"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> between <see langword="this"/> instance and the given <paramref name="other"/> point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.DirectionTo(NQualityOfLife.Geometry.Point2D@)">
            <summary></summary>
            <param name="other"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.Direction"/> vector pointing towards the <paramref name="other"/> point</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Angle(NQualityOfLife.Geometry.Point2D@)">
            <summary></summary>
            <param name="endPoint"></param>
            <returns>The angle towards the <paramref name="endPoint"/> in <see cref="T:NQualityOfLife.Units.Degrees"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IPoint2D.Deconstruct(System.Single@,System.Single@)">
            <summary>Deconstruct <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IPoint2D"/> into the 'x' and 'y' components</summary>
            <param name="x"><see cref="P:NQualityOfLife.Geometry.IPoint2D.X"/></param>
            <param name="y"><see cref="P:NQualityOfLife.Geometry.IPoint2D.Y"/></param>
        </member>
        <member name="T:NQualityOfLife.Geometry.Point2D">
            <summary>Represents a point in 2D space, usually representing a point on the screen</summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.#ctor">
            <summary>Create a <see langword="default"/> (0f, 0f) <see cref="T:NQualityOfLife.Geometry.Point2D"/></summary>
            <inheritdoc cref="T:NQualityOfLife.Geometry.Point2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.#ctor(System.Single,System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> with the given position</summary>
            <param name="x">The <see cref="P:NQualityOfLife.Geometry.Point2D.X"/> component of the <see cref="T:NQualityOfLife.Geometry.Point2D"/></param>
            <param name="y">The <see cref="P:NQualityOfLife.Geometry.Point2D.Y"/> component of the <see cref="T:NQualityOfLife.Geometry.Point2D"/></param>
            <inheritdoc cref="T:NQualityOfLife.Geometry.Point2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.#ctor(System.Double,System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.#ctor(System.Single,System.Single)"/>
            <inheritdoc cref="T:NQualityOfLife.Geometry.Point2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.#ctor(NQualityOfLife.Geometry.Point2D@)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Point2D"/>
            <summary></summary>
            <param name="copyFrom">Make a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> that is a copy of this <see cref="T:NQualityOfLife.Geometry.Point2D"/></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.#ctor(NQualityOfLife.Geometry.IPoint2D@)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Point2D"/>
            <summary></summary>
            <param name="copyFrom">Make a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> that is a copy of this <see cref="T:NQualityOfLife.Geometry.IPoint2D"/></param>
            <exception cref="T:System.NullReferenceException"><paramref name="copyFrom"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.#ctor(System.ValueTuple{System.Single,System.Single}@)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Point2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.#ctor(NQualityOfLife.Types.Vector2Float@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> from a <see cref="T:NQualityOfLife.Types.Vector2Float"/></summary>
            <inheritdoc cref="T:NQualityOfLife.Geometry.Point2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.#ctor(UnityEngine.Vector2@)">
            <inheritdoc cref="T:NQualityOfLife.Geometry.Point2D"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.NewLine(NQualityOfLife.Units.Degrees@,System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> that starts from <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></summary>
            <param name="angle">The angle of the <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/></param>
            <param name="distance">The <see cref="P:NQualityOfLife.Geometry.Line2D.Length"/> of the <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Line2D"/> that starts from <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Explicit(NQualityOfLife.Geometry.Point2D@)~NQualityOfLife.Geometry.Point3D">
            <summary>Cast the <see cref="T:NQualityOfLife.Geometry.Point2D"/> to a <see cref="T:NQualityOfLife.Geometry.Point3D"/>, The <see cref="P:NQualityOfLife.Geometry.Point3D.Z"/> will be 0f</summary>
            <param name="point2d"></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <summary>Add the <see cref="F:NQualityOfLife.Geometry.Point2D.x">x</see> and <see cref="F:NQualityOfLife.Geometry.Point2D.y">y</see> coordinates together and return it as a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/>
            <para><code><see langword="new"/>(<paramref name="a"/>.x + <paramref name="b"/>.x, <paramref name="a"/>.y + <paramref name="b"/>.y)</code></para></summary>
            <param name="a"></param><param name="b"></param>
            <returns><see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,System.ValueTuple{System.Single,System.Single}@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,System.ValueTuple{System.Single,System.Int32}@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,System.ValueTuple{System.Int32,System.Single}@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,System.ValueTuple{System.Int32,System.Int32}@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <summary>Subtract the <see cref="F:NQualityOfLife.Geometry.Point2D.x">x</see> and <see cref="F:NQualityOfLife.Geometry.Point2D.y">y</see> coordinates and return it as a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/>
            <para><code><see langword="new"/>(<paramref name="a"/>.x - <paramref name="b"/>.x, <paramref name="a"/>.y - <paramref name="b"/>.y)</code></para></summary>
            <param name="a"></param><param name="b"></param>
            <returns><see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,System.ValueTuple{System.Single,System.Single}@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,System.ValueTuple{System.Single,System.Int32}@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,System.ValueTuple{System.Int32,System.Single}@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,System.ValueTuple{System.Int32,System.Int32}@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Multiply(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <summary>Multiply the <see cref="F:NQualityOfLife.Geometry.Point2D.x">x</see> and <see cref="F:NQualityOfLife.Geometry.Point2D.y">y</see> coordinates together and return it as a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/>
            <para><code><see langword="new"/>(<paramref name="a"/>.x * <paramref name="b"/>.x, <paramref name="a"/>.y * <paramref name="b"/>.y)</code></para></summary>
            <param name="a"></param><param name="b"></param>
            <returns><see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Multiply(NQualityOfLife.Geometry.Point2D@,System.Single)">
            <summary>Multiply the <see cref="F:NQualityOfLife.Geometry.Point2D.x">x</see> and <see cref="F:NQualityOfLife.Geometry.Point2D.y">y</see> coordinates of the <paramref name="point"/> by the given <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#scalar">scalar</seealso> <paramref name="number"/>
            <para><code><see langword="new"/>(<paramref name="point"/>.x * <paramref name="number"/>, <paramref name="point"/>.y * <paramref name="number"/>)</code></para></summary>
            <param name="point"></param><param name="number"><seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#scalar">scalar</seealso> number</param>
            <returns><see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Multiply(System.Single,NQualityOfLife.Geometry.Point2D@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Multiply(NQualityOfLife.Geometry.Point2D@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Division(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@)">
            <summary>
            <para><code><see langword="new"/>(<paramref name="a"/>.x / <paramref name="b"/>.x, <paramref name="a"/>.y / <paramref name="b"/>.y)</code></para></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Division(NQualityOfLife.Geometry.Point2D@,System.Single)">
            <summary>Divide the <see cref="F:NQualityOfLife.Geometry.Point2D.x">x</see> and <see cref="F:NQualityOfLife.Geometry.Point2D.y">y</see> coordinates of the <paramref name="point"/> by the given <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#scalar">scalar</seealso> <paramref name="number"/>
            <para><code><see langword="new"/>(<paramref name="point"/>.x / <paramref name="number"/>, <paramref name="point"/>.y / <paramref name="number"/>)</code></para></summary>
            <param name="point"></param><param name="number"><seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#scalar">scalar</seealso> number</param>
            <returns><see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Division(NQualityOfLife.Geometry.Point2D@,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.op_Division(NQualityOfLife.Geometry.Point2D@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Addition(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Types.Vector2Float@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.MovedBy(NQualityOfLife.Types.Vector2Float@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.op_Subtraction(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Types.Vector2Float@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Geometry.Point2D.MovedBy(NQualityOfLife.Types.Vector2Float@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.SumOf(NQualityOfLife.Geometry.Point2D[])">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPoint2D.SumOf(NQualityOfLife.Geometry.Point2D[])"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.DrawLineHorizontal(NQualityOfLife.Geometry.Point2D@,UnityEngine.Color@,System.Single)">
            <summary>Draw a horizontal line starting from start going right</summary>
            <param name="color"></param><param name="end"></param><param name="thickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.DrawLineVertical(UnityEngine.Color@,System.Single,System.Single)">
            <summary>Draw a vertical line starting from <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> going down</summary>
            <param name="color"></param>
            <param name="thickness"></param><param name="height"></param>
            <returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Point2D.DrawLineHorizontal(UnityEngine.Color@,System.Single,System.Single)">
            <summary>Draw a <see cref="T:NQualityOfLife.Geometry.HorizontalLine"/> line starting from <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Point2D"/> going right</summary>
            <param name="color"></param><param name="length"></param><param name="thickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="T:NQualityOfLife.Geometry.IRectangle">
            <summary>A 2D <see cref="T:NQualityOfLife.Geometry.Rectangle"/></summary>
            <remarks>Does not support rotation
            <para>Implements <see cref="T:NQualityOfLife.Geometry.IPolygon"/> &lt;- <see cref="T:NQualityOfLife.Geometry.IGeometry2D"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.IsSquare">
            <summary>Is <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IRectangle"/> a square?</summary>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IRectangle"/> is a square</returns>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Width">
            <summary>The width of the <see cref="T:NQualityOfLife.Geometry.IRectangle"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Height">
            <summary>The height of the <see cref="T:NQualityOfLife.Geometry.IRectangle"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Diagonal">
            <summary>The distance from corner to corner</summary>
            <remarks>Defined in <see cref="T:NQualityOfLife.Geometry.IRectangle"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Size">
            <summary>The <see cref="P:NQualityOfLife.Geometry.IRectangle.Width">Width</see> and <see cref="P:NQualityOfLife.Geometry.IRectangle.Height">Height</see> as a <see cref="T:NQualityOfLife.Types.Vector2Float"/></summary>
            <remarks>Defined in <see cref="T:NQualityOfLife.Geometry.IRectangle"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.BottomLeftCorner">
            <summary>The bottom left corner of the <see cref="T:NQualityOfLife.Geometry.IRectangle">Rectangle</see> in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.BottomRightCorner">
            <summary>The bottom right corner of the <see cref="T:NQualityOfLife.Geometry.IRectangle">Rectangle</see> in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.TopLeftCorner">
            <summary>The top left corner of the <see cref="T:NQualityOfLife.Geometry.IRectangle">Rectangle</see> in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.TopRightCorner">
            <summary>The top right corner of the <see cref="T:NQualityOfLife.Geometry.IRectangle">Rectangle</see> in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Top">
            <summary>The top line of the <see cref="T:NQualityOfLife.Geometry.IRectangle">Rectangle</see> in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Bottom">
            <summary>The bottom line of the <see cref="T:NQualityOfLife.Geometry.IRectangle">Rectangle</see> in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Left">
            <summary>The left line of the <see cref="T:NQualityOfLife.Geometry.IRectangle">Rectangle</see> in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.Right">
            <summary>The right line of the <see cref="T:NQualityOfLife.Geometry.IRectangle">Rectangle</see> in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.InnerSquare">
            <summary>Get the largest possible <see cref="T:NQualityOfLife.Geometry.Square"/> that fits inside <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IRectangle"/><para>The middle of the returned <see cref="T:NQualityOfLife.Geometry.Square"/> should be the same as the <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> of <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IRectangle"/></para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IRectangle.OuterSquare">
            <summary>Get the smallest possible <see cref="T:NQualityOfLife.Geometry.Square"/> that fully contains <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IRectangle"/><para>The middle of the returned <see cref="T:NQualityOfLife.Geometry.Square"/> should be the same as the <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> of <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IRectangle"/></para></summary>
        </member>
        <member name="T:NQualityOfLife.Geometry.Rectangle">
            <summary>A 2D <see cref="T:NQualityOfLife.Geometry.IRectangle"/></summary>
            <remarks>Does not support rotation</remarks>
        </member>
        <member name="F:NQualityOfLife.Geometry.Rectangle.position">
            <summary>Top left corner in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary></summary>
            <param name="x">The x component of the <see cref="P:NQualityOfLife.Geometry.Rectangle.Position"/> (<see cref="P:NQualityOfLife.Geometry.Rectangle.TopLeftCorner"/>) for <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/></param>
            <param name="y">The y component of the <see cref="P:NQualityOfLife.Geometry.Rectangle.Position"/> (<see cref="P:NQualityOfLife.Geometry.Rectangle.TopLeftCorner"/>) for <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.#ctor(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Types.Vector2Float@)">
            <summary></summary>
            <param name="position">The <see cref="P:NQualityOfLife.Geometry.Rectangle.Position"/> (<see cref="P:NQualityOfLife.Geometry.Rectangle.TopLeftCorner"/>) for <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/></param>
            <param name="size"></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.#ctor(NQualityOfLife.Types.Vector2Float@,NQualityOfLife.Geometry.Point2D@)">
            <summary></summary>
            <param name="size"></param>
            <param name="position">The <see cref="P:NQualityOfLife.Geometry.Rectangle.Position"/> (<see cref="P:NQualityOfLife.Geometry.Rectangle.TopLeftCorner"/>) for <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.#ctor(NQualityOfLife.Geometry.Point2D@,System.Single,System.Single)">
            <summary></summary>
            <param name="position">The <see cref="P:NQualityOfLife.Geometry.Rectangle.Position"/> (<see cref="P:NQualityOfLife.Geometry.Rectangle.TopLeftCorner"/>) for <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.#ctor(NQualityOfLife.Geometry.Rectangle@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that is an identical copy of the input <paramref name="copyOtherRectangle"/></summary>
            <param name="copyOtherRectangle"><see cref="T:NQualityOfLife.Geometry.Rectangle"/> to copy</param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.#ctor(NQualityOfLife.Geometry.IRectangle@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Rectangle.#ctor(NQualityOfLife.Geometry.Rectangle@)"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Rectangle.X">
            <summary>Top left corner X in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
            <inheritdoc cref="P:NQualityOfLife.Geometry.IGeometry2D.X"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Rectangle.Y">
            <summary>Top left corner Y in <see cref="F:NQualityOfLife.Types.CoordinateContext.UnityScreenSpace"/></summary>
            <inheritdoc cref="P:NQualityOfLife.Geometry.IGeometry2D.Y"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Rectangle.Position">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IGeometry2D.Position"/>
            <inheritdoc cref="F:NQualityOfLife.Geometry.Rectangle.position"/>
            <remarks>For <see cref="T:NQualityOfLife.Geometry.Rectangle"/> (<see langword="this"/>) the <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Position"/> is the top left corner</remarks>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.op_Explicit(NQualityOfLife.Geometry.Rectangle@)~NQualityOfLife.Geometry.Square">
            <summary></summary>
            <param name="squareRectangle"></param>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.ScaledBy(NQualityOfLife.Types.Factor2@)">
            <summary></summary>
            <param name="scaleFactor"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/> where the <see cref="P:NQualityOfLife.Geometry.Rectangle.Middle"/> is the same as the input <see cref="T:NQualityOfLife.Geometry.Rectangle"/> and the size is multiplied by the given <see cref="T:NQualityOfLife.Types.Factor2"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.ScaledBy(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Rectangle.ScaledBy(NQualityOfLife.Types.Factor2@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.MovedBy(System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Rectangle.MovedBy(NQualityOfLife.Types.Vector2Float@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Rectangle.MovedBy(NQualityOfLife.Types.Vector2Float@)">
            <summary></summary>
            <param name="offset"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/> where the <see cref="P:NQualityOfLife.Geometry.Rectangle.Middle"/>/<see cref="P:NQualityOfLife.Geometry.Rectangle.Position"/> has been shifted by the given <paramref name="offset"/> but the dimensions remain the same</returns>
        </member>
        <member name="T:NQualityOfLife.Geometry.ISquare">
            <summary>A 2D <see cref="T:NQualityOfLife.Geometry.Square"/></summary>
            <remarks>The <see cref="T:NQualityOfLife.Geometry.ISquare"/> is a <see cref="T:NQualityOfLife.Geometry.IRectangle"/> that has the same width and height
            <para>Does not support rotation</para>
            <para>Implements <see cref="T:NQualityOfLife.Geometry.IRectangle"/>, <see cref="T:NQualityOfLife.Geometry.INewCopy`1"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ISquare.Diagonal">
            <summary>The distance between opposing corners of the square.
            <para>Geometry term: <b>Diagonal</b> (the line segment connecting opposite vertices).</para></summary>
            <remarks>The <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> should remain un-changed when setting this value</remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ISquare.SideLength">
            <summary>The length of the sides of the square.
            <para>Geometry term: <b>Side length</b> (commonly denoted as <c>a</c>).</para></summary>
            <remarks>The <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> should remain un-changed when setting this value</remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ISquare.OuterCircle">
            <summary>The smallest possible <see cref="T:NQualityOfLife.Geometry.Circle"/> that fully contains <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.ISquare"/>.
            <para>Geometry term: <b>Circumcircle</b> (circle through all four vertices).</para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ISquare.InnerCircle">
            <summary>The largest possible <see cref="T:NQualityOfLife.Geometry.Circle"/> that fits entirely inside <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.ISquare"/>.
            <para>Geometry term: <b>Incircle</b> (circle tangent to all four sides).</para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ISquare.Area">
            <summary>The total geometric area of the <see cref="T:NQualityOfLife.Geometry.ISquare"/>.
            <para>Geometry term: <b>Area</b> (for a square, <c>a</c> where <c>a</c> is the side length).</para></summary>
            <remarks>The <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> should remain un-changed when setting this value</remarks>
        </member>
        <member name="T:NQualityOfLife.Geometry.Square">
            <summary>A 2D <see cref="T:NQualityOfLife.Geometry.Square"/></summary>
            <remarks>Does not support rotation
            <para>Implements <see cref="T:NQualityOfLife.Geometry.ISquare"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Geometry.Square.position">
            <summary>The top left corner of the <see cref="T:NQualityOfLife.Geometry.Square"/></summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.Square.#ctor(NQualityOfLife.Geometry.Rectangle@)">
            <summary></summary>
            <param name="squareRect"></param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.Square.#ctor(System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Square"/> with a <paramref name="sideLength"/> and the default <see cref="P:NQualityOfLife.Geometry.Square.Position"/></summary>
            <param name="sideLength"></param>
        </member>
        <member name="P:NQualityOfLife.Geometry.Square.Position">
            <summary>Top left corner of <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Square"/></summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.Square.op_Explicit(UnityEngine.Rect@)~NQualityOfLife.Geometry.Square">
            <summary></summary>
            <param name="squareRect"></param>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:NQualityOfLife.Geometry.Square.Contains(NQualityOfLife.Geometry.Point2D@)">
            <summary></summary>
            <param name="point"></param>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Square"/> contains the given <paramref name="point"/></returns>
        </member>
        <member name="T:NQualityOfLife.Geometry.ICircle">
            <summary>Represents a 2D <see cref="T:NQualityOfLife.Geometry.ICircle"/> <seealso cref="T:NQualityOfLife.Geometry.IGeometry2D">geometric shape</seealso>.
            <para>Provides properties for <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso>, <seealso cref="P:NQualityOfLife.Geometry.ICircle.Diameter">diameter</seealso>, <seealso cref="P:NQualityOfLife.Geometry.ICircle.Circumference">circumference</seealso>, and helper <seealso cref="T:NQualityOfLife.Geometry.Square">squares</seealso>.</para></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Geometry.IGeometry2D"/>
            <para>Implements <see cref="T:NQualityOfLife.Geometry.IScale`1"/> where 'T' is <see cref="T:NQualityOfLife.Geometry.ICircle"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ICircle.Radius">
            <summary>The radius of the <see cref="T:NQualityOfLife.Geometry.ICircle"/>, defined as the distance from the <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> point to the edge of the circle.
            <para>Mathematically, <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso> = <seealso cref="P:NQualityOfLife.Geometry.ICircle.Diameter">diameter</seealso> / 2.</para>
            <para>Also known as the <b>circumradius</b> of the circle.</para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ICircle.Diameter">
            <summary>The diameter of the <see cref="T:NQualityOfLife.Geometry.ICircle"/>, defined as the distance across the circle through its <seealso cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle">center</seealso>.
            <para>Mathematically, <seealso cref="P:NQualityOfLife.Geometry.ICircle.Diameter">diameter</seealso> = <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso> * 2.</para>
            <para>Also called the <b>width across</b> or <b>chord length through center</b>.</para></summary>
            <remarks>Setting this property will adjust the <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso> of the <see cref="T:NQualityOfLife.Geometry.ICircle"/> to match the specified diameter.
            <para>The new <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso> is calculated as <c>Diameter / 2</c>.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ICircle.Circumference">
            <summary>The circumference (perimeter) of the <see cref="T:NQualityOfLife.Geometry.ICircle"/>.
            <para>Calculated as 2 *  * <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso>.</para>
            <para>Represents the total distance around the circle.</para></summary>
            <remarks>Setting this property will adjust the <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso> of the <see cref="T:NQualityOfLife.Geometry.ICircle"/> to match the specified circumference.
            <para>The new <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso> is calculated as <c>Circumference / (2 * )</c>.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ICircle.Area">
            <summary>The total area of the <see cref="T:NQualityOfLife.Geometry.ICircle"/>.
            <para>Calculated as <c>  <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso></c>.</para></summary>
            <remarks>Setting this property will adjust the <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso> of the <see cref="T:NQualityOfLife.Geometry.ICircle"/> to match the specified area.
            <para>The new <seealso cref="P:NQualityOfLife.Geometry.ICircle.Radius">radius</seealso> is calculated as <c>(Area / )</c>.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.ICircle.OuterSquare">
            <summary>The smallest possible <see cref="T:NQualityOfLife.Geometry.Square"/> that completely contains this <see cref="T:NQualityOfLife.Geometry.ICircle"/>.
            <para>Also known as the <b>circumscribed square</b> or <b>outer square</b>.</para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.ICircle.InnerSquare">
            <summary>The largest possible <see cref="T:NQualityOfLife.Geometry.Square"/> that fits entirely inside this <see cref="T:NQualityOfLife.Geometry.ICircle"/>.
            <para>Also known as the <b>inscribed square</b> or <b>inner square</b>.</para></summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.ICircle.ScaledBy(NQualityOfLife.Types.Factor@)">
            <summary>Multiply the <see cref="P:NQualityOfLife.Geometry.ICircle.Radius"/> by the given <paramref name="factor"/></summary>
            <param name="factor"></param>
            <returns>The scaled <see cref="T:NQualityOfLife.Geometry.ICircle"/></returns>
            <remarks>The <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> of the returned <see cref="T:NQualityOfLife.Geometry.ICircle"/> should be the same as <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.ICircle"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Geometry.Circle">
            <inheritdoc cref="T:NQualityOfLife.Geometry.ICircle"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.#ctor(NQualityOfLife.Geometry.Point2D@,System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Circle"/> centered on <paramref name="middle"/></summary>
            <param name="middle"></param>
            <param name="radius">The <see cref="P:NQualityOfLife.Geometry.Circle.Radius"/> of the <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Circle"/></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.#ctor(System.Single,NQualityOfLife.Geometry.Point2D@)">
             <inheritdoc cref="M:NQualityOfLife.Geometry.Circle.#ctor(NQualityOfLife.Geometry.Point2D@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.Equals(System.Object)">
            <summary></summary><param name="obj"></param>
            <returns><see langword="true"/> if the <paramref name="obj"/> is a <see cref="T:NQualityOfLife.Geometry.ICircle"/> and has the same <see cref="P:NQualityOfLife.Geometry.Circle.Radius"/> and <see cref="P:NQualityOfLife.Geometry.Circle.Middle"/> as <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Circle"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.Equals(NQualityOfLife.Geometry.Circle)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Circle.op_Equality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.Circle@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.Equals(NQualityOfLife.Geometry.ICircle)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Circle.op_Equality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.Circle@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.op_Equality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.Circle@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see langword="true"/> if the two <see cref="T:NQualityOfLife.Geometry.Circle"/>s have the same <see cref="P:NQualityOfLife.Geometry.Circle.Radius"/> and <see cref="P:NQualityOfLife.Geometry.Circle.Middle"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.op_Inequality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.Circle@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see langword="false"/> if the two <see cref="T:NQualityOfLife.Geometry.Circle"/>s have the same <see cref="P:NQualityOfLife.Geometry.Circle.Radius"/> and <see cref="P:NQualityOfLife.Geometry.Circle.Middle"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.op_Equality(NQualityOfLife.Geometry.ICircle@,NQualityOfLife.Geometry.Circle@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Circle.op_Equality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.Circle@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.op_Inequality(NQualityOfLife.Geometry.ICircle@,NQualityOfLife.Geometry.Circle@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Circle.op_Inequality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.Circle@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.op_Equality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.ICircle@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Circle.op_Equality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.Circle@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Circle.op_Inequality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.ICircle@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Circle.op_Inequality(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Geometry.Circle@)"/>
        </member>
        <member name="T:NQualityOfLife.Geometry.IHexagon">
            <summary>Represents a regular hexagon (six-sided polygon) in 2D space.
            <para>Extends <see cref="T:NQualityOfLife.Geometry.IPolygon"/> &lt;- <see cref="T:NQualityOfLife.Geometry.IGeometry2D"/></para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.Angle">
            <summary>The angle of the hexagon, where 0 is point up and flats to the sides
            <para>Positive numbers rotate the hexagon clockwise</para>
            <para><see cref="P:NQualityOfLife.Geometry.IHexagon.Angle"/> of 90 means the top point is now the right most point, and the hexagon is positioned with flats up and down</para></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.Area">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPolygon.Area"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.Width">
            <summary>The flat-to-flat width (distance between opposite sides) of the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>.</summary>
            <remarks>Also called the <b>span</b> or <b>flat width</b>.  
            <para>Getter: Calculated as <c>Width = sqrt(3) * CircumRadius</c>.</para>
            <para>Setter: Adjusts <see cref="P:NQualityOfLife.Geometry.IHexagon.CircumRadius"/> so that the new Width satisfies <c>CircumRadius = Width / sqrt(3)</c>.</para>
            <para>Changing this property will automatically update dependent properties like <see cref="P:NQualityOfLife.Geometry.IHexagon.Height"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.SideLength"/>, and <see cref="P:NQualityOfLife.Geometry.IHexagon.InRadius"/>.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.Height">
            <summary>The point-to-point height (distance between opposite vertices) of the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>.</summary>
            <remarks>Also called the <b>vertex-to-vertex distance</b>.  
            <para>Getter: Calculated as <c>Height = 2 * CircumRadius</c>.</para>
            <para>Setter: Adjusts <see cref="P:NQualityOfLife.Geometry.IHexagon.CircumRadius"/> so that the new Height satisfies <c>CircumRadius = Height / 2</c>.</para>
            <para>Changing this property will automatically update dependent properties like <see cref="P:NQualityOfLife.Geometry.IHexagon.Width"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.SideLength"/>, and <see cref="P:NQualityOfLife.Geometry.IHexagon.InRadius"/>.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.CircumRadius">
            <summary>The radius of the circumcircle, i.e., a circle that passes through all corners of the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>.</summary>
            <remarks><para>Getter: Returns the distance from the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>'s center to any of its corners.</para>
            <para>Setter: Updates all size-dependent properties (<see cref="P:NQualityOfLife.Geometry.IHexagon.Width"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.Height"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.SideLength"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.InRadius"/>)
            so that the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso> remains regular with the new circumradius.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.InRadius">
            <summary>The radius of the largest circle that fits entirely inside the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso> (the inradius).</summary>
            <remarks><para>Getter: Calculated as <c>InRadius = CircumRadius * 0.5f * sqrt(3)</c><para> or <c>CircumRadius * cos(30)</c>.</para></para>
            <para>Setter: Adjusts <see cref="P:NQualityOfLife.Geometry.IHexagon.CircumRadius"/> so that the new InRadius satisfies <c>CircumRadius = InRadius / cos(30)</c>.</para>
            <para>Changing this property updates all dependent properties like <see cref="P:NQualityOfLife.Geometry.IHexagon.Width"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.Height"/>, and <see cref="P:NQualityOfLife.Geometry.IHexagon.SideLength"/>.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.SideLength">
            <summary>The length of each edge (side) of the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>.</summary>
            <remarks>Also called the <b>side length</b> (commonly denoted as <c>a</c>).  
            <para>Getter: Calculated as <c>SideLength = CircumRadius</c> (for a regular <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>).</para>
            <para>Setter: Updates <see cref="P:NQualityOfLife.Geometry.IHexagon.CircumRadius"/> so that the new side length is satisfied, which in turn updates dependent properties (<see cref="P:NQualityOfLife.Geometry.IHexagon.Width"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.Height"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.InRadius"/>).</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.CircumCircle">
            <summary>The circumcircle of the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso> (circle passing through all corners).</summary>
            <remarks><para>Getter: Returns a <see cref="T:NQualityOfLife.Geometry.Circle"/> centered at the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>'s middle with radius equal to <see cref="P:NQualityOfLife.Geometry.IHexagon.CircumRadius"/>.</para>
            <para>Setter: Updates the <see cref="P:NQualityOfLife.Geometry.IHexagon.CircumRadius"/> and all dependent properties so that the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso> remains regular with the new circumcircle.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.InnerCircle">
            <summary>The <b>incircle</b> of the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso> (largest circle that fits entirely inside the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>).</summary>
            <remarks><para>Getter: Returns a <see cref="T:NQualityOfLife.Geometry.Circle"/> centered at the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>'s middle with radius equal to <see cref="P:NQualityOfLife.Geometry.IHexagon.InRadius"/>.</para>
            <para>Setter: Adjusts <see cref="P:NQualityOfLife.Geometry.IHexagon.CircumRadius"/> so that the new <b>incircle</b> radius is satisfied, updating dependent properties accordingly.</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Geometry.IHexagon.Circumference">
            <summary>The perimeter of the <seealso cref="T:NQualityOfLife.Geometry.IHexagon">hexagon</seealso>.</summary>
            <remarks><para>Getter: Calculated as <c>Circumference = 6 * SideLength</c>.</para>
            <para>Setter: Adjusts <see cref="P:NQualityOfLife.Geometry.IHexagon.SideLength"/> so that the new circumference is satisfied, which in turn updates <see cref="P:NQualityOfLife.Geometry.IHexagon.CircumRadius"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.Width"/>, <see cref="P:NQualityOfLife.Geometry.IHexagon.Height"/>, and <see cref="P:NQualityOfLife.Geometry.IHexagon.InRadius"/>.</para></remarks>
        </member>
        <member name="T:NQualityOfLife.Geometry.Hexagon">
            <inheritdoc cref="T:NQualityOfLife.Geometry.IHexagon"/>
        </member>
        <member name="F:NQualityOfLife.Geometry.Hexagon.NumberOfSides">
            <summary>The number of sides on a <see cref="T:NQualityOfLife.Geometry.Hexagon">hexagon</see></summary>
        </member>
        <member name="F:NQualityOfLife.Geometry.Hexagon.__preCalcForArea">
            <summary>The constant used for calculating the <see cref="P:NQualityOfLife.Geometry.Hexagon.Area"/> of a <see cref="T:NQualityOfLife.Geometry.Hexagon"/> from the length of the <see cref="P:NQualityOfLife.Geometry.Hexagon.Edges"/></summary>
        </member>
        <member name="F:NQualityOfLife.Geometry.Hexagon._positionCircumCircle">
            <summary>The <seealso cref="P:NQualityOfLife.Geometry.Hexagon.Corners">corners</seealso> of <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.Hexagon"/> are placed on the edge of this <see cref="T:NQualityOfLife.Geometry.Circle"/></summary>
        </member>
        <member name="F:NQualityOfLife.Geometry.Hexagon._angle">
            <inheritdoc cref="P:NQualityOfLife.Geometry.IHexagon.Angle"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Hexagon.#ctor(NQualityOfLife.Geometry.Point2D@,System.Single,NQualityOfLife.Units.Degrees@)">
            <summary></summary>
            <param name="center">The <seealso cref="P:NQualityOfLife.Geometry.Hexagon.Middle">center / middle</seealso> of the <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Hexagon"/></param>
            <param name="circumRadiusSlashSideLength">The <seealso cref="P:NQualityOfLife.Geometry.Hexagon.CircumRadius">Circumradius</seealso> / <seealso cref="P:NQualityOfLife.Geometry.Hexagon.SideLength">side length</seealso> of the <see cref="T:NQualityOfLife.Geometry.Hexagon"/></param>
            <param name="angle"></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Hexagon.#ctor(System.Single,NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Hexagon.#ctor(NQualityOfLife.Geometry.Point2D@,System.Single,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Hexagon.#ctor(NQualityOfLife.Geometry.Circle@,NQualityOfLife.Units.Degrees@)">
            <summary>The <seealso cref="P:NQualityOfLife.Geometry.Hexagon.Corners">corners</seealso> of the <see cref="T:NQualityOfLife.Geometry.Hexagon"/> will be placed on the edges of the input <see cref="T:NQualityOfLife.Geometry.Circle"/></summary>
            <param name="circumCircle">Place the <seealso cref="P:NQualityOfLife.Geometry.Hexagon.Corners">corners</seealso> of the <see cref="T:NQualityOfLife.Geometry.Hexagon"/> on the edges of this <see cref="T:NQualityOfLife.Geometry.Circle"/>
            <para>This is also know as the <b>Circumcircle</b> of the <see cref="T:NQualityOfLife.Geometry.Hexagon"/></para></param>
            <param name="angle"></param>
        </member>
        <member name="M:NQualityOfLife.Geometry.Hexagon.Rotate(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPolygon.Rotate(NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Triangle.Vertices">
            <inheritdoc cref="P:NQualityOfLife.Geometry.Triangle.Corners"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Triangle.Corners">
            <remarks>Returns the corners in the order:
            <para>a, b, c</para></remarks>
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPolygon.Corners"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Triangle.Edges">
            <remarks>Returns the edges in the order:
            <para>ab, bc, ca</para></remarks>
            <inheritdoc cref="P:NQualityOfLife.Geometry.IPolygon.Edges"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Triangle.Sides">
            <inheritdoc cref="P:NQualityOfLife.Geometry.Triangle.Edges"/>
        </member>
        <member name="P:NQualityOfLife.Geometry.Triangle.InRadius">
            <summary>The <see cref="P:NQualityOfLife.Geometry.Circle.Radius"/> of the <see cref="P:NQualityOfLife.Geometry.Triangle.InnerCircle"/></summary>
        </member>
        <member name="P:NQualityOfLife.Geometry.Triangle.InCenter">
            <summary>The <see cref="P:NQualityOfLife.Geometry.Circle.Middle"/> of the <see cref="P:NQualityOfLife.Geometry.Triangle.InnerCircle"/></summary>
        </member>
        <member name="M:NQualityOfLife.Geometry.Triangle.Rotate(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPolygon.Rotate(NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.Triangle.Rotated(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IPolygon.Rotate(NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="T:NQualityOfLife.Geometry.IImmutableGeometry">
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Geometry.IProjectable">
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Geometry.ILineCurve2D">
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Geometry.INewCopy`1">
            <remarks>Implements <see cref="T:System.ICloneable"/>
            <para>Extends <see cref="T:NQualityOfLife.Types.ICoordinateContext"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
            <inheritdoc cref="T:System.ICloneable"/>
            <summary></summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:NQualityOfLife.Geometry.ITranspose`1">
            <summary>Defines methods for moving '<typeparamref name="T"/>' by a given x,y offset</summary>
            <typeparam name="T"></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Geometry.ITranspose`1.MovedBy(NQualityOfLife.Types.Vector2Float@)">
            <summary></summary>
            <param name="offset"></param>
            <returns>A <see langword="new"/> <typeparamref name="T"/> where the position has been moved by the given <paramref name="offset"/></returns>
            <remarks><see langword="this"/> instance should not be <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#mutation">mutated</see>
            <para>Defined in <see cref="T:NQualityOfLife.Geometry.ITranspose`1"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Geometry.ITranspose`1.MovedBy(System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.ITranspose`1.MovedBy(NQualityOfLife.Types.Vector2Float@)"/>
            <summary></summary>
            <param name="offsetX">Offset of the horizontal position</param>
            <param name="offsetY">Offset of the vertical position</param>
            <returns></returns>
            <remarks><see langword="this"/> instance should not be <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#mutation">mutated</see>
            <para>Defined in <see cref="T:NQualityOfLife.Geometry.ITranspose`1"/></para></remarks>
        </member>
        <member name="T:NQualityOfLife.Geometry.IScale`1">
            <summary></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> that is returned when <see langword="this"/> <see cref="T:NQualityOfLife.Geometry.IScale`1"/> is scaled</typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Geometry.IScale`1.ScaledBy(NQualityOfLife.Types.Factor@)">
            <summary>Scale all dimensions of the shape by the given <paramref name="factor"/></summary>
            <param name="factor"></param>
            <remarks>The <see langword="new"/> <typeparamref name="T"/> should have the same <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> as the input <typeparamref name="T"/></remarks>
            <returns>a <see langword="new"/> <typeparamref name="T"/> that is a copy of <see langword="this"/> instance, scaled by the given <paramref name="factor"/></returns>
        </member>
        <member name="T:NQualityOfLife.Geometry.IScaleXY`1">
            <remarks>Extends <see cref="T:NQualityOfLife.Geometry.IScale`1"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.Geometry.IScale`1"/>
        </member>
        <member name="M:NQualityOfLife.Geometry.IScaleXY`1.ScaledBy(NQualityOfLife.Types.Factor2@)">
            <summary></summary>
            <param name="scaleFactor"></param>
            <returns>a <see langword="new"/> <typeparamref name="T"/> where the <see cref="P:NQualityOfLife.Geometry.IGeometry2D.Middle"/> is the same as the input <typeparamref name="T"/> and the size is multiplied by the given <see cref="T:NQualityOfLife.Types.Factor2"/></returns>
        </member>
        <member name="M:NQualityOfLife.Geometry.IScaleXY`1.ScaledBy(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.IScaleXY`1.ScaledBy(NQualityOfLife.Types.Factor2@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.MassFlow">
            <summary><see cref="T:NQualityOfLife.Units.MassFlow"/> in <seealso cref="T:NQualityOfLife.Units.Kg">kg</seealso>/<seealso cref="T:NQualityOfLife.Units.Second">s</seealso><para>Describes how much mass flows through something per <see cref="T:NQualityOfLife.Units.Second"/></para></summary>
            <remarks><see cref="T:NQualityOfLife.Units.Kg"/> / <see cref="T:NQualityOfLife.Units.Second"/>
            <para><b>MT^-1</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.MassFlow._flow">
            <summary>The <see cref="T:NQualityOfLife.Units.MassFlow"/> in <seealso cref="T:NQualityOfLife.Units.Kg">kg</seealso>/<seealso cref="T:NQualityOfLife.Units.Second">s</seealso></summary>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.MassFlow"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Second@)">
            <remarks><see cref="T:NQualityOfLife.Units.Kg">M</see> / <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.MassFlow">MT^-1</see>
            <para><see cref="T:NQualityOfLife.Units.Kg"/> / <see cref="T:NQualityOfLife.Units.Second"/></para></remarks>
            <summary>Get <see cref="T:NQualityOfLife.Units.MassFlow"/> from <paramref name="mass"/> <paramref name="perSecond"/></summary>
            <param name="mass">How much total <paramref name="mass"/> is transferred</param>
            <param name="perSecond">How much time it took to transfer the given <paramref name="mass"/></param>
            <inheritdoc cref="T:NQualityOfLife.Units.MassFlow"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.VolumetricFlow@,NQualityOfLife.Units.Density@)">
            <remarks><see cref="T:NQualityOfLife.Units.VolumetricFlow">LT^-1</see> * <see cref="T:NQualityOfLife.Units.Density">ML^-3</see> == <see cref="T:NQualityOfLife.Units.MassFlow">MT^-1</see></remarks>
            <summary>Calculate how much <see cref="T:NQualityOfLife.Units.IMass">mass</see> moves per <see cref="T:NQualityOfLife.Units.Second"/> from the <paramref name="volumetricFlow"/> and the <paramref name="massDensity"/> of the substance</summary>
            <param name="volumetricFlow"></param>
            <param name="massDensity">The <see cref="T:NQualityOfLife.Units.Density"/> of the fluid</param>
            <remarks><see cref="T:NQualityOfLife.Units.Kg"/> / <see cref="T:NQualityOfLife.Units.Second"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.MassFlow"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.VolumetricFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.VolumetricFlow@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Density@)">
            <remarks><see cref="T:NQualityOfLife.Units.Area">L</see> * <see cref="T:NQualityOfLife.Units.Speed">LT^-1</see> * <see cref="T:NQualityOfLife.Units.Density">ML^-3</see> == <see cref="T:NQualityOfLife.Units.MassFlow">MT^-1</see></remarks>
            <summary>Calculate the amount of mass that flows through the given <paramref name="crossSection"/> when given the <paramref name="flowVelocity"/> and the <paramref name="massDensity"/> of the substance</summary>
            <param name="crossSection">The cross sectional <see cref="T:NQualityOfLife.Units.Area"/> of for example the pipe that a fluid is flowing through</param>
            <param name="flowVelocity">The <see cref="T:NQualityOfLife.Units.Speed"/> of the fluid through the <paramref name="crossSection"/></param>
            <param name="massDensity">The <see cref="T:NQualityOfLife.Units.Density"/> of the fluid</param>
            <remarks><see cref="T:NQualityOfLife.Units.Kg"/> / <see cref="T:NQualityOfLife.Units.Second"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.MassFlow"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Density@,NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Area@,NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Density@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Area@,NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.MassFlux@,NQualityOfLife.Units.Area@)">
            <remarks><see cref="T:NQualityOfLife.Units.MassFlux">MT^-1L^-2</see> / <see cref="T:NQualityOfLife.Units.Area">L</see> == <see cref="T:NQualityOfLife.Units.MassFlow">MT^-1</see></remarks>
            <summary></summary>
            <param name="massFlux"></param>
            <param name="crossSection"></param>
            <remarks><see cref="T:NQualityOfLife.Units.Kg"/> / <see cref="T:NQualityOfLife.Units.Second"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.MassFlow"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.MassFlux@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.MassFlux@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="P:NQualityOfLife.Units.MassFlow.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.MassFlow._flow"/>
        </member>
        <member name="P:NQualityOfLife.Units.MassFlow.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.MassFlow"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Kg@)">
            <summary>Solve how long it takes to transfer the given mass amount at the given <see cref="T:NQualityOfLife.Units.MassFlow"/></summary>
            <param name="val"></param>
            <returns>The total time it takes to transfer the mass in <see cref="T:NQualityOfLife.Units.Second"/>s</returns>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.VolumetricFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.VolumetricFlow@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlux.#ctor(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Second@)">
            <summary>Solve for the total transferred mass</summary>
            <param name="val"></param>
            <returns>The total transferred mass in <see cref="T:NQualityOfLife.Units.Kg"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.op_Division(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.VolumetricFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.VolumetricFlow@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.op_Multiply(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.op_Multiply(NQualityOfLife.Units.Second@,NQualityOfLife.Units.MassFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.op_Multiply(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.op_Multiply(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.MassFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.op_Division(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlow.op_Division(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.SolveFor(NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.MassFlux">
            <summary></summary>
            <remarks><b>MT^-1L^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.MassFlux._flux">
            <inheritdoc cref="T:NQualityOfLife.Units.MassFlux"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlux.#ctor(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.Area@)">
            <remarks><see cref="T:NQualityOfLife.Units.MassFlow">MT^-1</see> / <see cref="T:NQualityOfLife.Units.Area">L</see> == <see cref="T:NQualityOfLife.Units.MassFlux">MT^-1L^-2</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlux.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Second@,NQualityOfLife.Units.Area@)">
            <remarks><see cref="T:NQualityOfLife.Units.MassFlow">M</see> / <see cref="T:NQualityOfLife.Units.Second">T</see> / <see cref="T:NQualityOfLife.Units.Area">L</see> == <see cref="T:NQualityOfLife.Units.MassFlux">MT^-1L^-2</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.MassFlux.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.MassFlux._flux"/>
        </member>
        <member name="P:NQualityOfLife.Units.MassFlux.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.MassFlux"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlux.SolveFor(NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.MassFlux@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlux.op_Multiply(NQualityOfLife.Units.MassFlux@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.MassFlux@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.MassFlux.op_Multiply(NQualityOfLife.Units.Area@,NQualityOfLife.Units.MassFlux@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.MassFlux@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.VolumetricFlow">
            <summary><see cref="T:NQualityOfLife.Units.VolumetricFlow"/> in <see cref="T:NQualityOfLife.Units.Volume"/>/<see cref="T:NQualityOfLife.Units.Second"/><para><see cref="T:NQualityOfLife.Units.VolumetricFlow"/> is the amount of <see cref="T:NQualityOfLife.Units.Volume"/> that flows through something in one <see cref="T:NQualityOfLife.Units.Second"/></para></summary>
            <remarks><see cref="T:NQualityOfLife.Units.Volume"/> / <see cref="T:NQualityOfLife.Units.Second"/>
            <para><b>LT^-1</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.VolumetricFlow._flow">
            <inheritdoc cref="T:NQualityOfLife.Units.VolumetricFlow"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Second@)">
            <remarks><see cref="T:NQualityOfLife.Units.Volume">L</see> / <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.VolumetricFlow">LT^-1</see></remarks>
            <summary>Get the <see cref="T:NQualityOfLife.Units.VolumetricFlow"/> from the total transferred <paramref name="volume"/> in the given time</summary>
            <param name="volume">The total amount of <paramref name="volume"/> that is moved through something</param>
            <param name="perSecond">How long it took to move the given <paramref name="volume"/></param>
            <remarks><see cref="T:NQualityOfLife.Units.Volume"/> / <see cref="T:NQualityOfLife.Units.Second"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Density@,NQualityOfLife.Units.Second@)">
            <remarks><see cref="T:NQualityOfLife.Units.Kg">M</see> / <see cref="T:NQualityOfLife.Units.Density">ML^-3</see> / <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.VolumetricFlow">LT^-1</see></remarks>
            <summary>Calculate a <see cref="T:NQualityOfLife.Units.VolumetricFlow"/></summary>
            <param name="mass"></param>
            <param name="density"></param>
            <param name="perSecond"></param>
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.Density@)">
            <remarks><see cref="T:NQualityOfLife.Units.MassFlow">MT^-1</see> / <see cref="T:NQualityOfLife.Units.Density">ML^-3</see> == <see cref="T:NQualityOfLife.Units.VolumetricFlow">LT^-1</see></remarks>
            <summary>Convert a <see cref="T:NQualityOfLife.Units.MassFlow"/> into a <see cref="T:NQualityOfLife.Units.VolumetricFlow"/> using the <see cref="T:NQualityOfLife.Units.Density"/> of the material</summary>
            <param name="massFlow">The <see cref="T:NQualityOfLife.Units.MassFlow"/></param>
            <param name="density">The <see cref="T:NQualityOfLife.Units.Density"/> of the flowing material</param>
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="P:NQualityOfLife.Units.VolumetricFlow.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.VolumetricFlow._flow"/>
        </member>
        <member name="P:NQualityOfLife.Units.VolumetricFlow.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.VolumetricFlow"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.MassFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.VolumetricFlow@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.VolumetricFlow@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.op_Multiply(NQualityOfLife.Units.VolumetricFlow@,NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.VolumetricFlow@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.op_Multiply(NQualityOfLife.Units.Density@,NQualityOfLife.Units.VolumetricFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.VolumetricFlow@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Volume@)">
            <summary>Solve how long it takes to transfer the given <see cref="T:NQualityOfLife.Units.Volume"/> at the given <see cref="T:NQualityOfLife.Units.VolumetricFlow"/></summary>
            <param name="val"></param>
            <returns>The total time it takes to transfer the volume in <see cref="T:NQualityOfLife.Units.Second"/>s</returns>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.op_Multiply(NQualityOfLife.Units.VolumetricFlow@,NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.op_Multiply(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.VolumetricFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Second@)">
            <summary>Solve how much volume is transferred in the given time at the given <see cref="T:NQualityOfLife.Units.VolumetricFlow"/></summary>
            <param name="val"></param>
            <returns>The total <see cref="T:NQualityOfLife.Units.Volume"/> transferred in the given time at the given <see cref="T:NQualityOfLife.Units.VolumetricFlow"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.op_Multiply(NQualityOfLife.Units.VolumetricFlow@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.op_Multiply(NQualityOfLife.Units.Second@,NQualityOfLife.Units.VolumetricFlow@)">
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Density@)">
            <summary>Solve how much total mass is transferred in the given time at the given <see cref="T:NQualityOfLife.Units.VolumetricFlow"/> at the given <see cref="T:NQualityOfLife.Units.Density"/></summary>
            <param name="val">The total time that the <see cref="T:NQualityOfLife.Units.VolumetricFlow"/> is applied</param>
            <param name="density">The <see cref="T:NQualityOfLife.Units.Density"/> of the subtance</param>
            <returns>The total mass transferred in the given time at the given <see cref="T:NQualityOfLife.Units.VolumetricFlow"/> and <see cref="T:NQualityOfLife.Units.Density"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.SolveFor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Density">
            <summary>Mass <see cref="T:NQualityOfLife.Units.Density"/><para>(<see cref="T:NQualityOfLife.Units.Kg"/>/<see cref="T:NQualityOfLife.Units.Volume"/>)</para><para>Water has a <see cref="T:NQualityOfLife.Units.Density"/> of 1000<see cref="T:NQualityOfLife.Units.Kg"/>/<seealso cref="T:NQualityOfLife.Units.Volume">m</seealso> or 1<see cref="T:NQualityOfLife.Units.Kg"/>/<see cref="T:NQualityOfLife.Units.Liter"/></para></summary>
            <remarks><para><b>ML^-3</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Density._density">
            <summary>The <see cref="T:NQualityOfLife.Units.Density"/> in <seealso cref="T:NQualityOfLife.Units.Kg">kg</seealso>/<seealso cref="T:NQualityOfLife.Units.Volume">m</seealso></summary>
        </member>
        <member name="M:NQualityOfLife.Units.Density.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Density"/>
        </member>
        <member name="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Volume@)">
            <remarks><see cref="T:NQualityOfLife.Units.Kg">M</see> / <see cref="T:NQualityOfLife.Units.Volume">L</see> == <see cref="T:NQualityOfLife.Units.Density">ML^-3</see></remarks>
            <summary>Calculate the <see cref="T:NQualityOfLife.Units.Density"/> of a substance from the total <paramref name="mass"/>, and the <see cref="T:NQualityOfLife.Units.Volume"/> it occupies</summary>
            <param name="mass">The total mass of the substance contained in the given <see cref="T:NQualityOfLife.Units.Volume"/></param>
            <param name="perCube">The <see cref="T:NQualityOfLife.Units.Volume"/> that the given <paramref name="mass"/> occupies</param>
        </member>
        <member name="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.MassFlow@,NQualityOfLife.Units.VolumetricFlow@)">
            <remarks><see cref="T:NQualityOfLife.Units.MassFlow">MT^-1</see> / <see cref="T:NQualityOfLife.Units.VolumetricFlow">LT^-1</see> == <see cref="T:NQualityOfLife.Units.Density">ML^-3</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Density"/>
        </member>
        <member name="P:NQualityOfLife.Units.Density.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Density._density"/>
        </member>
        <member name="P:NQualityOfLife.Units.Density.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.MassDensity"/>
        </member>
        <member name="M:NQualityOfLife.Units.Density.op_LessThan(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Density@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see langword="true"/> if the <paramref name="left"/> <see cref="T:NQualityOfLife.Units.Density"/> is less dense than the <paramref name="right"/> one</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Density.op_GreaterThan(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Density@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see langword="true"/> if the <paramref name="left"/> <see cref="T:NQualityOfLife.Units.Density"/> is more dense than the <paramref name="right"/> one</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Density.SolveFor(NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Density.SolveFor(NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Density.op_Multiply(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Density.op_Multiply(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.op_Multiply(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="P:NQualityOfLife.Units.Density.OfZinc">
            <summary></summary>
            <remarks>At 20 <see cref="T:NQualityOfLife.Units.Celsius"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Density.OfCopper">
            <summary></summary>
            <remarks>At 20 <see cref="T:NQualityOfLife.Units.Celsius"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.IAngle">
            <summary>Interface for types that represent angles</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IMath"/> &lt;- <see cref="T:NQualityOfLife.Types.IFloat"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle.InDegrees">
            <summary>The value of this <see cref="T:NQualityOfLife.Units.IAngle"/> in <see cref="T:NQualityOfLife.Units.Degrees"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle.InRadians">
            <summary>The value of this <see cref="T:NQualityOfLife.Units.IAngle"/> in <see cref="T:NQualityOfLife.Units.Radians"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle.ToDegrees">
            <summary>The value of this <see cref="T:NQualityOfLife.Units.IAngle"/> converted to <see cref="T:NQualityOfLife.Units.Degrees"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle.ToRadians">
            <summary>The value of this <see cref="T:NQualityOfLife.Units.IAngle"/> converted to <see cref="T:NQualityOfLife.Units.Radians"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.IAngle`1">
            <summary></summary>
            <typeparam name="TU">The unit of the <see cref="T:NQualityOfLife.Units.IAngle"/></typeparam>
            <remarks>Implements <see cref="T:NQualityOfLife.Units.IAngle"/>, <see cref="T:NQualityOfLife.Types.IMath`1"/> &lt;- <see cref="T:NQualityOfLife.Types.IMath"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.IAngle`1.OneRevolution">
            <summary>1 full revolution (360 <see cref="T:NQualityOfLife.Units.Degrees"/>) in <typeparamref name="TU"/>
            <para>This value is constant and the same for all instances of '<typeparamref name="TU"/>'</para></summary>
            <returns>1 full revolution in units of '<typeparamref name="TU"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Units.IAngle`1.Abs">
            <summary>Get the Absolute value</summary>
            <returns>The absolute value (non negative) of the angle</returns>
            <remarks>y = |x|</remarks>
        </member>
        <member name="M:NQualityOfLife.Units.IAngle`1.Normalize">
            <summary>0~360</summary>
            <returns>0~360 <see cref="T:NQualityOfLife.Units.Degrees"/> in <typeparamref name="TU"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.IAngle`1.NormalizeSigned">
            <summary>-180~180</summary>
            <returns>-180~180 <see cref="T:NQualityOfLife.Units.Degrees"/> in <typeparamref name="TU"/></returns>
        </member>
        <member name="T:NQualityOfLife.Units.Degrees">
            <summary>Unit of <see cref="T:NQualityOfLife.Units.IAngle`1"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Degrees.valueDegrees">
            <summary><see cref="T:NQualityOfLife.Units.Degrees"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.#ctor(NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Degrees"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.#ctor(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Degrees"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.#ctor(NQualityOfLife.Units.IAngle@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Degrees"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Degrees"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.#ctor(System.Double)">
            <inheritdoc cref="T:NQualityOfLife.Units.Degrees"/>
        </member>
        <member name="P:NQualityOfLife.Units.Degrees.InDegrees">
            <inheritdoc cref="F:NQualityOfLife.Units.Degrees.valueDegrees"/>
        </member>
        <member name="P:NQualityOfLife.Units.Degrees.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Degrees.valueDegrees"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.ToString">
            <summary></summary>
            <returns>A string formatted like: '32' etc</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)">
            <summary>Check if the two angles are the same</summary><param name="left"></param><param name="right"></param>
            <returns><see langword="true"/> if the angles are (<seealso cref="M:NQualityOfLife.Units.Degrees.EqualsApprox(System.Single,System.Single)">approximately</seealso>) equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)">
            <summary>Check if the two angles are different</summary><param name="left"></param><param name="right"></param>
            <returns><see langword="true"/> if the angles are <b>not</b> (<seealso cref="M:NQualityOfLife.Units.Degrees.EqualsApprox(System.Single,System.Single)">approximately</seealso>) equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Equality(System.Single,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Inequality(System.Single,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Equality(System.Double,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Inequality(System.Double,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Degrees.TryParse(System.String,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)"></inheritdoc>
        </member>
        <member name="T:NQualityOfLife.Units.Radians">
            <summary>Unit of <see cref="T:NQualityOfLife.Units.IAngle`1"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Radians.valueRadians">
            <summary><see cref="T:NQualityOfLife.Units.Radians"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.#ctor(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Radians"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.#ctor(NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Radians"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.#ctor(NQualityOfLife.Units.IAngle@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Radians"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Radians"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.#ctor(System.Double)">
            <inheritdoc cref="T:NQualityOfLife.Units.Radians"/>
        </member>
        <member name="P:NQualityOfLife.Units.Radians.InRadians">
            <inheritdoc cref="F:NQualityOfLife.Units.Radians.valueRadians"/>
        </member>
        <member name="P:NQualityOfLife.Units.Radians.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Radians.valueRadians"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Equality(NQualityOfLife.Units.Radians@,NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Inequality(NQualityOfLife.Units.Radians@,NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Equality(NQualityOfLife.Units.Radians@,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Inequality(NQualityOfLife.Units.Radians@,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Equality(System.Single,NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Inequality(System.Single,NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Equality(NQualityOfLife.Units.Radians@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Inequality(NQualityOfLife.Units.Radians@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Equality(System.Double,NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Inequality(System.Double,NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Equality(NQualityOfLife.Units.Radians@,System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Equality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Radians.op_Inequality(NQualityOfLife.Units.Radians@,System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.op_Inequality(NQualityOfLife.Units.Degrees@,NQualityOfLife.Units.Degrees@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.AngularVelocity_">
            <summary>AngularVelocity  || <see cref="T:NQualityOfLife.Units.Radians"/> / <see cref="T:NQualityOfLife.Units.Second"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.AngularVelocity_._radiansPerSecond">
            <inheritdoc cref="T:NQualityOfLife.Units.AngularVelocity_"/>
        </member>
        <member name="M:NQualityOfLife.Units.AngularVelocity_.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.AngularVelocity_"/>
        </member>
        <member name="M:NQualityOfLife.Units.AngularVelocity_.#ctor(System.Double)">
            <inheritdoc cref="T:NQualityOfLife.Units.AngularVelocity_"/>
        </member>
        <member name="M:NQualityOfLife.Units.AngularVelocity_.#ctor(NQualityOfLife.Units.Hertz@)">
            <inheritdoc cref="T:NQualityOfLife.Units.AngularVelocity_"/>
        </member>
        <member name="M:NQualityOfLife.Units.AngularVelocity_.#ctor(NQualityOfLife.Units.IAngle@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="T:NQualityOfLife.Units.AngularVelocity_"/>
        </member>
        <member name="P:NQualityOfLife.Units.AngularVelocity_.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.AngularVelocity_._radiansPerSecond"/>
        </member>
        <member name="T:NQualityOfLife.Units.Meter">
            <summary>The <see cref="T:NQualityOfLife.Units.Meter"/> is the standard unit of <see cref="P:NQualityOfLife.Units.Dimension.Length"/> in the metric system</summary>
            <remarks><para><b>L</b> == <i><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.Length"/></i></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Meter.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Meter"/>
            <para>Lowercase 'm'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Meter.meters">
            <inheritdoc cref="T:NQualityOfLife.Units.Meter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Meter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.#ctor(NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Meter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)">
            <summary>Calculate the total <seealso cref="T:NQualityOfLife.Units.Meter">distance</seealso> traveled when traveling at the given constant <paramref name="speed"/> for the given <seealso cref="T:NQualityOfLife.Units.Second">duration</seealso></summary>
            <param name="speed">The speed of travel</param>
            <param name="time">The total time spent traveling at the given <paramref name="speed"/></param>
            <remarks><see cref="T:NQualityOfLife.Units.Speed">LT^-1</see> * <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Meter">L</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Meter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Meter.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="P:NQualityOfLife.Units.Meter.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Meter.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Meter.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Meter.meters"/>
        </member>
        <member name="P:NQualityOfLife.Units.Meter.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Length"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.Pow2">
            <inheritdoc cref="M:NQualityOfLife.Units.Area.#ctor(NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.SolveFor">
            <inheritdoc cref="M:NQualityOfLife.Units.Area.#ctor(NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.SolveFor(NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Area.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.SolveFor(NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Speed@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.SolveFor(NQualityOfLife.Units.Newton@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Stiffness.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.SolveFor(NQualityOfLife.Units.Stiffness@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Stiffness.SolveFor(NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.op_Multiply(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Area.#ctor(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.op_Division(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Speed@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Meter.op_Division(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Distance">
            <summary>Represents a distance in 3 or 2 dimensional space</summary>
            <inheritdoc cref="T:NQualityOfLife.Units.Meter"/>
        </member>
        <member name="F:NQualityOfLife.Units.Distance.X">
            <inheritdoc cref="T:NQualityOfLife.Units.Distance"/>
        </member>
        <member name="F:NQualityOfLife.Units.Distance.Y">
            <inheritdoc cref="T:NQualityOfLife.Units.Distance"/>
        </member>
        <member name="F:NQualityOfLife.Units.Distance.Z">
            <inheritdoc cref="T:NQualityOfLife.Units.Distance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Distance.#ctor(NQualityOfLife.Units.Velocity@,NQualityOfLife.Units.Second@)">
            <summary>The <see cref="T:NQualityOfLife.Units.Distance"/> traveled in the given time at the given speed</summary>
            <param name="velocity">The constant velocity/speed vector</param><param name="time">How long to travel at the given speed</param>
            <remarks><see cref="T:NQualityOfLife.Units.Velocity">LT^-1</see> * <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Distance">L</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Distance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Distance.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Distance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Distance.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Distance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Distance.#ctor(System.Single,System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Distance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Distance.#ctor(System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Distance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Distance.op_Division(NQualityOfLife.Units.Distance@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Velocity.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Speed@)"/>
        </member>
        <member name="F:NQualityOfLife.Units.Rankine.Ra">
            <summary>Rankine</summary>
        </member>
        <member name="P:NQualityOfLife.Units.Rankine.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Rankine.Ra"/>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Rankine,NQualityOfLife.Units.Rankine)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Rankine,NQualityOfLife.Units.Fahrenheit)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Fahrenheit,NQualityOfLife.Units.Rankine)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Rankine,NQualityOfLife.Units.Kelvin)">
            <summary></summary><param name="left"></param><param name="kelvin"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Rankine.op_Equality(NQualityOfLife.Units.Kelvin,NQualityOfLife.Units.Rankine)">
            <summary></summary><param name="kelvin"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="T:NQualityOfLife.Units.ITime">
            <summary>Represents a <see cref="T:System.TimeSpan">time span</see></summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Units.IDimension"/>, <see cref="T:NQualityOfLife.Types.IMath`1"/> &lt;- <see cref="T:NQualityOfLife.Types.IMath"/> &lt;- <see cref="T:NQualityOfLife.Types.IFloat"/> where 'T' is <see cref="T:NQualityOfLife.Units.Second"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.ITime.MS">
            <summary>The <see cref="T:NQualityOfLife.Units.ITime"/> in milliseconds as an <see cref="T:System.Int32"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITime.TotalSeconds">
            <summary>The total time in seconds that <see langword="this"/> <see cref="T:NQualityOfLife.Units.ITime"/> represents as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Second">
            <summary>The <see cref="T:NQualityOfLife.Units.Second"/> is the standard unit of time used by the metric system</summary>
            <remarks>Can be used with/instead of common time formats such as <see cref="T:System.TimeSpan"/>
            <para><b>T</b> == <i><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.Time"/></i></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Second.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Second"/>
            <para>Lowercase 's'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Second.seconds">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.FromMilliSeconds(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.FromMinutes(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.FromHours(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(System.Int32)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(System.TimeSpan@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Hertz@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.AngularVelocity_@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Speed@)">
            <summary>Calculate how long it take to travel the <paramref name="distance"/> at the given constant/average <see cref="T:NQualityOfLife.Units.Speed"/></summary>
            <param name="distance">The total distance to travel at the given <see cref="T:NQualityOfLife.Units.Speed"/></param>
            <param name="atSpeed">The average <see cref="T:NQualityOfLife.Units.Speed"/> during the travel</param>
            <returns>The <seealso cref="T:NQualityOfLife.Units.Second">time</seealso> it takes to travel the <paramref name="distance"/> at the given <see cref="T:NQualityOfLife.Units.Speed"/></returns>
            <remarks><see cref="T:NQualityOfLife.Units.Meter">L</see> / <see cref="T:NQualityOfLife.Units.Speed">LT^-1</see> == <see cref="T:NQualityOfLife.Units.Second">T</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Ohm@)">
            <remarks><see cref="T:NQualityOfLife.Units.Farad">M^-1L^-2T^4I</see> * <see cref="T:NQualityOfLife.Units.Ohm">MLT^-3I^-2</see> == <see cref="T:NQualityOfLife.Units.Second">T</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Ampere@)">
            <summary>Calculate how long the amount of <paramref name="charge"/> can sustain the <paramref name="current"/>
            <para>Or how long it takes to move the given total <paramref name="charge"/> at the given <paramref name="current"/></para></summary>
            <param name="charge"></param>
            <param name="current"></param>
            <remarks><see cref="T:NQualityOfLife.Units.Charge">IT</see> / <see cref="T:NQualityOfLife.Units.Ampere">I</see> == <see cref="T:NQualityOfLife.Units.Second">T</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Acceleration@)">
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Second">time</seealso> needed to reach the <paramref name="speedChange"/> at the given <paramref name="acceleration"/></summary>
            <param name="speedChange"></param>
            <param name="acceleration"></param>
            <remarks><see cref="T:NQualityOfLife.Units.Speed">LT^-1</see> / <see cref="T:NQualityOfLife.Units.Acceleration">LT^-2</see> == <see cref="T:NQualityOfLife.Units.Second">T</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Watt@)">
            <remarks><see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Watt">MLT^-3</see> == <see cref="T:NQualityOfLife.Units.Second">T</see></remarks>
            <summary>Calculate how long the given <paramref name="energy"/> amount can sustain the given <seealso cref="T:NQualityOfLife.Units.Watt">power</seealso> level</summary>
            <param name="energy">Total <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso></param>
            <param name="overPower"><seealso cref="T:NQualityOfLife.Units.Watt">power</seealso></param>
            <returns>The total time that the <paramref name="energy"/> can sustain the power</returns>
            <inheritdoc cref="T:NQualityOfLife.Units.Second"/>
        </member>
        <member name="P:NQualityOfLife.Units.Second.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Second.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Second.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Time"/>
        </member>
        <member name="P:NQualityOfLife.Units.Second.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Second.seconds"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.SolveFor(NQualityOfLife.Units.Farad@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Farad@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.SolveFor(NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.SolveFor(NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Second.op_Division(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Farad@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Farad@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Second2">
            <summary>Represents an <see cref="T:NQualityOfLife.Units.IAbstractUnit"/> with a dimension T</summary>
            <remarks><para><b>T</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Second2.s2">
            <inheritdoc cref="T:NQualityOfLife.Units.Second2"/>
        </member>
        <member name="P:NQualityOfLife.Units.Second2.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Second2.s2"/>
        </member>
        <member name="T:NQualityOfLife.Units.Hertz">
            <summary>The <see cref="T:NQualityOfLife.Units.Hertz"/> is used to describe periodic oscillations etc</summary>
            <remarks><para><b>T^-1</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Hertz.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Hertz"/>
            <para>Hz - Uppercase 'H' and lowercase 'z'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Hertz.hz">
            <inheritdoc cref="T:NQualityOfLife.Units.Hertz"/>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.FromRPM(System.Single)">
            <returns><see cref="T:NQualityOfLife.Units.Hertz"/> representing rotations per <see cref="T:NQualityOfLife.Units.Second">second</see></returns>
            <inheritdoc cref="T:NQualityOfLife.Units.Hertz"/>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.FromPeriod(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Hertz"/>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Hertz"/>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.#ctor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Hertz"/>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Meter@)">
            <remarks><see cref="T:NQualityOfLife.Units.Speed">LT^-1</see> / <see cref="T:NQualityOfLife.Units.Meter">L</see> == <see cref="T:NQualityOfLife.Units.Hertz">T^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Hertz"/>
        </member>
        <member name="P:NQualityOfLife.Units.Hertz.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Hertz.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Hertz.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Hertz.hz"/>
        </member>
        <member name="P:NQualityOfLife.Units.Hertz.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Frequency"/>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.op_Multiply(NQualityOfLife.Units.Hertz@,System.Single)">
            <summary>Multiply the <paramref name="frequency"/> by the given <paramref name="value"/></summary>
            <param name="frequency"></param><param name="value"></param><returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Units.Hertz"/> of the <paramref name="frequency"/> multiplied by the given <paramref name="value"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.op_Multiply(System.Single,NQualityOfLife.Units.Hertz@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Hertz.op_Multiply(NQualityOfLife.Units.Hertz@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.op_Multiply(NQualityOfLife.Units.Hertz@,NQualityOfLife.Types.Percentage@)">
            <summary>Multiply the <paramref name="frequency"/> by the given <paramref name="percentage"/></summary>
            <param name="frequency"></param><param name="percentage"></param><returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Units.Hertz"/> of the <paramref name="frequency"/> multiplied by the given <paramref name="percentage"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.op_Multiply(NQualityOfLife.Types.Percentage@,NQualityOfLife.Units.Hertz@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Hertz.op_Multiply(NQualityOfLife.Units.Hertz@,NQualityOfLife.Types.Percentage@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Hertz.op_Division(NQualityOfLife.Units.Hertz@,System.Single)">
            <summary>Divide the <paramref name="frequency"/> by the given <paramref name="value"/></summary>
            <param name="frequency"></param><param name="value"></param><returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Units.Hertz"/> of the <paramref name="frequency"/> divided by the given <paramref name="value"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.IdealGasConstant.SolveFor(NQualityOfLife.Units.Kelvin@)">
            <inheritdoc cref="M:NQualityOfLife.Units.IdealGasConstant.op_Multiply(NQualityOfLife.Units.IdealGasConstant@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.IdealGasConstant.op_Multiply(NQualityOfLife.Units.IdealGasConstant@,NQualityOfLife.Units.Kelvin@)">
            <summary></summary>
            <param name="gasConstant"></param>
            <param name="temperature"></param>
            <returns>An <see cref="T:NQualityOfLife.Units.AbstractUnit"/> '<see cref="T:NQualityOfLife.Units.MolarEnergy"/>' with a dimension of (T^-2LMN^-1)</returns>
        </member>
        <member name="M:NQualityOfLife.Units.IdealGasConstant.op_Multiply(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.IdealGasConstant@)">
            <inheritdoc cref="M:NQualityOfLife.Units.IdealGasConstant.op_Multiply(NQualityOfLife.Units.IdealGasConstant@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="F:NQualityOfLife.Units.Mol.mol">
            <inheritdoc cref="T:NQualityOfLife.Units.Mol"/>
        </member>
        <member name="M:NQualityOfLife.Units.Mol.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Kelvin@)">
            <summary>Get the amount of matter using the ideal gas law</summary>
            <param name="pressure">The pressure inside the container</param>
            <param name="volumeOfContainer">The <see cref="T:NQualityOfLife.Units.Volume"/> of the container that contains the matter</param>
            <param name="temperature">The temperature of the matter inside the container</param>
            <remarks>(<see cref="T:NQualityOfLife.Units.Pascal">ML^-1T^-2</see> * <see cref="T:NQualityOfLife.Units.Volume">L</see>) / (<see cref="T:NQualityOfLife.Units.IdealGasConstant"/> * <see cref="T:NQualityOfLife.Units.Kelvin"/>) == <see cref="T:NQualityOfLife.Units.Mol"></see></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.Mol.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@,NQualityOfLife.Units.MolarEnergy@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Mol.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Mol.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.MolarEnergy@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Mol.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="P:NQualityOfLife.Units.Mol.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Mol.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Mol.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Mol.mol"/>
        </member>
        <member name="P:NQualityOfLife.Units.Mol.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.AmountOfSubstance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Mol.SolveFor(NQualityOfLife.Units.Joule@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MolarEnergy.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Mol@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Mol.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Mol@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MolarEnergy.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Mol@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Mol.SolveFor(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Kelvin@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Mol.SolveFor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Mol.SolveFor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.Volume@)">
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> inside the container that contains <see langword="this"/> matter with the given <paramref name="volume"/> and <paramref name="temperature"/></summary>
            <param name="temperature">The temperature of <see langword="this"/> matter inside the <paramref name="volume"/></param>
            <param name="volume">The <see cref="T:NQualityOfLife.Units.Volume"/> of the container</param>
            <returns>The pressure inside the container</returns>
        </member>
        <member name="T:NQualityOfLife.Units.IDimensionallyEquivalent`2">
            <summary>The unit ('<typeparamref name="TA"/>') is dimensionally equivalent to another unit ('<typeparamref name="TB"/>'), but not used in the same context / is not meaningfully comparable.</summary>
            <typeparam name="TA"></typeparam><typeparam name="TB"></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.Stiffness">
            <summary>Unit for spring stiffness / surface tension</summary>
            <remarks><see cref="T:NQualityOfLife.Units.Dimension"/> of <see cref="T:NQualityOfLife.Units.Stiffness"/> is <see cref="P:NQualityOfLife.Units.Dimension.SpringStiffness"/></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Stiffness.stiffness">
            <inheritdoc cref="T:NQualityOfLife.Units.Stiffness"/>
        </member>
        <member name="M:NQualityOfLife.Units.Stiffness.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Stiffness"/>
        </member>
        <member name="M:NQualityOfLife.Units.Stiffness.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)">
            <summary>Calculate the <see cref="T:NQualityOfLife.Units.Stiffness"/> from the force needed to displace a spring by the given distance</summary>
            <param name="newton"></param>
            <param name="perMeter"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.Stiffness"/>
        </member>
        <member name="P:NQualityOfLife.Units.Stiffness.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Stiffness.stiffness"/>
        </member>
        <member name="P:NQualityOfLife.Units.Stiffness.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.SpringStiffness"/>
        </member>
        <member name="M:NQualityOfLife.Units.Stiffness.SolveFor(NQualityOfLife.Units.Newton@)">
            <summary>Solve how much a spring can be stretched with the given <paramref name="force"/></summary>
            <param name="force"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Stiffness.SolveFor(NQualityOfLife.Units.Meter@)">
            <summary>Solve how much force is needed to stretch the spring by the given <paramref name="distance"/>
            <para>Or if the spring is stretched by the given <paramref name="distance"/>, how much force the spring is exerting</para></summary>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Stiffness.op_Multiply(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Stiffness@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Stiffness.SolveFor(NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Stiffness.op_Multiply(NQualityOfLife.Units.Stiffness@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Stiffness.SolveFor(NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Stiffness.op_Division(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Stiffness@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Stiffness.SolveFor(NQualityOfLife.Units.Newton@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Torque">
            <summary>Unit for Torque - NewtonMeter - (<see cref="T:NQualityOfLife.Units.Newton"/> * <see cref="T:NQualityOfLife.Units.Meter"/>)</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Acceleration">
            <summary>Acceleration - m/s<para><see cref="T:NQualityOfLife.Units.Acceleration"/> is the change in <seealso cref="T:NQualityOfLife.Units.Speed">speed</seealso> over <seealso cref="T:NQualityOfLife.Units.Second">time</seealso></para></summary>
            <remarks><b>LT^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Acceleration.metersPerSecondPerSecond">
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Kg@)">
            <summary>Get the <see cref="T:NQualityOfLife.Units.Acceleration"/> of an object with the given mass when the given <paramref name="force"/> is applied</summary>
            <param name="force">The force that is applied to the object</param>
            <param name="overMass">The mass of the object</param>
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)">
            <summary>Solve the <see cref="T:NQualityOfLife.Units.Acceleration"/> needed to reach the <paramref name="speedDelta"/> in the given <paramref name="time"/></summary>
            <param name="speedDelta">Speed change</param>
            <param name="time">Time taken to reach the <paramref name="speedDelta"/></param>
            <return>The <see cref="T:NQualityOfLife.Units.Acceleration"/> needed to reach the <paramref name="speedDelta"/> in the given <paramref name="time"/></return>
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)">
            <summary><see cref="T:NQualityOfLife.Units.Acceleration"/> needed to reach the <paramref name="final"/> <see cref="T:NQualityOfLife.Units.Speed"/> from the <paramref name="initial"/> <see cref="T:NQualityOfLife.Units.Speed"/> in the given <paramref name="time"/>.</summary>
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="P:NQualityOfLife.Units.Acceleration.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Acceleration.metersPerSecondPerSecond"/>
        </member>
        <member name="P:NQualityOfLife.Units.Acceleration.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Acceleration"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.SolveFor(NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Acceleration@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.op_Multiply(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Acceleration.op_Multiply(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.AccelerationVector">
            <summary>3D acceleration vector</summary>
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="F:NQualityOfLife.Units.AccelerationVector.X">
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="F:NQualityOfLife.Units.AccelerationVector.Y">
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="F:NQualityOfLife.Units.AccelerationVector.Z">
            <inheritdoc cref="T:NQualityOfLife.Units.Acceleration"/>
        </member>
        <member name="M:NQualityOfLife.Units.AccelerationVector.#ctor(NQualityOfLife.Units.Force@,NQualityOfLife.Units.Kg@)">
            <remarks><see cref="T:NQualityOfLife.Units.Force">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Kg">M</see> == <see cref="T:NQualityOfLife.Units.AccelerationVector">LT^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.AccelerationVector"/>
        </member>
        <member name="M:NQualityOfLife.Units.AccelerationVector.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="T:NQualityOfLife.Units.AccelerationVector"/>
        </member>
        <member name="M:NQualityOfLife.Units.AccelerationVector.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="T:NQualityOfLife.Units.AccelerationVector"/>
        </member>
        <member name="M:NQualityOfLife.Units.AccelerationVector.#ctor(System.Single,System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.AccelerationVector"/>
        </member>
        <member name="M:NQualityOfLife.Units.AccelerationVector.#ctor(System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.AccelerationVector"/>
        </member>
        <member name="T:NQualityOfLife.Units.Area">
            <summary>Unit of <see cref="T:NQualityOfLife.Units.Area"/> || Usually used with <see cref="T:NQualityOfLife.Units.Meter"/> but that is not required</summary>
            <remarks><para><b>L</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Area.area">
            <inheritdoc cref="T:NQualityOfLife.Units.Area"/>
        </member>
        <member name="M:NQualityOfLife.Units.Area.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Area"/>
        </member>
        <member name="M:NQualityOfLife.Units.Area.#ctor(NQualityOfLife.Units.Meter@)">
            <summary>Solve the <see cref="T:NQualityOfLife.Units.Area"/> of a <see cref="T:NQualityOfLife.Geometry.Square"/> with the given <paramref name="sideLength"/></summary>
            <param name="sideLength"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.Area"/>
        </member>
        <member name="M:NQualityOfLife.Units.Area.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@)">
            <summary>Solve the <see cref="T:NQualityOfLife.Units.Area"/> of a <see cref="T:NQualityOfLife.Geometry.Rectangle"/> with the given <paramref name="height"/> and <paramref name="width"/></summary>
            <param name="width"></param>
            <param name="height"></param>
            <remarks><see cref="T:NQualityOfLife.Units.Meter">L</see> * <see cref="T:NQualityOfLife.Units.Meter">L</see> == <see cref="T:NQualityOfLife.Units.Area">L</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Area"/>
        </member>
        <member name="P:NQualityOfLife.Units.Area.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Area.area"/>
        </member>
        <member name="P:NQualityOfLife.Units.Area.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Area"/>
        </member>
        <member name="M:NQualityOfLife.Units.Area.SolveFor(NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Area.op_Multiply(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Area.SolveFor(NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Area.op_Multiply(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Area.SolveFor(NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.IEnergy">
            <summary>Represents an unit of <see cref="P:NQualityOfLife.Units.Dimension.Energy">energy</see></summary>
            <remarks><b>MLT^-2</b></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.Joule">
            <summary>The <see cref="T:NQualityOfLife.Units.Joule"/> is an unit of <see cref="P:NQualityOfLife.Units.Dimension.Energy">energy</see></summary>
            <remarks><b>MLT^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Joule.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Joule"/>
            <para>Uppercase 'J'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Joule.j">
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(System.Double)">
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Joule@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.ElectronVolt@)">
            <summary>Convert the given <paramref name="eV"/> into an equivelant amount of <seealso cref="T:NQualityOfLife.Units.Joule">Joules</seealso></summary>
            <param name="eV"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)">
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> needed to heat the object by the given amount of <see cref="T:NQualityOfLife.Units.Kelvin"/></summary>
            <param name="temperatureDelta">How much the object is heated as a temperature change</param>
            <param name="heatCapacity">The <see cref="T:NQualityOfLife.Units.HeatCapacity"/> of the object</param>
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFrom(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFrom(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Watt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@)">
            <remarks><see cref="T:NQualityOfLife.Units.Watt">MLT^-3</see> * <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see></remarks>
            <summary>Solve the total <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> from the <paramref name="power"/> and <paramref name="time"/></summary>
            <param name="power">The constant power</param>
            <param name="time">The time that the <paramref name="power"/> is applied over</param>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFrom(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Newton@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFrom(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)">
            <remarks><see cref="T:NQualityOfLife.Units.Newton">MLT^-2</see> * <see cref="T:NQualityOfLife.Units.Meter">L</see> == <see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFrom(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFrom(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Charge@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)">
            <remarks><see cref="T:NQualityOfLife.Units.Charge"></see> * <see cref="T:NQualityOfLife.Units.Volt"></see> == <see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFrom(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFrom(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Pascal@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@)">
            <remarks><see cref="T:NQualityOfLife.Units.Pascal">ML^-1T^-2</see> * <see cref="T:NQualityOfLife.Units.Volume">L</see> == <see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.MagneticMoment@,NQualityOfLife.Units.Tesla@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Speed2@,NQualityOfLife.Units.Kg@)">
            <remarks><see cref="T:NQualityOfLife.Units.Speed2">LT^-2</see> * <see cref="T:NQualityOfLife.Units.Kg">M</see> == <see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Joule"/>
        </member>
        <member name="P:NQualityOfLife.Units.Joule.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Joule.j"/>
        </member>
        <member name="P:NQualityOfLife.Units.Joule.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Energy"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFor(NQualityOfLife.Units.Charge@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Charge@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFor(NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.SolveFor(NQualityOfLife.Units.Kelvin@)">
            <inheritdoc cref="M:NQualityOfLife.Units.HeatCapacity.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Kelvin@)">
            <inheritdoc cref="M:NQualityOfLife.Units.HeatCapacity.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Joule.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.HeatCapacity@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Kelvin.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.HeatCapacity@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.ElectronVolt">
            <summary>Despite the name the <see cref="T:NQualityOfLife.Units.ElectronVolt"/> is an unit of <see cref="T:NQualityOfLife.Units.IEnergy">Energy</see><para>Can be converted to <seealso cref="T:NQualityOfLife.Units.Joule">Joules</seealso></para></summary>
            <remarks><b>MLT^-2</b>
            <para>1 <see cref="T:NQualityOfLife.Units.ElectronVolt">eV</see> is the energy an electron gains moving through a 1 <see cref="T:NQualityOfLife.Units.Volt">V</see> potential, the numerical value of the <see cref="T:NQualityOfLife.Units.Volt">voltage</see> is equivalent to the energy in <see cref="T:NQualityOfLife.Units.ElectronVolt">eV</see> divided by the <see cref="T:NQualityOfLife.Units.ElementaryCharge">charge of one electron.</see></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.ElectronVolt.eV">
            <inheritdoc cref="T:NQualityOfLife.Units.ElectronVolt"/>
        </member>
        <member name="P:NQualityOfLife.Units.ElectronVolt.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.ElectronVolt.eV"/>
        </member>
        <member name="P:NQualityOfLife.Units.ElectronVolt.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Energy"/>
        </member>
        <member name="T:NQualityOfLife.Units.Pascal">
            <summary>The <see cref="T:NQualityOfLife.Units.Pascal"/> is the unit of pressure used by the metric system</summary>
            <remarks><b>ML^-1T^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Pascal.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Pascal"/>
            <para>Pa - Uppercase 'P' and lowercase 'a'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Pascal.pa">
            <inheritdoc cref="T:NQualityOfLife.Units.Pascal"/>
        </member>
        <member name="M:NQualityOfLife.Units.Pascal.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Pascal"/>
        </member>
        <member name="M:NQualityOfLife.Units.Pascal.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Area@)">
            <remarks><see cref="T:NQualityOfLife.Units.Newton">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Area">L</see> == <see cref="T:NQualityOfLife.Units.Pascal">ML^-1T^-2</see></remarks>
            <summary>The pressure resulting from the <paramref name="force"/> being applied over the given <see cref="T:NQualityOfLife.Units.Area"/></summary>
            <param name="force"></param>
            <param name="perArea"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.Pascal"/>
        </member>
        <member name="M:NQualityOfLife.Units.Pascal.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Volume@)">
            <remarks><see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Volume">L</see> == <see cref="T:NQualityOfLife.Units.Pascal">ML^-1T^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Pascal"/>
        </member>
        <member name="P:NQualityOfLife.Units.Pascal.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Pascal.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Pascal.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Pascal.pa"/>
        </member>
        <member name="P:NQualityOfLife.Units.Pascal.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Pressure"/>
        </member>
        <member name="M:NQualityOfLife.Units.Pascal.SolveFor(NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Pascal.SolveFor(NQualityOfLife.Units.Joule@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Pascal@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Pascal.op_Multiply(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Pascal.op_Multiply(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Pascal@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Pascal.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Pascal@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Pascal@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.ISpeed`1">
            <summary>Represents a scalar velocity in units of '<typeparamref name="U"/>'</summary>
            <typeparam name="U">The unit of speed '<typeparamref name="U"/>'</typeparam>
        </member>
        <member name="P:NQualityOfLife.Units.ISpeed`1.SpeedOfLight">
            <summary><seealso href="https://en.wikipedia.org/wiki/Speed_of_light">Speed of light</seealso> in units of <typeparamref name="U"/> || <seealso href="https://en.wikipedia.org/wiki/Speed_of_light">Speed of light</seealso> is also known as the <seealso href="https://en.wikipedia.org/wiki/Planck_units">Planck speed</seealso></summary>
            <remarks>This property is constant and the same for all instances of '<typeparamref name="U"/>'</remarks>
        </member>
        <member name="P:NQualityOfLife.Units.ISpeed`1.AsPlanckSpeed">
            <summary>The speed of <see langword="this"/> <typeparamref name="U"/> in <see cref="T:NQualityOfLife.Units.PlanckSpeed"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ISpeed`1.InPlanckSpeed">
            <summary>The speed of <see langword="this"/> <typeparamref name="U"/> in <see cref="T:NQualityOfLife.Units.PlanckSpeed"/> as a <see cref="T:System.Single"/></summary>
            <inheritdoc cref="P:NQualityOfLife.Units.ISpeed`1.AsPlanckSpeed"/>
        </member>
        <member name="P:NQualityOfLife.Units.ISpeed`1.Inkmph">
            <summary>Get the <see cref="T:NQualityOfLife.Units.ISpeed`1"/> '<typeparamref name="U"/>' in kilometers per hour</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ISpeed`1.Inmps">
            <summary>Get the <see cref="T:NQualityOfLife.Units.ISpeed`1"/> '<typeparamref name="U"/>' in <seealso cref="T:NQualityOfLife.Units.Meter">meters</seealso> per <seealso cref="T:NQualityOfLife.Units.Second">second</seealso></summary>
        </member>
        <member name="T:NQualityOfLife.Units.PlanckSpeed">
            <summary>The <see cref="T:NQualityOfLife.Units.PlanckSpeed"/> is an unit of <see cref="T:NQualityOfLife.Units.ISpeed`1"/> where 1 <see cref="T:NQualityOfLife.Units.PlanckSpeed"/> == The speed of light</summary>
        </member>
        <member name="F:NQualityOfLife.Units.PlanckSpeed.c">
             <inheritdoc cref="T:NQualityOfLife.Units.PlanckSpeed"/>
        </member>
        <member name="M:NQualityOfLife.Units.PlanckSpeed.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.PlanckSpeed"/>
        </member>
        <member name="M:NQualityOfLife.Units.PlanckSpeed.#ctor(System.Double)">
            <inheritdoc cref="T:NQualityOfLife.Units.PlanckSpeed"/>
        </member>
        <member name="M:NQualityOfLife.Units.PlanckSpeed.#ctor(NQualityOfLife.Units.PlanckSpeed@)">
            <inheritdoc cref="T:NQualityOfLife.Units.PlanckSpeed"/>
        </member>
        <member name="M:NQualityOfLife.Units.PlanckSpeed.#ctor(NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="T:NQualityOfLife.Units.PlanckSpeed"/>
        </member>
        <member name="M:NQualityOfLife.Units.PlanckSpeed.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Second@)">
            <summary>The speed delta from accelerating at the given rate for the given time</summary>
            <param name="acceleration"></param>
            <param name="seconds"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.PlanckSpeed"/>
        </member>
        <member name="M:NQualityOfLife.Units.PlanckSpeed.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="T:NQualityOfLife.Units.PlanckSpeed"/>
        </member>
        <member name="P:NQualityOfLife.Units.PlanckSpeed.Value">
             <inheritdoc cref="F:NQualityOfLife.Units.PlanckSpeed.c"/>
        </member>
        <member name="P:NQualityOfLife.Units.PlanckSpeed.Dimension">
             <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Speed"/>
        </member>
        <member name="T:NQualityOfLife.Units.Speed">
            <summary>Non-vector (scalar) <see cref="T:NQualityOfLife.Units.Speed"/> in <seealso cref="T:NQualityOfLife.Units.Meter">m</seealso>/<seealso cref="T:NQualityOfLife.Units.Second">s</seealso></summary>
            <remarks>For a vector use <see cref="T:NQualityOfLife.Units.Velocity"/>
            <para><b>LT^-1</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Speed.metersPerSecond">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Second@)">
            <summary>Solve the speed delta from accelerating at the given rate for the given <paramref name="time"/></summary>
            <param name="acceleration">The constant <see cref="T:NQualityOfLife.Units.Acceleration"/></param>
            <param name="time">The time that we are accelerating at the given <paramref name="acceleration"/></param>
            <remarks><see cref="T:NQualityOfLife.Units.Acceleration">LT^-2</see> * <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Speed">LT^-1</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Second@)">
            <summary>Solve the average <see cref="T:NQualityOfLife.Units.Speed"/> of travel from the distance traveled in the given time</summary>
            <param name="meters">The total distance travelled</param>
            <param name="perSecond">The total time it took to travel the distance</param>
            <remarks><see cref="T:NQualityOfLife.Units.Meter">L</see> / <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Speed">LT^-1</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Speed.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Speed.metersPerSecond"/>
        </member>
        <member name="P:NQualityOfLife.Units.Speed.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Speed"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Meter.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.SolveFor(NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Speed@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.SolveFor(NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Acceleration@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.NQualityOfLife#Units#ISolveFor{NQualityOfLife#Units#Acceleration,NQualityOfLife#Units#Second}#SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.op_Multiply(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Meter.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.op_Multiply(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Meter.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.op_Division(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Acceleration@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed.op_Division(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Speed2">
            <summary>Represents an <see cref="T:NQualityOfLife.Units.IAbstractUnit"/> with a dimension LT^-2</summary>
            <remarks><para><b>LT^-2</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Speed2.speed2">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed2.#ctor(NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed2.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed2.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed2"/>
        </member>
        <member name="P:NQualityOfLife.Units.Speed2.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Speed2.speed2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed2.SolveFor(NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Speed2@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed2.op_Multiply(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Speed2@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Speed2@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Speed2.op_Multiply(NQualityOfLife.Units.Speed2@,NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Speed2@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Velocity">
            <summary>Velocity is a 3D speed vector, Can be used in a 2D or 3D context</summary>
            <remarks><b>LT^-1</b><para>For a simple scalar value; use <see cref="T:NQualityOfLife.Units.Speed"/></para></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Speed"/>
        </member>
        <member name="F:NQualityOfLife.Units.Velocity.X">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed"/>
        </member>
        <member name="F:NQualityOfLife.Units.Velocity.Y">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed"/>
        </member>
        <member name="F:NQualityOfLife.Units.Velocity.Z">
            <inheritdoc cref="T:NQualityOfLife.Units.Speed"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.#ctor(NQualityOfLife.Units.Velocity@,NQualityOfLife.Units.Distance@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Velocity"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Velocity"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.#ctor(NQualityOfLife.Units.Speed@,NQualityOfLife.Units.Speed@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Velocity"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.#ctor(System.Single,System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Velocity"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.#ctor(System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Velocity"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.#ctor(System.Double,System.Double)">
            <inheritdoc cref="T:NQualityOfLife.Units.Velocity"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.#ctor(System.Double,System.Double,System.Double)">
            <inheritdoc cref="T:NQualityOfLife.Units.Velocity"/>
        </member>
        <member name="P:NQualityOfLife.Units.Velocity.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Speed"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.op_Multiply(NQualityOfLife.Units.Velocity@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Distance.#ctor(NQualityOfLife.Units.Velocity@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Velocity.op_Multiply(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Velocity@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Distance.#ctor(NQualityOfLife.Units.Velocity@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.IVolume">
            <summary>Represents a <seealso cref="P:NQualityOfLife.Units.Dimension.Volume">physical volume</seealso></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/>
            <para>Implements <see cref="T:System.IEquatable`1"/>, <see cref="T:System.IComparable`1"/> where 'T' is <see cref="T:NQualityOfLife.Units.IVolume"/></para>
            <para><b>L</b></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.IVolume.AsLiters">
            <summary>The <see cref="T:NQualityOfLife.Units.IVolume"/> in <see cref="T:NQualityOfLife.Units.Liter">liters</see></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IVolume.AsCubes">
            <summary>The <see cref="T:NQualityOfLife.Units.IVolume"/> in cubic meters (m)</summary>
        </member>
        <member name="P:NQualityOfLife.Units.IVolume.InLiters">
            <summary>The <see cref="T:NQualityOfLife.Units.IVolume"/> in <see cref="T:NQualityOfLife.Units.Liter">liters</see> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IVolume.InCubes">
            <summary>The <see cref="T:NQualityOfLife.Units.IVolume"/> in cubic meters (m) as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Volume">
            <summary><see cref="T:NQualityOfLife.Units.Volume"/> in cubic <see cref="T:NQualityOfLife.Units.Meter"/>s</summary>
            <remarks><see cref="T:NQualityOfLife.Units.Volume"/> has the <see cref="T:NQualityOfLife.Units.Dimension"/> '<seealso cref="P:NQualityOfLife.Units.Dimension.Volume">L</seealso>'
            <para><b>L</b></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Volume._volume">
            <summary>The <see cref="T:NQualityOfLife.Units.Volume"/> in m</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Volume"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Liter@)">
            <summary>Convert <paramref name="liters"/> into <see cref="T:NQualityOfLife.Units.Volume"/></summary>
            <param name="liters"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.Volume"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@)">
            <summary>Get the <see cref="T:NQualityOfLife.Units.Volume"/> of the given dimensions</summary>
            <param name="width"></param><param name="height"></param><param name="depth"></param>
            <remarks><see cref="T:NQualityOfLife.Units.Meter">L</see> * <see cref="T:NQualityOfLife.Units.Meter">L</see> * <see cref="T:NQualityOfLife.Units.Meter">L</see> == <see cref="T:NQualityOfLife.Units.Volume">L</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Volume"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Meter@)">
            <summary>Get the <see cref="T:NQualityOfLife.Units.Volume"/> of the given dimensions</summary>
            <param name="crossSection"></param><param name="depth"></param>
            <remarks><see cref="T:NQualityOfLife.Units.Area">L</see> * <see cref="T:NQualityOfLife.Units.Meter">L</see> == <see cref="T:NQualityOfLife.Units.Volume">L</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Volume"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.AbstractUnit@)">
            <summary>Cast the given <paramref name="abstractUnit"/> into <see cref="T:NQualityOfLife.Units.Volume"/></summary>
            <param name="abstractUnit"></param>
            <exception cref="T:NQualityOfLife.Exceptions.DimensionMismatchException"></exception>
            <inheritdoc cref="T:NQualityOfLife.Units.Volume"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Density@)">
            <summary>Calculate the <see cref="T:NQualityOfLife.Units.Volume"/> of the given substance when it has the given <paramref name="mass"/></summary>
            <param name="mass">The total amount of substance</param>
            <param name="overDensity">The <see cref="T:NQualityOfLife.Units.Density"/> of the substance</param>
            <remarks>1000<seealso cref="T:NQualityOfLife.Units.Kg">kg</seealso> of <seealso cref="P:NQualityOfLife.Units.Density.OfWater">water</seealso> should result in a <see cref="T:NQualityOfLife.Units.Volume"/> of 1<seealso cref="T:NQualityOfLife.Units.Volume">m</seealso>
            <para><see cref="T:NQualityOfLife.Units.Kg">M</see> / <see cref="T:NQualityOfLife.Units.Density">ML^-3</see> == <see cref="T:NQualityOfLife.Units.Volume">L</see></para></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Volume"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Pascal@)">
            <summary>Calculate the <see cref="T:NQualityOfLife.Units.Volume"/> that a gas is contained in from the total <paramref name="energy"/> and pressure inside the space</summary>
            <param name="energy">The total energy of the gas contained in the <see cref="T:NQualityOfLife.Units.Volume"/></param>
            <param name="overPressure">The pressure inside the <see cref="T:NQualityOfLife.Units.Volume"/></param>
            <remarks><see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Pascal">ML^-1T^-2</see> == <see cref="T:NQualityOfLife.Units.Volume">L</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Volume"/>
        </member>
        <member name="P:NQualityOfLife.Units.Volume.Value">
            <inheritdoc cref="P:NQualityOfLife.Units.IVolume.InCubes"/>
        </member>
        <member name="P:NQualityOfLife.Units.Volume.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Volume"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Joule@)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> of a container with <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/> and the given <paramref name="energy"/></summary>
            <param name="energy"></param>
            <returns>The <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> inside this <see cref="T:NQualityOfLife.Units.Volume"/> with the given <paramref name="energy"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Pascal@)">
            <summary>Solve the total <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> inside <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/> at the given <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso></summary>
            <param name="pressure"></param>
            <returns>The total <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> inside <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Mol@,NQualityOfLife.Units.Kelvin@)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> inside the <see cref="T:NQualityOfLife.Units.Volume"/> when it has the given amount of matter at the specified <paramref name="temperature"/></summary>
            <param name="a"></param>
            <param name="temperature"></param>
            <returns>The resulting <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.Mol@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Mol@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Mol@)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Kelvin">temperature</seealso> of the gas inside the <see cref="T:NQualityOfLife.Units.Volume"/> when at the given <paramref name="pressure"/></summary>
            <param name="pressure"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Mol@,NQualityOfLife.Units.Pascal@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Mol@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.VolumetricFlow.#ctor(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volume.op_Division(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Liter">
            <summary><see cref="T:NQualityOfLife.Units.Volume"/> in <see cref="T:NQualityOfLife.Units.Liter"/>s</summary>
            <remarks><b>L</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Liter.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Liter"/>
            <para>Lowercase 'l' (L)</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Liter._liters">
            <inheritdoc cref="T:NQualityOfLife.Units.Liter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Liter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.#ctor(System.Int64)">
            <inheritdoc cref="T:NQualityOfLife.Units.Liter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.#ctor(NQualityOfLife.Units.Volume@)">
            <summary>Convert the <see cref="T:NQualityOfLife.Units.Volume"/> to <see cref="T:NQualityOfLife.Units.Liter"/>s</summary>
            <param name="cubes"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.Liter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.#ctor(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Liter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.#ctor(NQualityOfLife.Units.AbstractUnit@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Liter"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Pascal@)">
            <remarks><see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Pascal">ML^-1T^-2</see> == <see cref="T:NQualityOfLife.Units.Liter">L</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Liter"/>
        </member>
        <member name="P:NQualityOfLife.Units.Liter.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Liter.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Liter.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Liter._liters"/>
        </member>
        <member name="P:NQualityOfLife.Units.Liter.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Volume"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.op_Implicit(System.Int64)~NQualityOfLife.Units.Liter">
            <inheritdoc cref="M:NQualityOfLife.Units.Liter.#ctor(System.Int64)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.op_Implicit(NQualityOfLife.Units.Liter@)~NQualityOfLife.Units.Volume">
            <inheritdoc cref="P:NQualityOfLife.Units.Liter.AsCubes"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.op_Explicit(System.Single)~NQualityOfLife.Units.Liter">
            <inheritdoc cref="M:NQualityOfLife.Units.Liter.#ctor(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Joule@)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> of a container with <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/> and the given <paramref name="energy"/></summary>
            <param name="energy"></param>
            <returns>The <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> inside this <see cref="T:NQualityOfLife.Units.Volume"/> with the given <paramref name="energy"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Pascal@)">
            <summary>Solve the total <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> inside <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/> at the given <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso></summary>
            <param name="pressure"></param>
            <returns>The total <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> inside <see langword="this"/> <see cref="T:NQualityOfLife.Units.Volume"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Mol@,NQualityOfLife.Units.Kelvin@)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso> inside the <see cref="T:NQualityOfLife.Units.Volume"/> when it has the given amount of matter at the specified <paramref name="temperature"/></summary>
            <param name="a"></param>
            <param name="temperature"></param>
            <returns>The resulting <seealso cref="T:NQualityOfLife.Units.Pascal">pressure</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.Mol@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Mol@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Mol@)">
            <summary>Solve the <seealso cref="T:NQualityOfLife.Units.Kelvin">temperature</seealso> of the gas inside the <see cref="T:NQualityOfLife.Units.Volume"/> when at the given <paramref name="pressure"/></summary>
            <param name="pressure"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Mol@,NQualityOfLife.Units.Pascal@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Pascal@,NQualityOfLife.Units.Mol@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.SolveFor(NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Liter.op_Division(NQualityOfLife.Units.Liter@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.SolveFor(NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.IDimension">
            <summary>Interface for units - Used for <see href="https://en.wikipedia.org/wiki/Dimensional_analysis">dimensional analysis</see></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.IDimension.Dimension">
            <summary>The dimensionality of the unit</summary>
            <remarks>See: <see href="https://en.wikipedia.org/wiki/Dimensional_analysis">dimensional analysis</see>
            <para>Defined in <see cref="T:NQualityOfLife.Units.IDimension"/></para></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.IMetricSystem">
            <summary>Interface for units of the metric system</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.IMetricSystem.Symbol">
            <summary>The symbol used for the unit, for example: 'm' for <see cref="T:NQualityOfLife.Units.Meter"/>, 'g' for gram, 'F' for <see cref="T:NQualityOfLife.Units.Farad"/></summary>
            <remarks>Defined in <see cref="T:NQualityOfLife.Units.IMetricSystem"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.IMetricSystem.ToStringSI">
            <summary></summary>
            <returns>The given unit as a <see cref="T:System.String"/> using the metric system prefixes</returns>
            <example>Examples: <see cref="M:NQualityOfLife.Units.Meter.ToStringSI"/></example>
            <remarks>Defined in <see cref="T:NQualityOfLife.Units.IMetricSystem"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.IMetricSystemFloats">
            <summary>Interface for <see cref="T:System.Single"/>-like units of the metric system</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IMetricSystem"/>, <see cref="T:NQualityOfLife.Types.IFloat"/> &lt;- <see cref="T:NQualityOfLife.Units.IDimension"/>, <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.Dimension">
            <summary><see langword="struct"/> for performing <see href="https://en.wikipedia.org/wiki/Dimensional_analysis">Dimensional analysis</see></summary>
            <remarks>Implements <see cref="T:System.IEquatable`1"/> where 'T' is <see cref="T:NQualityOfLife.Units.Dimension"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.Dimension.BaseDimension">
            <summary>The base dimensions that all other dimensions / units are derived from</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.BaseDimension.None">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.None"/>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.BaseDimension.Time">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Time"/>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.BaseDimension.Length">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Length"/>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.BaseDimension.Mass">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Mass"/>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.BaseDimension.ElectricCurrent">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.ElectricCurrent"/>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.BaseDimension.AbsoluteTemperature">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Temperature"/>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.BaseDimension.AmountOfSubstance">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.AmountOfSubstance"/>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.BaseDimension.LuminousIntensity">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.LuminousIntensity"/>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.T">
            <summary>Time dimension - <see cref="T:NQualityOfLife.Units.Second"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.L">
            <summary>Length dimension - <see cref="T:NQualityOfLife.Units.Meter"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.M">
            <summary>Mass dimension - <see cref="T:NQualityOfLife.Units.Kg"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.I">
            <summary>Electric Current dimension - <see cref="T:NQualityOfLife.Units.Ampere"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.">
            <summary>Absolute Temperature dimension - <see cref="T:NQualityOfLife.Units.Kelvin"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.N">
            <summary>Amount of Substance dimension - <see cref="T:NQualityOfLife.Units.Mol"/></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Dimension.J">
            <summary>Luminous Intensity dimension</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Dimension.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Create a Dimension object with the given dimensions</summary>
            <param name="T">Time - <see cref="T:NQualityOfLife.Units.Second"/></param>
            <param name="L">Length dimension - <see cref="T:NQualityOfLife.Units.Meter"/></param>
            <param name="M">Mass dimension - <see cref="T:NQualityOfLife.Units.Kg"/></param>
            <param name="I">Electric Current dimension - <see cref="T:NQualityOfLife.Units.Ampere"/></param>
            <param name="">Absolute Temperature dimension - <see cref="T:NQualityOfLife.Units.Kelvin"/></param>
            <param name="N">Amount of Substance dimension - <see cref="T:NQualityOfLife.Units.Mol"/></param>
            <param name="J">Luminous Intensity dimension</param>
        </member>
        <member name="M:NQualityOfLife.Units.Dimension.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Dimension.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Dimension.ParseStep">
            <summary>enum for tracking the state of the string parser</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Dimension.#ctor(System.String)">
            <summary>Create a <see cref="T:NQualityOfLife.Units.Dimension"/> object with the given dimensions parsed from a <see cref="T:System.String"/></summary>
            <param name="fromString"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Internal error if the parser tries to access an invalid dimension address</exception>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.None">
            <summary>Dimensionless
            <para><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.None"/></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Time">
            <summary>Time - <see cref="T:NQualityOfLife.Units.Second"/>
            <para><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.Time"/></para>
            <para><b>T</b></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Length">
            <summary>Length - <see cref="T:NQualityOfLife.Units.Meter"/>
            <para><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.Length"/></para>
            <para><b>L</b></para></summary>
            <remarks>Often called displacement</remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Mass">
            <summary>Mass - <see cref="T:NQualityOfLife.Units.Kg"/>
            <para><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.Mass"/></para>
            <para><b>M</b></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricCurrent">
            <summary>Electrical Current - <see cref="T:NQualityOfLife.Units.Ampere"/><para><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.ElectricCurrent"/></para>
            <para><b>I</b></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Temperature">
            <summary>Absolute Temperature - <see cref="T:NQualityOfLife.Units.Kelvin"/>
            <para><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.AbsoluteTemperature"/></para>
            <para><b></b></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.AmountOfSubstance">
            <summary>Amount Of Substance - <see cref="T:NQualityOfLife.Units.Mol"/>
            <para><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.AmountOfSubstance"/></para>
            <para><b>N</b></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.LuminousIntensity">
            <summary>Luminous Intensity
            <para><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.LuminousIntensity"/></para>
            <para><b>J</b></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Frequency">
            <summary>Frequency - <see cref="T:NQualityOfLife.Units.Hertz"/>
            <para><b>T^-1</b></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Area">
            <summary>Area - <see cref="T:NQualityOfLife.Units.Area"/>
            <para><seealso cref="T:NQualityOfLife.Units.Area">Area</seealso> has a dimensionality of <seealso cref="P:NQualityOfLife.Units.Dimension.Length">Length</seealso> * <seealso cref="P:NQualityOfLife.Units.Dimension.Length">Length</seealso></para>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Area">Area</see> == <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see> * <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see></para>
            <para><b>L</b> == <i>L * L</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Volume">
            <summary>The <see cref="T:NQualityOfLife.Units.Dimension"/> of <see cref="P:NQualityOfLife.Units.Dimension.Volume"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Volume">Volume</see> == <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see> * <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see> * <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see></para>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Volume">Volume</see> == <see cref="P:NQualityOfLife.Units.Dimension.Area">Area</see> * <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see></para>
            <para><b>L</b> == <i>L * L * L</i></para>
            <para><b>L</b> == <i>L * L</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricCharge">
            <summary>Electric Charge - <see cref="T:NQualityOfLife.Units.Charge"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.ElectricCharge">ElectricCharge</see> == <see cref="P:NQualityOfLife.Units.Dimension.ElectricCurrent">Current</see> * <see cref="P:NQualityOfLife.Units.Dimension.Time">Time</see></para>
            <para><b>IT</b> == <i>I * T</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Speed">
            <summary>Speed - <see cref="T:NQualityOfLife.Units.Speed"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Speed">Speed</see> == <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see> / <see cref="P:NQualityOfLife.Units.Dimension.Time">Time</see></para>
            <para><b>LT^-1</b> == <i>L / T</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.MassFlow">
            <summary>MassFlow - <see cref="T:NQualityOfLife.Units.MassFlow"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.MassFlow">MassFlow</see> == <see cref="P:NQualityOfLife.Units.Dimension.Mass">Mass</see> / <see cref="P:NQualityOfLife.Units.Dimension.Time">Time</see></para>
            <para><b>MT^-1</b> == <i>M / T</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Acceleration">
            <summary>Acceleration - <see cref="T:NQualityOfLife.Units.Acceleration"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Acceleration">Acceleration</see> == <see cref="P:NQualityOfLife.Units.Dimension.Speed">Speed</see> / <see cref="P:NQualityOfLife.Units.Dimension.Time">Time</see></para>
            <para><b>LT^-2</b> == <i>LT^-1 / T</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.RadiationExposure">
            <summary>RadiationExposure
            <para><see cref="P:NQualityOfLife.Units.Dimension.RadiationExposure">RadiationExposure</see> == <see cref="P:NQualityOfLife.Units.Dimension.ElectricCharge">ElectricCharge</see> / <see cref="P:NQualityOfLife.Units.Dimension.Mass">Mass</see></para>
            <para><b>ITM^-1</b> == <i>IT / M</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.VolumetricFlow">
            <summary>VolumetricFlow - <see cref="T:NQualityOfLife.Units.VolumetricFlow"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.VolumetricFlow">VolumetricFlow</see> == <see cref="P:NQualityOfLife.Units.Dimension.Volume">Volume</see> / <see cref="P:NQualityOfLife.Units.Dimension.Time">Time</see></para>
            <para><b>LT^-1</b> == <i>L / T</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.MassFlux">
            <summary>MassFlux - <see cref="T:NQualityOfLife.Units.MassFlux"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.MassFlux">MassFlux</see> == <see cref="P:NQualityOfLife.Units.Dimension.MassFlow">MassFlow</see> / <see cref="P:NQualityOfLife.Units.Dimension.Area">Area</see></para>
            <para><b>MT^-1L^-2</b> == <i>MT^-1 / L</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.MassDensity">
            <summary>MassDensity - <see cref="T:NQualityOfLife.Units.Density"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.MassDensity">MassDensity</see> == <see cref="P:NQualityOfLife.Units.Dimension.Mass">Mass</see> / <see cref="P:NQualityOfLife.Units.Dimension.Volume">Volume</see></para>
            <para><b>ML^-3</b> == <i>M / L</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Force">
            <summary>Force - <see cref="T:NQualityOfLife.Units.Newton"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Force">Force</see> == <see cref="P:NQualityOfLife.Units.Dimension.Mass">Mass</see> * <see cref="P:NQualityOfLife.Units.Dimension.Acceleration">Acceleration</see></para>
            <para><b>MLT^-2</b> == <i>LT^-2 * M</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Energy">
            <summary>Energy - <see cref="T:NQualityOfLife.Units.Joule"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Energy">Energy</see> == <see cref="P:NQualityOfLife.Units.Dimension.Force">Force</see> * <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see></para>
            <para><b>MLT^-2</b> == <i>MLT^-2 * L</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.SpringStiffness">
            <summary>SpringStiffness - <see cref="T:NQualityOfLife.Units.Stiffness"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.SpringStiffness">SpringStiffness</see> == <see cref="P:NQualityOfLife.Units.Dimension.Force">Force</see> / <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see></para>
            <para><b>MT^-2</b> == <i>MLT^-2 / L</i></para></summary>
            <remarks>This is also the <see cref="T:NQualityOfLife.Units.Dimension"/> of surface tension</remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Pressure">
            <summary>Pressure - <see cref="T:NQualityOfLife.Units.Pascal"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Pressure">Pressure</see> == <see cref="P:NQualityOfLife.Units.Dimension.Force">Force</see> / <see cref="P:NQualityOfLife.Units.Dimension.Area">Area</see></para>
            <para><b>ML^-1T^-2</b> == <i>MLT^-2 / L</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.HeatCapacity">
            <summary>HeatCapacity - <see cref="T:NQualityOfLife.Units.HeatCapacity"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.HeatCapacity">HeatCapacity</see> == <see cref="P:NQualityOfLife.Units.Dimension.Energy">Energy</see> / <see cref="P:NQualityOfLife.Units.Dimension.Temperature">Temperature</see></para>
            <para><b>MLT^-2^-1</b> == <i>MLT^-2 / </i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Power">
            <summary>Power - <see cref="T:NQualityOfLife.Units.Watt"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Power">Power</see> == <see cref="P:NQualityOfLife.Units.Dimension.Energy">Energy</see> / <see cref="P:NQualityOfLife.Units.Dimension.Time">Time</see></para>
            <para><b>MLT^-3</b> == <i>MLT^-2 / T</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.MagneticFlux">
            <summary>MagneticFlux - <see cref="T:NQualityOfLife.Units.Weber"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.MagneticFlux">MagneticFlux</see> == <see cref="P:NQualityOfLife.Units.Dimension.Energy">Energy</see> / <see cref="P:NQualityOfLife.Units.Dimension.ElectricCurrent">Current</see></para>
            <para><b>MLT^-2I^-1</b> == <i>MLT^-2 / I</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.AbsorbedRadiationDose">
            <summary>AbsorbedRadiationDose - <see cref="T:NQualityOfLife.Units.Rad"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.AbsorbedRadiationDose">AbsorbedRadiationDose</see> == <see cref="P:NQualityOfLife.Units.Dimension.Energy">Energy</see> / <see cref="P:NQualityOfLife.Units.Dimension.Mass">Mass</see></para>
            <para><b>LT^-2</b> == <i>MLT^-2 / M</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricPotentialDifference">
            <summary>Electric Potential Difference - <see cref="T:NQualityOfLife.Units.Volt"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.ElectricPotentialDifference">ElectricPotentialDifference</see> == <see cref="P:NQualityOfLife.Units.Dimension.Power">Power</see> / <see cref="P:NQualityOfLife.Units.Dimension.ElectricCurrent">Current</see></para>
            <para><b>MLT^-3I^-1</b> == <i>MLT^-3 / I</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Inductance">
            <summary>Inductance - <see cref="T:NQualityOfLife.Units.Henry"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Inductance">Inductance</see> == <see cref="P:NQualityOfLife.Units.Dimension.MagneticFlux">MagneticFlux</see> / <see cref="P:NQualityOfLife.Units.Dimension.ElectricCurrent">Current</see></para>
            <para><b>MLT^-2I^-2</b> == <i>MLT^-2I^-1 / I</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.SpecificHeatCapacity">
            <summary>SpecificHeatCapacity - <see cref="T:NQualityOfLife.Units.SpecificHeatCapacity"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.SpecificHeatCapacity">SpecificHeatCapacity</see> == <see cref="P:NQualityOfLife.Units.Dimension.HeatCapacity">HeatCapacity</see> / <see cref="P:NQualityOfLife.Units.Dimension.Mass">Mass</see></para>
            <para><b>LT^-2^-1</b> == <i>MLT^-2^-1 / M</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.MagneticFluxDensity">
            <summary>MagneticFluxDensity - <see cref="T:NQualityOfLife.Units.Tesla"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.MagneticFluxDensity">MagneticFluxDensity</see> == <see cref="P:NQualityOfLife.Units.Dimension.MagneticFlux">MagneticFlux</see> / <see cref="P:NQualityOfLife.Units.Dimension.Area">Area</see></para>
            <para><b>MT^-2I^-1</b> == <i>MLT^-2I^-1 / L</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricalResistance">
             <summary>Electrical Resistance - <see cref="T:NQualityOfLife.Units.Ohm"/>
             <para><see cref="P:NQualityOfLife.Units.Dimension.ElectricalResistance">ElectricalResistance</see> == <see cref="P:NQualityOfLife.Units.Dimension.ElectricPotentialDifference">ElectricPotentialDifference</see> / <see cref="P:NQualityOfLife.Units.Dimension.ElectricCurrent">Current</see></para>
             <para><b>MLT^-3I^-2</b> == <i>MLT^-3I^-1 / I</i></para></summary>
            <remarks>Not to be confused with <see cref="P:NQualityOfLife.Units.Dimension.ElectricalResistivity">ElectricalResistivity</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricalConductance">
            <summary>ElectricalConductance - <see cref="T:NQualityOfLife.Units.Siemens"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.ElectricalConductance">ElectricalConductance</see> == <see cref="P:NQualityOfLife.Units.Dimension.ElectricCurrent">Current</see> / <see cref="P:NQualityOfLife.Units.Dimension.ElectricPotentialDifference">ElectricPotentialDifference</see></para>
            <para><b>TIM^-1L^-2</b> == <i>I / MLT^-3I^-1</i></para></summary>
            <remarks>Not to be confused with <see cref="P:NQualityOfLife.Units.Dimension.ElectricalConductivity">ElectricalConductivity</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.Capacitance">
            <summary>Capacitance - <see cref="T:NQualityOfLife.Units.Farad"/>
            <para><see cref="P:NQualityOfLife.Units.Dimension.Capacitance">Capacitance</see> == <see cref="P:NQualityOfLife.Units.Dimension.ElectricCharge">ElectricCharge</see> / <see cref="P:NQualityOfLife.Units.Dimension.ElectricPotentialDifference">ElectricPotentialDifference</see></para>
            <para><b>ITM^-1L^-2</b> == <i>IT / MLT^-3I^-1</i></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricalResistivity">
            <summary><seealso href="https://en.wikipedia.org/wiki/Electrical_resistivity_and_conductivity">Resistivity</seealso> is a property of materials.
            <para><see cref="P:NQualityOfLife.Units.Dimension.ElectricalResistivity">ElectricalResistivity</see> == <see cref="P:NQualityOfLife.Units.Dimension.ElectricalResistance">ElectricalResistance</see> * <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see></para>
            <para><b>MLT^-3I^-2</b> == <i>MLT^-3I^-2 * L</i></para></summary>
            <remarks>Not to be confused with <see cref="P:NQualityOfLife.Units.Dimension.ElectricalResistance">ElectricalResistance</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ElectricalConductivity">
            <summary>ElectricalConductivity - <see cref="T:NQualityOfLife.Units.Conductivity"/>
            <para><seealso href="https://en.wikipedia.org/wiki/Electrical_resistivity_and_conductivity">Conductivity</seealso> is a property of materials.</para>
            <para><see cref="P:NQualityOfLife.Units.Dimension.ElectricalConductivity">ElectricalConductivity</see> == <see cref="P:NQualityOfLife.Units.Dimension.ElectricalConductance">ElectricalConductance</see> / <see cref="P:NQualityOfLife.Units.Dimension.Length">Length</see></para>
            <para><b>TIM^-1L^-3</b> == <i>TIM^-1L^-2 / L</i></para></summary>
            <remarks>Not to be confused with <see cref="P:NQualityOfLife.Units.Dimension.ElectricalConductance">ElectricalConductance</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ThermalResistivity">
            <summary><seealso href="https://en.wikipedia.org/wiki/Thermal_conductivity_and_resistivity">Resistivity</seealso> is a property of materials.</summary>
             <remarks>Inverse of <see cref="P:NQualityOfLife.Units.Dimension.ThermalConductivity">ThermalConductivity</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.ThermalConductivity">
            <summary><seealso href="https://en.wikipedia.org/wiki/Thermal_conductivity_and_resistivity">Conductivity</seealso> is a property of materials.</summary>
            <remarks>Inverse of <see cref="P:NQualityOfLife.Units.Dimension.ThermalResistivity">ThermalResistivity</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.BigG">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.GravitationalConstant"/>
        </member>
        <member name="P:NQualityOfLife.Units.Dimension.GravitationalConstant">
            <summary>This is the <see cref="T:NQualityOfLife.Units.Dimension"/> of <seealso cref="T:NQualityOfLife.Physics.G">big G</seealso>
            <para><b>LM^-1T^-2</b> == <i>L / M / T</i></para>
            <para><b>LM^-1T^-2</b> == <i>MLT^-2 * L * L / M</i></para>
            <para><b>LM^-1T^-2</b> == <i>MLT^-2 * L / M</i></para></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Farad">
            <summary>An unit of <seealso href="https://en.wikipedia.org/wiki/Capacitance">capacitance</seealso> || <seealso cref="T:NQualityOfLife.Units.Charge">coulomb</seealso> per <seealso cref="T:NQualityOfLife.Units.Volt">volt</seealso> || The capacity for a body to store <seealso cref="T:NQualityOfLife.Units.Charge">charge</seealso>
            <para>It is often seen alongside '<see cref="T:NQualityOfLife.Units.Henry"/>'</para></summary>
            <remarks><b>ITM^-1L^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Farad.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Farad"/>
            <para>Uppercase 'F'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Farad.capacitance">
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)">
            <remarks><see cref="T:NQualityOfLife.Units.Charge">IT</see> / <see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Second@,NQualityOfLife.Units.Volt@)">
            <remarks><see cref="T:NQualityOfLife.Units.Ampere">I</see> * <see cref="T:NQualityOfLife.Units.Second">T</see> / <see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@,NQualityOfLife.Units.Volt2@)">
            <remarks>(<see cref="T:NQualityOfLife.Units.Watt">MLT^-3</see> * <see cref="T:NQualityOfLife.Units.Second">T</see>) / <see cref="T:NQualityOfLife.Units.Volt2">MLT^-6I^-2</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Volt2@)">
            <remarks><see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Volt2">MLT^-6I^-2</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Volt2@)">
            <remarks>(<see cref="T:NQualityOfLife.Units.Newton">MLT^-2</see> * <see cref="T:NQualityOfLife.Units.Meter">L</see>) / <see cref="T:NQualityOfLife.Units.Volt2">MLT^-6I^-2</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Ohm@)">
            <remarks><see cref="T:NQualityOfLife.Units.Second">T</see> / <see cref="T:NQualityOfLife.Units.Ohm">MLT^-3I^-2</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Siemens@,NQualityOfLife.Units.Hertz@)">
            <remarks><see cref="T:NQualityOfLife.Units.Siemens">TIM^-1L^-2</see> / <see cref="T:NQualityOfLife.Units.Hertz">T^-1</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Hertz@)">
            <remarks>1 / (<see cref="T:NQualityOfLife.Units.Ohm">MLT^-3I^-2</see> * <see cref="T:NQualityOfLife.Units.Hertz">T^-1</see>) == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Charge2@,NQualityOfLife.Units.Joule@)">
            <remarks><see cref="T:NQualityOfLife.Units.Charge2">IT</see> / <see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Charge2@,NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)">
            <remarks><see cref="T:NQualityOfLife.Units.Charge2">IT</see> / (<see cref="T:NQualityOfLife.Units.Newton">MLT^-2</see> * <see cref="T:NQualityOfLife.Units.Meter">L</see>) == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Second2@,NQualityOfLife.Units.Henry@)">
            <remarks><see cref="T:NQualityOfLife.Units.Second2">T</see> / <see cref="T:NQualityOfLife.Units.Henry">MLT^-2I^-2</see> == <see cref="T:NQualityOfLife.Units.Farad">ITM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.ReactanceX@,NQualityOfLife.Units.AngularVelocity_@)">
            <summary>1/(<seealso cref="T:NQualityOfLife.Units.AngularVelocity_"></seealso><seealso cref="F:NQualityOfLife.Utils.Common.Chars.DotProd"></seealso>|Xc|)</summary>
            <param name="reactanceXc"></param>
            <param name="angularVelocity"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.ReactanceX@,NQualityOfLife.Units.Hertz@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Farad"/>
        </member>
        <member name="P:NQualityOfLife.Units.Farad.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Farad.capacitance"/>
        </member>
        <member name="P:NQualityOfLife.Units.Farad.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Capacitance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.SolveFor(NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Permittivity.#ctor(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.SolveFor(NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.op_Division(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Permittivity.#ctor(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.op_Multiply(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Farad.op_Multiply(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Farad@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.ICharge">
            <summary>Electric <seealso cref="T:NQualityOfLife.Units.Charge">charge</seealso></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/>
            <para><b>IT</b> == <i><see cref="T:NQualityOfLife.Units.Ampere">I</see> * <see cref="T:NQualityOfLife.Units.Second">T</see></i></para></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.ElementaryCharge">
            <summary>The <seealso cref="T:NQualityOfLife.Units.Charge">charge</seealso> of one electron(-) or proton(+)</summary>
            <remarks><b>IT</b> == <i><see cref="T:NQualityOfLife.Units.Ampere">I</see> * <see cref="T:NQualityOfLife.Units.Second">T</see></i></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.ElementaryCharge.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.ElementaryCharge"/>
            <para>Lowercase 'e'</para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ElementaryCharge.InCoulombs">
            <inheritdoc cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs"/>
        </member>
        <member name="M:NQualityOfLife.Units.ElementaryCharge.#ctor(NQualityOfLife.Units.Charge@)">
            <summary>Convert a <see cref="T:NQualityOfLife.Units.Charge"/> given in <paramref name="coulomb"/> to <see cref="T:NQualityOfLife.Units.ElementaryCharge"/></summary>
            <param name="coulomb"></param>
        </member>
        <member name="P:NQualityOfLife.Units.ElementaryCharge.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.ElectricCharge"/>
        </member>
        <member name="P:NQualityOfLife.Units.ElementaryCharge.Value">
            <summary>The value in <see cref="T:NQualityOfLife.Units.Charge">Coulombs</see></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Charge">
            <summary><b>Coulomb</b> is the unit of electric <see cref="T:NQualityOfLife.Units.ICharge">charge</see> || "It is defined to be equal to the electric charge delivered by a 1 <seealso cref="T:NQualityOfLife.Units.Ampere">ampere</seealso> current in 1 <seealso cref="T:NQualityOfLife.Units.Second">second</seealso>."(Wikipedia) || <seealso cref="T:NQualityOfLife.Units.Charge">Coulomb</seealso> == <see cref="T:NQualityOfLife.Units.Ampere"/> * <see cref="T:NQualityOfLife.Units.Second"/></summary>
            <remarks><b>IT</b> == <i><see cref="T:NQualityOfLife.Units.Ampere">I</see> * <see cref="T:NQualityOfLife.Units.Second">T</see></i></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Charge.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Charge">Coulomb</see>
            <para>Uppercase 'C'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Charge.coulomb">
            <inheritdoc cref="T:NQualityOfLife.Units.Charge"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Second@)">
            <summary>Calculate the total <see cref="T:NQualityOfLife.Units.Charge"/> transferred at the given <paramref name="current"/> and <paramref name="time"/>
            <para>The total <see cref="T:NQualityOfLife.Units.Charge"/> to sustain the given <paramref name="current"/> for the given amount of <paramref name="time"/></para></summary><param name="current"></param><param name="time"></param>
            <remarks><see cref="T:NQualityOfLife.Units.Ampere">I</see> * <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Charge">IT</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Charge.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="P:NQualityOfLife.Units.Charge.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Charge.coulomb"/>
        </member>
        <member name="P:NQualityOfLife.Units.Charge.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.ElectricCharge"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.SolveFor(NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.SolveFor(NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.SolveFor(NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.op_Multiply(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.op_Multiply(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Charge@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.op_Division(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.op_Division(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Charge.op_Division(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Charge2">
            <summary>Represents an <see cref="T:NQualityOfLife.Units.IAbstractUnit"/> with a dimension IT</summary>
            <remarks><para><b>IT</b></para></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.Ampere">
            <summary><see cref="T:NQualityOfLife.Units.Ampere"/> is how many <seealso cref="T:NQualityOfLife.Units.Charge">Charges</seealso> / <see cref="T:NQualityOfLife.Units.Second"/> are moving past a given point</summary>
            <remarks><para><b>I</b> == <i><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.ElectricCurrent"/></i></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Ampere.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Ampere"/>
            <para>Uppercase 'A'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Ampere.ampere">
            <inheritdoc cref="T:NQualityOfLife.Units.Ampere"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Volt@)">
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso> required to achieve the given <seealso cref="T:NQualityOfLife.Units.Watt">power</seealso> with the given <seealso cref="T:NQualityOfLife.Units.Volt">voltage</seealso></summary>
            <param name="power"></param>
            <param name="overVolt"></param>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Second@)">
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso> from the amount of <seealso cref="T:NQualityOfLife.Units.Charge">charges</seealso> moved <paramref name="overTime"/>
            <para>This is the <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso> needed to transfer the given total <paramref name="charge"/> in the given <seealso cref="T:NQualityOfLife.Units.Second">time</seealso></para>
            <para>/ <seealso cref="T:NQualityOfLife.Units.Charge">charges</seealso> per <see cref="T:NQualityOfLife.Units.Second"/> - aka the definition of <see cref="T:NQualityOfLife.Units.Ampere"/></para></summary>
            <param name="charge">The amount of <see cref="T:NQualityOfLife.Units.Charge"/> moved</param>
            <param name="overTime"></param>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ohm@)">
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso> that will pass through the given <seealso cref="T:NQualityOfLife.Units.Ohm">resistance</seealso> at the given <paramref name="voltage"/></summary>
            <param name="voltage">The <seealso cref="T:NQualityOfLife.Units.Volt">voltage</seealso> over the <seealso cref="T:NQualityOfLife.Units.Ohm">resistance</seealso></param>
            <param name="overResistance"></param>
        </member>
        <member name="P:NQualityOfLife.Units.Ampere.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Ampere.ampere"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Charge.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.op_Multiply(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Charge.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.op_Multiply(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Charge.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.op_Multiply(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Ohm@)">
            <summary></summary><param name="current"></param><param name="resistance"></param>
            <returns>The <seealso cref="T:NQualityOfLife.Units.Volt">voltage</seealso> over the resistor with the given <paramref name="current"/></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere.op_Multiply(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Ampere@)">
            <summary></summary><param name="current"></param><param name="resistance"></param>
            <returns>The <seealso cref="T:NQualityOfLife.Units.Volt">voltage</seealso> over the resistor with the given <paramref name="current"/></returns>
        </member>
        <member name="T:NQualityOfLife.Units.Ampere2">
            <remarks><para><b>I</b></para></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Ampere"/>
        </member>
        <member name="F:NQualityOfLife.Units.Ampere2.ampere2">
            <inheritdoc cref="T:NQualityOfLife.Units.Ampere2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere2.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ampere2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere2.#ctor(NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ampere2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere2.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ampere2"/>
        </member>
        <member name="P:NQualityOfLife.Units.Ampere2.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Ampere2.ampere2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere2.SolveFor(NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere2.op_Multiply(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ampere2.op_Multiply(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Ampere2@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Henry">
            <summary>The <see cref="T:NQualityOfLife.Units.Henry"/> is the unit of <see cref="P:NQualityOfLife.Units.Dimension.Inductance">electrical inductance</see> in the metric system
            <para>It is often seen alongside '<see cref="T:NQualityOfLife.Units.Farad"/>'</para></summary>
            <remarks><b>MLT^-2I^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Henry.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Henry"/>
            <para>Uppercase 'H'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Henry.henry">
            <inheritdoc cref="T:NQualityOfLife.Units.Henry"/>
        </member>
        <member name="P:NQualityOfLife.Units.Henry.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Inductance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Henry.op_Multiply(NQualityOfLife.Units.Henry@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Henry@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Henry.op_Multiply(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Henry@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Henry@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Tesla">
            <summary>The <see cref="T:NQualityOfLife.Units.Tesla"/> is an unit of <seealso cref="T:NQualityOfLife.Units.Weber">magnetic flux</seealso> density || <see cref="T:NQualityOfLife.Units.Weber"/> per square <seealso cref="T:NQualityOfLife.Units.Meter">meter</seealso></summary>
            <remarks><b>MT^-2I^-1</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Tesla.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Tesla"/>
            <para>Uppercase 'T'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Tesla.tesla">
            <inheritdoc cref="T:NQualityOfLife.Units.Tesla"/>
        </member>
        <member name="M:NQualityOfLife.Units.Tesla.SolveFrom(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Second@,NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Tesla"/>
        </member>
        <member name="M:NQualityOfLife.Units.Tesla.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Tesla"/>
        </member>
        <member name="M:NQualityOfLife.Units.Tesla.SolveFrom(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Weber@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Tesla.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Tesla.SolveFrom(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Tesla.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Tesla.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Tesla"/>
        </member>
        <member name="P:NQualityOfLife.Units.Tesla.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Tesla.tesla"/>
        </member>
        <member name="P:NQualityOfLife.Units.Tesla.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.MagneticFluxDensity"/>
        </member>
        <member name="M:NQualityOfLife.Units.Tesla.SolveFor(NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Tesla@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Tesla.op_Multiply(NQualityOfLife.Units.Tesla@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Tesla@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Tesla.op_Multiply(NQualityOfLife.Units.Area@,NQualityOfLife.Units.Tesla@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Tesla@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Weber">
            <summary><seealso cref="T:NQualityOfLife.Units.Volt">volt</seealso> <seealso cref="T:NQualityOfLife.Units.Second">second</seealso> || The <see cref="T:NQualityOfLife.Units.Weber"/> is an unit of magnetic flux || 1Wb == 1V * 1s || <see cref="T:NQualityOfLife.Units.Weber"/> == <see cref="T:NQualityOfLife.Units.Henry"/> * <see cref="T:NQualityOfLife.Units.Ampere"/></summary>
            <remarks><b>MLT^-2I^-1</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Weber.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Weber"/>
            <para>Wb - Uppercase 'W' and lowercase 'b'</para></summary>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Weber"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Henry@,NQualityOfLife.Units.Ampere@)">
            <remarks><see cref="T:NQualityOfLife.Units.Henry">MLT^-2I^-2</see> * <see cref="T:NQualityOfLife.Units.Ampere">I</see> == <see cref="T:NQualityOfLife.Units.Weber">MLT^-2I^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Weber"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Tesla@,NQualityOfLife.Units.Area@)">
            <remarks><see cref="T:NQualityOfLife.Units.Tesla">MT^-2I^-1</see> * <see cref="T:NQualityOfLife.Units.Area">L</see> == <see cref="T:NQualityOfLife.Units.Weber">MLT^-2I^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Weber"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Second@)">
            <remarks><see cref="T:NQualityOfLife.Units.Henry">MLT^-3I^-1</see> * <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Weber">MLT^-2I^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Weber"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Ampere@)">
            <remarks><see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Ampere">I</see> == <see cref="T:NQualityOfLife.Units.Weber">MLT^-2I^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Weber"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Charge@)">
            <remarks><see cref="T:NQualityOfLife.Units.Ohm">MLT^-3I^-2</see> * <see cref="T:NQualityOfLife.Units.Charge">IT</see> == <see cref="T:NQualityOfLife.Units.Weber">MLT^-2I^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Weber"/>
        </member>
        <member name="P:NQualityOfLife.Units.Weber.Value">
            <inheritdoc cref="T:NQualityOfLife.Units.Weber"/>
        </member>
        <member name="P:NQualityOfLife.Units.Weber.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.MagneticFlux"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.SolveFor(NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Henry.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.op_Division(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Henry.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.op_Division(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.SolveFor(NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Tesla.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.op_Division(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Tesla.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.SolveFor(NQualityOfLife.Units.Charge@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Weber.op_Division(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Charge@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Watt">
            <summary>The <see cref="T:NQualityOfLife.Units.Watt"/> is an unit of power || the energy(<see cref="T:NQualityOfLife.Units.Joule"/>) / second(<see cref="T:NQualityOfLife.Units.Second"/>)</summary>
            <remarks><b>MLT^-3</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Watt.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Watt"/>
            <para>Uppercase 'W'</para></summary>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Watt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Watt@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Watt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFrom(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFrom(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)">
            <remarks><see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see> * <see cref="T:NQualityOfLife.Units.Ampere">I</see> == <see cref="T:NQualityOfLife.Units.Watt">MLT^-3</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Watt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFrom(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Volt2@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt2@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFrom(NQualityOfLife.Units.Volt2@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt2@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt2@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Watt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFrom(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFrom(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Ampere2@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Ohm@)">
            <remarks><see cref="T:NQualityOfLife.Units.Ampere2">I</see> * <see cref="T:NQualityOfLife.Units.Ohm">MLT^-3I^-2</see> == <see cref="T:NQualityOfLife.Units.Watt">MLT^-3</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Watt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFrom(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFrom(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Joule@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Second@)">
            <remarks><see cref="T:NQualityOfLife.Units.Joule">ML^2T^-2</see> / <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Watt">ML^2T^-3</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Watt"/>
        </member>
        <member name="P:NQualityOfLife.Units.Watt.Value">
            <inheritdoc cref="T:NQualityOfLife.Units.Watt"/>
        </member>
        <member name="P:NQualityOfLife.Units.Watt.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Power"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFor(NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.op_Division(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFor(NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Volt@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.SolveFor(NQualityOfLife.Units.Joule@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Watt@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Watt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Second.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Watt@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Multiply(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Multiply(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Watt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Division(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere@)">
            <summary></summary><param name="power"></param><param name="perCurrent"></param>
            <returns>The <seealso cref="T:NQualityOfLife.Units.Volt">voltage</seealso> required to achieve the given <paramref name="power"/> with the given <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Division(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere2@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere2@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Watt.op_Division(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Volt@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Resistivity">
            <summary>Electrical Resistivity<para><see cref="T:NQualityOfLife.Units.Resistivity"/> is a property of <seealso cref="T:NQualityOfLife.Physics.IMaterial">materials</seealso></para></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Conductivity">
            <summary>Electrical <see cref="T:NQualityOfLife.Units.Conductivity"/> is a property of <seealso cref="T:NQualityOfLife.Physics.IMaterial">materials</seealso></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Conductivity.OfSilver">
            <summary><para>At 20 <see cref="T:NQualityOfLife.Units.Celsius"/></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Conductivity.OfCopper">
            <summary><para>At 20 <see cref="T:NQualityOfLife.Units.Celsius"/></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Conductivity.OfGold">
            <summary><para>At 20 <see cref="T:NQualityOfLife.Units.Celsius"/></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Conductivity.OfTungsten">
            <summary><para>At 20 <see cref="T:NQualityOfLife.Units.Celsius"/></para></summary>
        </member>
        <member name="P:NQualityOfLife.Units.Conductivity.OfIron">
            <summary><para>At 20 <see cref="T:NQualityOfLife.Units.Celsius"/></para></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Ohm">
            <summary>The <see cref="T:NQualityOfLife.Units.Ohm"/> is an unit of electrical resistance</summary>
            <remarks><b>MLT^-3I^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Ohm.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Ohm"/>
            <para>Uppercase '' (Omega)</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Ohm.">
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)">
            <remarks><see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see> / <see cref="T:NQualityOfLife.Units.Ampere">I</see> == <see cref="T:NQualityOfLife.Units.Ohm">MLT^-3I^-2</see></remarks>
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Ohm">resistance</seealso> of the system with the given <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso> and <paramref name="voltage"/></summary>
            <param name="voltage"></param>
            <param name="perCurrent"></param>
            <returns>The <seealso cref="T:NQualityOfLife.Units.Ohm">resistance</seealso> of the system with the given <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso> and <paramref name="voltage"/></returns>
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Ampere2@,NQualityOfLife.Units.Watt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere2@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere2@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere2@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere2@)">
            <remarks><see cref="T:NQualityOfLife.Units.Watt">MLT^-3</see> / <see cref="T:NQualityOfLife.Units.Ampere2">I</see> == <see cref="T:NQualityOfLife.Units.Ohm">MLT^-3I^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Farad@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Farad@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Farad@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Farad@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Farad@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Henry@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Henry@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Henry@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Henry@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Henry@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Weber@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFrom(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Charge@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Charge@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Charge@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Second@,NQualityOfLife.Units.Charge2@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Volt2@,NQualityOfLife.Units.Watt@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Siemens@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Ohm"/>
        </member>
        <member name="P:NQualityOfLife.Units.Ohm.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.ElectricalResistance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.SolveFor(NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Resistivity.#ctor(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.op_Division(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.op_Multiply(NQualityOfLife.Units.Meter@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Resistivity.#ctor(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Ohm.op_Multiply(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Resistivity.#ctor(NQualityOfLife.Units.Ohm@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Siemens">
            <summary><see cref="T:NQualityOfLife.Units.Siemens"/> is the inverse of the <see cref="T:NQualityOfLife.Units.Ohm"/>
            <para>SI unit for electric conductance, susceptibility, and admittance.</para></summary>
            <remarks><b>TIM^-1L^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Siemens.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Siemens"/>
            <para>Uppercase 'S'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Siemens.s">
            <inheritdoc cref="T:NQualityOfLife.Units.Siemens"/>
        </member>
        <member name="M:NQualityOfLife.Units.Siemens.#ctor(NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Siemens"/>
        </member>
        <member name="M:NQualityOfLife.Units.Siemens.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Siemens"/>
        </member>
        <member name="M:NQualityOfLife.Units.Siemens.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Volt@)">
            <remarks><see cref="T:NQualityOfLife.Units.Ampere">I</see> / <see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see> == <see cref="T:NQualityOfLife.Units.Siemens">TIM^-1L^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Siemens"/>
        </member>
        <member name="P:NQualityOfLife.Units.Siemens.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Siemens.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Siemens.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Siemens.s"/>
        </member>
        <member name="P:NQualityOfLife.Units.Siemens.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.ElectricalConductance"/>
        </member>
        <member name="M:NQualityOfLife.Units.Siemens.op_Division(NQualityOfLife.Units.Siemens@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Conductivity.#ctor(NQualityOfLife.Units.Siemens@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Siemens.op_Division(NQualityOfLife.Units.Siemens@,NQualityOfLife.Units.Hertz@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Siemens@,NQualityOfLife.Units.Hertz@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Volt">
            <summary>The <see cref="T:NQualityOfLife.Units.Volt"/> is an unit of <see cref="P:NQualityOfLife.Units.Dimension.ElectricPotentialDifference">electric potential</see></summary>
            <remarks><b>MLT^-3I^-1</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Volt.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Volt"/>
            <para>Uppercase 'V'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Volt.volts">
            <inheritdoc cref="T:NQualityOfLife.Units.Volt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Volt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.Watt@,NQualityOfLife.Units.Ampere@)">
            <remarks><see cref="T:NQualityOfLife.Units.Watt">MLT^-3</see> / <see cref="T:NQualityOfLife.Units.Ampere">I</see> == <see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see></remarks>
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Volt">voltage</seealso> required to achieve the given <paramref name="power"/> with the given <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso></summary>
            <param name="power"></param>
            <param name="overCurrent"></param>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Charge@)">
            <remarks><see cref="T:NQualityOfLife.Units.Joule">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Charge">IT</see> == <see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Volt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Ohm@)">
            <remarks><see cref="T:NQualityOfLife.Units.Ampere">I</see> * <see cref="T:NQualityOfLife.Units.Ohm">MLT^-3I^-2</see> == <see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see></remarks>
            <summary>Calculate the <seealso cref="T:NQualityOfLife.Units.Volt">voltage</seealso> needed to push the given <paramref name="current"/> through the given <paramref name="resistance"/></summary>
            <param name="current">The amount of <seealso cref="T:NQualityOfLife.Units.Ampere">current</seealso> passing through the <paramref name="resistance"/></param>
            <param name="resistance"></param>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.Weber@,NQualityOfLife.Units.Second@)">
            <remarks><see cref="T:NQualityOfLife.Units.Weber">MLT^-2I^-1</see> / <see cref="T:NQualityOfLife.Units.Second">T</see> == <see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Volt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.ElectronVolt@,NQualityOfLife.Units.ElementaryCharge@)">
            <remarks><see cref="T:NQualityOfLife.Units.ElectronVolt">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.ElementaryCharge">IT</see> == <see cref="T:NQualityOfLife.Units.Volt">MLT^-3I^-1</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Volt"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.#ctor(NQualityOfLife.Units.EField@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Volt"/>
        </member>
        <member name="P:NQualityOfLife.Units.Volt.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Volt.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Volt.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.ElectricPotentialDifference"/>
        </member>
        <member name="P:NQualityOfLife.Units.Volt.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Volt.volts"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Multiply(NQualityOfLife.Units.Charge@,NQualityOfLife.Units.Volt@)">
            <summary></summary>
            <param name="charge"></param>
            <param name="voltage"></param>
            <returns>The total amount of stored energy</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Multiply(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Charge@)">
            <summary></summary>
            <param name="charge"></param>
            <param name="voltage"></param>
            <returns>The total amount of stored energy</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.SolveFor(NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Multiply(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Multiply(NQualityOfLife.Units.Ampere@,NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Watt.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Multiply(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Multiply(NQualityOfLife.Units.Second@,NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Weber.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.NQualityOfLife#Units#ISolveFor{NQualityOfLife#Units#Ohm,NQualityOfLife#Units#Ampere}#SolveFor(NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Division(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ohm.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ampere@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.SolveFor(NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt.op_Division(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ohm@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Ampere.#ctor(NQualityOfLife.Units.Volt@,NQualityOfLife.Units.Ohm@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Volt2">
            <summary>Represents an <see cref="T:NQualityOfLife.Units.IAbstractUnit"/> with a dimension of '<see cref="T:NQualityOfLife.Units.Volt"/>^2'</summary>
            <remarks><b>MLT^-6I^-2</b></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Volt"/>
        </member>
        <member name="F:NQualityOfLife.Units.Volt2.voltagePow2">
            <inheritdoc cref="T:NQualityOfLife.Units.Volt2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt2.#ctor(NQualityOfLife.Units.Volt@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Volt2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt2.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Volt2"/>
        </member>
        <member name="P:NQualityOfLife.Units.Volt2.Value">
            <inheritdoc cref="T:NQualityOfLife.Units.Volt2"/>
        </member>
        <member name="M:NQualityOfLife.Units.Volt2.op_Division(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Volt2@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Farad.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Volt2@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Newton">
            <summary>The <see cref="T:NQualityOfLife.Units.Newton"/> is an unit of <see cref="P:NQualityOfLife.Units.Dimension.Force">force</see></summary>
            <remarks><b>MLT^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Newton.SYMB">
            <summary>The short unique symbol for the <see cref="T:NQualityOfLife.Units.Newton"/>
            <para>Uppercase 'N'</para></summary>
        </member>
        <member name="F:NQualityOfLife.Units.Newton.newtons">
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.#ctor(NQualityOfLife.Units.Newton@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Acceleration@)">
            <remarks><see cref="T:NQualityOfLife.Units.Kg">M</see> * <see cref="T:NQualityOfLife.Units.Acceleration">LT^-2</see> == <see cref="T:NQualityOfLife.Units.Newton">MLT^-2</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.#ctor(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Newton.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Acceleration@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.#ctor(NQualityOfLife.Units.Kg@,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="P:NQualityOfLife.Units.Newton.Symbol">
            <inheritdoc cref="F:NQualityOfLife.Units.Newton.SYMB"/>
        </member>
        <member name="P:NQualityOfLife.Units.Newton.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Newton.newtons"/>
        </member>
        <member name="P:NQualityOfLife.Units.Newton.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.Force"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.SolveFor(NQualityOfLife.Units.Stiffness@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Stiffness.SolveFor(NQualityOfLife.Units.Newton@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.SolveFor(NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Stiffness.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.op_Division(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Stiffness.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Meter@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.SolveFor(NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Pascal.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.op_Division(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Area@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Pascal.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Area@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Newton.op_Division(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Force">
            <summary><see cref="T:NQualityOfLife.Units.Force"/> vector</summary>
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="F:NQualityOfLife.Units.Force.X">
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="F:NQualityOfLife.Units.Force.Y">
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="F:NQualityOfLife.Units.Force.Z">
            <inheritdoc cref="T:NQualityOfLife.Units.Newton"/>
        </member>
        <member name="M:NQualityOfLife.Units.Force.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Newton@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Force"/>
        </member>
        <member name="M:NQualityOfLife.Units.Force.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Newton@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Force"/>
        </member>
        <member name="M:NQualityOfLife.Units.Force.#ctor(System.Single,System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Force"/>
        </member>
        <member name="M:NQualityOfLife.Units.Force.#ctor(System.Single,System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Force"/>
        </member>
        <member name="M:NQualityOfLife.Units.Force.op_Division(NQualityOfLife.Units.Force@,NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.AccelerationVector.#ctor(NQualityOfLife.Units.Force@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Magnetization">
            <summary>"In classical electromagnetism, magnetization is the vector field that expresses the density of permanent or induced magnetic dipole moments in a magnetic material."(<seealso href="https://en.wikipedia.org/wiki/Magnetization">wikipedia</seealso>)</summary>
        </member>
        <member name="T:NQualityOfLife.Units.IMass">
            <summary>An unit of mass, such as the <see cref="T:NQualityOfLife.Units.Kg"/></summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IFloat"/>, <see cref="T:NQualityOfLife.Units.IDimension"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.IMass.ToKg">
            <summary>The mass of <see langword="this"/> <see cref="T:NQualityOfLife.Units.IMass"/> in <see cref="T:NQualityOfLife.Units.Kg"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.IMass.InKg">
            <summary>The mass of <see langword="this"/> <see cref="T:NQualityOfLife.Units.IMass"/> in <see cref="T:NQualityOfLife.Units.Kg"/> as a <see cref="T:System.Single"/></summary>
            <returns>The mass of <see langword="this"/> in <see cref="T:NQualityOfLife.Units.Kg"/> (<see cref="T:System.Single"/>)</returns>
        </member>
        <member name="T:NQualityOfLife.Units.Kg">
            <summary>The <see cref="T:NQualityOfLife.Units.Kg"/> is the standard unit of <see cref="T:NQualityOfLife.Units.IMass"/> in the metric system</summary>
            <remarks><para><b>M</b> == <i><see cref="F:NQualityOfLife.Units.Dimension.BaseDimension.Mass"/></i></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Units.Kg.kg">
            <summary>The mass in <see cref="T:NQualityOfLife.Units.Kg"/></summary>
            <inheritdoc cref="T:NQualityOfLife.Units.Kg"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.#ctor(System.Single)">
            <inheritdoc cref="T:NQualityOfLife.Units.Kg"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="T:NQualityOfLife.Units.Kg"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.IMass@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Units.Kg"/> that equals the given <paramref name="mass"/></summary>
            <param name="mass"></param>
            <inheritdoc cref="T:NQualityOfLife.Units.Kg"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Acceleration@)">
            <remarks><see cref="T:NQualityOfLife.Units.Newton">MLT^-2</see> / <see cref="T:NQualityOfLife.Units.Acceleration">LT^-2</see> == <see cref="T:NQualityOfLife.Units.Kg">M</see></remarks>
            <inheritdoc cref="T:NQualityOfLife.Units.Kg"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Volume@)">
            <remarks><see cref="T:NQualityOfLife.Units.Density">ML^-3</see> * <see cref="T:NQualityOfLife.Units.Volume">L</see> == <see cref="T:NQualityOfLife.Units.Kg">M</see></remarks>
            <summary>Calculate the mass of a substance with the given <paramref name="density"/> that occupies the given <paramref name="volume"/></summary>
            <param name="density">The <see cref="T:NQualityOfLife.Units.Density"/> of the substance</param>
            <param name="volume">The <see cref="T:NQualityOfLife.Units.Volume"/> that the substance occupies</param>
            <inheritdoc cref="T:NQualityOfLife.Units.Kg"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Volume@,NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Kg.#ctor(NQualityOfLife.Units.Density@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="P:NQualityOfLife.Units.Kg.NQualityOfLife#Units#IMass#ToKg">
            <inheritdoc cref="T:NQualityOfLife.Units.Kg"/>
        </member>
        <member name="P:NQualityOfLife.Units.Kg.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Kg.kg"/>
        </member>
        <member name="P:NQualityOfLife.Units.Kg.InKg">
            <inheritdoc cref="F:NQualityOfLife.Units.Kg.kg"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.SolveFor(NQualityOfLife.Units.Speed2@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Speed2@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.SolveFor(NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Newton.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Acceleration@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.SolveFor(NQualityOfLife.Units.Newton@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Acceleration.#ctor(NQualityOfLife.Units.Newton@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.SolveFor(NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.SolveFor(NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.SolveFor(NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.SolveFor(NQualityOfLife.Units.MassFlow@)">
            <summary>Solve how long it takes to transfer <see langword="this"/> mass at the given <paramref name="flow"/></summary>
            <param name="flow"></param>
            <returns>The total time in <see cref="T:NQualityOfLife.Units.Second">seconds</see></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.op_Multiply(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Acceleration@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Newton.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Acceleration@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.op_Multiply(NQualityOfLife.Units.Acceleration@,NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Newton.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Acceleration@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.op_Multiply(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Kg@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see cref="T:NQualityOfLife.Units.AbstractUnit"/> with dimension <b>M</b></returns>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.op_Division(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Units.MassFlow.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Second@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.op_Division(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Volume@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.op_Division(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Liter@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Density.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Volume@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kg.op_Division(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Density@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Volume.#ctor(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.Density@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.IAbstractUnit">
            <summary></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/>, <see cref="T:NQualityOfLife.Types.IFloat"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.AbstractUnit">
            <summary>A Value that has some other dimensionality than any defined unit.</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Units.IAbstractUnit"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.AbstractUnit.TryCastUnsafe``1">
            <summary></summary>
            <typeparam name="TD"></typeparam>
            <returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.DimensionMismatchException"></exception>
        </member>
        <member name="M:NQualityOfLife.Units.AbstractUnit.op_GreaterThan(NQualityOfLife.Units.AbstractUnit@,NQualityOfLife.Units.AbstractUnit@)">
            <summary></summary><param name="left"></param><param name="right"></param><returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.DimensionMismatchException">Cannot compare two units with different dimensionalities!</exception>
        </member>
        <member name="M:NQualityOfLife.Units.AbstractUnit.op_LessThan(NQualityOfLife.Units.AbstractUnit@,NQualityOfLife.Units.AbstractUnit@)">
            <summary></summary><param name="left"></param><param name="right"></param><returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.DimensionMismatchException">Cannot compare two units with different dimensionalities!</exception>
        </member>
        <member name="M:NQualityOfLife.Units.AbstractUnit.op_GreaterThanOrEqual(NQualityOfLife.Units.AbstractUnit@,NQualityOfLife.Units.AbstractUnit@)">
            <summary></summary><param name="left"></param><param name="right"></param><returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.DimensionMismatchException">Cannot compare two units with different dimensionalities!</exception>
        </member>
        <member name="M:NQualityOfLife.Units.AbstractUnit.op_LessThanOrEqual(NQualityOfLife.Units.AbstractUnit@,NQualityOfLife.Units.AbstractUnit@)">
            <summary></summary><param name="left"></param><param name="right"></param><returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.DimensionMismatchException">Cannot compare two units with different dimensionalities!</exception>
        </member>
        <member name="M:NQualityOfLife.Units.AbstractUnit.op_Addition(NQualityOfLife.Units.AbstractUnit@,NQualityOfLife.Units.AbstractUnit@)">
            <summary></summary><param name="left"></param><param name="right"></param><returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.DimensionMismatchException">Cannot add two units with different dimensionalities!</exception>
        </member>
        <member name="M:NQualityOfLife.Units.AbstractUnit.op_Subtraction(NQualityOfLife.Units.AbstractUnit@,NQualityOfLife.Units.AbstractUnit@)">
            <summary></summary><param name="left"></param><param name="right"></param><returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.DimensionMismatchException">Cannot subtract two units with different dimensionalities!</exception>
        </member>
        <member name="T:NQualityOfLife.Units.IAbstractUnitVector">
            <summary></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.AbstractUnitVector">
            <summary></summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Units.IAbstractUnitVector"/>, <see cref="T:NQualityOfLife.Types.IVector3`1"/> where 'T' is <see cref="T:System.Single"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.ISolveFor`1">
            <summary>Solve for <typeparamref name="TResult"/> from <see langword="this"/></summary>
            <typeparam name="TResult"></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.ISolveFor`1.SolveFor">
            <summary>Solve the value of '<typeparamref name="TResult"/>' from <see langword="this"/> instance of '<see cref="T:NQualityOfLife.Units.ISolveFor`1"/>'</summary>
            <returns>A <see langword="new"/> instance of <typeparamref name="TResult"/></returns>
        </member>
        <member name="T:NQualityOfLife.Units.ISolveFor`2">
            <summary>Solve for <typeparamref name="TResult"/> from <see langword="this"/> and <typeparamref name="TOther"/></summary>
            <typeparam name="TResult"></typeparam><typeparam name="TOther"></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.ISolveFor`2.SolveFor(`1@)">
            <summary>Solve for <typeparamref name="TResult"/> from <see langword="this"/> and <typeparamref name="TOther"/></summary>
            <param name="val"></param>
            <returns><typeparamref name="TResult"/></returns>
        </member>
        <member name="T:NQualityOfLife.Units.ISolveFor`4">
            <summary>Solve for <typeparamref name="TResult"/> from <see langword="this"/>, <typeparamref name="TOther_A"/> and <typeparamref name="TOther_B"/></summary>
            <typeparam name="TImplementer">The <see cref="T:System.Type"/> '<typeparamref name="TImplementer"/>' that implements this <see langword="interface"/></typeparam>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TOther_A"></typeparam>
            <typeparam name="TOther_B"></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.ISolveFor`3">
            <inheritdoc cref="T:NQualityOfLife.Units.ISolveFor`4"/>
        </member>
        <member name="T:NQualityOfLife.Units.IPow2`2">
            <summary>Defines a <see cref="M:NQualityOfLife.Units.IPow2`2.Pow2">Pow2</see> method with dimensional types
            <para>Where '<typeparamref name="TB"/>' to the power of 2 == '<typeparamref name="TPow"/>'</para></summary>
            <typeparam name="TB"></typeparam>
            <typeparam name="TPow"></typeparam>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.IPow2`2.Pow2">
            <summary>Raise '<typeparamref name="TB"/>' to the second power, resulting in an unit of '<typeparamref name="TPow"/>'</summary>
            <returns><see langword="new"/> <typeparamref name="TPow"/></returns>
            <remarks>Defined in <see cref="T:NQualityOfLife.Units.IPow2`2"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.ThermalResistivity">
            <summary>Thermal Resistivity</summary>
        </member>
        <member name="T:NQualityOfLife.Units.ThermalConductivity">
            <summary>Thermal Conductivity, a property of <seealso cref="T:NQualityOfLife.Physics.IMaterial">materials</seealso></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ThermalConductivity.OfCopper">
            <summary></summary>
            <remarks>At 18.05 <see cref="T:NQualityOfLife.Units.Celsius"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.ThermalConductivity.OfSteel">
            <summary></summary>
            <remarks>At 18.05 <see cref="T:NQualityOfLife.Units.Celsius"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.ThermalConductivity.OfWater">
            <summary></summary>
            <remarks>At 26.85 <see cref="T:NQualityOfLife.Units.Celsius"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.ThermalConductivity.OfAir">
            <summary></summary>
            <remarks>At 25 <see cref="T:NQualityOfLife.Units.Celsius"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Units.BoltzmannConstant">
            <inheritdoc cref="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK"/>
            <summary></summary>
        </member>
        <member name="M:NQualityOfLife.Units.BoltzmannConstant.#ctor">
            <inheritdoc cref="T:NQualityOfLife.Units.BoltzmannConstant"/>
        </member>
        <member name="P:NQualityOfLife.Units.BoltzmannConstant.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.BoltzmannConstant.valJoulesPerKelvin"/>
        </member>
        <member name="T:NQualityOfLife.Units.HeatCapacity">
            <summary>Heat capacity - <seealso cref="T:NQualityOfLife.Units.Joule">joules</seealso>/<see cref="T:NQualityOfLife.Units.Kelvin"/><para>Describes how much energy is needed to increase the temperature of the object by 1 <see cref="T:NQualityOfLife.Units.Celsius"/></para></summary>
            <remarks><see cref="T:NQualityOfLife.Units.HeatCapacity"/> is a property of an object, not to be confused with <see cref="T:NQualityOfLife.Units.SpecificHeatCapacity"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Units.HeatCapacity.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Kelvin@)">
            <summary>The <see cref="T:NQualityOfLife.Units.HeatCapacity"/> of an object when it heats by the given amount using the given amount of energy</summary>
            <param name="joule">The energy used to heat the object</param>
            <param name="perKelvin">The resulting temperature change from the given energy</param>
        </member>
        <member name="M:NQualityOfLife.Units.HeatCapacity.#ctor(NQualityOfLife.Units.SpecificHeatCapacity@,NQualityOfLife.Units.Kg@)">
            <summary>Calculate the <see cref="T:NQualityOfLife.Units.HeatCapacity"/> of an amount of material with the given <see cref="T:NQualityOfLife.Units.SpecificHeatCapacity"/></summary>
            <param name="cap">The <see cref="T:NQualityOfLife.Units.SpecificHeatCapacity"/> of the material</param>
            <param name="mass">The amount of material with the given <see cref="T:NQualityOfLife.Units.SpecificHeatCapacity"/></param>
        </member>
        <member name="M:NQualityOfLife.Units.HeatCapacity.SolveFor(NQualityOfLife.Units.Kelvin@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.SpecificHeatCapacity">
            <summary>Specific heat capacity - J/(Kg*K)</summary>
            <remarks><see cref="T:NQualityOfLife.Units.SpecificHeatCapacity"/> is a property of a material, not to be confused with <see cref="T:NQualityOfLife.Units.HeatCapacity"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.SpecificHeatCapacity.OfAir">
            <summary></summary>
            <remarks>Dry, 0 <see cref="T:NQualityOfLife.Units.Celsius"/> at sea level</remarks>
        </member>
        <member name="M:NQualityOfLife.Units.SpecificHeatCapacity.SolveFor(NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.HeatCapacity.#ctor(NQualityOfLife.Units.SpecificHeatCapacity@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.SpecificHeatCapacity.op_Multiply(NQualityOfLife.Units.SpecificHeatCapacity@,NQualityOfLife.Units.Kg@)">
            <inheritdoc cref="M:NQualityOfLife.Units.HeatCapacity.#ctor(NQualityOfLife.Units.SpecificHeatCapacity@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.SpecificHeatCapacity.op_Multiply(NQualityOfLife.Units.Kg@,NQualityOfLife.Units.SpecificHeatCapacity@)">
            <inheritdoc cref="M:NQualityOfLife.Units.HeatCapacity.#ctor(NQualityOfLife.Units.SpecificHeatCapacity@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="T:NQualityOfLife.Units.Gray">
            <summary>Unit for absorbed dose of ionizing radiation - J/Kg - (<see cref="T:NQualityOfLife.Units.Joule"/> / <see cref="T:NQualityOfLife.Units.Kg"/>) || 1 <see cref="T:NQualityOfLife.Units.Gray"/> == 100 <see cref="T:NQualityOfLife.Units.Rad"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Rad">
            <summary>Unit for absorbed dose of ionizing radiation - 1 <see cref="T:NQualityOfLife.Units.Rad"/> == 0.01 <see cref="T:NQualityOfLife.Units.Gray"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Roentgen_Rem">
            <summary>Unit for Health effect of ionizing radiation - 1 <see cref="T:NQualityOfLife.Units.Roentgen_Rem"/> == 0.01 <see cref="T:NQualityOfLife.Units.Sievert"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Sievert">
            <summary>Unit for Health effect of ionizing radiation - J/Kg - (<see cref="T:NQualityOfLife.Units.Joule"/> / <see cref="T:NQualityOfLife.Units.Kg"/>) || 1 <see cref="T:NQualityOfLife.Units.Sievert"/> == 100 <see cref="T:NQualityOfLife.Units.Roentgen_Rem"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.RadiationExposure">
            <summary>Unit for Radiation Exposure - C/Kg - (<see cref="T:NQualityOfLife.Units.Charge"/> / <see cref="T:NQualityOfLife.Units.Kg"/>)</summary>
        </member>
        <member name="T:NQualityOfLife.Units.Roentgen">
            <summary>Unit for Radiation Exposure || 1 <see cref="T:NQualityOfLife.Units.Roentgen"/> == 2.5810^4 <see cref="T:NQualityOfLife.Units.Charge"/>/<see cref="T:NQualityOfLife.Units.Kg"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Celsius">
            <summary>Celsius degrees</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.FromKelvin(System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Units.Celsius"/> from a given <see cref="T:NQualityOfLife.Units.Kelvin"/> value</summary>
            <param name="kelvin"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Units.Celsius"/> <see cref="T:System.Object"/> that is the same temperature as the given <see cref="T:NQualityOfLife.Units.Kelvin"/> value</returns>
        </member>
        <member name="F:NQualityOfLife.Units.Celsius.C">
            <summary>floating point value in Celsius</summary>
        </member>
        <member name="P:NQualityOfLife.Units.Celsius.Value">
            <inheritdoc cref="F:NQualityOfLife.Units.Celsius.C"/>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Equality(NQualityOfLife.Units.Celsius@,NQualityOfLife.Units.Celsius@)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Equality(NQualityOfLife.Units.Celsius@,System.Single)">
            <summary></summary><param name="left"></param><param name="celsius">A floating point number in Celsius</param><returns>True if the two temperature values represent the same temperature || True if the two Celsius degree values are equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Inequality(NQualityOfLife.Units.Celsius@,System.Single)">
            <summary></summary><param name="left"></param><param name="celsius">A floating point number in Celsius</param><returns>True if the two Celsius degree values are not equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Equality(System.Single,NQualityOfLife.Units.Celsius@)">
            <summary></summary><param name="right"></param><param name="celsius">A floating point number in Celsius</param><returns>True if the two temperature values represent the same temperature || True if the two Celsius degree values are equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Inequality(System.Single,NQualityOfLife.Units.Celsius@)">
            <summary></summary><param name="right"></param><param name="celsius">A floating point number in Celsius</param><returns>True if the two Celsius degree values are not equal</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.SolveFor(NQualityOfLife.Units.HeatCapacity@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Multiply(NQualityOfLife.Units.HeatCapacity@,NQualityOfLife.Units.Celsius@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Celsius.op_Multiply(NQualityOfLife.Units.Celsius@,NQualityOfLife.Units.HeatCapacity@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)"/>
        </member>
        <member name="F:NQualityOfLife.Units.Fahrenheit.F">
            <summary>Fahrenheit</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Fahrenheit@,NQualityOfLife.Units.Fahrenheit@)">
            <summary></summary><param name="left"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Fahrenheit@,NQualityOfLife.Units.Kelvin@)">
            <summary></summary><param name="left"></param><param name="kelvin"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Fahrenheit@,NQualityOfLife.Units.Celsius@)">
            <summary></summary><param name="left"></param><param name="celsius"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.Fahrenheit@)">
            <summary></summary><param name="kelvin"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Celsius@,NQualityOfLife.Units.Fahrenheit@)">
            <summary></summary><param name="celsius"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(NQualityOfLife.Units.Fahrenheit@,System.Single)">
            <summary></summary><param name="left"></param><param name="fahrenheit"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Units.Fahrenheit.op_Equality(System.Single,NQualityOfLife.Units.Fahrenheit@)">
            <summary></summary><param name="fahrenheit"></param><param name="right"></param><returns>True if the two temperature values represent the same temperature</returns>
        </member>
        <member name="T:NQualityOfLife.Units.ITemperature">
            <summary>Interface for temperature units</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.IDimension"/>, <see cref="T:NQualityOfLife.Types.IFloat"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.IsAbsoluteZero">
            <summary>Is the current value of <see langword="this"/> instance 0 <see cref="T:NQualityOfLife.Units.Kelvin"/>?</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.ToC">
            <summary>Get <see langword="this"/> <see cref="T:NQualityOfLife.Units.ITemperature">temperature</see> in <see cref="T:NQualityOfLife.Units.Celsius"/> degrees</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.InC">
            <summary>Get <see langword="this"/> <see cref="T:NQualityOfLife.Units.ITemperature">temperature</see> in <see cref="T:NQualityOfLife.Units.Celsius"/> degrees as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.ToK">
            <summary>Get <see langword="this"/> <see cref="T:NQualityOfLife.Units.ITemperature">temperature</see> in <see cref="T:NQualityOfLife.Units.Kelvin"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.InK">
            <summary>Get <see langword="this"/> <see cref="T:NQualityOfLife.Units.ITemperature">temperature</see> in <see cref="T:NQualityOfLife.Units.Kelvin"/> as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.ToF">
            <summary>Get <see langword="this"/> <see cref="T:NQualityOfLife.Units.ITemperature">temperature</see> in <see cref="T:NQualityOfLife.Units.Fahrenheit"/> degrees</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperature.InF">
            <summary>Get <see langword="this"/> <see cref="T:NQualityOfLife.Units.ITemperature">temperature</see> in <see cref="T:NQualityOfLife.Units.Fahrenheit"/> degrees as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.ITemperatureAdditional">
            <summary>Provides extended functionality to <see cref="T:NQualityOfLife.Units.ITemperature"/></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Units.ITemperature"/> &lt;- <see cref="T:NQualityOfLife.Units.IDimension"/>, <see cref="T:NQualityOfLife.Types.IFloat"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperatureAdditional.ToRa">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Rankine"/> degrees</summary>
        </member>
        <member name="P:NQualityOfLife.Units.ITemperatureAdditional.InRa">
            <summary>Get this temperature in <see cref="T:NQualityOfLife.Units.Rankine"/> degrees as a <see cref="T:System.Single"/></summary>
        </member>
        <member name="T:NQualityOfLife.Units.Kelvin">
            <summary>Kelvin is the unit of absolute temperature</summary>
        </member>
        <member name="F:NQualityOfLife.Units.Kelvin.K">
            <summary>Kelvin</summary>
        </member>
        <member name="M:NQualityOfLife.Units.Kelvin.#ctor(System.Single)">
            <summary></summary>
            <param name="kelvin"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Units.Kelvin.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.HeatCapacity@)">
            <summary>Get the temperature of an object from its total <see cref="T:NQualityOfLife.Units.HeatCapacity"/> and <paramref name="energy"/></summary>
            <param name="energy">The total energy of the object</param>
            <param name="overHeatCapacity">The <see cref="T:NQualityOfLife.Units.HeatCapacity"/> of the object</param>
        </member>
        <member name="M:NQualityOfLife.Units.Kelvin.SolveFor(NQualityOfLife.Units.HeatCapacity@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kelvin.op_Multiply(NQualityOfLife.Units.HeatCapacity@,NQualityOfLife.Units.Kelvin@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kelvin.op_Multiply(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Joule.#ctor(NQualityOfLife.Units.Kelvin@,NQualityOfLife.Units.HeatCapacity@)"/>
        </member>
        <member name="M:NQualityOfLife.Units.Kelvin.SolveFor(NQualityOfLife.Units.Joule@)">
            <inheritdoc cref="M:NQualityOfLife.Units.HeatCapacity.#ctor(NQualityOfLife.Units.Joule@,NQualityOfLife.Units.Kelvin@)"/>
        </member>
        <member name="T:NQualityOfLife.IO.IImageInfo">
            <summary>Represents the metadata of an image</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="P:NQualityOfLife.IO.IImageInfo.SupportsTransparency">
            <summary>Get if the <see cref="T:NQualityOfLife.IO.IPixelImage"/> format supports transparency</summary>
        </member>
        <member name="P:NQualityOfLife.IO.IImageInfo.UsesTransparency">
            <summary>Get if the image represented by <see langword="this"/> <see cref="T:NQualityOfLife.IO.IPixelImage"/> uses the alpha channel</summary>
            <remarks>This is useful to know for example when converting from an image format to another<para><see cref="P:NQualityOfLife.IO.IImageInfo.UsesTransparency"/> should probably return <see langword="false"/> if <see cref="P:NQualityOfLife.IO.IImageInfo.SupportsTransparency"/> is <see langword="false"/>, as that would mean the <see cref="T:NQualityOfLife.IO.IPixelImage"/> is in an invalid / impossible state</para>
            <para>Should return <see langword="false"/> if the <see cref="T:NQualityOfLife.IO.IPixelImage"/> is empty / does not contain any pixel data</para></remarks>
        </member>
        <member name="P:NQualityOfLife.IO.IImageInfo.Width">
            <summary>The width of the <see cref="T:NQualityOfLife.IO.IPixelImage"/> in pixels.</summary>
            <returns>The width of the <see cref="T:NQualityOfLife.IO.IPixelImage"/> in pixels.<para>0 if the <see cref="T:NQualityOfLife.IO.IPixelImage"/> is empty, such as when the data has not yet been written to it</para></returns>
            <remarks>Any return that is &lt; 0 is used to represent an invalid state</remarks>
        </member>
        <member name="P:NQualityOfLife.IO.IImageInfo.Height">
            <summary>The height of the <see cref="T:NQualityOfLife.IO.IPixelImage"/> in pixels.</summary>
            <returns>The height of the <see cref="T:NQualityOfLife.IO.IPixelImage"/> in pixels.<para>0 if the <see cref="T:NQualityOfLife.IO.IPixelImage"/> is empty, such as when the data has not yet been written to it</para></returns>
            <remarks>Any return that is &lt; 0 is used to represent an invalid state</remarks>
        </member>
        <member name="P:NQualityOfLife.IO.IImageInfo.TotalPixels">
            <summary>The total amount of pixels in the image</summary>
        </member>
        <member name="T:NQualityOfLife.IO.IPixelImage">
            <summary><see cref="T:NQualityOfLife.IO.IPixelImage"/> represents a two dimensional array of <see cref="T:NQualityOfLife.Colors.RGBA"/> values</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.IO.IImageInfo"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.IO.ImageTools.FlagsAreSet(NQualityOfLife.IO.PNG.ColorType,NQualityOfLife.IO.PNG.ColorType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.ImageTools.AnyFlagIsSet(NQualityOfLife.IO.PNG.ColorType,NQualityOfLife.IO.PNG.ColorType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="T:NQualityOfLife.IO.Png">
            <summary>A simple class for encoding PNG image files.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.Png.SetFilter(System.Int32,System.Byte)">
            Sets the PNG filter for the current row.
        </member>
        <member name="M:NQualityOfLife.IO.Png.GetFilter(System.Int32)">
            Gets the PNG filter for the current row.
        </member>
        <member name="M:NQualityOfLife.IO.Png.SetPixel(System.Int32,System.Int32,System.Byte[]@)">
            
              Sets the pixel located at the X and Y coordinates of the
              image.  The pixel byte array is either 3 or 4 elements
              long and contains the red, green, blue, and optionally
              alpha components in that order.  If the byte array is 3
              elements long, sets alpha to 255.
              Because the row may use a PNG filter, those components may
              not actually represent the intensity of each color returned.
            
        </member>
        <member name="M:NQualityOfLife.IO.Png.SetPixel(System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)">
            
              Sets the pixel located at the X and Y coordinates of the
              image.  r, g, b are the red, green, and blue components.
              Sets alpha to 255.  This function should only be used if the
              PNG filter for the row is 0 (or not set), since this class
              currently does not apply PNG filters.
            
        </member>
        <member name="M:NQualityOfLife.IO.Png.SetPixel(System.Int32,System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
            
              Sets the pixel located at the X and Y coordinates of the
              image.  r, g, b are the red, green, and blue components.
              a is the alpha component.
              Because the row may use a PNG filter, those components may
              not actually represent the intensity of each color returned.
            
        </member>
        <member name="M:NQualityOfLife.IO.Png.GetPixel(System.Int32,System.Int32)">
            
              Gets the pixel located at the X and Y coordinates of the
              image.  Returns a bit array containing four elements for
              the red, green, blue, and alpha components, in that order.
              Because the row may use a PNG filter, the returned data may
              not actually represent the intensity of each color returned.
            
        </member>
        <member name="M:NQualityOfLife.IO.Png.GetBE(System.UInt32)">
            <summary>Get big endian</summary>
            <param name="crc"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.Png.Save(System.String)">
            Saves the image to a file.
        </member>
        <member name="M:NQualityOfLife.IO.Png.#ctor(System.Int32,System.Int32)">
            Creates a new PNG image with the given
            width and height.
        </member>
        <member name="T:NQualityOfLife.IO.PNG">
            <summary>Represents a PNG image</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.IO.IPixelImage"/></remarks>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.CompressionMethod">
            <summary>The method used to compress the image data.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.CompressionMethod.DeflateWithSlidingWindow">
            <summary>Deflate/inflate compression with a sliding window of at most 32768 bytes.</summary>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.ColorType">
            <summary>The color type that the <see cref="T:NQualityOfLife.IO.PNG"/> is encoded as</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ColorType.Grayscale">
            <summary>Only use 1 color channel to represent a grayscale image</summary>
            <remarks>int 0</remarks>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ColorType.PaletteFlag__">
            <summary>Use color palette for colors</summary>
            <remarks>int 1</remarks>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ColorType.Truecolor">
            <summary></summary>
            <remarks>int 2</remarks>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ColorType.Indexed">
            <summary>Use color palette for colors</summary>
            <remarks>int 3</remarks>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ColorType.AlphaFlag__">
            <summary>Use alpha channel</summary>
            <remarks>int 4</remarks>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ColorType.GrayscaleAndAlpha">
            <summary>Use 2 color channel to represent a grayscale image with transparency</summary>
            <remarks>int 4</remarks>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ColorType.Invalid__">
            <summary>Invalid value</summary>
            <remarks>int 5</remarks>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ColorType.TruecolorAndAlpha">
            <summary>Use 4 channels for a full RGBA color space</summary>
            <remarks>int 6</remarks>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.FilterMethod">
            <summary>Indicates the pre-processing method applied to the image data before compression.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.FilterMethod.AdaptiveFiltering">
            <summary>Adaptive filtering with five basic filter types.</summary>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.InterlaceMethod">
            <summary>Indicates the transmission order of the image data.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.InterlaceMethod.None">
            <summary>No interlacing.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.InterlaceMethod.Adam7">
            <summary><see cref="T:NQualityOfLife.IO.PNG.Adam7"/> interlacing.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.Header">
            <summary>The header data of the <see cref="T:NQualityOfLife.IO.PNG"/> image.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.#ctor(NQualityOfLife.IO.PNG.ImageHeader@,NQualityOfLife.IO.PNG.RawPngData)">
            <summary>Use one of the <see cref="M:NQualityOfLife.IO.PNG.Open(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.PNG.IChunkVisitor)"/> methods, or <see cref="M:NQualityOfLife.IO.PNG.Create(System.Int32,System.Int32,System.Boolean)"/></summary>
            <param name="header"></param>
            <param name="data"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> is <see langword="null"/></exception>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.Item(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.GetPixel(System.Int32,System.Int32)"/>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.DataBytes">
            <summary>How many <see cref="T:System.Byte"/>s are taken up by the actual pixel data</summary>
            <remarks>For a 1x1 <see cref="F:NQualityOfLife.IO.PNG.ColorType.TruecolorAndAlpha"/> <see cref="T:NQualityOfLife.IO.PNG"/> this will be 4 <see cref="T:System.Byte"/>s</remarks>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.BitsPerPixel">
            <summary>How many bits are used to represent one pixel</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.BytesPerPixel">
            <summary>How many <see cref="T:System.Byte"/>s are used to represent each pixel</summary>
            <remarks>This depends on the <see cref="T:NQualityOfLife.IO.PNG.ColorType"/> and bit depth</remarks>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.Channels">
            <summary></summary>
            <returns>1~4 or -1 if invalid</returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.GetPixel(System.Int32,System.Int32)">
            <summary>Get the pixel at the given column and row (x, y).</summary>
            <remarks>Pixel values are generated on demand from the underlying data to prevent holding many items in memory at once, so consumers
            should cache values if they're going to be looped over many time.</remarks>
            <param name="x">The x coordinate (column).</param>
            <param name="y">The y coordinate (row).</param>
            <returns>The pixel color information at the coordinate.</returns>
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.RawPngData.GetPixel(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Create(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngBuilder.Create(System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Draw(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.DrawImageTexture(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.IO.PNG@,NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Units.Degrees@)"/>
            <summary></summary>
            <param name="position"></param>
            <param name="drawParams"></param>
            <param name="rotation"></param>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Open(System.IO.Stream,NQualityOfLife.IO.PNG.IChunkVisitor)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)"/>
            <summary>Read the PNG image from the <see cref="T:System.IO.Stream">stream</see>.</summary>
            <param name="streamIn">The <see cref="T:System.IO.Stream">stream</see> containing PNG data to be read.
            <para>This <see cref="T:System.IO.Stream"/> is closed when <see cref="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)"/> has completed</para></param>
            <param name="chunkVisitor">Optional: A visitor which is called whenever a chunk is read by the library.</param>
            <returns>The <see cref="T:NQualityOfLife.IO.PNG"/> data from the <see cref="T:System.IO.Stream">stream</see>.</returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)"/>
            <summary>Read the <see cref="T:NQualityOfLife.IO.PNG"/> image from the <see cref="T:System.IO.Stream">stream</see>.</summary>
            <param name="streamIn">The <see cref="T:System.IO.Stream">stream</see> containing PNG data to be read.
            <para>This <see cref="T:System.IO.Stream"/> is closed when <see cref="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)"/> has completed</para></param>
            <param name="settings">Settings to apply when opening the PNG.</param>
            <returns>The <see cref="T:NQualityOfLife.IO.PNG"/> data from the <see cref="T:System.IO.Stream">stream</see>.</returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Open(System.Byte[],NQualityOfLife.IO.PNG.IChunkVisitor)">
            <summary>Read the PNG image from the bytes.</summary>
            <param name="bytes">The bytes of the PNG data to be read.</param>
            <param name="chunkVisitor">Optional: A visitor which is called whenever a chunk is read by the library.</param>
            <returns>The <see cref="T:NQualityOfLife.IO.PNG"/> data from the bytes.</returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Open(System.Byte[],NQualityOfLife.IO.PNG.PngOpener.Settings)">
            <summary>Read the PNG image from the bytes.</summary>
            <param name="bytes">The bytes of the PNG data to be read.</param>
            <param name="settings">Settings to apply when opening the PNG.</param>
            <returns>The <see cref="T:NQualityOfLife.IO.PNG"/> data from the bytes.</returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Open(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.PNG.IChunkVisitor)">
            <summary>Read the <see cref="T:NQualityOfLife.IO.PNG"/> from the given <paramref name="filePath"/>.</summary>
            <param name="filePath">The path to the PNG file to open.</param>
            <param name="chunkVisitor">Optional: A visitor which is called whenever a chunk is read by the library.</param>
            <remarks>This will open the file to obtain a <see cref="T:System.IO.FileStream"/> so will lock the file during reading.</remarks>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.IO.PNG"/> <see cref="T:System.Object"/> from the file.</returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Open(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.PNG.PngOpener.Settings)">
            <summary>Read the PNG from the file path.</summary>
            <param name="filePath">The path to the PNG file to open.</param>
            <param name="settings">Settings to apply when opening the PNG.</param>
            <remarks>This will open the file to obtain a <see cref="T:System.IO.FileStream"/> so will lock the file during reading.</remarks>
            <returns>The <see cref="T:NQualityOfLife.IO.PNG"/> data from the file.</returns>
            <inheritdoc cref="M:System.IO.File.OpenRead(System.String)"/>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.Adam7._passToScanlineGridIndex">
            <summary>For a given pass number (1 indexed) the scanline indexes of the lines included in that pass in the 8x8 grid.</summary>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.ChunkHeader">
            <summary>The header for a data chunk in a <see cref="T:NQualityOfLife.IO.PNG"/> file.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ChunkHeader.PLTE_Name">
            <summary><see cref="T:NQualityOfLife.IO.PNG.Palette"/> chunk</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ChunkHeader.Position">
            <summary>The position/start of the chunk header within the stream.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ChunkHeader.Length">
            <summary>The length of the chunk in bytes.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ChunkHeader.Name">
            <summary>The name of the chunk, uppercase first letter means the chunk is critical (vs. ancillary).</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.ChunkHeader.#ctor(System.Int64,System.Int32,System.String)">
            <summary>Create a new <see cref="T:NQualityOfLife.IO.PNG.ChunkHeader"/>.</summary>
            <param name="position">The position/start of the chunk header within the stream.</param>
            <param name="length">The length of the chunk in bytes.</param>
            <param name="name">The name of the chunk, uppercase first letter means the chunk is critical (vs. ancillary).</param>
            <exception cref="T:System.ArgumentException"><paramref name="length"/> is &lt; 0</exception>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"><paramref name="name"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></exception>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ChunkHeader.IsCritical">
            <summary>Whether the chunk is critical (must be read by all readers) or ancillary (may be ignored).</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ChunkHeader.IsPublic">
            <summary>A public chunk is one that is defined in the International Standard or is registered in the list of public chunk types maintained by the Registration Authority. 
            Applications can also define private (unregistered) chunk types for their own purposes.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ChunkHeader.IsSafeToCopy">
            <summary>Whether the (if unrecognized) chunk is safe to copy.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.Decoder.FilterType.None">
            <summary>The raw byte is unaltered.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.Decoder.FilterType.Sub">
            <summary>The byte to the left.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.Decoder.FilterType.Up">
            <summary>The byte above.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.Decoder.FilterType.Average">
            <summary>The mean of bytes left and above, rounded down.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.Decoder.FilterType.Paeth">
            <summary>Byte to the left, above or top-left based on Paeth's algorithm.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Decoder.SamplesPerPixel_Channels(NQualityOfLife.IO.PNG.ImageHeader@)">
            <inheritdoc cref="P:NQualityOfLife.IO.PNG.Channels"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Decoder.BytesPerScanline(NQualityOfLife.IO.PNG.ImageHeader@,System.Byte)">
            <summary>Get how many bytes are in one scanline when using '<see cref="F:NQualityOfLife.IO.PNG.InterlaceMethod.None"/>'</summary>
            <param name="header"></param>
            <param name="samplesPerPixel_channels"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Decoder.GetPaethValue(System.Byte,System.Byte,System.Byte)">
            <summary>Computes a simple linear function of the three neighboring pixels (left, above, upper left), then chooses as predictor the neighboring pixel closest to the computed value.</summary>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.HeaderValidationResult">
            <summary>Helper <see langword="struct"/> for validating and creating <see cref="T:NQualityOfLife.IO.PNG"/> headers</summary>
            <param name="byte1"></param><param name="byte2"></param><param name="byte3"></param>
            <param name="byte4"></param><param name="byte5"></param><param name="byte6"></param><param name="byte7"></param><param name="byte8"></param>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.HeaderValidationResult.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Helper <see langword="struct"/> for validating and creating <see cref="T:NQualityOfLife.IO.PNG"/> headers</summary>
            <param name="byte1"></param><param name="byte2"></param><param name="byte3"></param>
            <param name="byte4"></param><param name="byte5"></param><param name="byte6"></param><param name="byte7"></param><param name="byte8"></param>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.IChunkVisitor">
            <summary>Enables execution of custom logic whenever a chunk is read.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.IChunkVisitor.Visit(System.IO.Stream,NQualityOfLife.IO.PNG.ImageHeader@,NQualityOfLife.IO.PNG.ChunkHeader@,System.Byte[]@,System.Byte[]@)">
            <summary>Called by the PNG reader after a chunk is read.</summary>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.ImageHeader">
            <summary>a <see langword="struct"/> for a <see cref="T:NQualityOfLife.IO.PNG"/> header<para>The high level information about the image.</para></summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.ImageHeader.headerBytes">
            <summary>Bytes used to identify the file as a <see cref="T:NQualityOfLife.IO.PNG"/></summary>
            <remarks>"IHDR"</remarks>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ImageHeader.BitDepth">
            <summary>The bit depth of the image.
            <para>For example a <see cref="T:NQualityOfLife.IO.PNG"/> with either '<see cref="F:NQualityOfLife.IO.PNG.ColorType.TruecolorAndAlpha"/>' or '<see cref="F:NQualityOfLife.IO.PNG.ColorType.Truecolor"/>' can have a bit depth of '8' or '16'</para>
            <para>For a <see cref="F:NQualityOfLife.IO.PNG.ColorType.Indexed"/> it can be '1', '2', '4' or '8'</para>
            <para>For color images, this represents how many bits is used per color channel, Meaning a <see cref="T:NQualityOfLife.IO.PNG"/> with '<see cref="F:NQualityOfLife.IO.PNG.ColorType.TruecolorAndAlpha"/>' and a <see cref="P:NQualityOfLife.IO.PNG.ImageHeader.BitDepth"/> of '8' uses 4 bytes (32 bits) per pixel (1 <see cref="T:System.Byte"/> per color channel)</para></summary>
            <remarks>See: <see href="https://stackoverflow.com/questions/6278159/find-out-if-png-is-8-or-24"/> for more info</remarks>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ImageHeader.ColorType">
            <summary>The color type of the image.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ImageHeader.CompressionMethod">
            <summary>The compression method used for the image.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ImageHeader.FilterMethod">
            <summary>The filter method used for the image.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.ImageHeader.InterlaceMethod">
            <summary>The interlace method used by the image.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.ImageHeader.#ctor(System.Int32,System.Int32,System.Byte,NQualityOfLife.IO.PNG.ColorType,NQualityOfLife.IO.PNG.CompressionMethod,NQualityOfLife.IO.PNG.FilterMethod,NQualityOfLife.IO.PNG.InterlaceMethod)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.IO.PNG.ImageHeader"/>.</summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="bitDepth"></param>
            <param name="colorType"></param>
            <param name="compressionMethod"></param>
            <param name="filterMethod"></param>
            <param name="interlaceMethod"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.Palette">
            <summary>Represents a dictionary of colors used in the image
            <para>This is used as a jump table when decoding the image to save file space</para></summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Palette.#ctor(System.Byte[])">
            <summary></summary>
            <param name="data"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.Palette.Item(System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.Palette.GetColor(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.Palette.GetColor(System.Int32)">
            <summary>Get the color at the given index of the <see cref="T:NQualityOfLife.IO.PNG.Palette"/></summary>
            <param name="index"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Colors.RGB"/> <see cref="T:System.Object"/> with the color from the <see cref="T:NQualityOfLife.IO.PNG.Palette"/></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.PngBuilder">
            <summary>Used to construct <see cref="T:NQualityOfLife.IO.PNG"/> images. Call <see cref="M:NQualityOfLife.IO.PNG.PngBuilder.Create(System.Int32,System.Int32,System.Boolean)"/> to make a new builder.</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.IO.IImageInfo"/></remarks>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.PngBuilder.SaveOptions">
            <summary>Options for configuring generation of PNGs from a <see cref="T:NQualityOfLife.IO.PNG.PngBuilder"/>.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.PngBuilder.SaveOptions.AttemptCompression">
            <summary>Whether the library should try to reduce the resulting image size.
            This process does not affect the original image data (it is lossless) but may 
            result in longer save times.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.PngBuilder.SaveOptions.MaxDegreeOfParallelism">
            <summary>The number of parallel tasks allowed during compression.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.PngBuilder.__colorCounts">
            <summary>The unique colors used in the image</summary>
            <remarks>A <see cref="F:NQualityOfLife.IO.PNG.ColorType.Indexed"/> can be used if there are &lt;= 256 unique colors</remarks>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.#ctor(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngBuilder.Create(System.Int32,System.Int32,System.Boolean)"/>
            <summary></summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="hasAlphaChannel"></param>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.Create(System.Int32,System.Int32,System.Boolean)">
            <summary>Create a builder for a PNG with the given width and size.</summary>
            <param name="width"></param>
            <param name="height"></param>
            <param name="hasAlphaChannel"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.FromPng(NQualityOfLife.IO.PNG)">
            <summary>Create a builder from a <see cref="T:NQualityOfLife.IO.PNG"/>.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.FromPngBytes(System.Byte[])">
            <summary>Create a builder from the bytes of the specified <see cref="T:NQualityOfLife.IO.PNG"/> image.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.FromBgra32Pixels(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>Create a builder from the bytes in the BGRA32 pixel format. <see href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pixelformats.bgra32"/></summary>
            <param name="data">The pixels in BGRA32 format.</param>
            <param name="width">The width in pixels.</param>
            <param name="height">The height in pixels.</param>
            <param name="useAlphaChannel">Whether to include an alpha channel in the output.</param>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.FromBgra32Pixels(System.IO.Stream,System.Int32,System.Int32,System.Boolean)">
            <summary>Create a builder from the bytes in the BGRA32 pixel format. <see href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.pixelformats.bgra32"/></summary>
            <param name="data">The pixels in BGRA32 format.</param>
            <param name="width">The width in pixels.</param>
            <param name="height">The height in pixels.</param>
            <param name="useAlphaChannel">Whether to include an alpha channel in the output.</param>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel(System.Byte,System.Byte,System.Byte,System.Byte,System.Int32,System.Int32)">
            <summary>Set the pixel value for the given column (x) and row (y).</summary>
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel_Internal(System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel(System.Byte,System.Byte,System.Byte,System.Int32,System.Int32)">
            <summary>Set the pixel value for the given column (x) and row (y).</summary>
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel_Internal(System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel(System.Int32,System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel(System.Byte,System.Byte,System.Byte,System.Int32,System.Int32)"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel(NQualityOfLife.Colors.IColorImmutableBasic@,System.Int32,System.Int32)">
            <summary>Set the pixel value for the given column (x) and row (y).</summary>
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel_Internal(System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel(System.Int32,System.Int32,NQualityOfLife.Colors.IColorImmutableBasic@)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel(NQualityOfLife.Colors.IColorImmutableBasic@,System.Int32,System.Int32)"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.SetPixel_Internal(System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary></summary>
            <param name="dataIndex"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.StoreText(System.String,System.String)">
            <summary>Allows you to store arbitrary text data in the "iTXt" international textual data chunks of the generated PNG image.</summary>
            <param name="keyword">
            A keyword identifying the text data between 1-79 characters in length.
            Must not start with, end with or contain consecutive whitespace characters.
            Only characters in the range 32 - 126 and 161 - 255 are permitted.
            </param>
            <param name="text">
            The text data to store. Encoded as UTF-8 that may not contain zero (0) bytes but can be zero-length.
            </param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <returns><see langword="this"/> <see cref="T:NQualityOfLife.IO.PNG.PngBuilder"/> instance</returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.Done(NQualityOfLife.IO.PNG.PngBuilder.SaveOptions)">
            <summary>Finalize editing the <see cref="T:NQualityOfLife.IO.PNG"/></summary>
            <param name="options"></param>
            <returns>The <see langword="new"/> <see cref="T:NQualityOfLife.IO.PNG"/> created by <see langword="this"/> <see cref="T:NQualityOfLife.IO.PNG.PngBuilder"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.Save(NQualityOfLife.IO.PNG.PngBuilder.SaveOptions)">
            <summary>Get the bytes of the <see cref="T:NQualityOfLife.IO.PNG"/> file for <see langword="this"/> builder.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.Save(System.IO.Stream,NQualityOfLife.IO.PNG.PngBuilder.SaveOptions)">
            <summary>Write the PNG file bytes to the provided stream.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngBuilder.AttemptCompressionOfRawData(System.Byte[],NQualityOfLife.IO.PNG.PngBuilder.SaveOptions)">
            <summary>Attempt to improve compressability of the raw data by using adaptive filtering.</summary>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.PngOpener.Settings">
            <summary>Settings to use when opening a <see cref="T:NQualityOfLife.IO.PNG"/> using <see cref="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)"/></summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.PngOpener.Settings.ChunkVisitor">
            <summary>The code to execute whenever a chunk is read. Can be <see langword="null"/>.</summary>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.PngOpener.Settings.DisallowTrailingData">
            <summary>Whether to throw if the image contains data after the image end marker.
            <see langword="false"/> by default.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.IChunkVisitor)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)">
            <summary>Open a <see cref="T:NQualityOfLife.IO.PNG"/> that is contained in the <see cref="T:System.IO.Stream">stream</see> and then close the <see cref="T:System.IO.Stream">stream</see></summary>
            <param name="streamIn">This <see cref="T:System.IO.Stream"/> is closed when <see cref="M:NQualityOfLife.IO.PNG.PngOpener.Open(System.IO.Stream,NQualityOfLife.IO.PNG.PngOpener.Settings)"/> has completed</param>
            <param name="settings"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="streamIn"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngOpener.TryReadChunkHeader(System.IO.Stream,NQualityOfLife.IO.PNG.ChunkHeader@)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.StreamHelper.TryReadHeaderBytes(System.IO.Stream,System.Byte[]@)"/>
            <summary></summary>
            <param name="stream"></param>
            <param name="chunkHeader"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngOpener.ReadImageHeader(System.IO.Stream,System.Byte[]@)">
            <summary>Read the "IHDR" <see cref="T:NQualityOfLife.IO.PNG.ImageHeader"/> from the <paramref name="stream"/></summary>
            <param name="stream"></param>
            <param name="crc">a 4 <see cref="T:System.Byte"/> crc</param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.PngStreamWriteHelper">
            <summary>Helper <see cref="T:System.IO.Stream"/> <see langword="class"/> for creating <see cref="T:NQualityOfLife.IO.PNG"/>s</summary>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.PngStreamWriteHelper.#ctor(System.IO.Stream)">
            <summary></summary>
            <param name="inner"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="inner"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.IO.PNG.RawPngData">
            <summary>Provides convenience methods for indexing into a raw byte array to extract pixel values.</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.RawPngData.__bytesPerPixel">
            <summary>How many bytes is used to represent one pixel</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.RawPngData.__width">
            <summary>The width of the PNG in pixels</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.RawPngData.__palette">
            <summary>A color <see cref="T:NQualityOfLife.IO.PNG.Palette"/> of all the colors in the image, or <see langword="null"/> if the image does not use the <see cref="F:NQualityOfLife.IO.PNG.ColorType.Indexed"/> colors</summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.RawPngData.__bitDepth">
            <inheritdoc cref="P:NQualityOfLife.IO.PNG.ImageHeader.BitDepth"/>
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.IO.PNG.RawPngData.__colorType">
            <inheritdoc cref="T:NQualityOfLife.IO.PNG.ColorType"/>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.RawPngData.Item(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.RawPngData.GetPixel(System.Int32,System.Int32)"/>
        </member>
        <member name="P:NQualityOfLife.IO.PNG.RawPngData.Item(System.Int32)">
            <summary></summary>
            <param name="i"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.RawPngData.#ctor(System.Byte[],System.Int32,NQualityOfLife.IO.PNG.Palette@,NQualityOfLife.IO.PNG.ImageHeader@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.IO.PNG.RawPngData"/>.</summary>
            <param name="data">The decoded pixel data as bytes.</param>
            <param name="bytesPerPixel">The number of bytes in each pixel.</param>
            <param name="palette">The palette for the image.</param>
            <param name="imageHeader">The image header.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">width is &lt; 0</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.RawPngData.GetPixel(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.GetPixel(System.Int32,System.Int32)"/>
            <inheritdoc cref="M:NQualityOfLife.IO.PNG.Palette.GetColor(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.StreamHelper.ReadBigEndianInt32(System.IO.Stream)">
            <summary></summary>
            <param name="stream"></param>
            <returns></returns>
            <remarks>The first <see cref="T:System.Byte"/> is the most significant<para>See: <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#big-endian">Big-Endian</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.StreamHelper.ReadBigEndianInt32(System.Byte[],System.Int32)">
            <summary>Read the given <paramref name="bytes"/> as an <see cref="T:System.Int32"/>, where <paramref name="offset"/> can be used to select where the start of the <see cref="T:System.Int32"/> is in the given array of bytes</summary>
            <param name="bytes"></param>
            <param name="offset"></param>
            <returns></returns>
            <remarks>The first <see cref="T:System.Byte"/> is the most significant<para>See: <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#big-endian">Big-Endian</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.StreamHelper.WriteBigEndianInt32(System.IO.Stream,System.Int32)">
            <summary></summary>
            <param name="stream"></param>
            <param name="value"></param>
            <remarks>The first <see cref="T:System.Byte"/> is the most significant<para>See: <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#big-endian">Big-Endian</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.StreamHelper.ReadOrTerminate(System.IO.Stream)">
            <summary></summary>
            <param name="stream"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.PNG.StreamHelper.TryReadHeaderBytes(System.IO.Stream,System.Byte[]@)">
            <summary></summary>
            <param name="stream"></param>
            <param name="bytes"></param>
            <returns><see langword="true"/> if successfully read the next 8 bytes from the <paramref name="stream"/></returns>
        </member>
        <member name="T:NQualityOfLife.IO.IIO">
            <summary>Interface for file paths and folders</summary>
        </member>
        <member name="P:NQualityOfLife.IO.IIO.Exists">
            <summary>Returns <see langword="true"/> if the <see cref="T:System.IO.Directory"/>, <see cref="T:System.IO.File"/> or other file object exists and is found</summary>
        </member>
        <member name="T:NQualityOfLife.IO.IFolder">
            <summary>Interface for folders / <seealso cref="T:System.IO.Directory">directories</seealso></summary>
        </member>
        <member name="T:NQualityOfLife.IO.IFile">
            <summary>Interface for files</summary>
        </member>
        <member name="T:NQualityOfLife.IO.IFileType">
            <summary>Interface for files</summary>
        </member>
        <member name="P:NQualityOfLife.IO.IFileType.FileExtension">
            <summary>The file extension string of the file, such as 'xml', 'txt' or 'png'<para><see cref="F:System.String.Empty"/> if the file has no extension</para></summary>
        </member>
        <member name="T:NQualityOfLife.IO.FolderPath">
            <summary>Represents a path to a folder / <seealso cref="T:System.IO.DirectoryInfo">directory</seealso></summary>
        </member>
        <member name="M:NQualityOfLife.IO.FolderPath.#ctor(System.Uri)">
            <summary></summary>
            <param name="copyFrom"></param>
            <remarks>"%20" seems to be used for spaces in the <see cref="T:System.Uri"/>, so we replace those with an actual space for the <see cref="F:NQualityOfLife.IO.FolderPath._path"/></remarks>
        </member>
        <member name="P:NQualityOfLife.IO.FolderPath.Exists">
            <inheritdoc cref="M:System.IO.Directory.Exists(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FolderPath.op_Addition(NQualityOfLife.IO.FolderPath@,NQualityOfLife.IO.FileName@)">
            <summary>Combine the given <paramref name="folder"/> and <paramref name="file"/> to form a <see cref="T:NQualityOfLife.IO.FilePath"/> to the <paramref name="file"/></summary>
            <param name="folder">The folder that contains the <paramref name="file"/><para>Or where the file will be created</para></param>
            <param name="file">The file contained or to be created in the <paramref name="folder"/></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.IO.FilePath"/> that points to the given <paramref name="file"/> in the <paramref name="folder"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.FolderPath.Combine(NQualityOfLife.IO.FolderPath@,NQualityOfLife.IO.FileName@)">
            <summary>Combine the <see cref="T:NQualityOfLife.IO.FolderPath"/> '<paramref name="folder"/>' with the given <see cref="T:NQualityOfLife.IO.FileName"/> '<paramref name="file"/>' to get the <see cref="T:NQualityOfLife.IO.FilePath"/> to the file</summary>
            <param name="folder"></param>
            <param name="file"></param>
            <returns>The <see cref="T:NQualityOfLife.IO.FilePath"/> pointing to the given file</returns>
        </member>
        <member name="M:NQualityOfLife.IO.FolderPath.Combine(NQualityOfLife.IO.FileName@)">
            <summary>Combine <see langword="this"/> <see cref="T:NQualityOfLife.IO.FolderPath"/> with the given <paramref name="fileName"/> to get the <see cref="T:NQualityOfLife.IO.FilePath"/> to the file</summary>
            <param name="fileName"></param>
            <returns>The <see cref="T:NQualityOfLife.IO.FilePath"/> pointing to the given file</returns>
        </member>
        <member name="T:NQualityOfLife.IO.FilePath">
            <summary>Represents a path to a file</summary>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.#ctor(System.Uri)">
            <summary></summary>
            <param name="copyFrom"></param>
            <remarks>"%20" seems to be used for spaces in the <see cref="T:System.Uri"/>, so we replace those with an actual space for the <see cref="F:NQualityOfLife.IO.FilePath._path"/></remarks>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.#ctor(System.Reflection.Assembly)">
            <summary></summary>
            <param name="assembly"></param>
            <inheritdoc cref="P:System.Reflection.Assembly.Location"/>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.#ctor(System.IO.FileInfo)">
            <summary></summary>
            <param name="fileInfo"></param>
            <inheritdoc cref="P:System.IO.FileSystemInfo.FullName"/>
        </member>
        <member name="P:NQualityOfLife.IO.FilePath.Exists">
            <inheritdoc cref="M:System.IO.File.Exists(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.WriteBytes(System.Byte[])">
            <inheritdoc cref="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])"/>
            <summary></summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.op_Equality(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.FilePath@)">
            <inheritdoc cref="M:System.String.op_Equality(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.op_Inequality(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.FilePath@)">
            <inheritdoc cref="M:System.String.op_Inequality(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.op_Equality(System.String,NQualityOfLife.IO.FilePath@)">
            <inheritdoc cref="M:NQualityOfLife.IO.FilePath.op_Equality(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.FilePath@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.op_Inequality(System.String,NQualityOfLife.IO.FilePath@)">
            <inheritdoc cref="M:NQualityOfLife.IO.FilePath.op_Inequality(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.FilePath@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.op_Equality(NQualityOfLife.IO.FilePath@,System.String)">
            <inheritdoc cref="M:NQualityOfLife.IO.FilePath.op_Equality(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.FilePath@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FilePath.op_Inequality(NQualityOfLife.IO.FilePath@,System.String)">
            <inheritdoc cref="M:NQualityOfLife.IO.FilePath.op_Inequality(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.FilePath@)"/>
        </member>
        <member name="T:NQualityOfLife.IO.FileName">
            <summary>Represents a file with no known location</summary>
        </member>
        <member name="M:NQualityOfLife.IO.FileName.#ctor(System.String,System.String)">
            <summary></summary>
            <param name="name">The name of the file</param>
            <param name="extension">The file extension || do not include the dot</param>
        </member>
        <member name="M:NQualityOfLife.IO.FileName.op_Equality(NQualityOfLife.IO.FileName@,NQualityOfLife.IO.FileName@)">
            <inheritdoc cref="M:System.String.op_Equality(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FileName.op_Inequality(NQualityOfLife.IO.FileName@,NQualityOfLife.IO.FileName@)">
            <inheritdoc cref="M:System.String.op_Inequality(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FileName.op_Equality(System.String,NQualityOfLife.IO.FileName@)">
            <inheritdoc cref="M:NQualityOfLife.IO.FileName.op_Equality(NQualityOfLife.IO.FileName@,NQualityOfLife.IO.FileName@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FileName.op_Inequality(System.String,NQualityOfLife.IO.FileName@)">
            <inheritdoc cref="M:NQualityOfLife.IO.FileName.op_Inequality(NQualityOfLife.IO.FileName@,NQualityOfLife.IO.FileName@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FileName.op_Equality(NQualityOfLife.IO.FileName@,System.String)">
            <inheritdoc cref="M:NQualityOfLife.IO.FileName.op_Equality(NQualityOfLife.IO.FileName@,NQualityOfLife.IO.FileName@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.FileName.op_Inequality(NQualityOfLife.IO.FileName@,System.String)">
            <inheritdoc cref="M:NQualityOfLife.IO.FileName.op_Inequality(NQualityOfLife.IO.FileName@,NQualityOfLife.IO.FileName@)"/>
        </member>
        <member name="T:NQualityOfLife.IO.JavaDecompiler">
            <summary>Utility to make decompiling <seealso href="https://www.java.com/en/">Java</seealso> classes easier</summary>
        </member>
        <member name="P:NQualityOfLife.IO.JavaDecompiler.DecompilerExists">
            <summary>Check if the currently selected decompiler exists on the current system</summary>
            <returns><see langword="true"/> if the selected decompiler file exists</returns>
        </member>
        <member name="P:NQualityOfLife.IO.JavaDecompiler.Decompiler">
            <summary>The <see cref="T:NQualityOfLife.IO.FileName"/> of the selected decompiler</summary>
        </member>
        <member name="P:NQualityOfLife.IO.JavaDecompiler.DecompilerFolder">
            <summary>The folder where the <see cref="P:NQualityOfLife.IO.JavaDecompiler.Decompiler"/> is located on the system</summary>
        </member>
        <member name="P:NQualityOfLife.IO.JavaDecompiler.DecompilerFullPath">
            <summary>The full <see cref="T:NQualityOfLife.IO.FilePath"/> of the selected <see cref="P:NQualityOfLife.IO.JavaDecompiler.Decompiler"/></summary>
        </member>
        <member name="M:NQualityOfLife.IO.JavaDecompiler.SetDecompiler(NQualityOfLife.IO.FolderPath@,NQualityOfLife.IO.FileName@)">
            <summary>Set the <see cref="P:NQualityOfLife.IO.JavaDecompiler.Decompiler"/> <paramref name="location"/> and <paramref name="exe"/></summary>
            <param name="location">The folder where the <paramref name="exe"/> is located</param>
            <param name="exe">The decompiler executable</param>
            <returns><see langword="true"/> if the specified file was found and set as the current <see cref="P:NQualityOfLife.IO.JavaDecompiler.Decompiler"/></returns>
            <remarks><see href="https://github.com/leibnitz27/cfr"/> is recommended</remarks>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.JavaDecompiler.DecompileJavaClass(NQualityOfLife.IO.FilePath@)">
            <summary>Decompile a Java '.class' file</summary>
            <param name="pathToClass">The path to the Java '.class' file we want to decompile</param>
            <returns>The decompiled '.class' as a <see cref="T:System.String"/> or an error message <see cref="T:System.String"/> if failed</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.JavaDecompiler.RunJavaDecompiler(NQualityOfLife.IO.FilePath@,NQualityOfLife.IO.FolderPath@,NQualityOfLife.IO.FileName@,System.Boolean)">
            <summary>Decompile a Java '.class' or '.jar' file</summary>
            <param name="pathToClass">The path to the Java '.class' file we want to decompile</param>
            <param name="outputFolder">The folder where we put the decompilation result, leave empty if only <paramref name="print"/> to log is desired</param>
            <param name="outputFileName">What name to give to the decompiler result file, leave empty if only <paramref name="print"/> to log is desired</param>
            <param name="print">Print the decompilation result to log/console?</param>
            <returns><see langword="true"/> if the operation succeeded</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="T:NQualityOfLife.IO.ISaveLoad`2">
            <summary>
            <para><typeparamref name="T"/> is the deserialized form of <typeparamref name="TD"/></para>
            <para><typeparamref name="TD"/> is the serialized form of <typeparamref name="T"/></para></summary>
            <typeparam name="T"><typeparamref name="T"/> is the deserialized form of <typeparamref name="TD"/></typeparam>
            <typeparam name="TD"><typeparamref name="TD"/> is the serialized form of <typeparamref name="T"/></typeparam>
        </member>
        <member name="M:NQualityOfLife.IO.ISaveLoad`2.Deserialize(`1)">
            <summary>Load the given <paramref name="data"/> into an instance of <typeparamref name="T"/></summary>
            <param name="data">The result of <see cref="M:NQualityOfLife.IO.ISaveLoad`2.Serialize"/></param>
            <returns>The <typeparamref name="T"/> that was decoded from the <paramref name="data"/> <typeparamref name="TD"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="data"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.IO.ISaveLoad`2.Serialize">
            <summary>Turn <see langword="this"/> into a <typeparamref name="TD"/> that can be later <seealso cref="M:NQualityOfLife.IO.ISaveLoad`2.Deserialize(`1)">deserialized</seealso></summary>
            <returns>a <typeparamref name="TD"/> that can be later used to create a copy of <see langword="this"/> instance using <see cref="M:NQualityOfLife.IO.ISaveLoad`2.Deserialize(`1)"/></returns>
            <exception cref="T:System.InvalidOperationException">The <typeparamref name="T"/> instance cannot be serialized in it's current state</exception>
        </member>
        <member name="T:NQualityOfLife.IO.ISaveLoadFile`2">
            <inheritdoc cref="T:NQualityOfLife.IO.ISaveLoad`2"/>
        </member>
        <member name="M:NQualityOfLife.IO.ISaveLoadFile`2.Save(NQualityOfLife.IO.FolderPath@,NQualityOfLife.IO.FileName@)">
            <summary></summary>
            <param name="folderPath"></param>
            <param name="fileName"></param>
            <returns><see langword="true"/> if the operation was successfully completed</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.ISaveLoadFile`2.Load(NQualityOfLife.IO.FolderPath@,NQualityOfLife.IO.FileName@)">
            <summary></summary>
            <param name="folderPath"></param>
            <param name="fileName"></param>
            <returns><see langword="true"/> if the operation was successfully completed</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.ISaveLoadFile`2.Save(NQualityOfLife.IO.FilePath@)">
            <summary></summary>
            <param name="filePath"></param>
            <returns><see langword="true"/> if the operation was successfully completed</returns>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.ISaveLoadFile`2.Load(NQualityOfLife.IO.FilePath@)">
            <summary></summary>
            <param name="filePath"></param>
            <returns><see langword="true"/> if the operation was successfully completed</returns>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NQualityOfLife.IO.VersionInfo">
            <summary>Represents version information</summary>
        </member>
        <member name="F:NQualityOfLife.IO.VersionInfo.FormatConvention.SemVer">
            <summary>Semantic versioning - <see href="https://semver.org/"/> - 1.0.0</summary>
        </member>
        <member name="F:NQualityOfLife.IO.VersionInfo.FormatConvention.NumStat">
            <summary>Numeric status - 1.0.0.0</summary>
        </member>
        <member name="F:NQualityOfLife.IO.VersionInfo.FormatConvention.CalVer">
            <summary>Calendar Versioning</summary>
        </member>
        <member name="F:NQualityOfLife.IO.VersionInfo.FormatConvention.CalVer_ISO8601">
            <summary>Calendar Versioning - ISO 8601 Standard - <see href="https://en.wikipedia.org/wiki/ISO_8601"/></summary>
        </member>
        <member name="F:NQualityOfLife.IO.VersionInfo.DefaultAssemblyVersionString">
            <inheritdoc cref="F:NQualityOfLife.IO.VersionInfo.DefaultAssemblyVersion"/>
        </member>
        <member name="F:NQualityOfLife.IO.VersionInfo.Invalid">
            <summary>Represents an invalid or missing <see cref="T:NQualityOfLife.IO.VersionInfo"/></summary>
        </member>
        <member name="F:NQualityOfLife.IO.VersionInfo.DefaultAssemblyVersion">
            <summary>The default version of an assembly if it is not specified - 1.0.0.0</summary>
        </member>
        <member name="P:NQualityOfLife.IO.VersionInfo.Major">
            <summary>The major version in a <see cref="F:NQualityOfLife.IO.VersionInfo.FormatConvention.SemVer"/> (1.x.x.x) or <see cref="F:NQualityOfLife.IO.VersionInfo.FormatConvention.NumStat"/> (1.x.x) format</summary>
        </member>
        <member name="P:NQualityOfLife.IO.VersionInfo.Minor">
            <summary>The minor version in a <see cref="F:NQualityOfLife.IO.VersionInfo.FormatConvention.SemVer"/> (x.1.x.x) or <see cref="F:NQualityOfLife.IO.VersionInfo.FormatConvention.NumStat"/> (x.1.x) format</summary>
        </member>
        <member name="P:NQualityOfLife.IO.VersionInfo.Build">
            <summary>The build version in a <see cref="F:NQualityOfLife.IO.VersionInfo.FormatConvention.NumStat"/> (x.x.1.x) format or the last number in a <see cref="F:NQualityOfLife.IO.VersionInfo.FormatConvention.SemVer"/> (x.x.1) format</summary>
        </member>
        <member name="P:NQualityOfLife.IO.VersionInfo.Revision">
            <summary>The revision number in a <see cref="F:NQualityOfLife.IO.VersionInfo.FormatConvention.NumStat"/> (x.x.x.1) format</summary>
        </member>
        <member name="M:NQualityOfLife.IO.VersionInfo.IsComparableTo(NQualityOfLife.IO.VersionInfo@)">
            <summary></summary>
            <param name="other"></param>
            <returns><see langword="true"/> if the two <see cref="T:NQualityOfLife.IO.VersionInfo"/> objects can be meaningfully compared</returns>
        </member>
        <member name="F:NQualityOfLife.IO.File_.RimWorldAppId">
            <summary>The id of RimWorld on steam</summary>
        </member>
        <member name="F:NQualityOfLife.IO.File_.myLocalModPath">
            <summary>The path on my local PC, only intended to be used for DEV tools that are not supposed to work or be included in released features</summary>
        </member>
        <member name="F:NQualityOfLife.IO.File_.PathSeparatorC">
            <inheritdoc cref="F:System.IO.Path.DirectorySeparatorChar"/>
        </member>
        <member name="M:NQualityOfLife.IO.File_.FlagsAreSet(NQualityOfLife.IO.VersionInfo.FormatConvention,NQualityOfLife.IO.VersionInfo.FormatConvention)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.File_.AnyFlagIsSet(NQualityOfLife.IO.VersionInfo.FormatConvention,NQualityOfLife.IO.VersionInfo.FormatConvention)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.File_.UnSetFlags(NQualityOfLife.IO.VersionInfo.FormatConvention,NQualityOfLife.IO.VersionInfo.FormatConvention)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.IO.File_.MakeDirectoryTree(System.IO.DirectoryInfo,NQualityOfLife.Types.Tree{System.IO.FileSystemInfo}.Node)">
            <summary></summary>
            <param name="localRoot"></param>
            <param name="parentDirectoryNode"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.File_.MakeFileTree(NQualityOfLife.IO.FolderPath@)">
            <summary>Create a <see cref="T:NQualityOfLife.Types.Tree`1"/> <see cref="T:System.Object"/> from the specified folder</summary>
            <param name="startingAt">The path to the folder that will be the root of the <see cref="T:NQualityOfLife.Types.Tree`1"/></param>
            <returns>a <see cref="T:NQualityOfLife.Types.Tree`1"/> that represents the structure of the target folder</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.File_.CaptureFirstMatchingXMLNode(System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="rawText"></param>
            <param name="xmlNode"></param>
            <param name="targetNodeData">Data inside the node must match this.</param>
            <param name="debugLogging"></param>
            <returns>3 nulls if no match found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ReplaceFirstMatchingXMLNode(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="originalRawText"></param>
            <param name="xmlNode"></param>
            <param name="newValue"></param>
            <param name="oldValue">Node must have this value to be matched</param>
            <param name="debugLogging"></param>
            <returns>The input text with the specified node replaced</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.UpdateAboutXML(NQualityOfLife.IO.FolderPath@,NQualityOfLife.IO.FileName@,System.Boolean)">
            <summary>Update the About.xml file date and version info</summary>
            <param name="folderPath">The path to the folder that contains the about file</param>
            <param name="fileName"></param>
            <param name="debugLogging"></param>
            <returns><see langword="true"/> if was successfully updated or no update needed, || <see langword="false"/> if update failed</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateVersion(System.String)">
            <summary>Ensure that the <paramref name="versionString"/> is valid and correctly formatted</summary>
            <param name="versionString"></param>
            <returns><see langword="true"/> if the <paramref name="versionString"/> follows the '2.1.4' format</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.IncrementVersion(System.String,System.String@)">
            <summary>Increment the version <see cref="T:System.String"/> number</summary>
            <param name="oldVersion">Example: '2.1.5'</param>
            <param name="newVersion">Example: '2.1.6'</param>
            <returns>'2.1.5' -> '2.1.6'</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.WriteTextFile(NQualityOfLife.IO.FilePath@,System.String)">
            <summary>Set the text of the specified file to the given <paramref name="text"/><para>If the file doesn't exist a new one is created. Else it is overwritten</para></summary>
            <param name="filePath">The full path to the target file</param>
            <param name="text">The new text for the file</param>
            <returns><see langword="false"/> if there was an error</returns>
            <inheritdoc cref="M:System.IO.File.WriteAllText(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ReadFirstLine(NQualityOfLife.IO.FilePath)">
            <summary>Reads the first line of the specified text file</summary>
            <param name="filePath">The full path to the file</param>
            <returns>The text <see cref="T:System.String"/> on the first line or <see langword="null"/> if failed or there was no data</returns>
            <inheritdoc cref="M:System.IO.File.OpenText(System.String)"/>
            <inheritdoc cref="M:System.IO.StreamReader.ReadLine"/>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ReadLines(NQualityOfLife.IO.FilePath@)">
            <inheritdoc cref="M:System.IO.File.ReadAllLines(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateFolderPath(NQualityOfLife.IO.FolderPath@)">
            <summary>Makes sure the path is valid and that the target folder exists</summary>
            <param name="folderPath"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateFilePath(NQualityOfLife.IO.FilePath@)">
            <summary>Makes sure the path is valid and that the target file exists</summary>
            <param name="fullFilePath"></param>
            <returns><see langword="true"/> if the <paramref name="fullFilePath"/> is valid and points to an existing file</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateXMLFile(NQualityOfLife.IO.FolderPath@,NQualityOfLife.IO.FileName@,System.Boolean,System.Boolean)">
            <summary>Checks the validity of the path <seealso cref="T:System.String">strings</seealso>, if the fileName ends with an xml file, if the file exists, and has a valid xml header</summary>
            <param name="folderPath">The folder path of the file</param>
            <param name="fileName">The name of the file, must end with '.xml' to be valid</param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="isNewFile"></param>
            <returns><see langword="true"/> if valid, else <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.ValidateXMLFile(NQualityOfLife.IO.FilePath@,System.Boolean,System.Boolean)">
            <summary>Checks the validity of the path <see cref="T:System.String"/>, if it ends with an xml file, if the file exists, and has a valid xml header</summary>
            <param name="filePath">The full file path of the target file</param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="isNewFile"></param>
            <returns><see langword="true"/> if valid, else <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.OverWriteFirstMatchingXMLNode(NQualityOfLife.IO.FolderPath,NQualityOfLife.IO.FileName,System.String,System.String,System.String,System.Boolean)">
            <summary>Find and replace the first matching node in an xml file</summary>
            <param name="folderPath"></param>
            <param name="fileName"></param>
            <param name="xmlNode"></param>
            <param name="newValue"></param>
            <param name="oldValue"></param>
            <param name="debugLogging"></param>
            <returns><see langword="true"/> if the file was successfully modified</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.OverWriteFirstMatchingXMLNode(NQualityOfLife.IO.FolderPath,NQualityOfLife.IO.FileName,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="folderPath"></param>
            <param name="fileName"></param>
            <param name="xmlNode"></param>
            <param name="newValue"></param>
            <param name="oldValue"></param>
            <param name="xmlNode2"></param>
            <param name="newValue2"></param>
            <param name="oldValue2"></param>
            <param name="debugLogging"></param>
            <returns><see langword="true"/> if the write was successful, or no changes were needed</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.CreateAnalyzerXML(System.Reflection.Assembly,System.String,NQualityOfLife.IO.FileName,NQualityOfLife.IO.FolderPath,System.Boolean,System.Boolean)">
            <summary>Create an 'Analyzer.xml' file for use with 'Dubs Performance Analyzer'</summary>
            <param name="assembly">Create the Analyzer.xml for this <see cref="T:System.Reflection.Assembly"/></param>
            <param name="categoryName">The category name that will be displayed in game in the analyzer ui</param>
            <param name="fileName">Must be: 'Analyzer.xml' for the analyzer to detect it.</param>
            <param name="folderPath">Where to create the file? Should be the root folder of the mod, or the analyzer wont find it.</param>
            <param name="allowOverWrite">Allow over writing the existing file?</param>
            <param name="creatingNew">Are we creating a new file?</param>
            <returns><see langword="true"/> if file creation was successful, else <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAssembliesFromFolder(System.IO.DirectoryInfo,System.String@,System.Boolean,System.Boolean,System.String)">
            <summary>Get a list of (reflection only) <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> in the specified <paramref name="folder"/>, or in sub folders of the specified folder</summary>
            <param name="folder"><see cref="T:System.IO.DirectoryInfo"/> of the target <paramref name="folder"/></param>
            <param name="message">Error message <see cref="T:System.String"/> or <see langword="null"/> if no error</param>
            <param name="checkSubFolders">Also get <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> from sub folders inside the specified folder</param>
            <param name="onlyAsFallback">Only check for <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> in sub folders, if none were found in the primary target folder, <paramref name="checkSubFolders"/> must also be <see langword="true"/></param>
            <param name="assemblyFolderMustBeCalled">The <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> must be inside a folder named x, if <see langword="null"/>: this condition is ignored</param>
            <returns>List of the found <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> or empty list</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAssembliesFromFolder(System.Collections.Generic.List{System.Reflection.Assembly}@,NQualityOfLife.IO.FolderPath,System.String@,System.String)">
            <summary>Add the (reflection only) <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> from a folder to an existing list of <seealso cref="T:System.Reflection.Assembly">assemblies</seealso>, or if the list is null, create a new list.</summary>
            <param name="assemblies">A pre existing list of <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> that we want to add more <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> to</param>
            <param name="folderPath">The full file <paramref name="folderPath"/> to the folder that contains the <seealso cref="T:System.Reflection.Assembly">assemblies</seealso></param>
            <param name="message">Soft error message <see cref="T:System.String"/></param>
            <param name="assemblyFolderMustBeCalled">The folder that contains the .dll files must have this name</param>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAssembliesFromFolder(NQualityOfLife.IO.FolderPath@,System.String@,System.Boolean,System.Boolean,System.String,System.Boolean)">
            <summary>Get a list of (reflection only) <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> in the specified folder folderPath, or in sub folders of the specified folder</summary>
            <param name="folderPath">Full folderPath to the target folder, such as a mod root folder</param>
            <param name="message">Error message <see cref="T:System.String"/> or <see langword="null"/> if no error</param>
            <param name="checkSubFolders">Also get <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> from sub folders inside the specified folder</param>
            <param name="onlyAsFallback">Only check for <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> in sub folders, if none were found in the primary target folder, checkSubFolders must also be true</param>
            <param name="assemblyFolderMustBeCalled">The <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> must be inside a folder named x, if <see langword="null"/>: this condition is ignored</param>
            <param name="mustBeLoaded">Only return assemblies that are loaded into the current <see cref="T:System.AppDomain"/></param>
            <returns>List of the found <seealso cref="T:System.Reflection.Assembly">assemblies</seealso> or empty list - never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFileVersion(NQualityOfLife.IO.FilePath@,System.String@)">
            <summary>Get the file version of the file at the given path</summary>
            <param name="filePath"></param>
            <param name="message"></param>
            <returns><see langword="null"/>, <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null symbol</seealso> or the found version</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAssemblyVersion(System.Reflection.Assembly,System.String@)">
            <summary>Get the version from the assembly meta data</summary>
            <param name="assembly"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFileVersion(System.Reflection.Assembly,System.String@)">
            <summary>Get the actual file version of the given assembly (.dll) file</summary>
            <param name="assembly"></param><param name="message"></param>
            <returns>The file version of the actual .dll file. - Not always the same as the <see cref="M:NQualityOfLife.IO.File_.GetAssemblyVersion(System.Reflection.Assembly,System.String@)"/></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetVersion(System.Reflection.Assembly,System.String@,System.String@)">
            <summary>Get the file and assembly version of the given assembly</summary>
            <param name="assembly"></param>
            <param name="messageFileVer">The file version of the actual .dll file</param>
            <param name="messageAssemblyVer">The internal version from the assembly metadata</param>
            <returns>(<see cref="T:System.String"/>? fileVersion, <see cref="T:System.String"/>? assemblyVersion)</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetVersion(Verse.ModMetaData,System.String@)">
            <summary>Try get the mod version from the meta data - Tries to look for the version in the description text if no explicit version field exists - Returns null if the version data is not given or found</summary>
            <param name="modMetaData"></param><param name="message"><see langword="null"/> if was successful, else contains some info about why info was not found</param>
            <returns>null if no version field or info was found</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetVersion(Verse.Mod,System.String@,System.String@,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Try get the mod version in order: About.xml -> Assembly (version and or file version)</summary>
            <param name="mod"></param>
            <param name="message_FileVer"></param>
            <param name="message_AssemblyVer"></param>
            <param name="skipList">Skip assemblies with the provided <see cref="T:System.String"/> key in their name unless they are the mod in the value</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetAboutFile(NQualityOfLife.IO.FolderPath,System.String@)">
            <summary>Get a FileInfo of the about xml, or <see langword="null"/> if not found</summary>
            <param name="aboutFolderPath">The full path to the About folder that contains the About.xml</param>
            <param name="message">Error message or <see langword="null"/></param>
            <returns>FileInfo of the About.xml or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFile(NQualityOfLife.IO.FolderPath,NQualityOfLife.IO.FileName,System.String@)">
            <summary>Get a file from a folder</summary>
            <param name="fileName">The path to the folder containing the file.</param>
            <param name="message">Error message or <see langword="null"/></param>
            <param name="folderPath">The name of the file to get</param>
            <returns>FileInfo of the file or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetXMLNode_FromModAboutFile(System.String,System.String,Verse.ModMetaData,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Gets the xmlNodes inside the specified node</summary>
            <param name="modPackageId">For example "niilo007.niilosqol"</param>
            <param name="xmlNode">Format in the name of the node, with no slashes or greater / less than symbols For example: "supportedVersions"</param>
            <param name="metaData"></param>
            <param name="logNonCaptureRelatedErrors"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns><see cref="T:System.String"/> of the value inside the node, or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFirstMatchingXMLNode_FromFile(System.IO.FileInfo,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="file"></param>
            <param name="xmlNode"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IO.File_.GetFirstMatchingXMLNode_FromFile(NQualityOfLife.IO.FilePath,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="filePath"></param>
            <param name="xmlNode"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.IO.Adler32Checksum">
            <summary>Used to calculate the Adler-32 checksum used for ZLIB data in accordance with RFC 1950: ZLIB Compressed Data Format Specification.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.Adler32Checksum.Calculate(System.Collections.Generic.IEnumerable{System.Byte},System.Int32)">
            <summary>Calculate the Adler-32 checksum for some data.</summary>
        </member>
        <member name="T:NQualityOfLife.IO.Crc32">
            <summary>32-bit Cyclic Redundancy Code used by the PNG for checking the data is intact.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.Crc32.Calculate(System.Byte[])">
            <summary>Calculate the CRC32 for data.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.Crc32.Calculate(System.Collections.Generic.List{System.Byte})">
            <summary>Calculate the CRC32 for data.</summary>
        </member>
        <member name="M:NQualityOfLife.IO.Crc32.Calculate(System.Byte[],System.Byte[])">
            <summary>Calculate the combined CRC32 for data.</summary>
        </member>
        <member name="T:NQualityOfLife.Core.Constants">
            <summary>Class that contains various constants related to physics, unit conversions etc</summary>
        </member>
        <member name="T:NQualityOfLife.Core.Constants.SI">
            <summary>Constants used in the definitions of SI units, and other important constants derived from them</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.SpeedOfLight_C_MS">
            <summary>c
            <para>Has a <seealso cref="T:NQualityOfLife.Units.Dimension">dimension</seealso> of <see cref="T:NQualityOfLife.Units.Speed"/></para>
            <para>the speed of light (<see cref="T:NQualityOfLife.Units.PlanckSpeed">c</see>) in <seealso cref="T:NQualityOfLife.Units.Meter">m</seealso>/<seealso cref="T:NQualityOfLife.Units.Second">s</seealso></para></summary>
            <remarks>
            Note that this value is too large for '<see cref="T:System.Single"/>' to represent accurately! (~+-10)
            <para><i>This is a key defining constant of the metric system</i></para>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">
            <summary>e
            <para>Has a <seealso cref="T:NQualityOfLife.Units.Dimension">dimension</seealso> of <see cref="T:NQualityOfLife.Units.Charge"/></para>
            <para>1.60217663  10-19</para>
            <para>The <see cref="T:NQualityOfLife.Units.Charge"/> of an electron in <see cref="T:NQualityOfLife.Units.Charge">coulombs</see></para>
            <para>Also knowns as the <see cref="T:NQualityOfLife.Units.ElementaryCharge"/> 'e'</para></summary>
            <remarks>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">e</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs"></see> / <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.FaradayConstant_F_CperMol"></see> / <see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">e</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">e</see> * <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.FaradayConstant_F_CperMol"></see></para>
            <para><i>This is a key defining constant of the metric system</i></para>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_eVPerK">
            <inheritdoc cref="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK"/>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK">
            <summary><i>k</i>
            <para>Has a <seealso cref="T:NQualityOfLife.Units.Dimension">dimension</seealso> of <see cref="T:NQualityOfLife.Units.Joule"/>/<see cref="T:NQualityOfLife.Units.Kelvin"/></para>
            </summary>
            <remarks>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK"><i>k</i></see> == <see cref="F:NQualityOfLife.Core.Constants.SI.IdealGasConstant_R">R</see> / <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK"><i>k</i></see> * <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.IdealGasConstant_R">R</see></para>
            <para><i>This is a key defining constant of the metric system</i></para>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">
            <summary>N
            <para>Has a <seealso cref="T:NQualityOfLife.Units.Dimension">dimension</seealso> of <i>inverse</i> <see cref="T:NQualityOfLife.Units.Mol"/> - (<b><see cref="F:NQualityOfLife.Units.Dimension.N">N</see>^-1</b>)</para>
            <para>6.02214076E23</para></summary>
            <remarks>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.FaradayConstant_F_CperMol"></see> / <see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">e</see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.IdealGasConstant_R">R</see> / <see cref="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK"><i>k</i></see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs"></see> / <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">e</see></para>
            <para><i>This is a key defining constant of the metric system</i></para>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.PlanckConstant_h">
            <summary><i>h</i>
            <para>Has a <seealso cref="T:NQualityOfLife.Units.Dimension">dimension</seealso> <see cref="T:NQualityOfLife.Units.Joule"/><see cref="T:NQualityOfLife.Units.Second"/></para>
            <para>6.62607015E-34</para></summary>
            <remarks>
            <para><i>This is a key defining constant of the metric system</i></para>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.CaesiumFrequency">
            <summary>vCs
            <para>Has a <seealso cref="T:NQualityOfLife.Units.Dimension">dimension</seealso> <see cref="T:NQualityOfLife.Units.Hertz"/></para>
            <para>9_192_631_770</para></summary>
            <remarks>
            <para><i>This is a key defining constant of the metric system</i></para>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.FaradayConstant_F_CperMol">
            <summary> 
            <para><seealso cref="T:NQualityOfLife.Units.Charge">C</seealso>/<seealso cref="T:NQualityOfLife.Units.Mol">mol</seealso></para></summary>
            <remarks><see href="https://en.wikipedia.org/wiki/Faraday_constant"/>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.FaradayConstant_F_CperMol"></see> == <see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">e</see> * <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.FaradayConstant_F_CperMol"></see> == <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> * <see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">e</see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs"></see> / <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.ChargeOfElectron_E_Coulombs">e</see></para>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.IdealGasConstant_R">
            <summary>R</summary>
            <remarks>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.IdealGasConstant_R">R</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> * <see cref="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK"><i>k</i></see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.IdealGasConstant_R">R</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK"><i>k</i></see> * <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see></para>
            <para><see cref="F:NQualityOfLife.Core.Constants.SI.IdealGasConstant_R">R</see> / <see cref="F:NQualityOfLife.Core.Constants.SI.AvogadroConstant_N_InverseMol">N</see> == <see cref="F:NQualityOfLife.Core.Constants.SI.BoltzmannConstant_K_JPerK"><i>k</i></see></para>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.ElementaryChargesInCoulomb">
            <summary>1 <seealso cref="T:NQualityOfLife.Units.Charge">coulomb</seealso> == <see langword="this"/> many <see cref="T:NQualityOfLife.Units.ElementaryCharge"/>s</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.SpeedOfLightPlanckSpeed">
            <summary>c
            <para>Speed of light in units of <see cref="T:NQualityOfLife.Units.PlanckSpeed"/></para></summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SI.ValueOfBigG">
            <summary>G
            <para>The value of the gravitational constant <see cref="T:NQualityOfLife.Physics.G"/></para></summary>
        </member>
        <member name="T:NQualityOfLife.Core.Constants.Primitives">
            <summary>Constants related to primitive data types of C#</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Primitives.BitsInNibble">
            <summary>How many bits are in a <see cref="T:NQualityOfLife.Types.Nibble"/> / <see cref="T:NQualityOfLife.Types.SNibble"/>
            <para>A <see cref="T:NQualityOfLife.Types.Nibble"/> is half a <see cref="T:System.Byte"/></para></summary>
            <remarks>4</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Primitives.BitsInByte">
            <summary>How many bits is in a <see cref="T:System.Byte"/> / <see cref="T:System.SByte"/>
            <para><see cref="T:System.Byte">Byte</see> / <see cref="T:System.SByte">SByte</see></para></summary>
            <remarks>8</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Primitives.BitsInShort">
            <summary>How many bits is in a <see cref="T:System.Int16"/> / <see cref="T:System.UInt16"/>
            <para><see cref="T:System.Int16">Int16</see> / <see cref="T:System.UInt16">UInt16</see></para></summary>
            <remarks>16</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Primitives.BitsInInt">
            <summary>How many bits is in a <see cref="T:System.Int32"/> / <see cref="T:System.UInt32"/>
            <para><see cref="T:System.Int32">Int32</see> / <see cref="T:System.UInt32">UInt32</see></para></summary>
            <remarks>32</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Primitives.BitsInLong">
            <summary>How many bits is in a <see cref="T:System.Int64"/> / <see cref="T:System.UInt64"/>
            <para><see cref="T:System.Int64">Int64</see> / <see cref="T:System.UInt64">UInt64</see></para></summary>
            <remarks>64</remarks>
        </member>
        <member name="T:NQualityOfLife.Core.Constants.IEEE754">
            <summary>Constants related to floating point numbers as defined in the <see href="https://en.wikipedia.org/wiki/IEEE_754">IEEE754</see> standard</summary>
        </member>
        <member name="T:NQualityOfLife.Core.Constants.IEEE754.SinglePrecision">
            <summary><see cref="T:System.Single"/></summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.IEEE754.SinglePrecision.MantissaBitsMask">
            <summary></summary>
            <remarks><see cref="T:System.Int32"/> value == '8_388_607'</remarks>
        </member>
        <member name="T:NQualityOfLife.Core.Constants.IEEE754.DoublePrecision">
            <summary><see cref="T:System.Double"/></summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.DaysInYear">
            <summary>The amount of days in a year, rounded</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SecondsInMinute">
            <summary>The amount of <see cref="T:NQualityOfLife.Units.Second">seconds</see> in one minute</summary>
            <remarks>The <see cref="T:NQualityOfLife.Units.Second"/> <see cref="T:System.Type"/> can be used to represent seconds</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.MinutesInHour">
            <summary>The amount of minutes in one hour</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.HoursInDay">
            <summary>The number of hours in one full day</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SecondsInHour">
            <summary><see cref="F:NQualityOfLife.Core.Constants.SecondsInHour"/> == 3_600 == (<see cref="F:NQualityOfLife.Core.Constants.MinutesInHour"/> * <see cref="F:NQualityOfLife.Core.Constants.SecondsInMinute"/>)</summary>
            <remarks>The <see cref="T:NQualityOfLife.Units.Second"/> <see cref="T:System.Type"/> can be used to represent seconds</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.MinutesInDay">
            <summary><see cref="F:NQualityOfLife.Core.Constants.MinutesInDay"/> == 1_440 == (<see cref="F:NQualityOfLife.Core.Constants.HoursInDay"/> * <see cref="F:NQualityOfLife.Core.Constants.MinutesInHour"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SecondsInDay">
            <summary><see cref="F:NQualityOfLife.Core.Constants.SecondsInDay"/> == 86_400 == (<see cref="F:NQualityOfLife.Core.Constants.MinutesInDay"/> * <see cref="F:NQualityOfLife.Core.Constants.SecondsInMinute"/>)</summary>
            <remarks>The <see cref="T:NQualityOfLife.Units.Second"/> <see cref="T:System.Type"/> can be used to represent seconds</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.HoursInYear">
            <summary><see cref="F:NQualityOfLife.Core.Constants.HoursInYear"/> == 8_760 == (<see cref="F:NQualityOfLife.Core.Constants.DaysInYear"/> * <see cref="F:NQualityOfLife.Core.Constants.HoursInDay"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.MinutesInYear">
            <summary><see cref="F:NQualityOfLife.Core.Constants.MinutesInYear"/> == 525_600 == (<see cref="F:NQualityOfLife.Core.Constants.HoursInYear"/> * <see cref="F:NQualityOfLife.Core.Constants.MinutesInHour"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SecondsInYear">
            <summary><see cref="F:NQualityOfLife.Core.Constants.SecondsInYear"/> == 31_536_000 == (<see cref="F:NQualityOfLife.Core.Constants.MinutesInYear"/> * <see cref="F:NQualityOfLife.Core.Constants.SecondsInMinute"/>)</summary>
            <remarks>The <see cref="T:NQualityOfLife.Units.Second"/> <see cref="T:System.Type"/> can be used to represent seconds</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.DaysInWeek">
            <summary>The number of days in a week as used in most calendar systems</summary>
            <remarks>The <see cref="T:NQualityOfLife.Types.WeekDay"/> <see langword="enum"/> can be used to represent one of these days</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.HoursInWeek">
            <summary><see cref="F:NQualityOfLife.Core.Constants.HoursInWeek"/> == 168 == (<see cref="F:NQualityOfLife.Core.Constants.DaysInWeek"/> * <see cref="F:NQualityOfLife.Core.Constants.HoursInDay"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.MinutesInWeek">
            <summary><see cref="F:NQualityOfLife.Core.Constants.MinutesInWeek"/> == 10_080 == (<see cref="F:NQualityOfLife.Core.Constants.HoursInWeek"/> * <see cref="F:NQualityOfLife.Core.Constants.MinutesInHour"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.SecondsInWeek">
            <summary><see cref="F:NQualityOfLife.Core.Constants.SecondsInWeek"/> == 604_800 == (<see cref="F:NQualityOfLife.Core.Constants.MinutesInWeek"/> * <see cref="F:NQualityOfLife.Core.Constants.SecondsInMinute"/>)</summary>
            <remarks>The <see cref="T:NQualityOfLife.Units.Second"/> <see cref="T:System.Type"/> can be used to represent seconds</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.MonthsInYear">
            <summary>The amount of months in one year as defined by the <see href="https://en.wikipedia.org/wiki/Gregorian_calendar">Gregorian calendar</see></summary>
            <remarks>The <see cref="T:NQualityOfLife.Types.Month"/> <see langword="enum"/> can be used to represent one of these months</remarks>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.OneRevolutionDegrees">
            <summary>One full revolution in <see cref="T:NQualityOfLife.Units.Degrees"/> ~360f</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.HalfRevolutionDegrees">
            <summary>Half of a full revolution in <see cref="T:NQualityOfLife.Units.Degrees"/> ~180f</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.OneRevolutionRadians">
            <summary>One full revolution in <see cref="T:NQualityOfLife.Units.Radians"/> == 2 ~= 6.28319f</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.HalfRevolutionRadians">
            <summary>Half of a full revolution in <see cref="T:NQualityOfLife.Units.Radians"/> == 1 ~= 3.14159f</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.AbsoluteZeroF">
            <summary>Absolute Zero (0<see cref="T:NQualityOfLife.Units.Kelvin">K</see>) in <see cref="T:NQualityOfLife.Units.Fahrenheit"/> as a <see cref="T:System.Single"/> ~= '-459.67f'</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.ZeroCelciusF">
            <summary>Freezing point of water (0C) in <see cref="T:NQualityOfLife.Units.Fahrenheit"/> as a <see cref="T:System.Single"/> ~= '32f'</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.ZeroCelsiusK">
            <summary>0C in <see cref="T:NQualityOfLife.Units.Kelvin"/> as a <see cref="T:System.Single"/> ~= '273.15f'</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.ZeroCelciusRa">
            <summary>Freezing point of water in <see cref="T:NQualityOfLife.Units.Rankine"/> (0C) as a <see cref="T:System.Single"/> ~= '491.67f'</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.ZeroFahrenheitRa">
            <summary>Zero <see cref="T:NQualityOfLife.Units.Fahrenheit"/> in <see cref="T:NQualityOfLife.Units.Rankine"/> as a <see cref="T:System.Single"/> ~= '459.67f'</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.AbsoluteZeroC">
            <summary>Absolute zero in <see cref="T:NQualityOfLife.Units.Celsius"/> as a <see cref="T:System.Single"/> ~= '-273.15f'</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Roentgen_coulombPerKg">
            <summary>1 <see cref="T:NQualityOfLife.Units.Roentgen"/> in <see cref="T:NQualityOfLife.Units.Charge"/>/<see cref="T:NQualityOfLife.Units.Kg"/></summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.KilometersPerHourToMetersPerSecond">
            <summary>m/s = km/h * <see langword="this"/> ~= 0.2777778f</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.MetersPerSecondToKilometersPerHour">
            <summary>km/h = m/s * <see langword="this"/> ~= '3.6f'</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.LitersInCubicMeter">
            <summary>How many <see cref="T:NQualityOfLife.Units.Liter"/>s fit into one <seealso cref="T:NQualityOfLife.Units.Volume">cubic meter</seealso> ~= '1000f'</summary>
        </member>
        <member name="T:NQualityOfLife.Core.Constants.Planets">
            <summary>Constants related to planetary bodies, such as the <seealso cref="T:NQualityOfLife.Core.Constants.Planets.Earth">earth</seealso></summary>
        </member>
        <member name="T:NQualityOfLife.Core.Constants.Planets.Earth">
            <summary>Constants related to the earth</summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Planets.Earth.RadiusMeters">
            <summary>The approximate radius of the earth in <seealso cref="T:NQualityOfLife.Units.Meter">meters</seealso></summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Planets.Earth.MassKg">
            <summary>The mass of the earth in <seealso cref="T:NQualityOfLife.Units.Kg">kg</seealso></summary>
        </member>
        <member name="F:NQualityOfLife.Core.Constants.Planets.Earth.AccelerationDueToGravity">
            <summary>The acceleration due to gravity on earths surface in <see cref="T:NQualityOfLife.Units.Acceleration">m/s</see></summary>
        </member>
        <member name="T:NQualityOfLife.Physics.G">
            <summary>The <seealso href="https://en.wikipedia.org/wiki/Gravitational_constant">gravitational constant</seealso> big <see cref="T:NQualityOfLife.Physics.G"/></summary>
            <remarks><b>LM^-1T^-2</b></remarks>
        </member>
        <member name="F:NQualityOfLife.Physics.G.val">
            <inheritdoc cref="T:NQualityOfLife.Physics.G"/>
        </member>
        <member name="M:NQualityOfLife.Physics.G.#ctor">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Physics.G"/> with the default value <see cref="F:NQualityOfLife.Core.Constants.SI.ValueOfBigG"/></summary>
            <inheritdoc cref="T:NQualityOfLife.Physics.G"/>
        </member>
        <member name="M:NQualityOfLife.Physics.G.#ctor(System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Physics.G"/> with a custom value</summary>
            <param name="valueOfG">The custom value for <see cref="T:NQualityOfLife.Physics.G"/></param>
            <inheritdoc cref="T:NQualityOfLife.Physics.G"/>
        </member>
        <member name="P:NQualityOfLife.Physics.G.Dimension">
            <inheritdoc cref="P:NQualityOfLife.Units.Dimension.BigG"/>
        </member>
        <member name="P:NQualityOfLife.Physics.G.Value">
            <inheritdoc cref="F:NQualityOfLife.Physics.G.val"/>
        </member>
        <member name="M:NQualityOfLife.Physics.G.op_Multiply(NQualityOfLife.Physics.G@,NQualityOfLife.Units.Kg@)">
            <summary></summary><param name="left"></param><param name="right"></param>
            <returns><see cref="T:NQualityOfLife.Units.AbstractUnit"/> with dimension <b>LT^-2</b></returns>
        </member>
        <member name="M:NQualityOfLife.Physics.G.op_Multiply(NQualityOfLife.Units.Kg@,NQualityOfLife.Physics.G@)">
            <inheritdoc cref="M:NQualityOfLife.Physics.G.op_Multiply(NQualityOfLife.Physics.G@,NQualityOfLife.Units.Kg@)"/>
        </member>
        <member name="P:NQualityOfLife.Physics.Universe.TotalMass">
            <summary>The total mass contained in the universe</summary>
        </member>
        <member name="F:NQualityOfLife.Physics.PhysicsObject2D.parent_">
            <summary>The parent object of a ghost object</summary>
        </member>
        <member name="T:NQualityOfLife.Physics.IMaterial">
            <summary>Interface for materials and material properties, such as <see cref="T:NQualityOfLife.Units.SpecificHeatCapacity"/></summary>
        </member>
        <member name="P:NQualityOfLife.Physics.IMaterial.HeatCapacity">
            <summary><see langword="get"/> or <see langword="set"/> the <see cref="T:NQualityOfLife.Units.SpecificHeatCapacity"/> of the material</summary>
        </member>
        <member name="P:NQualityOfLife.Physics.IMaterial.Density">
            <summary><see langword="get"/> or <see langword="set"/> the <see cref="T:NQualityOfLife.Units.Density"/> of the material</summary>
        </member>
        <member name="P:NQualityOfLife.Physics.IMaterial.ThermalConductivity">
            <summary><see langword="get"/> or <see langword="set"/> the <see cref="T:NQualityOfLife.Units.ThermalConductivity"/> of the material</summary>
        </member>
        <member name="P:NQualityOfLife.Physics.IMaterial.ThermalResistivity">
            <summary><see langword="get"/> or <see langword="set"/> the <see cref="T:NQualityOfLife.Units.ThermalResistivity"/> of the material</summary>
        </member>
        <member name="P:NQualityOfLife.Physics.IMaterial.Conductivity">
            <summary><see langword="get"/> or <see langword="set"/> the electrical <see cref="T:NQualityOfLife.Units.Conductivity"/> of the material</summary>
        </member>
        <member name="P:NQualityOfLife.Physics.IMaterial.Resistivity">
            <summary><see langword="get"/> or <see langword="set"/> the electrical <see cref="T:NQualityOfLife.Units.Resistivity"/> of the material</summary>
        </member>
        <member name="T:NQualityOfLife.Physics.IMassHaver">
            <summary>An object with <seealso cref="T:NQualityOfLife.Units.Kg">mass</seealso></summary>
        </member>
        <member name="P:NQualityOfLife.Physics.IMassHaver.Mass">
            <summary><see langword="get"/> or <see langword="set"/> the <see cref="P:NQualityOfLife.Physics.IMassHaver.Mass"/> of the object</summary>
        </member>
        <member name="T:NQualityOfLife.Physics.ITemperatureHaver">
            <summary>An object with a <seealso cref="T:NQualityOfLife.Units.ITemperature">temperature</seealso> and <see cref="T:NQualityOfLife.Units.HeatCapacity"/></summary>
        </member>
        <member name="P:NQualityOfLife.Physics.ITemperatureHaver.Temperature">
            <summary><see langword="get"/> or <see langword="set"/> the <see cref="P:NQualityOfLife.Physics.ITemperatureHaver.Temperature"/> of the object</summary>
        </member>
        <member name="P:NQualityOfLife.Physics.ITemperatureHaver.HeatCapacity">
            <summary><see langword="get"/> or <see langword="set"/> the <see cref="T:NQualityOfLife.Units.HeatCapacity"/> of the object</summary>
        </member>
        <member name="P:NQualityOfLife.Physics.ITemperatureHaver.ThermalEnergy">
            <summary><see langword="get"/> or <see langword="set"/> the total thermal <seealso cref="T:NQualityOfLife.Units.Joule">energy</seealso> of the object</summary>
        </member>
        <member name="T:NQualityOfLife.AI.Jobs">
            <summary><see cref="T:Verse.AI.Job"/> utility methods</summary>
        </member>
        <member name="M:NQualityOfLife.AI.Jobs.IsReserved(Verse.AI.ReservationManager,Verse.LocalTargetInfo@,Verse.Pawn@)">
            <inheritdoc cref="M:NQualityOfLife.AI.Jobs.IsReserved(Verse.Thing,Verse.Pawn@)"/>
        </member>
        <member name="M:NQualityOfLife.AI.Jobs.IsReserved(Verse.Thing,Verse.AI.ReservationManager,Verse.Pawn@)">
            <inheritdoc cref="M:NQualityOfLife.AI.Jobs.IsReserved(Verse.Thing,Verse.Pawn@)"/>
        </member>
        <member name="M:NQualityOfLife.AI.Jobs.IsReserved(Verse.Thing,Verse.Pawn@)">
            <summary></summary>
            <param name="possibleJobTarget"></param>
            <param name="byPawn">The <see cref="P:Verse.AI.ReservationManager.Reservation.Claimant"/> of the first found <see cref="T:Verse.AI.ReservationManager.Reservation"/> on the given <paramref name="possibleJobTarget"/></param>
            <returns><see langword="true"/> if the <paramref name="possibleJobTarget"/> is reserved by anyone</returns><exception cref="T:System.ArgumentNullException"><paramref name="possibleJobTarget"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.AI.WorkGiver_PlantsCut">
            <summary>Used to separate tree chopping from plant cutting, used along side <see cref="T:NQualityOfLife.AI.WorkGiver_PlantsCut_Trees"/></summary>
        </member>
        <member name="T:NQualityOfLife.AI.WorkGiver_PlantsCut_Trees">
            <summary>Used to separate tree chopping from plant cutting, used along side <see cref="T:NQualityOfLife.AI.WorkGiver_PlantsCut"/></summary>
        </member>
        <member name="M:NQualityOfLife.AI.Trigger_RestedAndFed.#ctor">
            <inheritdoc cref="T:NQualityOfLife.AI.Trigger_RestedAndFed"/>
        </member>
        <member name="M:NQualityOfLife.AI.Trigger_ShouldForage.#ctor">
            <inheritdoc cref="M:NQualityOfLife.AI.Trigger_RestedAndFed.#ctor"/>
        </member>
        <member name="T:NQualityOfLife.AI.Trigger_Starving">
            <summary>Trigger that activates when any of the pawns of the lord are starving</summary>
        </member>
        <member name="M:NQualityOfLife.AI.Trigger_Starving.#ctor">
            <inheritdoc cref="T:NQualityOfLife.AI.Trigger_Starving"/>
        </member>
        <member name="M:NQualityOfLife.AI.Toil_.UnDraftIfDrafted(Verse.Pawn)">
            <summary><see langword="null"/> checks included</summary>
            <param name="pawn"></param>
            <returns>a <see cref="T:Verse.AI.Toil"/> with the un-draft action</returns>
        </member>
        <member name="M:NQualityOfLife.AI.Find.DefensivePositions(Verse.Pawn,System.Int32@,RimWorld.Faction,Verse.Map,Verse.Region,System.Single,System.Byte,System.Boolean)">
            <summary></summary>
            <param name="inRegion"></param>
            <param name="faction"></param>
            <param name="positionCount"></param>
            <param name="map"></param>
            <param name="pawn"></param>
            <param name="minimumCover"></param>
            <param name="maxPositionsToGet"></param>
            <param name="debug"></param>
            <returns>Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.AI.Find.DefensivePositions(Verse.Region,RimWorld.Faction,System.Int32@,Verse.Map,Verse.Pawn,System.Single,System.Byte,System.Boolean)">
            <summary></summary>
            <param name="inRegion"></param>
            <param name="faction"></param>
            <param name="positionCount"></param>
            <param name="map"></param>
            <param name="pawn"></param>
            <param name="minimumCover"></param>
            <param name="maxPositionsToGet"></param>
            <param name="debug"></param>
            <returns>Never <see langword="null"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="F:NQualityOfLife.Weapons.SuppressionSystem.SuppressionHediff.maxPinTimePerBuller">
            <summary>How many ticks can one bullet add to the timer?</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.SuppressionSystem.SuppressionHediff.minPinTimePerBuller">
            <summary>How many ticks should be the minimum amount to add?</summary>
        </member>
        <member name="M:NQualityOfLife.Weapons.SuppressionSystem.Utils_Suppression.CanSuppress(Verse.Pawn)">
            <summary>Can the given pawn be affected by supression?</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.postShotSmokeSize">
            <summary>Spawn smoke after shooting? -1f is default/no smoke</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.magazineSize">
            <summary>The max capacity of the magazine</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.reloadTicks">
            <summary>The reload job duration ticks</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.bipodGraphic">
            <summary>Optional alternate graphic to use when the bipod is deployed</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.reloadStartSound">
            <summary>The <see cref="T:Verse.SoundDef"/> to play when a <see cref="T:Verse.Pawn"/> starts reloading the weapon</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.reloadDoneSound">
            <summary>The <see cref="T:Verse.SoundDef"/> to play when a <see cref="T:Verse.Pawn"/> is done reloading the weapon</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.weaponType">
            <summary><see cref="T:NQualityOfLife.Weapons.WeaponType"/> type flags</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.durabilityPerShot">
            <summary>How much durability is consumed per shot, 0 is default</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.debug">
            <summary>Enable debug logging for this weapon</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.backBlast">
            <summary>Does the weapon cause a back blast?</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp_Properties.hasBipod">
            <summary>Does the weapon have a bipod that can be deployed?</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp.magazine">
            <summary>The current amount of bullets in the magazine</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.Comps.WeaponComp.myPawn">
            <summary>The <see cref="T:Verse.Pawn"/> who is currently using the weapon</summary>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.DeployBipod(Verse.Pawn)">
            <summary>Start deploying the bipod job</summary>
            <param name="pawn"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException">The bipod is already deployed or the weapon doesn't have one</exception>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.Start_DeployBipod_Job">
            <summary>Make and start a bipod deploy job</summary>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.SetBipodDeployed(Verse.Pawn)">
            <summary>Set the bipod state of the weapon to deployed</summary>
            <param name="pawn"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException">Bipod is already deployed</exception>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.Reload(Verse.Pawn,System.Boolean)">
            <summary>Start a reload job</summary>
            <param name="pawn"></param>
            <param name="noCooldown"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.Start_Reload_Job(System.Boolean)">
            <summary>Create and start the reload job</summary>
            <param name="noCooldown"></param>
        </member>
        <member name="M:NQualityOfLife.Weapons.Comps.WeaponComp.SetMagazineFull(Verse.Pawn)">
            <summary>Set the magazine state to full</summary>
            <param name="pawn"></param>
        </member>
        <member name="T:NQualityOfLife.Animal.AnimalComp">
            <summary>Comp for animals</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalComp.ShouldTickNow">
            <summary>Updates the cached <see cref="T:RimWorld.Faction"/> and <see cref="T:Verse.AI.Group.Lord"/> and disbands any invalid lord if the animal is no longer wild</summary>
            <returns><see langword="true"/> if the animal is a wild alive animal</returns>
        </member>
        <member name="T:NQualityOfLife.Animal.LordJob_Animal">
            <summary>Base animal lord jobWaitWander</summary>
        </member>
        <member name="P:NQualityOfLife.Animal.LordJob_Animal.Map">
            <summary>Get the map of the lord (lordManager) - Can be null if the lord / lordManager has not yet initialized</summary>
        </member>
        <member name="T:NQualityOfLife.Animal.LordToil_Animal">
            <summary>Base animal lord toil</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Utils_Animal.IsHiddenFromPredator(Verse.Pawn,Verse.Pawn,Verse.Map)">
            <summary></summary>
            <param name="prey"></param>
            <param name="predator"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.Utils_Animal.IsAcceptablePreyFor(Verse.Pawn,Verse.Pawn,System.Boolean,Verse.Map,System.Boolean)">
            <summary>Is <see langword="this"/> <paramref name="prey"/> valid for the given <paramref name="predator"/>?</summary>
            <param name="prey"></param>
            <param name="predator"></param>
            <param name="baseGameResult"></param>
            <param name="map"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Utils_Animal.ValidPreyForMe(Verse.Pawn,Verse.Pawn,System.Boolean,Verse.Map)">
            <summary>Check if the <paramref name="prey"/> is valid for <see langword="this"/> <paramref name="predator"/></summary>
            <param name="predator"></param>
            <param name="prey"></param>
            <param name="debugOnGUI"></param>
            <param name="map"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.LordJob_Dwelling.#ctor">
            <summary>Empty constructor is needed to prevent errors</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Dwelling.SpawnDwellingFlooring(Verse.IntVec3,Verse.Map,Verse.ThingDef)">
            <summary>Spawns decorative stuff on the cell</summary>
            <param name="cell">Where to spawn?</param><param name="map">What map?</param><param name="flooringDef">What to spawn?</param>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Dwelling.DigDwelling(Verse.Pawn,Verse.Map,Verse.Building@,Verse.Region,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Animal.Dweller.Dwelling.DigDwelling(Verse.Pawn,Verse.Map,Verse.Region,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Dwelling.DigDwelling(Verse.Pawn,Verse.Map,Verse.Region,System.Boolean)">
            <summary>Tries to queue a digging job for the given dweller animal</summary>
            <param name="pawn"></param><param name="map"></param>
            <param name="existingDwellingToExpand">Expand this existing dwelling, try to dig new if this is <see langword="null"/></param>
            <param name="debug"></param>
            <returns><see langword="true"/> if was able to queue the digging job</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Dwelling.NewDwelling_Internal(Verse.Pawn,Verse.Map,System.Nullable{System.Int32},Verse.AI.Group.Lord,System.Boolean,Verse.IntVec3)">
            <summary>Create a new dwelling lord for the given pawn</summary>
            <param name="pawn"></param><param name="map"></param><param name="maxDwellers"></param>
            <param name="oldLord"></param><param name="isMother"></param>
            <param name="customDwellingLocation"></param>
            <returns>The created dwelling <see cref="T:Verse.AI.Group.Lord"/></returns>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.CompProperties_Dweller">
            <summary>These are the properties that define the behaviour of a dweller type animal</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellerComp.JoinOrCreateLord">
            <summary>Join or create a <see langword="new"/> <see cref="T:Verse.AI.Group.Lord"/></summary>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.Dweller_Temperature_Patch">
            <summary>This patch allows for dwellers to not freeze to death, even when they are 'outside'</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Dweller_Temperature_Patch.ShouldReturnSafeTemp(Verse.IntVec3,Verse.Map,Verse.Thing)">
            <summary></summary>
            <param name="pos"></param>
            <param name="map"></param>
            <param name="thingInstance"></param>
            <returns><see langword="true"/> of the <paramref name="thingInstance"/> is a <see cref="T:Verse.Pawn"/> that is in it's dwelling, and the <see cref="T:NQualityOfLife.Animal.Dweller.DwellingType"/> is one of the <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.WarmTypes"/></returns>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.DutyDefOf">
            <summary>XML defs</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DutyDefOf.NQoL_Dwell">
            <summary>XML def for dweller animals</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType.Roofed">
            <summary>Has roof, mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.UnRoofed"/></summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType.Cave">
            <summary><see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Roofed"/> with natural rock, mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.UnRoofed"/></summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType.Pond">
            <summary><see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Water"/> that is not flowing, mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.River"/> and <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Dry"/></summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType.River">
            <summary><see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Water"/> that is flowing, mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Pond"/> and <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Dry"/></summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType.Water">
            <summary>Has water, mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Dry"/></summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType.UnRoofed">
            <summary>No roof of any kind, mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Roofed"/></summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType.Dry">
            <summary>Dry ground, mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Water"/></summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType._Still">
            <summary>Mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType._Flowing"/></summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingType._Flowing">
            <summary>Mutally exclusive with <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType._Still"/></summary>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.DwellingFinder">
            <summary>Utilities for finding good dwelling spots for dwellers</summary>
        </member>
        <member name="P:NQualityOfLife.Animal.Dweller.DwellingFinder.DwellingTypeForWildMan">
            <summary>The <see cref="T:NQualityOfLife.Animal.Dweller.DwellingType"/> that wild men should use</summary>
        </member>
        <member name="P:NQualityOfLife.Animal.Dweller.DwellingFinder.Default">
            <summary>The <see cref="T:NQualityOfLife.Animal.Dweller.DwellingType"/> to use if there is no valid type</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.FlagsAreSet(NQualityOfLife.Animal.Dweller.DwellingType,NQualityOfLife.Animal.Dweller.DwellingType)">
            <summary></summary>
            <param name="type"></param>
            <param name="flags"></param>
            <returns><see langword="true"/> if all the <paramref name="flags"/> are set in <paramref name="type"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.AnyFlagIsSet(NQualityOfLife.Animal.Dweller.DwellingType,NQualityOfLife.Animal.Dweller.DwellingType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.UnSetFlags(NQualityOfLife.Animal.Dweller.DwellingType,NQualityOfLife.Animal.Dweller.DwellingType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.IsValid(NQualityOfLife.Animal.Dweller.DwellingType)">
            <summary>Check if the <paramref name="dwellingType"/> is valid, and does not contain contradictory flags</summary>
            <param name="dwellingType"></param>
            <returns><see langword="true"/> if the <paramref name="dwellingType"/> is valid</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.IsWarm(NQualityOfLife.Animal.Dweller.DwellingType)">
            <summary></summary>
            <param name="dwellingType"></param>
            <returns><see langword="true"/> if the dwelling type provides protection from extreme temperatures</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.DwellingTypeForPawn(Verse.Pawn)">
            <summary>Get the <see cref="T:NQualityOfLife.Animal.Dweller.DwellingType"/> for the given <paramref name="dweller"/></summary>
            <param name="dweller"></param>
            <returns>the <see cref="T:NQualityOfLife.Animal.Dweller.DwellingType"/> for the given <see cref="T:Verse.Pawn"/> || <see cref="F:NQualityOfLife.Animal.Dweller.DwellingType.Invalid"/> if the <see cref="T:Verse.Pawn"/> is not a dweller</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.OnCooldown(Verse.Map)">
            <summary></summary>
            <param name="map"></param>
            <returns><see langword="true"/> if the dwelling finder is on cooldown for the given <paramref name="map"/></returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.ValidDwellingsForPawn(Verse.Pawn,Verse.Map,NQualityOfLife.Animal.Dweller.DwellingType,System.Boolean)">
            <summary>Try to get a <see langword="ref"/> to a set of valid dwelling locations for the given <paramref name="pawn"/> from the cache</summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <param name="ofType"></param>
            <param name="detailedDebug"><see cref="F:NQualityOfLife.Animal.Settings.DebugAnimals"/> must also be enabled</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.GoodDwellingSpotsForPawn(Verse.Map,Verse.Pawn,Verse.AI.Group.Lord,System.Boolean)">
            <summary></summary>
            <param name="map"></param>
            <param name="pawn"></param>
            <param name="pawnLord"></param>
            <param name="debug"></param>
            <returns>A <see langword="ref"/> to a set of spots from the cache</returns>
            <inheritdoc cref="M:NQualityOfLife.Animal.Dweller.DwellingFinder.GoodDwellingSpots_Internal(Verse.Map,Verse.Pawn,Verse.AI.Group.Lord,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.GoodDwellingSpots_Internal(Verse.Map,Verse.Pawn,Verse.AI.Group.Lord,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="map"></param><param name="pawn">Get the valid dwellings for this pawn</param><param name="pawnLord"></param><param name="debug"></param>
            <param name="isAsyncOperation">Leave as <see langword="false"/></param>
            <returns>A list of valid dwellings for the <paramref name="pawn"/>, if <paramref name="pawn"/> is not given, will return all valid dwellings of all types. || <see langword="null"/> if the <see cref="F:NQualityOfLife.Animal.Dweller.DwellingFinder.asyncTask"/> is currently getting the dwellings</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.CorpseCaching">
            <summary>Adds all newly created <seealso cref="T:Verse.Corpse">corpses</seealso> to a list for fast lookup for dwellers</summary>
            <remarks>This cache can be accessed from <see cref="P:NQualityOfLife.Animal.Dweller.CorpseCaching.CachedCorpses"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Animal.Dweller.CorpseCaching.CachedCorpses">
            <summary>Contains all corpses for all maps, Listed corpses must be validated by the caller.</summary>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling">
            <summary>Remove rotting corpses from a dwelling to prevent lung rot</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling.TryMakeCleanDwellingJob(Verse.Pawn,Verse.Map,Verse.AI.Group.Lord)">
            <summary>Returns <see langword="null"/> or the job ready to be started, Does not reserve or start the job, only creates it.</summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <param name="myLord"></param>
            <returns><see langword="null"/> if no job, or the job</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling.TryIssueJobPackage(Verse.Pawn,Verse.AI.JobIssueParams)">
            <summary>Try to give haul job</summary>
            <param name="pawn">The pawn who will do the job</param>
            <param name="jobParams">jobParams</param>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling.TryGiveJob(Verse.Pawn)">
            <summary>Try to give haul job</summary>
            <param name="pawn">The pawn who will do the job</param>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.JobGiver_HaulCorpseToDwelling">
            <summary>Haul fresh corpses to dwelling</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_HaulCorpseToDwelling.TryMakeHaulCorpseToDwellingJob(Verse.Pawn,Verse.IntVec3,Verse.Map,Verse.ThingDef)">
            <summary>Tries to get a fresh corpse to haul, and if found returns the hauling job, Does not reserve or start the job, only creates it.</summary>
            <param name="pawn"></param>
            <param name="cellInDwelling">Where the corpse should be hauled, and where to spawn dwelling deco</param>
            <param name="myMap"></param>
            <param name="dwellingDecoToSpawn"></param>
            <returns>null if no jobs available, else the job</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_HaulCorpseToDwelling.TryGetTargetPreyCorpse(Verse.Pawn,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <returns>a fresh <see cref="T:Verse.Corpse"/> that the <paramref name="pawn"/> can reach and reserve</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_HaulCorpseToDwelling.TryGiveJob(Verse.Pawn)">
            <summary>Try to give a job to haul a fresh corpse into the dwelling</summary>
            <param name="pawn">The pawn who will do the job</param>
            <returns>The <see cref="T:Verse.AI.Job"/> that was started, or <see langword="null"/> if it was not</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Animal.AnimalPopulationManager">
            <summary>Tries to keep wild animal populations in balance</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.AnimalPopulationManager.ratioTrigger">
            <summary></summary>
            <remarks>
            <code>float ratioTriggerLevel = totalWild / (uniqueKinds * ratioTrigger);
            (val.females + val.males) >= ratioTriggerLevel;</code>
            </remarks>
        </member>
        <member name="F:NQualityOfLife.Animal.AnimalPopulationManager.ratioTriggerTotalAnimals">
            <summary></summary>
            <remarks>
            <code>float totalAnimalsTriggerLevel = totalWild * ratioTriggerTotalAnimals;
            (val.females + val.males) >= totalAnimalsTriggerLevel;</code>
            </remarks>
        </member>
        <member name="P:NQualityOfLife.Animal.AnimalPopulationManager.EcosystemFull">
            <summary>The current cached value of <see cref="P:RimWorld.WildAnimalSpawner.AnimalEcosystemFull"/></summary>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.GetReports(System.Boolean)">
            <summary>Get fresh reports for all maps</summary>
            <param name="debug"></param>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.KindToCullOrNull(NQualityOfLife.Animal.AnimalPopulationManager.Report@,System.Boolean)">
            <summary></summary>
            <param name="report"></param>
            <param name="debug"></param>
            <returns>The <see cref="T:Verse.PawnKindDef"/> that is overpopulated, or <see langword="null"/> if none of the kinds are too over populated</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.TakePopulationControlMeasuresForKind(Verse.PawnKindDef,Verse.Map,System.Boolean)">
            <summary>Try to cull the population of the given <paramref name="kind"/> on the given <see cref="T:Verse.Map"/></summary>
            <param name="kind"></param>
            <param name="onMap"></param>
            <param name="debug"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="kind"/> or <paramref name="onMap"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.MakeRandomMemberSterile(Verse.PawnKindDef,Verse.Map,System.Boolean)">
            <summary>Makes a random member of the <paramref name="kind"/> sterile to slow down population growth</summary>
            <param name="kind"></param>
            <param name="onMap"></param>
            <param name="debug"></param>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.MakeRandomMemberSick(Verse.PawnKindDef,Verse.Map,System.Boolean)">
            <summary>Make a single random member of the <paramref name="kind"/> sick, this method is used when the <see cref="F:NQualityOfLife.Medical.Hediffs.GermMaker.diseaseSpreadEnabled"/> is enabled</summary>
            <param name="kind"></param>
            <param name="onMap"></param>
            <param name="debug"></param>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.MakeRandomMembersSick(Verse.PawnKindDef,Verse.Map)">
            <summary>Make a random set of the given <paramref name="kind"/> sick with animal diseases</summary>
            <param name="kind"></param>
            <param name="onMap"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="kind"/> or <paramref name="onMap"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.NeedsMorePredators(Verse.Map)">
            <summary></summary>
            <param name="map"></param>
            <returns><see langword="true"/> if the <paramref name="map"/> needs more predators to control the animal population</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.BioDiversityReport(Verse.Map,System.Boolean)">
            <summary></summary>
            <param name="map"></param>
            <param name="debug"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Animal.AnimalPopulationManager.Report">
            <summary>The cached data about the current population on a given map</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.AnimalPopulationManager.Report.TotalWildAnimals">
            <summary>The total amount of wild animals on the map</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.AnimalPopulationManager.Report.TotalPreyAnimals">
            <summary>The total amount of wild prey animals on the map</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.AnimalPopulationManager.Report.TotalPredatorAnimals">
            <summary>The total amount of wild predators on the map</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.AnimalPopulationManager.Report.AnimalCounts">
            <summary>The counts of males and females for each kind</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.Report.NoneOnMap(Verse.PawnKindDef)">
            <summary></summary>
            <param name="kind"></param>
            <returns><see langword="true"/> if there are no animals of the given <paramref name="kind"/> on the map</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="kind"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.Report.NoMates(Verse.PawnKindDef)">
            <summary></summary>
            <param name="kind"></param>
            <returns><see langword="true"/> if there are no mates to breed with for the given <paramref name="kind"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="kind"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.Report.NoMatesOrNoneOnMap(Verse.PawnKindDef)">
            <summary></summary>
            <param name="kind"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="kind"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Animal.AnimalPopulationManager.AnimalCommonality_Patch_1">
            <summary>This patch adjusts the spawn chances of different animals based on the current population</summary>
        </member>
        <member name="T:NQualityOfLife.Animal.AnimalPopulationManager.AnimalCommonality_Patch_2">
            <summary>This patch activates the population control measures, and monitors if the ecosystem is full</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.AnimalPopulationManager.AnimalCommonality_Patch_2.Postfix(System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="__result"><see cref="P:RimWorld.WildAnimalSpawner.AnimalEcosystemFull"/> result</param>
            <param name="___map"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Animal.Settings">
            <summary>Settings for animal related features</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Settings.DebugAnimals">
            <summary>Main toggle for all animal related debugging, requires <see cref="F:NQualityOfLife.Utils.Settings.DebugMode"/> to also be active</summary>
        </member>
        <member name="T:NQualityOfLife.Animal.NQoL_TrainingPatch">
            <summary>Patch to make animals wait for the trainer, or come to the trainer in some cases</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.JobGiver_AnimalForage.CanForageEver(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> is capable of foraging assuming the current map conditions allow for it</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.JobGiver_AnimalForage.CanForageOnBiome(Verse.Pawn,RimWorld.BiomeDef)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="biome"></param>
            <returns><see langword="true"/> if the <paramref name="biome"/> can be foraged for valid food for the <paramref name="pawn"/></returns>
        </member>
        <member name="M:NQualityOfLife.Animal.JobGiver_WanderInAndNearDwelling.WanderCellFromRadius(Verse.Pawn,Verse.Map,Verse.IntVec3@,System.Single)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <param name="root"></param>
            <param name="radius"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Animal.JobGiver_StaySafeInDwelling">
            <summary>Job to stay in the dwelling to stay safe from extreme map temperatures</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.JobGiver_StaySafeInDwelling.TryGiveJob(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="null"/> if there is no need to hide in the dwelling</returns>
        </member>
        <member name="M:NQualityOfLife.Comps.BuildingComp.Notify_AddBedThoughts(Verse.Pawn)">
            <summary>N/A - Only applies to pawn comps</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.BuildingComp.Notify_Killed(Verse.Map,System.Nullable{Verse.DamageInfo})">
            <summary>N/A - Only applies to pawn comps</summary><param name="prevMap">N/A</param><param name="dinfo">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.BuildingComp.CompAllowVerbCast(Verse.Verb)">
            <summary>N/A - Only applies to apparel comps</summary><param name="verb"></param><returns></returns>
        </member>
        <member name="T:NQualityOfLife.Comps.ItemComp">
            <summary>A <see cref="T:Verse.ThingComp"/> that is to be applied to items only</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_Unequipped(Verse.Pawn)">
            <summary>Is called when the weapon or apparel is unequipped</summary>
            <param name="pawn">The pawn who unequipped this thing</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_KilledPawn(Verse.Pawn)">
            <summary>Called on all equipment when a pawn kills another pawn</summary>
            <param name="pawn">The pawn that was killed</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_WearerDied">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_Arrested(System.Boolean)">
            <summary>N/A</summary><param name="succeeded">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_WearerDied">
            <summary>Called when the pawn wearing this apparel has died</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.CompAllowVerbCast(Verse.Verb)">
            <summary>Can the verb be casted while wearing this?</summary>
            <param name="verb"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.PostIngested(Verse.Pawn)">
            <summary>N/A</summary><param name="ingester">>N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.PrePostIngested(Verse.Pawn)">
            <summary>N/A</summary><param name="ingester">>N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_UsedVerb(Verse.Pawn,Verse.Verb)">
            <summary>N/A</summary><param name="pawn">N/A</param><param name="verb">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Released">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Downed">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Arrested(System.Boolean)">
            <summary>N/A</summary><param name="succeeded">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.GetAdditionalHarvestYield">
            <summary>N/A</summary>
        </member>
        <member name="T:NQualityOfLife.Comps.PawnComp">
            <summary>A <see cref="T:Verse.ThingComp"/> that is applied to <see cref="T:Verse.Pawn"/>s</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_AbandonedAtTile(RimWorld.Planet.PlanetTile)">
            <summary><see cref="F:NQualityOfLife.Comps.PawnComp.myMap"/> is set to <see langword="null"/> and <see cref="F:NQualityOfLife.Comps.PawnComp.spawned"/> is set to <see langword="false"/></summary>
            <param name="tile"></param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_MapRemoved">
            <summary><see cref="F:NQualityOfLife.Comps.PawnComp.myMap"/> is set to <see langword="null"/></summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Killed(Verse.Map,System.Nullable{Verse.DamageInfo})">
            <summary>Triggers when the pawn is killed || <see cref="F:NQualityOfLife.Comps.PawnComp.alive"/> is set to <see langword="false"/></summary>
            <param name="prevMap"></param>
            <param name="dinfo"></param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.PostSpawnSetup(System.Boolean)">
            <summary><see cref="F:NQualityOfLife.Comps.PawnComp.spawned"/> is set to <see langword="true"/> <see cref="F:NQualityOfLife.Comps.PawnComp.myMap"/> is set to <see cref="F:Verse.ThingComp.parent"/>.Map, state of <see cref="F:NQualityOfLife.Comps.PawnComp.alive"/> is updated</summary>
            <param name="respawningAfterLoad"></param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_LordDestroyed">
            <summary>Called when the lord of this pawn is destroyed</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Arrested(System.Boolean)">
            <summary>Called when this pawn is getting arrested</summary>
            <param name="succeeded">true if was successfully arrested</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Released">
            <summary>Called when the pawn is released from prison / slavery etc</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Downed">
            <summary>Called when this pawn is downed</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Equipped(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_UsedWeapon(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_WearerDied">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Unequipped(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.myPlatformIsStale">
            <summary>Should we re-cache <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.myPlatform"/>?</summary>
        </member>
        <member name="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.myPlatform">
            <summary>The cached value of <see cref="P:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.HeldPlatform"/></summary>
        </member>
        <member name="P:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.HeldPlatform">
            <summary>Get the <see cref="T:RimWorld.Building_HoldingPlatform"/> that the thing is currently held on, or <see langword="null"/> if not held, <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.myPlatform"/> gets updated to the returend value, <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.myPlatformIsStale"/> gets set to <see langword="false"/></summary>
        </member>
        <member name="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.heldOnAnyPlatformCached">
            <summary>Was this thing held on a platform last we checked?</summary>
        </member>
        <member name="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.hasFerriteHarvesterStale">
            <summary>Should we get a fresh value for the <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.hasFerriteHarvesterCached"/></summary>
        </member>
        <member name="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.hasFerriteHarvesterCached">
            <summary>Did this thing have a bio ferrite harvester last we checked?</summary>
        </member>
        <member name="P:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.CurrentlyHeldOnPlatform">
            <summary>Get the state of <see cref="P:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.CurrentlyHeldOnPlatform"/> and store the value to <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.heldOnAnyPlatformCached"/></summary>
            <remarks>value of <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.hasFerriteHarvesterCached"/> also gets updated<para><see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.hasFerriteHarvesterCached"/> is updated and <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.hasFerriteHarvesterStale"/> is set to <see langword="false"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.canBeCapturedCachedIsDirty">
            <summary>Should we re-cache <see cref="P:RimWorld.CompHoldingPlatformTarget.CanBeCaptured"/>?</summary>
        </member>
        <member name="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.canBeCapturedCached">
            <summary>Cached value of <see cref="P:RimWorld.CompHoldingPlatformTarget.CanBeCaptured"/></summary>
        </member>
        <member name="P:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.CanBeCaptured">
            <summary>Get the value from the <see cref="P:RimWorld.CompHoldingPlatformTarget.CanBeCaptured"/> and store it in <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.canBeCapturedCached"/>, <see cref="F:NQualityOfLife.Comps.NQoL_CompHoldingPlatformTarget.canBeCapturedCachedIsDirty"/> is set to <see langword="false"/></summary>
        </member>
        <member name="T:NQualityOfLife.RW.BiomeExtensions">
            <summary>Extra values for biomes, used in various NQoL systems</summary>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.UnlockAndClearAllCaches">
            <summary>Unlock and clear all the caches for '<see cref="T:Verse.ResearchProjectDef"/>'s allowing them to re-populate if needed</summary>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.ClearAndLockAllCaches">
            <summary>Clear and lock all the caches for '<see cref="T:Verse.ResearchProjectDef"/>'s once they are no longer needed</summary>
            <inheritdoc cref="M:NQualityOfLife.Types.StaticCache`2.Clear"/>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.ClearPartOfMainTreeCache">
            <inheritdoc cref="M:NQualityOfLife.Types.StaticCache`2.Clear"/>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.ClearIsDeadEndResearchCaches">
            <inheritdoc cref="M:NQualityOfLife.Types.StaticCache`2.Clear"/>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.ClearMyMainPrerequisiteCaches">
            <inheritdoc cref="M:NQualityOfLife.Types.StaticCache`2.Clear"/>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.ClearAllPrerequisitesCaches">
            <inheritdoc cref="M:NQualityOfLife.Types.StaticCache`2.Clear"/>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.IsDeadEndResearch(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns><see langword="true"/> if the <paramref name="researchProjectDef"/> has no children</returns>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.PartOfMainTree(Verse.ResearchProjectDef)">
            <summary>Is <see langword="this"/> <see cref="T:Verse.ResearchProjectDef"/> part of the main progression path?</summary>
            <param name="researchProjectDef"></param>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:Verse.ResearchProjectDef"/> is a pre-requisite of the ship research</returns>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.IsRootResearch(Verse.ResearchProjectDef)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <returns><see langword="true"/> if the <paramref name="researchProjectDef"/> has no parents</returns>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.IsLinearResearchPath(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns><see langword="true"/> if this research leads to exactly 1 other research</returns>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.MyMainPrerequisite_Populator(Verse.ResearchProjectDef,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <returns></returns>
            <remarks>If the <paramref name="researchProjectDef"/> only has one prerequisite; it will be given as the main prerequisite
            <para>If it has no prerequisites; returns <see langword="null"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.MyMainPrerequisite(Verse.ResearchProjectDef,System.Boolean)">
            <summary>Get the 'main' prerequisite for the given <see cref="T:Verse.ResearchProjectDef"/></summary>
            <param name="researchProjectDef"></param>
            <param name="onThisTab"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.ResearchSlotOccupiedByMe(Verse.ResearchProjectDef,UnityEngine.Rect@)">
            <summary></summary>
            <param name="researchProject"></param>
            <param name="slot"></param>
            <returns><see langword="true"/> if the <paramref name="slot"/> is occupied by the <paramref name="researchProject"/></returns>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.ResearchSlotOccupied(UnityEngine.Rect,RimWorld.ResearchTabDef)">
            <summary></summary>
            <param name="slot"></param>
            <param name="tab"></param>
            <returns><see langword="true"/> if the given <paramref name="slot"/> is occupied by any <see cref="T:Verse.ResearchProjectDef"/></returns>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.DirectChildren(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns>The projects that require the given project to be completed first</returns>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.DirectChildrenList(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <param name="inlcudeVisible"></param>
            <returns>The projects that require the given project to be completed first</returns>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.OneOfMyVisiblePrerequisitesIs_Recursive(Verse.ResearchProjectDef,Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Byte)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="visiblePrerequisite"></param>
            <param name="sameTab"></param>
            <param name="inludeHidden"></param>
            <param name="recursionDepth"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="researchProjectDef"/> or <paramref name="visiblePrerequisite"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="researchProjectDef"/> and <paramref name="visiblePrerequisite"/> are the same</exception>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.AllPrerequisitesPopulator(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="includeNonHidden"></param>
            <param name="includeHidden"></param>
            <param name="sameTabOnly"></param>
            <returns>A <see langword="ref"/> to '<see cref="F:Verse.ResearchProjectDef.prerequisites"/>' or '<see cref="F:Verse.ResearchProjectDef.hiddenPrerequisites"/>' or a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/>, <see langword="null"/> if the return is empty</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="researchProjectDef"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.AllPrerequisites(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Get all the direct prerequisites of the given <see cref="T:Verse.ResearchProjectDef"/></summary>
            <param name="researchProjectDef"></param>
            <param name="includeNonHidden"></param>
            <param name="includeHidden"></param>
            <param name="sameTabOnly"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="researchProjectDef"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="includeNonHidden"/> and <paramref name="includeHidden"/> are both <see langword="false"/></exception>
        </member>
        <member name="M:NQualityOfLife.RW.ResearchExtensions.AllPrerequisitesLazy(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.RW.ResearchExtensions.AllPrerequisites(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="T:NQualityOfLife.RW.TraitExtensions">
            <summary>Extra values for traits, used in various NQoL systems</summary>
        </member>
        <member name="F:NQualityOfLife.RW.TraitExtensions.isBad">
            <summary>Is this a negative trait? affects calculations</summary>
        </member>
        <member name="F:NQualityOfLife.RW.TraitExtensions.germResistanceOffset">
            <summary>float of germ resistance offset caused by the trait expects positive values between 0.25 and 0</summary>
        </member>
        <member name="M:NQualityOfLife.RW.TraitExtensions.ConfigErrors">
            <summary>Validate and give errors for invalid config values in xml</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.NQualityOfLife_Mod">
            <summary>My mod class</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Mod.Instance">
            <summary>The instance of my 'Mod'</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.#ctor(Verse.ModContentPack)">
            <summary>My <see cref="T:Verse.Mod"/> class constructor</summary>
            <param name="content"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.DoSettingsWindowContents(UnityEngine.Rect)">
            <summary>My mod settings menu contents</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.SettingsCategory">
            <summary>My mod settings label - Displayed in the mod settings list</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_">
            <summary>Utils for creating setting menus</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions">
            <summary>Extension to 'Listing_Standard' for creating setting menus</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawColumns(UnityEngine.Color@,UnityEngine.Color@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single,System.Boolean)">
            <summary>Draw 4 columns with specified height</summary>
            <param name="outlineColor">Outline color</param><param name="fillColor">Column fill color</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Border thickness</param>
            <param name="height">Height of the columns</param>
            <param name="progressScroll">Set to false to disable adding of gap. (Useful for some cases) Normally should leave to true</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawIconButton(UnityEngine.Texture2D,NQualityOfLife.Types.Vector2Float@,System.Action,System.Boolean,NQualityOfLife.Types.Vector2Float@)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawIconButton(NQualityOfLife.Geometry.Rectangle@,UnityEngine.Texture2D,System.Action)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawIconButton(NQualityOfLife.Geometry.Rectangle@,UnityEngine.Texture2D,System.Action)">
            <summary>Draw a texture inside the <paramref name="textureRectangle"/>, will be clickable if <paramref name="clickAction"/> is provided</summary>
            <param name="textureRectangle"></param>
            <param name="texture2D"></param>
            <param name="clickAction"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.RadioButton(System.String,System.Boolean,System.Single,System.String,System.Nullable{System.Single})">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.RadioButton(System.String,System.Boolean,System.Single,System.Single,System.String,System.Nullable{System.Single},System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.RadioButton(System.String,System.Boolean,System.Single,System.String,System.Nullable{System.Single},System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.RadioButton(System.String,System.Boolean,System.Single,System.Single,System.String,System.Nullable{System.Single},System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.RadioButton(System.String,System.Boolean,System.Single,System.Single,System.String,System.Nullable{System.Single},System.Boolean)">
            <summary></summary>
            <param name="labelTranslated"></param>
            <param name="active">Draw the selection highlight</param>
            <param name="tabIn"></param>
            <param name="tabInRight"></param>
            <param name="tooltip"></param>
            <param name="tooltipDelay"></param>
            <param name="disabled"></param>
            <returns><see langword="true"/> when the button is clicked</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.EndScrollLister">
            <summary>Ideally should be called inside a 'finally' block to prevent cascading errors</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.EndScrollLister(System.Single@)">
            <summary>Ideally should be called inside a 'finally' block to prevent cascading errors</summary>
            <param name="finalLength"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.End">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.End_Internal(System.Single@)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.End_Internal(System.Single@)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.EndScrollLister(System.Single@)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.GetRect(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.GetRect(System.Single,NQualityOfLife.Types.Ratio@)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.GetRect(System.Single,NQualityOfLife.Types.Ratio@)">
            <summary>Creates a new <see cref="T:NQualityOfLife.Geometry.Rectangle"/> at the end of <see langword="this"/> <see cref="T:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions"/> and extends the length</summary>
            <param name="height"></param>
            <param name="width"></param>
            <returns>A <see cref="T:NQualityOfLife.Geometry.Rectangle"/> a the end of the <see cref="T:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions"/></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.GapLine(System.Single)">
            <summary>Draw a horizontal line with a gap</summary>
            <param name="gapHeight"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Int32@,System.Int32,System.Int32,System.String,System.String,System.String)">
            <summary>Draw a nested setting section with an inner slider</summary>
            <param name="topSettingLabelTranslated"></param>
            <param name="topSetting"></param>
            <param name="innerSetting1LabelTranslated"></param>
            <param name="innerSetting1"></param>
            <param name="innerSetting1Min"></param>
            <param name="innerSetting1Max"></param>
            <param name="topSettingTipTranslated"></param>
            <param name="innerSetting1TipTranslated"></param>
            <param name="innerSetting1SuffixTranslated"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSetting1LabelTranslated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="topSettingTipTranslated">Main setting tooltip</param>
            <param name="innerSetting1TipTranslated">Inner setting tip</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSetting1LabelTranslated">Inner setting 1 label</param><param name="innerSetting1">Inner setting 1 bool</param>
            <param name="innerSetting2LabelTranslated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTipTranslated">Top setting tooltip</param>
            <param name="innerSetting1TipTranslated">Inner setting 1 tip</param>
            <param name="innerSetting2TipTranslated">Inner setting 2 tip</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 3 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSetting1LabelTranslated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param><param name="innerSetting2LabelTranslated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSetting3LabelTranslated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSetting1TipTranslated">Tooltip for the first inner setting</param><param name="innerSetting2TipTranslated">Tooltip for setting 2</param><param name="innerSetting3TipTranslated">Tooltip for setting 3</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSetting1LabelTranslated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param><param name="innerSetting2LabelTranslated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSetting3LabelTranslated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param><param name="innerSetting4LabelTranslated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSetting1TipTranslated">Tooltip for the first inner setting</param><param name="innerSetting2TipTranslated">Tooltip for setting 2</param>
            <param name="innerSetting3TipTranslated">Tooltip for setting 3</param><param name="innerSetting4TipTranslated">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.Boolean,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting in a horizontal row</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSetting1LabelTranslated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSetting2LabelTranslated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSetting3LabelTranslated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSetting4LabelTranslated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="horizontal">Must be true, if false you should call a different method will redirect if called with false</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSetting1TipTranslated">Tooltip for the first inner setting</param><param name="innerSetting2TipTranslated">Tooltip for setting 2</param>
            <param name="innerSetting3TipTranslated">Tooltip for setting 3</param><param name="innerSetting4TipTranslated">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param>
            <param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5Translated">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6Translated">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param>
            <param name="innerSettingTip3Translated">Tooltip for setting 3</param><param name="innerSettingTip4Translated">Tooltip for setting 4</param>
            <param name="innerSettingTip5Translated">Tooltip for setting 5</param><param name="innerSettingTip6Translated">Tooltip for setting 6</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.Slider(System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Int32@,System.Int32,System.Int32,System.String,System.Func{System.Int32,System.String})"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Int32@,System.Int32,System.Int32,System.String,System.Func{System.Int32,System.String})">
            <summary>Draw a slider with label and visible value</summary>
            <param name="labelTranslated">The label that is displayed above the slider</param>
            <param name="setting">The float we are adjusting, will be drawn on top of the slider</param>
            <param name="min">Minimum allowed input value</param><param name="max">Maximum allowed input value</param>
            <param name="customTooltip">Tooltip, if null: use default</param>
            <param name="specialNumberFormatter">Optionally convert the selected int to something else for display purposes.</param>
            <returns>value of setting</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Single@,System.Single,System.Single,System.String,System.Single)">
            <summary>Draw a slider with label and visible value</summary>
            <param name="labelTranslated">The label that is displayed above the slider</param>
            <param name="setting">The <see cref="T:System.Single"/> we are adjusting, will be drawn on top of the slider</param>
            <param name="min">Minimum allowed input value</param><param name="max">Maximum allowed input value</param>
            <param name="customTooltip">Tooltip, if null: use default</param>
            <param name="roundTo">Snap / round the value with the given precision</param>
             <returns>setting</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Single,System.Single,System.Single,System.String,System.Single)">
            <summary>Draw a slider with label and visible value</summary>
            <param name="labelTranslated">The label that is displayed above the slider</param>
            <param name="setting">The float we are adjusting, will be drawn on top of the slider</param>
            <param name="min">Minimum allowed input value</param><param name="max">Maximum allowed input value</param>
            <param name="customTooltip">Tooltip, if null: use default</param>
            <param name="roundTo"></param>
             <returns>setting</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewDualRangeSlider(System.String,Verse.IntRange@,Verse.IntRange@,System.Int32,System.Int32,System.String,System.Boolean,System.Boolean)">
            <summary>Slider that is a range of ranges</summary>
            <param name="label"></param>
            <param name="rangeMin"></param>
            <param name="rangeMax"></param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="customTooltip"></param>
            <param name="centeredLabel"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawHorizontalCheckButtons(System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32)">
            <summary>Draw 4 check box buttons in a horizontal row with grey border and no fill color</summary>
            <param name="setting1">Left most button setting</param><param name="setting2">Left middle button setting</param>
            <param name="setting3">Right middle button setting</param><param name="setting4">Right most button setting</param>
            <param name="label1">Left most button label</param><param name="label2">Left middle button label</param>
            <param name="label3">Right middle button label</param><param name="label4">Right most button label</param>
            <param name="borderThickness">Button border thickness pixels</param>
            <param name="tooltip1"></param><param name="tooltip2"></param>
            <param name="tooltip3"></param><param name="tooltip4"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawHorizontalCheckButtons(UnityEngine.Color@,UnityEngine.Color@,System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32)">
            <summary>Draw 4 check box buttons in a horizontal row</summary>
            <param name="outlineColor">Button border color</param><param name="fillColor">Button box fill color</param>
            <param name="setting1">Left most button setting</param><param name="setting2">Left middle button setting</param>
            <param name="setting3">Right middle button setting</param><param name="setting4">Right most button setting</param>
            <param name="label1">Left most button label</param><param name="label2">Left middle button label</param>
            <param name="label3">Right middle button label</param><param name="label4">Right most button label</param>
            <param name="borderThickness">Button border thickness pixels</param>
            <param name="tooltip1"></param><param name="tooltip2"></param>
            <param name="tooltip3"></param><param name="tooltip4"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelLargeCentered(System.String,System.Boolean)">
            <summary>Draw a large label centered with the given (translated) text.</summary>
            <param name="labelTranslated">The translated text to draw.</param>
            <param name="debug">Draw debug rects</param>
            <returns>The rect that contains the text.</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.Label(System.String,System.String,System.Boolean,System.Action,System.Nullable{UnityEngine.Color},System.Boolean)">
            <summary>Draw text with optional tooltip, highlight and click action</summary>
            <param name="textTranslated"></param>
            <param name="toolTipKey"></param>
            <param name="tipIsTranslationKey"></param>
            <param name="clickAction"></param>
            <param name="backgroundColor"></param>
            <param name="playClickSound"></param>
            <returns>The <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that contains the text</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelDouble(System.String,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelDouble(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelDouble(System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="leftLabelTranslated"></param>
            <param name="rightLabelTranslated"></param>
            <param name="tipTranslated"></param>
            <param name="onlyHighlightIfHasTooltip">Only draw the highlight on mouse over if the label has a tooltip?</param>
            <returns>The <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that contains the text</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelCentered(System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="labelTranslated"></param><param name="tooltip"></param><param name="debug"></param>
            <returns>The rect that contains the text.</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.CheckboxLabeled(System.String,System.Boolean@,System.String,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Ratio@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw a draggable labeled checkbox with an optional tooltip</summary>
            <param name="labelTranslated"></param>
            <param name="checkOn"></param>
            <param name="tooltipTranslated"></param>
            <param name="height"></param>
            <param name="labelPct"></param>
            <param name="onlyHighlightIfHasTooltip"></param>
            <param name="paintable"></param>
            <param name="tooltipsAreTranslationKeys"></param>
            <returns>The current value of this checkbox</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.CheckboxDualLabeled(System.String,System.String,System.Boolean,System.String,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Ratio@,System.Boolean,System.Boolean,System.Boolean,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.CheckboxDualLabeled(System.String,System.String,System.Boolean@,System.String,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Ratio@,System.Boolean,System.Boolean,System.Boolean,NQualityOfLife.Types.Ratio@)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.CheckboxDualLabeled(System.String,System.String,System.Boolean@,System.String,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Ratio@,System.Boolean,System.Boolean,System.Boolean,NQualityOfLife.Types.Ratio@)">
            <summary>Draw a checkbox with two labels, spaced the same way as <see cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelDouble(System.String,System.String,System.String,System.Boolean)"/></summary>
            <param name="leftLabelTranslated"></param>
            <param name="rightLabelTranslated"></param>
            <param name="checkOn"></param>
            <param name="tooltipTranslated"></param>
            <param name="height"></param>
            <param name="labelPct"></param>
            <param name="onlyHighlightIfHasTooltip"></param>
            <param name="paintable"></param>
            <param name="tooltipsAreTranslationKeys"></param>
            <param name="rightLabelRatio">Leave as <see langword="default"/> for 50/50 split</param>
            <returns>The <see cref="T:NQualityOfLife.Geometry.Rectangle"/>s that contain the lables</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DualCheckboxLabel(System.String,System.String,System.String,System.Boolean@,System.Boolean@,System.Single@,System.String,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DualCheckboxLabel(System.String,System.String,System.String,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DualCheckboxLabel(System.String,System.String,System.String,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>Draw a dual checkbox with three labels</summary>
            <param name="labelTranslated">The left most label before the check boxes</param>
            <param name="label_A">The label text next to the first check box</param>
            <param name="label_B">The label text next to the second check box</param>
            <param name="checkOn_A">The state of the first check box</param>
            <param name="checkOn_B">The state of the second check box</param>
            <param name="labelTip">The tooltip of the <paramref name="labelTranslated"/></param>
            <param name="tooltip_A">The tooltip of <paramref name="label_A"/></param>
            <param name="tooltip_B">The tooltip of <paramref name="label_B"/></param>
            <param name="height">Leave to <see langword="default"/> to calculate the needed height</param>
            <param name="labelPct"></param>
            <param name="paintable"></param>
            <param name="tooltipsAreTranslationKeys"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKeys``2(System.Collections.Generic.IDictionary{``0,``1},NQualityOfLife.Settings.SettingProfile@)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="keyValuePairs">The dict of defs etc to convert to settings data strings</param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKeys``1(System.Collections.Generic.IList{``0},NQualityOfLife.Settings.SettingProfile@)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="TK">The type, such as Verse.Def</typeparam>
            <param name="keys">The list of defs etc to convert to settings data strings</param>
            <param name="profile"></param>
            <returns>A List of 'Profile.Data_Key' strings</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKeys``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0})">
            <summary>Extracts the actual values and keys from a list of setting keys. (Input list format: 'Profile.DataName_Key')</summary>
            <typeparam name="T"></typeparam>
            <param name="keyValuePairs"></param>
            <returns>A dictionary of the keys and values, with Profile. and _Key removed from the keys</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKeys(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey})">
            <summary>Extracts the data from a list of 'Profile.Data_Key' strings</summary>
            <param name="keys">List of setting keys starting with 'profile.' and ending with '_Key'</param>
            <returns>The defNames of the defs, or equivalent</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKey(NQualityOfLife.Settings.SettingKey@,NQualityOfLife.Settings.SettingProfile@)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <param name="key"></param>
            <param name="profile"></param>
            <returns>A 'Profile.t_Key' string</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKey``1(``0,NQualityOfLife.Settings.SettingProfile@)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="profile"></param>
            <returns>A 'Profile.t_Key' string</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForCurrentProfile(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey})">
            <summary>Filters out the keys to get only the keys for the current profile</summary>
            <param name="keys">the input setting data keys</param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForProfile(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey},NQualityOfLife.Settings.SettingProfile)">
            <summary>Filters out the keys to get only the keys for the current profile</summary>
            <param name="keys">the input setting data keys</param>
            <param name="profile"></param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKey(NQualityOfLife.Settings.ProfileSettingKey@)">
            <summary>Extracts the data from a 'Profile.Data_Key' string</summary>
            <param name="k">A setting key starting with 'profile.' and ending with '_Key'</param>
            <returns>The defName of the def, or equivalent</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForCurrentProfile``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0})">
            <summary>Filters out the keys to get only the keys for the current profile (input strings format expected: 'Profile.DataName_Key')</summary>
            <typeparam name="T"></typeparam>
            <param name="keysForAllProfiles"></param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForProfile``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0},NQualityOfLife.Settings.SettingProfile@)">
            <summary>Filters out the keys to get only the keys for the provided profile</summary>
            <typeparam name="T"></typeparam>
            <param name="keysForAllProfiles"></param>
            <param name="profile"></param>
            <returns>All the raw keys for 'profile' in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDefs``2(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.SettingKey,``1})">
            <summary>Expected input is a list of defNames</summary>
            <typeparam name="TD"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDefs``1(System.Collections.Generic.IList{NQualityOfLife.Settings.SettingKey})">
            <summary>Extract the Defs from a list of 'defName's</summary>
            <typeparam name="TD">Def type</typeparam>
            <param name="defNames">The list of defNames</param>
            <returns>A list of Defs of type D</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDef``1(NQualityOfLife.Settings.SettingKey@)">
            <summary>Extract the Def from a 'defName'</summary>
            <typeparam name="TD">Def type</typeparam>
            <param name="defName">The defName</param>
            <returns>The def</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_Int(NQualityOfLife.Settings.SettingKey,System.Int32,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved <see cref="T:System.Int32"/> value</summary>
            <param name="settingKey">The unique key of the setting data - Should not have the profile prefix!</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved <see cref="T:System.Int32"/> value or <paramref name="fallback"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_Float(NQualityOfLife.Settings.SettingKey,System.Single,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved <see cref="T:System.Single"/> value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved <see cref="T:System.Single"/> value or <paramref name="fallback"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.SetSettingValue_Bool(NQualityOfLife.Settings.SettingKey,System.Boolean,System.Nullable{NQualityOfLife.Settings.SettingProfile})">
            <summary>Sets the saved float value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="newValue">Set this value as the new value</param>
            <param name="profile"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.SetSettingValue_Float(NQualityOfLife.Settings.SettingKey,System.Single,System.Nullable{NQualityOfLife.Settings.SettingProfile})">
            <summary>Sets the saved float value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="newValue">Set this value as the new value</param>
            <param name="profile"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_String(NQualityOfLife.Settings.SettingKey,System.String,System.String,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved <see cref="T:System.String"/> value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="directString">The <see cref="T:System.String"/> field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved <see cref="T:System.String"/> value or <paramref name="fallback"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingEnabled(NQualityOfLife.Settings.SettingKey,System.Nullable{System.Boolean},System.Nullable{NQualityOfLife.Settings.SettingProfile},System.Boolean,NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved <see cref="T:System.Boolean"/> value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="directBool">The bool field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys">Copy the setting from a legacy key if found.</param>
            <returns>The saved <see cref="T:System.Boolean"/> value or <paramref name="fallback"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Hyperlink(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.URL@,System.Boolean,System.String,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="rect"></param>
            <param name="link"></param>
            <param name="copyToClipboardOnClick">Copy to clipboard on click? || if set to <see langword="false"/>; will open the web page on click</param>
            <param name="customToolTipKey"></param>
            <param name="leftLabel"></param>
            <param name="centered"></param>
            <param name="debug"></param>
            <returns>The rect containing the hyperlink text</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.LabelLarge(UnityEngine.Rect@,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.LabelLarge(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.LabelLarge(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw text in a large font and center it inside a Rect</summary>
            <param name="rect">Text inside this Rect</param>
            <param name="labelTranslated">label text</param>
            <param name="centerX"></param>
            <param name="centerY"></param>
            <param name="debug">Draw debug info</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.TextArea(UnityEngine.Rect@,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="rect"></param>
            <param name="text">The current text in the area</param>
            <param name="tooltip"></param>
            <param name="readOnly"></param>
            <returns>The text in the text area after user input</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button(UnityEngine.Rect@,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.Button(UnityEngine.Rect@,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button(NQualityOfLife.Geometry.Rectangle@,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>Draw a rectangular button inside the given <paramref name="rect"/></summary>
            <param name="rect">The rectangle that the button occupies</param>
            <param name="labelKey">Label translation key</param>
            <param name="tooltipKey">Tooltip translation key, no tooltip if <see langword="null"/></param>
            <param name="maxHeight">Limit how tall the button can be at maximum</param>
            <param name="minHeight">The minimum height that the button can be.</param>
            <param name="labelIsPreTranslated">Is the label already translated, or do we translate it here?</param>
            <param name="tooltipIsPreTranslated">Is the tooltip already translated, or do we translate it here?</param>
            <returns><see langword="true"/> when the button is pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button_Confirmation_HyperLink(NQualityOfLife.Geometry.Rectangle@,System.String,System.String,System.String,NQualityOfLife.Types.URL@)">
            <summary>Draws a button that opens a pop-up confirmation window with the given link</summary>
            <param name="rect">The rect where the button is drawn</param>
            <param name="labelKey">The text on this button</param>
            <param name="tooltipKey">The tooltip when hovering over this button</param>
            <param name="confirmationLabelKey">The header text on the confirmation pop-up</param>
            <param name="hyperLink"></param>
            <returns><see langword="true"/> when clicking the button</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button_Confirmation(NQualityOfLife.Geometry.Rectangle@,System.String,System.String,System.String,System.Action,System.String)">
            <summary>Draws a button that when pressed; opens a popup window to confirm or cancel the action.</summary>
            <param name="rect">Draw button inside this rect</param>
            <param name="labelKey"></param>
            <param name="tooltipKey"></param>
            <param name="confirmationLabelKey"></param>
            <param name="actionOnConfirm">Action on pressing confirm on the pop-up</param>
            <param name="confirmationExtraLabel_Translated"></param>
            <returns><see langword="true"/> when this button is pressed (not the confirmation popup button)</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ClickAction(UnityEngine.Rect@,System.Boolean,Verse.SoundDef,System.Boolean,Verse.SoundDef)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.ClickAction(NQualityOfLife.Geometry.Rectangle@,System.Boolean,Verse.SoundDef,System.Boolean,Verse.SoundDef)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ClickAction(NQualityOfLife.Geometry.Rectangle@,System.Boolean,Verse.SoundDef,System.Boolean,Verse.SoundDef)">
            <summary></summary>
            <param name="rectangle"></param>
            <param name="doMouseoverSound"></param>
            <param name="customHoverSound"></param>
            <param name="doClickSound"></param>
            <param name="customClickSound"></param>
            <returns><see langword="true"/> when the <paramref name="rectangle"/> is clicked</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabs(NQualityOfLife.Geometry.Rectangle@,System.Int32@,System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.Single,System.Int32)">
            <summary>Draw 4 tab buttons at the top of the given Rect</summary>
            <param name="parentRect">Draw at the top of this</param>
            <param name="currentSelectedTabId">The currently active tab (1-6)</param>
            <param name="outlinePixels">Tab button outline thickness</param>
            <param name="heightPixels">Height of the tab buttons</param><param name="tabIdOffset"></param>
            <param name="tip1Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param><param name="tip2Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param>
            <param name="tip3Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param><param name="tip4Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param>
            <param name="label1">Label of the left most tab</param><param name="label2">Label of the 2. tab from the left</param>
            <param name="label3">Label of the 3. tab from the left</param><param name="label4">Label of the right most tab</param>
            <param name="selectSound">Play this sound when selecting a new tab</param>
            <param name="rejectSound">Play this sound if selecting already open tab</param>
            <param name="hoverSound">Play this sound on mouse hover</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabs(UnityEngine.Rect@,System.Int32@,System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.Single,System.Int32)">
            <summary>Draw 6 tab buttons at the top of the given Rect</summary>
            <param name="parentRect">Draw at the top of this</param>
            <param name="currentSelectedTabId">The currently active tab (1-6)</param>
            <param name="outlinePixels">Tab button outline thickness</param>
            <param name="label1">Label of the left most tab</param><param name="label2">Label of the 2. tab from the left</param>
            <param name="label3">Label of the 3. tab from the left</param><param name="label4">Label of the 4. tab from the left</param>
            <param name="label5">Label of the 5. tab from the left</param><param name="label6">Label of the right most tab</param>
            <param name="tip1Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param><param name="tip2Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param>
            <param name="tip3Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param><param name="tip4Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param>
            <param name="tip5Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param><param name="tip6Key">Tooltip translation key for the button, <see langword="null"/> means no tip</param>
            <param name="selectSound">Play this sound when selecting a new tab</param>
            <param name="rejectSound">Play this sound if selecting already open tab</param>
            <param name="hoverSound">Play this sound on mouse hover</param>
            <param name="buttonHeightPixels"></param><param name="tabIdOffset"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabButton(NQualityOfLife.Geometry.Rectangle@,System.Int32,System.String,System.Int32@,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.String,System.Boolean,System.Single)">
            <summary></summary>
            <param name="tabButtonRect"></param>
            <param name="thisTabId"></param>
            <param name="label"></param>
            <param name="currentSelectedTabId"></param>
            <param name="selectSound"></param>
            <param name="rejectSound"></param>
            <param name="hoverSound"></param>
            <param name="tooltipKey"></param>
            <param name="debug"></param>
            <param name="buttonHeightPixels"></param>
            <returns>The LabelLarge Rect inside the button</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single)">
            <summary>Draw 2 vertical column Rects inside a Rect with grey border and no fill color</summary>
            <param name="rect"></param>
            <param name="L">Left column</param><param name="R">Right column</param>
            <param name="outlinePixels">Column border thickness pixels</param>
            <param name="middleGap">Move the columns away from each other by this amount.</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle@,UnityEngine.Color@,UnityEngine.Color@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single)">
            <summary>Draw 2 vertical column Rects inside a Rect</summary>
            <param name="rect"></param>
            <param name="outlineColor">Column border color</param><param name="fillColor">Column fill color</param>
            <param name="L">Left column</param><param name="R">Right column</param>
            <param name="outlinePixels">Column border thickness pixels</param>
            <param name="middleGap">Move the columns away from each other by this amount.</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Single,System.Int32)">
            <summary>Draw 3 vertical column Rects inside a Rect with grey borders and no fill color</summary>
            <param name="rect"></param>
            <param name="L">Left column</param><param name="R">Right column</param><param name="M">Middle column</param>
            <param name="ColumnWidthPercent">How wide the columns should be (0f-1f) 1f = 1/3 of parent rect</param>
            <param name="outlinePixels">Column border thickness pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle@,UnityEngine.Color@,UnityEngine.Color@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Single,System.Int32)">
            <summary>Draw 3 vertical column Rects inside a Rect</summary>
            <param name="rect"></param>
            <param name="outlineColor"></param><param name="fillColor"></param>
            <param name="L">Left column</param><param name="R">Right column</param><param name="M">Middle column</param>
            <param name="ColumnWidthPercent">How wide the columns should be (0f-1f) 1f = 1/3 of parent rect</param>
            <param name="outlinePixels">Column border thickness pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32)">
            <summary>Draw 4 new vertical column Rects inside a Rect with default colors</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(NQualityOfLife.Geometry.Rectangle@,UnityEngine.Color@,UnityEngine.Color@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32)">
            <summary>Draw 4 new vertical column Rects inside a Rect</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="outlineColor">Column border color</param>
            <param name="fillColor">Column fill color</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32)">
            <summary>Draw 6 new vertical column Rects inside a Rect with default border and fill colors</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="A">1. from the left, Left most column</param><param name="B">2. from the left</param>
            <param name="C">3. from the left</param><param name="D">4. from the left</param>
            <param name="E">5. from the left</param><param name="F">6. from the left, Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect@,UnityEngine.Color@,UnityEngine.Color@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32)">
            <summary>Draw 6 new vertical column Rects inside a Rect</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="outlineColor">Column border color</param><param name="fillColor">Column fill color</param>
            <param name="A">1. from the left, Left most column</param><param name="B">2. from the left</param>
            <param name="C">3. from the left</param><param name="D">4. from the left</param>
            <param name="E">5. from the left</param><param name="F">6. from the left, Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Draw(NQualityOfLife.Geometry.Rectangle@,UnityEngine.Color@,UnityEngine.Color@,System.Int32)">
            <summary>Draw the <paramref name="rect"/> with the given border and fill color</summary>
            <param name="rect"></param>
            <param name="fillColor"></param>
            <param name="borderColor"></param>
            <param name="borderThickness"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawNewBorderInsideRectWithPads(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Int32,System.Single,System.Single)">
            <summary>Draw with default colors</summary>
            <param name="outerRect"></param>
            <param name="newRect"></param>
            <param name="borderThickness"></param>
            <param name="outerPadding"></param>
            <param name="innerPadding"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings.NewPopUpWindow_GeneratedToggles(System.String,System.String,System.Collections.Generic.Dictionary{NQualityOfLife.Settings.ProfileSettingKey,System.Boolean},System.Collections.Generic.IEnumerable{Verse.Def},System.Action{System.Collections.Generic.Dictionary{NQualityOfLife.Settings.ProfileSettingKey,System.Boolean}},System.Boolean,NQualityOfLife.Settings.SettingProfile,System.Func{Verse.Def,System.String},System.Boolean,Verse.WindowStack)">
            <summary>Create and pop a <see langword="new"/> <see cref="T:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings"/> with a list of toggles</summary>
            <param name="headerTextKey">The translation key for the header text</param>
            <param name="topTextKey">The translation key for the optional text under the header</param>
            <param name="existingData">The existing saved data</param>
            <param name="defsToKeys">A list of <see cref="T:Verse.Def"/>s that we use as keys for the toggles</param>
            <param name="onConfirm"></param>
            <param name="defaultToggle">The default state of the toggle</param>
            <param name="profile"></param>
            <param name="customTooltip"><see cref="T:System.Func`2"/> that creates the tooltip for the specific <see cref="T:Verse.Def"/></param>
            <param name="drawTextures"></param>
            <param name="windowStack"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings.NewPopUpWindow_GeneratedSliders(System.String,System.Collections.Generic.Dictionary{NQualityOfLife.Settings.ProfileSettingKey,System.Int32},System.Collections.Generic.IEnumerable{Verse.Def},System.Action{System.Collections.Generic.Dictionary{NQualityOfLife.Settings.ProfileSettingKey,System.Int32}},System.Func{Verse.Def,System.String},System.Nullable{System.Int32},NQualityOfLife.Settings.SettingProfile,System.Func{Verse.Def,System.Int32},System.ValueTuple{System.Int32,System.Int32},Verse.WindowStack)">
            <summary>Create and pop a <see langword="new"/> <see cref="T:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings"/> with a list of sliders</summary>
            <param name="headerTextKey">The translation key of the header text at the top of the window</param>
            <param name="existingData">The current/existing data for each slider/setting</param>
            <param name="defsToKeys">The <see cref="T:Verse.Def"/>s that correspond to the keys</param>
            <param name="onConfirm">The action to invoke when pressing confirm, usually a method that saves the new settings</param>
            <param name="sliderLabelMaker">The <see cref="T:System.Func`2"/> that decides what the label is for the def related slider</param>
            <param name="defaultNumber">The default value to use if there is no <paramref name="existingData"/> for the given key</param>
            <param name="profile">The setting profile that this pop-up window is for</param>
            <param name="defaultNumFromDef">This takes priority over <paramref name="defaultNumber"/> if provided</param>
            <param name="sliderMinMax">The min and max values for the sliders</param>
            <param name="windowStack"></param>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_GeneratedSettings.DoDefIcons">
            <summary>Draw the textures of the <see cref="T:Verse.Def"/>s next to the setting</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.GetData(System.Collections.Generic.List{NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.GraphData},System.Int32,NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.State@)">
            <summary></summary>
            <param name="data">The graphs to get the data for</param>
            <param name="forTick"></param>
            <param name="state"></param>
            <returns>True if the data was successfully collected</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ScrollControls(NQualityOfLife.Geometry.Rectangle,NQualityOfLife.Settings.Utils_.PopUpWindow,NQualityOfLife.Types.Factor2@,NQualityOfLife.Types.Vector2Float@)">
            <summary></summary>
            <param name="displayRect"></param>
            <param name="popUpWindow"></param>
            <param name="scaler"></param>
            <param name="DisplayOffset"></param>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow">
            <summary>Base pop up window - Pop up windows are draggable, resizable windows that are drawn on top of other UI elements</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.HeaderTextTranslated">
            <summary>The translated header text to draw at the top of the window</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.TextTranslated">
            <summary>Optional text to draw under the header</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Header">
            <summary>The top part of the window - Intended for a header text</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.HeaderTextBox">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.TextArea">
            <summary>The middle section of the window - Intended for text input fields or other controls or displays</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.TextAreaTextBox">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Bottom">
            <summary>The bottom part of the window - Intended for controls such as confirm or cancel buttons</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.HeaderPixelsOverride">
            <summary>The size (height) of the header independent of the <see cref="F:NQualityOfLife.Settings.Utils_.PopUpWindow.HeaderTextTranslated"/></summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.BottomPixels">
            <summary>The size (height) of the bottom rect</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Debug">
            <summary>Debug the ui elements</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.DefaultInitialSize">
            <summary>'DefaultInitialSize' / (500f, 250f)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.#ctor(System.String,System.String,System.Single)">
            <summary>The base pop up window with a header and text</summary>
            <param name="headerTextTranslated"></param><param name="textTranslated">Text drawn under the header</param><param name="bottomPixels"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.#ctor(System.String,System.Single)">
            <summary>The base pop up window with only a header</summary>
            <param name="headerTextTranslated"></param><param name="bottomPixels"></param>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow.CloseButtonText">
            <summary>The text on the default close button</summary>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow.InitialSize">
            <summary>The initial size of the popup window (x, y) - Default is 'DefaultInitialSize' / (500f, 250f)</summary>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow.InitialPosition">
            <summary>The initial position of the window when it is created - Middle of the screen by default</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.DoWindowContents(UnityEngine.Rect)">
            <summary>Should be called in the overrides, Draws the contents of the pop up window, such as text and or buttons.</summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.NotifyResized(UnityEngine.Rect@)">
            <summary>This is called with the <paramref name="newSize"/> when the window gets resized by dragging</summary>
            <param name="newSize"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.WindowUpdate">
            <summary>By default only maintains the sound sustainer if any</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.ExtraOnGUI">
            <summary>Does not do anything by default</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.WindowOnGUI">
            <summary>Called before <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.DoWindowContents(UnityEngine.Rect)"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.LateWindowOnGUI(UnityEngine.Rect)">
            <summary>Is called after <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.WindowOnGUI"/> and <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.DoWindowContents(UnityEngine.Rect)"/></summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreOpen">
            <summary>Sets initial size and position and does some other stuff || Called before <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostOpen"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostOpen">
            <summary>Plays the appear sound and starts the sound sustainer if any || Called after <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreOpen"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreClose">
            <summary>Does not do anything by default || Called before <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostClose"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostClose">
            <summary>Does not do anything by default || Called after <see cref="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreClose"/></summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.OnAcceptKeyPressed">
            <summary>Called on accept key press (Enter)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.OnCancelKeyPressed">
            <summary>Called on cancel key press (Esc)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.SetInitialSizeAndPosition">
            <summary>Sets the size and position, and makes sure the window is on screen.</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_IdeoRoleSettings.OnAcceptPressed">
            <summary>Saves the settings</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation">
            <summary>A pop up window with confirm and cancel buttons</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmAction">
            <summary>Action to invoke when pressing confirm - Can be null - Should be invoked last if multiple actions!</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelAction">
            <summary>Action to invoke when pressing cancel - Can be null - Should be invoked last if multiple actions!</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.AllowConfirmWithEnter">
            <summary>Set this to false to allow for a better text input experience.</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmTooltipKey">
            <summary>Confirm button hover tooltip translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelTooltipKey">
            <summary>Cancel button hover tooltip translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmKey">
            <summary>Confirm button label translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelKey">
            <summary>Cancel button label translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.DrawButtons">
            <summary>Draw the default buttons that invoke the default actions?</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.#ctor(System.String,System.Single)">
            <summary>Will not draw the base confirm / cancel buttons</summary>
            <param name="headerTextKey"></param><param name="bottomPixels"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.#ctor(System.String,System.Boolean,System.Single)">
            <summary>Draw the base confirm / cancel buttons</summary>
            <param name="headerTextKey"></param><param name="closeOnConfirm">Close the window instance when pressing confirm</param><param name="bottomPixels"></param>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.InitialSize">
            <summary>The initial size of the confirmation popup window (x, y) - Default is (600f, 250f)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.DoWindowContents(UnityEngine.Rect)">
            <summary>If 'DrawButtons' is true, draws the default cancel and confirm buttons, else draws the default popup window.</summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnAcceptKeyPressed">
            <summary>Must be called last inside the OnAcceptPressed() method! - Calls the confirm actions (ConfirmAction) when pressing accept / enter</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnAcceptPressed">
            <summary>Calls the confirm actions (ConfirmAction) when pressing accept / enter</summary>
            <returns>True if we should accept the input, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnCancelKeyPressed">
            <summary>Calls the cancel actions (CancelAction) when pressing cancel / esc</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_ColorSelector.OnAcceptPressed">
            <summary>Invokes the confirm action and color confirm action</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput">
            <summary>Use helper method -> 'NewPopUpWindow_TextInput'</summary>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextEntry">
            <summary>User inputted text</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextConfirmAction">
            <summary>Action to invoke on confirm using the inputted text as a parameter</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextCancelAction">
            <summary>Action to invoke on cancel using the inputted text as a parameter</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.NewPopUpWindow_TextInput(System.String,System.String,System.Action{System.String},System.Boolean,Verse.WindowStack)">
            <summary>Example usage: 'NewPopUpWindow_TextInput("NQoL_Animal_Color", TechLevel_.Animal_ColorHex, newText => TechLevel_.Animal_ColorHex = newText))'</summary>
            <param name="headerTextKey">Example usage: '"NQoL_Animal_Color"'</param>
            <param name="initialValue">Example usage: 'TechLevel_.Animal_ColorHex'</param>
            <param name="confirmAction">Example usage: 'newText => TechLevel_.Animal_ColorHex = newText'</param>
            <param name="closeOnConfirm">Close the window on confirm/accept (true) or keep it open (false).</param>
            <param name="windowStack">Optional, will find if null</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.NewPopUpWindow_TextInput(System.String,System.String,System.String,System.Action{System.String},System.Action,System.Boolean,Verse.WindowStack)">
            <summary>Example usage: 'NewPopUpWindow_TextInput("NQoL_Animal_Color", TechLevel_.Animal_ColorHex, newText => TechLevel_.Animal_ColorHex = newText))'</summary>
            <param name="headerTextKey">Example usage: '"NQoL_Animal_Color"'</param>
            <param name="topTextKey"></param>
            <param name="initialValue">Example usage: 'TechLevel_.Animal_ColorHex'</param>
            <param name="confirmAction">Example usage: 'newText => TechLevel_.Animal_ColorHex = newText'</param>
            <param name="confirmAction_2">Example usage: '() => NQualityOfLife_Mod.NQualityOfLife_Settings.Write()'</param>
            <param name="closeOnAccept">Close the window on accept (true) or keep it open (false).</param>
            <param name="windowStack">Optional, will find if null</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.AddPadding(NQualityOfLife.Geometry.Rectangle@,System.Single)">
            <summary></summary>
            <param name="rect">Input rect</param>
            <param name="padding">How much gap to add between the outer rect and the new rect</param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that is inside the input <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.IsFocus_ForKeyboardInput(UnityEngine.Rect@)">
            <summary>Is this rect the current focus for keyboard inputs?</summary>
            <param name="inputRect">The rect for the input widget</param>
            <returns><see langword="true"/> if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.MouseHover(NQualityOfLife.Geometry.Rectangle@,System.Boolean)">
            <summary>Return <see langword="true"/> when the mouse is over the given <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="debug">Enable debug draw.</param>
            <returns><see langword="true"/> if mouse is over the <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PositionForBottomRightCorner(Verse.Window)">
            <summary>Gets the position for the <paramref name="window"/> that positions it in the bottom right corner of the screen with some margin</summary>
            <param name="window"></param>
            <returns></returns><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PositionForTopLeftCorner(Verse.Window)">
            <summary>Gets the position for the <paramref name="window"/> that positions it in the top left corner of the screen with some margin</summary>
            <param name="window"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToTopLeftCorner(Verse.Window)">
            <summary>Move the <paramref name="window"/> to the top left corner of the screen</summary>
            <param name="window"></param><exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToFullScreen(Verse.Window,System.Single)">
            <summary>Set the window to full screen</summary>
            <param name="window"></param>
            <param name="border">How much gap to leave between the screen edges and the window</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.MoveToTheLeftOf(Verse.Window,Verse.Window)">
            <summary>Move the given <see cref="T:Verse.Window"/> to the left of the other <paramref name="window"/></summary>
            <param name="thisWindow"></param>
            <param name="window"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.AddPadding(UnityEngine.Rect@,System.Single)">
            <summary></summary>
            <param name="rect">Input rect</param>
            <param name="padding">How much gap to add between the outer rect and the new rect</param>
            <returns>A new Rect that is inside the input rect</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.TooltipAndHighlight(UnityEngine.Rect@,System.String,System.Boolean,System.Boolean)">
            <summary>Draw a semi transparent highlight on top of the <paramref name="rect"/> when the mouse is on top of it || and show tooltip</summary>
            <param name="rect"></param>
            <param name="tooltip"></param>
            <param name="tipIsTranslationKey"></param>
            <param name="onlyHighlightIfHasTooltip"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.TooltipAndHighlight(UnityEngine.Rect@,UnityEngine.Rect@,System.String,System.Boolean)">
            <summary>Highlight both rects when hovering over <paramref name="rect_A"/>, and draw tooltips when hovering over <paramref name="rect_A"/></summary>
            <param name="rect_A">Tooltip and highlight on hover</param><param name="rect_B">Highlight when hovering over <paramref name="rect_A"/></param><exception cref="T:System.ArgumentNullException"></exception>
            <param name="tooltip">Tooltip on hovering over <paramref name="rect_A"/></param><param name="tipIsTranslationKey">Is the tip already translated, or a translation key?</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect)">
            <summary>Draw a highlight over the <paramref name="rect"/> when the mouse is over it</summary>
            <param name="rect"></param><returns><see langword="true"/> on hover</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect,UnityEngine.Rect)">
            <inheritdoc cref="M:NQualityOfLife.Settings.Utils_.HighlightOnMouseHover(UnityEngine.Rect)"/>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.OnHover(UnityEngine.Rect@,System.Action)">
            <summary>Trigger an <see cref="T:System.Action"/> when the mouse enters the <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="action"></param>
            <returns><see langword="true"/> on hover</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.OnHover(UnityEngine.Rect@,System.Action,System.Action)">
            <summary>Trigger two <see cref="T:System.Action"/>s when the mouse enters the <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="action_A"></param><param name="action_B"></param>
            <returns><see langword="true"/> on hover</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.IndentIfNotIndented(System.String)">
            <summary>Indent the <paramref name="text"/> by 4 spaces if it is not already</summary>
            <param name="text"></param>
            <returns><paramref name="text"/> indented</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabelTranslated">Inner setting label</param><param name="innerSetting">Inner setting bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTipTranslated">Tooltip for the first inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Internal_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabelTranslated">Inner setting label</param><param name="innerSetting">Inner setting bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTipTranslated">Tooltip for the first inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting 1 label</param><param name="innerSetting1">Inner setting 1 bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param>
            <param name="innerSettingTip2">Tooltip for the second inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 3 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param><param name="innerSettingTip3">Tooltip for setting 3</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 3 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param><param name="innerSettingTip3Translated">Tooltip for setting 3</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
            <param name="innerSettingTip5">Tooltip for setting 5</param><param name="innerSettingTip6">Tooltip for setting 6</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(NQualityOfLife.Geometry.Rectangle@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5Translated">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6Translated">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param>
            <param name="innerSettingTip3Translated">Tooltip for setting 3</param><param name="innerSettingTip4Translated">Tooltip for setting 4</param>
            <param name="innerSettingTip5Translated">Tooltip for setting 5</param><param name="innerSettingTip6Translated">Tooltip for setting 6</param>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.SearchWindow">
            <summary>Pop-Up window for searching the XMLE settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.Pop">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.Pop.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.PreOpen">
            <summary>Set 'exampleStartingLevel' to the current player tech level</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.PostClose">
            <summary>Re-calculate and set the player tech level if player is in game, and write setting data to file.</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.ProfileSettingKey">
            <summary>A setting key made from a '<see cref="T:NQualityOfLife.Settings.SettingProfile"/>' and a '<see cref="T:NQualityOfLife.Settings.SettingKey"/>'</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.ProfileSettingKey.ToString">
            <summary></summary>
            <returns>"Profile.Data_Key"</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.ProfileSettingKey.TryParse(System.String,NQualityOfLife.Settings.ProfileSettingKey@)">
            <inheritdoc cref="T:NQualityOfLife.Utils.IParsable`1"/>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.ToString">
            <summary></summary>
            <returns>"Profile"</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(NQualityOfLife.Settings.SettingProfile@,NQualityOfLife.Settings.SettingProfile@)">
            <summary>Compare the internal profile strings</summary><param name="a"></param><param name="b"></param><returns><see langword="true"/> if the profile strings match / The 2 profiles are the same profile || <see langword="true"/> if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(NQualityOfLife.Settings.SettingProfile@,NQualityOfLife.Settings.SettingProfile@)">
            <summary>Compare the internal profile strings</summary><param name="a"></param><param name="b"></param><returns><see langword="false"/> if the profile strings match / The 2 profiles are the same profile || <see langword="false"/> if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(System.String,NQualityOfLife.Settings.SettingProfile@)">
            <summary>Compare the given string to the internal string of the given profile</summary><param name="a"></param><param name="b"></param><returns><see langword="true"/> if the string matches the given profile, <see langword="false"/> if they don't match || <see langword="true"/> if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(System.String,NQualityOfLife.Settings.SettingProfile@)">
            <summary>Compare the given string to the internal string of the given profile</summary><param name="a"></param><param name="b"></param><returns><see langword="false"/> if the string matches the given profile, <see langword="true"/> if they don't match || <see langword="false"/> if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(NQualityOfLife.Settings.SettingProfile@,System.String)">
            <summary>Compare the internal profile string to the given string</summary><param name="a"></param><param name="b"></param><returns><see langword="true"/> if the profile strings matches the given string / The 2 profiles are the same profile || <see langword="true"/> if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(NQualityOfLife.Settings.SettingProfile@,System.String)">
            <summary>Compare the internal profile string to the given string</summary><param name="a"></param><param name="b"></param><returns><see langword="false"/> if the profile strings matches the given string / The 2 profiles are the same profile || <see langword="false"/> if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.TryParse(System.String,NQualityOfLife.Settings.SettingProfile@)">
            <inheritdoc cref="T:NQualityOfLife.Utils.IParsable`1"/>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingKey.TryParse(System.String,NQualityOfLife.Settings.SettingKey@)">
            <inheritdoc cref="T:NQualityOfLife.Utils.IParsable`1"/>
        </member>
        <member name="T:NQualityOfLife.Settings.NQualityOfLife_Settings">
            <summary>My <see cref="T:Verse.ModSettings"/> class</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.rocketCacheHasBeenPurged">
            <summary><see langword="true"/> when the rocketman cache has been purged during this session and thus doesn't need to be again.</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.Write(System.Boolean)">
            <summary>Write the settings to file</summary>
            <param name="dontPurgeRocketCache">Set to <see langword="true"/> if purging the cache is not needed</param>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.TryPurgeRocketCache">
            <summary>Try purge the rocketman cache if rocketman loaded</summary>
            <returns><see langword="false"/> on error</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.PurgeRocketCache">
            <summary>Sets 'Gagarin.Context.IsUsingCache' to <see langword="false"/> when writing mod settings, to allow conditional xml patches to apply.</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.architectPosData">
            <summary>Key: $"{Utils.Settings.profile}.{item.defName}_Key"</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.architectColData">
            <summary>Key: $"{Utils.Settings.profile}.{item.defName}_Key"</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.mainButtonPosData">
            <summary>Keys: SettingProfileKey</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.mainButtonSizeData">
            <summary>Keys: SettingProfileKey</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalLetterFilterDefFilterData">
            <summary>Keys are formatted as Profile.defName_Key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalMessageFilterDefFilterData">
            <summary>Keys are formatted as Profile.defName_Key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalLetterFilterTextProfiles">
            <summary>Keys are the profiles, value is the text data</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalMessageFilterTextProfiles">
            <summary>Keys are the profiles, value is the text data</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.diseaseEventFilterData">
            <summary>Data keys saved in the Profile.Key_Key format</summary>
        </member>
        <member name="T:NQualityOfLife.Colors.IColorImmutableBasic">
            <summary>Represents an immutable / readonly RGBA color <see cref="T:System.Object"/></summary>
            <remarks>This <see langword="interface"/> is the most bare bones version of the <see cref="T:NQualityOfLife.Colors.IColor"/> interfaces
            <para>Implements <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutableBasic.R">
            <summary>Get the Red 'RGBA' <see cref="T:System.Byte"/> component of the color.<para>Where <see cref="F:System.Byte.MaxValue"/> (255) is as much red as possible</para> and <see cref="F:System.Byte.MinValue"/> (0) is no red at all</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutableBasic.G">
            <summary>Get the Green 'RGBA' <see cref="T:System.Byte"/> component of the color.<para>Where <see cref="F:System.Byte.MaxValue"/> (255) is as much green as possible</para> and <see cref="F:System.Byte.MinValue"/> (0) is no green at all</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutableBasic.B">
            <summary>Get the Blue 'RGBA' <see cref="T:System.Byte"/> component of the color.<para>Where <see cref="F:System.Byte.MaxValue"/> (255) is as much blue as possible</para> and <see cref="F:System.Byte.MinValue"/> (0) is no blue at all</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutableBasic.A">
            <summary>Get the A (Transparency) 'RGBA' component of the color.<para>Where <see cref="F:System.Byte.MaxValue"/> (255) is fully opaque</para> and <see cref="F:System.Byte.MinValue"/> (0) is fully transparent</summary>
        </member>
        <member name="T:NQualityOfLife.Colors.IColorImmutable">
            <summary>Represents an immutable / readonly RGBA color <see cref="T:System.Object"/></summary>
            <remarks><see cref="T:NQualityOfLife.Colors.IColorImmutable"/> expands upon <see cref="T:NQualityOfLife.Colors.IColorImmutableBasic"/>
            <para>Implements <see cref="T:NQualityOfLife.Colors.IColorImmutableBasic"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.HexCode">
            <summary>Get the hex color code (#AA4435FF) where the values are ordered #RR,GG,BB,AA</summary>
            <returns>a <see cref="T:System.String"/> hex code formatted as: "#RRGGBBFF" or possibly "#RRGGBB" if there is no alpha component</returns>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.AsRGBA">
            <summary>Get the color as 'RGBA'</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.AsRGB">
            <summary>Get the color as 'RGB'</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.UnityColor">
            <summary>Get the color as 'UnityEngine.Color'</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.AsColorRef">
            <summary></summary>
            <returns><see langword="this"/> <see cref="T:NQualityOfLife.Colors.IColorImmutable"/> as a <see cref="T:NQualityOfLife.Colors.COLORREF"/> <see langword="struct"/></returns>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.HexColor">
            <summary></summary>
            <returns><see langword="this"/> <see cref="T:NQualityOfLife.Colors.IColorImmutable"/> as a <see cref="T:NQualityOfLife.Colors.Hex"/> <see langword="struct"/></returns>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.RGBColor">
            <summary></summary>
            <returns><see langword="this"/> <see cref="T:NQualityOfLife.Colors.IColorImmutable"/> as a <see cref="T:NQualityOfLife.Colors.RGB"/> <see langword="struct"/></returns>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.RGBAColor">
            <summary></summary>
            <returns><see langword="this"/> <see cref="T:NQualityOfLife.Colors.IColorImmutable"/> as a <see cref="T:NQualityOfLife.Colors.RGBA"/> <see langword="struct"/></returns>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.ToColorTag">
            <summary>Get the &lt;color&gt; tag</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorImmutable.IsInvalid">
            <summary></summary>
            <returns><see langword="true"/> if the <see cref="T:NQualityOfLife.Colors.IColorImmutable"/> is set to an invalid value</returns>
        </member>
        <member name="M:NQualityOfLife.Colors.IColorImmutable.Deconstruct(System.Byte@,System.Byte@,System.Byte@)">
            <summary>Deconstruct the <see cref="T:NQualityOfLife.Colors.IColorImmutable"/> into RGB <see cref="T:System.Byte"/> components</summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
        </member>
        <member name="M:NQualityOfLife.Colors.IColorImmutable.Deconstruct(System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <summary>Deconstruct the <see cref="T:NQualityOfLife.Colors.IColorImmutable"/> into RGBA <see cref="T:System.Byte"/> components</summary>
            <remarks>If the color member has no transparency components <paramref name="a"/> should be set to <see cref="F:System.Byte.MaxValue"/></remarks>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
        </member>
        <member name="T:NQualityOfLife.Colors.IColor">
            <summary>Represents a RGB color <see cref="T:System.Object"/> that can be modified</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Colors.IColorImmutable"/> &lt;- <see cref="T:NQualityOfLife.Colors.IColorImmutableBasic"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.R">
            <summary>Set or get the Red 'RGBA' <see cref="T:System.Byte"/> component</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.G">
            <summary>Set or get the Green 'RGBA' <see cref="T:System.Byte"/> component</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.B">
            <summary>Set or get the Blue 'RGBA' <see cref="T:System.Byte"/> component</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.HexCode">
            <summary>Get or set the hex color code (#AA4435FF) where the values are ordered #RR,GG,BB,AA</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.AsRGBA">
            <summary>Get or set the color as 'RGBA' <see cref="T:System.Byte"/>s</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.AsRGB">
            <summary>Get or set the color as 'RGB' <see cref="T:System.Byte"/>s</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.HexColor">
            <inheritdoc cref="P:NQualityOfLife.Colors.IColorImmutable.HexColor"/>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.RGBColor">
            <inheritdoc cref="P:NQualityOfLife.Colors.IColorImmutable.RGBColor"/>
        </member>
        <member name="P:NQualityOfLife.Colors.IColor.RGBAColor">
            <inheritdoc cref="P:NQualityOfLife.Colors.IColorImmutable.RGBAColor"/>
        </member>
        <member name="T:NQualityOfLife.Colors.IColorRGBA">
            <summary>Represents a RGBA color <see cref="T:System.Object"/> that can be modified</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Colors.IColor"/> &lt;- <see cref="T:NQualityOfLife.Colors.IColorImmutable"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorRGBA.A">
            <summary><see langword="set"/> or <see langword="get"/> the A (Transparency) 'RGBA' <see cref="T:System.Byte"/> component - || 255 is max opacity, 0 is fully transparent</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorRGBA.AsRGBA">
            <summary>Get or set the color as 'RGBA'</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorRGBA.IsInvalid">
            <inheritdoc cref="P:NQualityOfLife.Colors.IColorImmutable.IsInvalid"/>
        </member>
        <member name="P:NQualityOfLife.Colors.IColorRGBA.FullyTransparent">
            <summary></summary>
            <returns><see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Colors.IColorRGBA"/> is fully transparent (<see cref="P:NQualityOfLife.Colors.IColorRGBA.A"/> == 0)</returns>
        </member>
        <member name="T:NQualityOfLife.Colors.COLORREF">
            <summary></summary>
            <remarks><see href="https://learn.microsoft.com/en-us/windows/win32/gdi/colorref">See documentation</see></remarks>
        </member>
        <member name="P:NQualityOfLife.Colors.COLORREF.IsInvalid">
            <summary><see langword="true"/> if the high-order <see cref="T:System.Byte"/> is non-zero (invalid COLORREF).</summary>
        </member>
        <member name="T:NQualityOfLife.Colors.Hex">
            <summary>Represents a hex color code such as #FF2277FF where the last two characters represent the <see cref="P:NQualityOfLife.Colors.IColorRGBA.A"/> value</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.NewRandom">
            <inheritdoc cref="P:NQualityOfLife.Colors.Hex.GetRandom"/>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.White">
            <summary>Pure white</summary>
            <remarks>FFFFFFFF</remarks>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.Black">
            <summary>Pure black</summary>
            <remarks>#000000FF</remarks>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.Red">
            <summary>Pure red</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.Green">
            <summary>Pure green</summary>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.Blue">
            <summary>Pure blue</summary>
        </member>
        <member name="F:NQualityOfLife.Colors.Hex._hex">
            <inheritdoc cref="T:NQualityOfLife.Colors.Hex"/>
        </member>
        <member name="M:NQualityOfLife.Colors.Hex.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <inheritdoc cref="T:NQualityOfLife.Colors.Hex"/>
        </member>
        <member name="M:NQualityOfLife.Colors.Hex.#ctor(System.Byte,System.Byte,System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Colors.Hex.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Colors.Hex.#ctor(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Colors.Hex.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Colors.Hex.#ctor(System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.HexCodeToRGBA(System.String)"/>
            <summary></summary>
            <param name="hexCode"></param>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.AsRGBA">
            <summary>Convert a hex color code such as #FF15ABFF into its RGBA components. If the hex code doesn't have an alpha component like in '#FF15AB', it will be returned as 255. - The input hex code can start with or without '#'</summary>
            <returns>If input is null or empty => (0, 0, 0, 255)</returns>
        </member>
        <member name="P:NQualityOfLife.Colors.Hex.AsRGB">
            <summary>Convert a hex color code such as #FF15AB into its RGB components. If the hex code has an alpha component like in '#FF00AAF6', it will be ignored</summary>
            <returns> If input is null or empty => (0, 0, 0)</returns>
        </member>
        <member name="T:NQualityOfLife.Colors.RGBA">
            <summary>Represents RGBA color values</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Colors.IColorRGBA"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Colors.RGB">
            <summary>Represents a RGB color with no alpha channel</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Colors.IColor"/>
            <para>For a color struct with an alpha channel, see: '<see cref="T:NQualityOfLife.Colors.RGBA"/>'</para></remarks>
        </member>
        <member name="M:NQualityOfLife.Colors.RGB.#ctor(NQualityOfLife.Colors.Hex@)">
            <summary></summary>
            <param name="copyFromHexColor"></param>
            <remarks>The <see cref="P:NQualityOfLife.Colors.Hex.A"/> is discarded!</remarks>
        </member>
        <member name="T:NQualityOfLife.World.FactionRelationUtility">
            <summary>Utilities for adjusting faction relations</summary>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.FlagsAreSet(NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers,NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.AnyFlagIsSet(NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers,NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.FlagsAreSet(NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes,NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.AnyFlagIsSet(NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes,NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.ChangeGoodwill(RimWorld.Faction,RimWorld.Faction,System.Int32,System.String,System.Boolean)">
            <summary>Change the goodwill between two faction by a given value</summary>
            <param name="faction">faction 1</param>
            <param name="other">faction 2</param>
            <param name="goodwillChange">how much to change the goodwill by</param>
            <param name="translatedReasonString">The reason for the goowill change</param>
            <param name="sendLetter"></param>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.CalculateFactionExpansionDesire(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>Calculate a faction's desire to expand it's settlement count</summary>
            <param name="faction">The faction who's expansion desire we are calculating</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns>float in a range of 0f-1f</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.CalculateTruceDesire(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>Calculate a faction's general desire to make peace with other factions</summary>
            <param name="faction">The faction who's truce desire we are calculating</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns>float in a range of 0f-1f</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="faction"/>, <paramref name="strongest"/> or <paramref name="weakest"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.DeclareWarOn(RimWorld.Faction,RimWorld.Faction,System.String,RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param>
            <param name="otherFaction"></param>
            <param name="reason"></param>
            <param name="joiningWarToHelpAlly"></param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="faction"/> or <paramref name="otherFaction"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.TryDeclareWarOnAnyFaction(RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="faction"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.Enemies(RimWorld.Faction)">
            <summary>Get all hostiles factions to the given <paramref name="faction"/></summary>
            <param name="faction"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.Allies(RimWorld.Faction)">
            <summary>Get all the allies of the given <paramref name="faction"/></summary>
            <param name="faction"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.AttemptATruceWithAllHostileFactions(RimWorld.Faction)">
            <summary>The given <paramref name="faction"/> will attempt to truce with all other factions, based on truce desire and other factors</summary>
            <param name="faction">The faction who's attempting truce</param>
            <returns><see langword="true"/> if truce is agreed upon</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="faction"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.ConditionalSurrender(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>The given faction will attempt to surrender to other factions</summary>
            <param name="surrenderingFaction">The faction who's trying to surrender</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns><see langword="true"/> if the given faction's surrender is accepted</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers.ImmuneToPollution">
            <summary>The <see cref="T:RimWorld.Faction"/> is immune to pollution</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers.WillNeverIntegratePopulation">
            <summary>Popuation of captured settlements will not join the faction</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers.CannotBeOccupied">
            <summary>Settlements of this faction cannot be occupied by other factions</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers.PopulationCannotIntegrate">
            <summary>The population of settlements owned by this faction cannot join the faction of an attacker</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers.CanTransferResources">
            <summary>This faction can transfer resources from settlements to others</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers.CanTransferPopulation">
            <summary>This faction can transfer population from settlements to others</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.SpecialFactionModifiers.CanBuildNewSettlements">
            <summary>This faction can create new settlements on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes.Annex">
            <summary>The target settlement becomes fully owned and controlled by the attacker</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes.Occupy">
            <summary>Occupy the settlement rather than fully annexing</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes.Destroy">
            <summary>The target settlement can be completely destroyed</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes.Raid">
            <summary>Raid the settlement for resources</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes.Skirmish">
            <summary>Undefined</summary>
        </member>
        <member name="F:NQualityOfLife.World.FactionExtensions.AllowedBattleOutcomes.Liberate">
            <summary>An occupied/annexed settlement is returned to the original owner</summary>
        </member>
        <member name="P:NQualityOfLife.World.FactionExtensions.MaxSettlementsAdjusted">
            <summary><see cref="F:NQualityOfLife.World.FactionExtensions.maxSettlements"/> adjusted by <see cref="P:RimWorld.Planet.World.PlanetCoverage"/></summary>
        </member>
        <member name="M:NQualityOfLife.World.PlayerLegacyTracker.RecordNewEvent(RimWorld.TaleDef,Verse.Pawn,Verse.ResearchProjectDef,RimWorld.TechLevel)">
            <summary></summary>
            <param name="taleDef"></param>
            <param name="pawn"></param>
            <param name="researchProject"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:NQualityOfLife.World.PlayerLegacyTracker.RecordNewEvent(RimWorld.TaleDef,Verse.Pawn,Verse.ResearchProjectDef)">
            <summary></summary>
            <param name="taleDef"></param>
            <param name="pawn"></param>
            <param name="researchProject"></param>
        </member>
        <member name="F:NQualityOfLife.World.LegacyEventData.renoun">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.World.LegacyEventData.infamy">
            <summary></summary>
        </member>
        <member name="M:NQualityOfLife.World.GoodWillUtility.RelevantEvents(RimWorld.Faction,System.Boolean)">
            <summary></summary>
            <param name="faction"></param>
            <param name="onlySpecificToThisFaction">Ignore events that affect all factions?</param>
            <returns></returns>
        </member>
        <member name="F:NQualityOfLife.World.Utils_.Tile_.TileCount">
            <summary>The total number of tiles on the planet map</summary>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.DistanceTo(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldObject,RimWorld.Planet.WorldGrid,System.UInt16)">
            <summary></summary>
            <param name="myLocation"></param><param name="destination"></param>
            <param name="worldGrid"></param><param name="maxDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.DistanceTo(RimWorld.Planet.PlanetTile@,System.Int32,RimWorld.Planet.WorldGrid,System.UInt16)">
            <summary></summary>
            <param name="myLocation"></param><param name="destination"></param>
            <param name="worldGrid"></param><param name="maxDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(System.Int32,RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid)">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(RimWorld.Planet.PlanetTile@,RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid)"/>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(RimWorld.Planet.PlanetTile@,RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid)">
            <summary>Get the tile neighbouring this tile in the direction of the other tile</summary>
            <param name="rootTile"></param>
            <param name="otherTile"></param>
            <param name="worldGrid"></param>
            <returns>The tile id of the Neighbouring tile || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(System.Int32,RimWorld.Direction8Way,RimWorld.Planet.WorldGrid)">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(RimWorld.Planet.PlanetTile@,RimWorld.Direction8Way,RimWorld.Planet.WorldGrid)"/>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(RimWorld.Planet.PlanetTile@,RimWorld.Direction8Way,RimWorld.Planet.WorldGrid)">
            <summary>Get the tile neighbouring this tile in the given direction</summary>
            <param name="rootTile"></param>
            <param name="direction"></param>
            <param name="worldGrid"></param>
            <returns>The tile id of the Neighbouring tile in the given direction || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.IsConnectedByRoad(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldObject,System.Collections.Generic.List{System.ValueTuple{System.Int32,System.Collections.Generic.List{RimWorld.Planet.SurfaceTile.RoadLink}}},System.ValueTuple{System.Int32,System.Int32}@,System.ValueTuple{NQualityOfLife.World.FactionExtensions.RoadLevel,System.Int32,System.Int32}@,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="worldObject"></param>
            <param name="other"></param>
            <param name="roadTilesOut"></param>
            <param name="roadHasBreakBetweenTiles">will always be (-1, -1) if road is not connected at all or doesn't have gaps</param>
            <param name="bottleNeck"></param>
            <param name="worldGrid"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.ClosestTileWithRoad(System.Int32,System.Int32@,System.Collections.Generic.ICollection{System.Int32})">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.ClosestTileWithRoad(RimWorld.Planet.PlanetTile,System.Int32@,System.Collections.Generic.ICollection{System.Int32})"/>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.ClosestTileWithRoad(RimWorld.Planet.PlanetTile,System.Int32@,System.Collections.Generic.ICollection{System.Int32})">
            <summary></summary>
            <param name="rootTile"></param>
            <param name="distanceToTile"></param>
            <param name="excludeTiles"></param>
            <returns>-1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.HasRoad(RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid)">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.HasRoad(RimWorld.Planet.Tile)"/>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.HasRoad(RimWorld.Planet.Tile)">
            <summary></summary><param name="tile"></param>
            <returns><see langword="true"/> if the given <paramref name="tile"/> has any roads on it</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="tile"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(System.Int32,RimWorld.Planet.WorldGrid,System.Int32,Verse.WorldFloodFiller)">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid,System.Int32,Verse.WorldFloodFiller)"/>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldGrid,System.Int32,Verse.WorldFloodFiller)">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid,System.Int32,Verse.WorldFloodFiller)"/>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid,System.Int32,Verse.WorldFloodFiller)">
            <summary></summary>
            <param name="tile"></param>
            <param name="worldGrid"></param>
            <param name="radius"></param>
            <param name="overrideFloodFiller"></param>
            <returns>1f - ?f</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.GetCloseTileToSettle(System.Int32,System.Int16@,RimWorld.Planet.WorldGrid,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.GetCloseTileToSettle(RimWorld.Planet.PlanetTile,System.Int16@,RimWorld.Planet.WorldGrid,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Boolean,System.Int32,System.Int32)"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.GetCloseTileToSettle(RimWorld.Planet.PlanetTile,System.Int16@,RimWorld.Planet.WorldGrid,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Boolean,System.Int32,System.Int32)">
            <summary></summary>
            <param name="rootTileId"></param>
            <param name="distanceToTile"></param>
            <param name="worldGrid"></param>
            <param name="forFaction"></param>
            <param name="forFactionFactionExtensions"></param>
            <param name="distanceReducesDesirability"></param>
            <param name="minDistanceBetweenSettlements"></param>
            <param name="maxDistanceApprox"></param>
            <returns>-1 if none found</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileSettleDesirability(RimWorld.Planet.PlanetTile@,NQualityOfLife.Types.Factor,System.Collections.Generic.HashSet{System.Int32},RimWorld.Planet.WorldGrid,RimWorld.Planet.SurfaceTile,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Int32)">
            <summary></summary>
            <param name="tileId"></param>
            <param name="minimumScore">Return zero early and skip expensive checks if we know the score is not what we want</param>
            <param name="allOccupiedTiles"></param>
            <param name="worldGrid"></param>
            <param name="tile"></param>
            <param name="forFaction"></param>
            <param name="forFactionFactionExtensions"></param>
            <param name="minDistanceBetweenSettlements"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.MakeWarTorn(RimWorld.Planet.Tile,RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid)">
            <summary>Try making the tile war torn</summary>
            <param name="tile"></param><param name="tileId"></param>
            <param name="worldGrid"></param>
            <returns>True if was made war torn, false if was already war torn.</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TryMakeUrban(RimWorld.Planet.Tile,RimWorld.Planet.PlanetTile@,System.Int32@,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="tile"></param>
            <param name="tileId"></param>
            <param name="buildCost"></param>
            <param name="worldGrid"></param>
            <returns>True if the tile was changed to urban || False if was already urban or cannot make urban</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileFertilityFactor(System.Int32,RimWorld.Planet.WorldGrid)">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.TileFertilityFactor(RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid)"/>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileFertilityFactor(RimWorld.Planet.PlanetTile@,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="tile"></param>
            <param name="worldGrid"></param>
            <returns>0f - ?f (-1f on error)</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileFertilityFactor(RimWorld.Planet.Tile,RimWorld.Planet.PlanetTile@)">
            <summary></summary>
            <param name="tile"></param>
            <param name="tileId"></param>
            <returns>0f - ?f (-1f on error)</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.CanDevelopTile(System.Int32,RimWorld.Planet.WorldGrid)">
            <inheritdoc cref="M:NQualityOfLife.World.Utils_.Tile_.CanDevelopTile(RimWorld.Planet.Tile,RimWorld.Planet.WorldGrid,RimWorld.BiomeDef)"/>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.CanDevelopTile(RimWorld.Planet.Tile,RimWorld.Planet.WorldGrid,RimWorld.BiomeDef)">
            <summary></summary>
            <param name="tile"></param>
            <param name="worldGrid"></param>
            <param name="toBuild"></param>
            <returns><see langword="true"/> if the given <see cref="T:RimWorld.Planet.Tile"/> can be developed</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="tile"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.World.RoadDefOf">
            <summary>Core game <see cref="T:RimWorld.RoadDef"/>s</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.baseGrowthRate">
            <summary>Base value for calculating population growth</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToSettleBaseValue">
            <summary>The base resource cost to build a new settlement on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToAttack">
            <summary>The base resource cost to perform an attack another settlement on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.raidCostToRewardMult">
            <summary>A successful raid will result in the attacker stealing <see cref="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToAttack"/> * <see cref="F:NQualityOfLife.World.NQoL_World_Object_Comp.raidCostToRewardMult"/></summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToDevelopFarmLand">
            <summary>The base resource cost to develop a tile into farmland</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToBuildRoad">
            <summary>The base resource cost to build or upgrade a road on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToDevelopUrban">
            <summary>The base resource cost to develop a tile into urban</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.closeSettlementsMax">
            <summary>The maximum amount of close-by settlements to save for fast lookup</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.minimumPopulationToAttack">
            <summary>The minimum population required to be able to perform an attack on another settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.tickInterval">
            <summary>The base tick interval of this comp</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.tickInterval_Population">
            <summary>The base population growth tick interval</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._originalOwner">
            <summary>The original owner / creator <see cref="T:RimWorld.Faction"/> of <see langword="this"/> settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._originalName">
            <summary>Get the original name of <see langword="this"/> settlement
            <para>'<see cref="P:RimWorld.Planet.Settlement.Name"/>' is the current name, and can be the same as the '<see cref="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginalName"/>' if the settlement has never been captured / the name was kept after capture</para></summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._myFaction">
            <inheritdoc cref="P:NQualityOfLife.World.NQoL_World_Object_Comp.Faction"/>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.population">
            <summary>The current population of the settlement, cannot be negative
            <para>This is a floating point value</para></summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.localTilePopulationCapCached">
            <summary>The maximum population that this settlement can currently hold</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.populationDensityRatio">
            <summary>1f means there is no more room for the population to grow, 0f means there are no people</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.localFertilityCached">
            <summary>Should be 0~1 - Can go above 1</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.attackDesire">
            <summary>The momentary desire to attack near by hostile bases.</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._originallyFoundedYear">
            <summary>The game year that this base was created - Bases that existed at the game start get a random year before the game start date</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._failedToFindEnemyInARowCounter">
            <summary>How many times this base has tried to attack a near by settlement but found nothing to attack - also known as the peace score</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._iAmIsolated">
            <summary>If this settlement is isolated from other settlements - This is used to stop isolated bases from ticking in some cases</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._canAttackEver">
            <summary>Can this settlement ever attack anyone</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._canAttackNow">
            <summary>If this settlement can attack another settlement at this moment</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp._canBeAttacked">
            <summary>Are other settlements allowed to attack this settlement?</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginalOwner">
            <inheritdoc cref="F:NQualityOfLife.World.NQoL_World_Object_Comp._originalOwner"/>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginalName">
            <inheritdoc cref="F:NQualityOfLife.World.NQoL_World_Object_Comp._originalName"/>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.Faction">
            <summary>The current owner <see cref="T:RimWorld.Faction"/> of <see langword="this"/> settlement</summary>
            <remarks>Setting this property will also call <see cref="M:RimWorld.Planet.WorldObject.SetFaction(RimWorld.Faction)"/></remarks>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginallyFoundedYear">
            <summary>Get the game year that <see langword="this"/> base was created - Bases that existed at the game start get a random year before the game start date</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.FailedToFindEnemyInARowCounter">
            <summary>Get how many times <see langword="this"/> base has tried to attack a near by settlement but found nothing to attack - also known as the peace score</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.Isolated">
            <summary>Get if <see langword="this"/> settlement is isolated from other settlements - This is used to stop isolated bases from ticking in some cases</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanBeAttacked">
            <summary>Are other settlements allowed to attack <see langword="this"/> settlement?</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanAttackEver">
            <summary>Can <see langword="this"/> settlement ever attack anyone</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanAttackNow">
            <summary>Get if <see langword="this"/> settlement can attack another settlement at this moment</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.PostMapGenerate">
            <summary>Triggers when a local map is generated - We disable attacking to prevent strange issues while the player is visiting the map</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.PostMyMapRemoved">
            <summary>Triggers when a local map is deleted - We restore the settings when the player leaves</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.AttackDesire">
            <summary>Calculate the momentary desire for this settlement to attack nearby hostile settlements</summary>
            <returns>attackDesire</returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.GetPopulationCapForTile(System.Int32,NQualityOfLife.Types.Factor,NQualityOfLife.Types.Factor,RimWorld.Planet.Tile,System.Int32)">
            <summary></summary>
            <param name="tileId"></param>
            <param name="populationSoftCap"></param>
            <param name="hardCap"></param>
            <param name="tile"></param>
            <param name="radius">At what radius do we take tiles into account</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.UpdateLocalExpansionDesire">
            <summary>Update the value of 'localExpansionDesireCached'</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.UpdateCachedFertility">
            <summary>Update the value of '<see cref="F:NQualityOfLife.World.NQoL_World_Object_Comp.localFertilityCached"/>'</summary>
            <returns>the new value of '<see cref="F:NQualityOfLife.World.NQoL_World_Object_Comp.localFertilityCached"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.TryTransferStuff(NQualityOfLife.World.NQoL_World_Object_Comp,NQualityOfLife.World.NQoL_World_Object_Comp,RimWorld.Faction,RimWorld.Faction)">
            <summary>Try to trade resources or population between friendly faction bases</summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="fromFaction"></param>
            <param name="toFaction"></param>
            <returns><see langword="true"/> if successfully transferred something</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.TryTransferPopulation(NQualityOfLife.World.NQoL_World_Object_Comp,NQualityOfLife.World.NQoL_World_Object_Comp,RimWorld.Faction,RimWorld.Faction,NQualityOfLife.World.FactionExtensions.RoadLevel)">
            <summary></summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="fromFaction"></param>
            <param name="toFaction"></param>
            <param name="roadLevel"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.TryTransferResources(NQualityOfLife.World.NQoL_World_Object_Comp,NQualityOfLife.World.NQoL_World_Object_Comp,RimWorld.Faction,RimWorld.Faction,NQualityOfLife.World.FactionExtensions.RoadLevel)">
            <summary></summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="fromFaction"></param>
            <param name="toFaction"></param>
            <param name="roadLevel"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.ChooseTargetFromList(RimWorld.Planet.Settlement@,System.Boolean)">
            <summary></summary>
            <param name="targetSettlement"></param>
            <param name="allowFriendliesInList"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:NQualityOfLife.Exceptions.InternalDataException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.TryDevelopUrban(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@,System.Boolean)">
            <summary></summary>
            <param name="oldPopCap"></param>
            <param name="newPopCap"></param>
            <param name="getAccurateOld">Refresh the old cached value before changing the biomes to ensure that the given <paramref name="oldPopCap"/> is accurate</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.TryDevelopFarms(NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="oldFertility"></param>
            <param name="newFertility"></param>
            <param name="getAccurateOld">Refresh the old cached value before changing the biomes to ensure that the given <paramref name="oldFertility"/> is accurate</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.SettleAtTile(NQualityOfLife.World.NQoL_World_Object_Comp,System.Int32,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Int16)">
            <summary></summary>
            <param name="originBaseComp"></param>
            <param name="tileId"></param>
            <param name="ourFaction"></param>
            <param name="ourFactionExtensions"></param>
            <param name="distanceToNewSettlement"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.DestroySettlement(RimWorld.Planet.WorldObject,NQualityOfLife.World.NQoL_World_Object_Comp,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,NQualityOfLife.World.FactionExtensions)">
            <summary></summary>
            <param name="targetSettlement"></param>
            <param name="targetSettlementComp"></param>
            <param name="theirFaction"></param>
            <param name="ourFactionExtensions"></param>
            <param name="theirFactionExtensions"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"><paramref name="targetSettlement"/> is already <see cref="P:RimWorld.Planet.WorldObject.Destroyed"/></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.DoBattleSim(NQualityOfLife.Types.Factor@,RimWorld.TechLevel,NQualityOfLife.Types.Factor@,NQualityOfLife.World.NQoL_World_Object_Comp.BattleGoal@,NQualityOfLife.Types.Factor@,RimWorld.TechLevel,NQualityOfLife.Types.Factor@,RimWorld.Planet.Hilliness,NQualityOfLife.Types.Ratio@,RimWorld.Faction,RimWorld.Faction,RimWorld.BiomeDef,NQualityOfLife.World.NQoL_World_Object_Comp)">
            <summary></summary>
            <param name="attackers"></param>
            <param name="attackerTechLevel"></param>
            <param name="attackerCasualties"></param>
            <param name="battleGoal"></param>
            <param name="defenders"></param>
            <param name="defenderTechLevel"></param>
            <param name="defenderCasualties"></param>
            <param name="hilliness"></param>
            <param name="attackSuccessChance"></param>
            <param name="attackerFaction"></param>
            <param name="defenderFaction"></param>
            <param name="biome">The biome where the battle takes place</param>
            <param name="defenderComp"></param>
            <returns><see langword="true"/> if attackers won the battle</returns>
        </member>
        <member name="T:NQualityOfLife.World.NQoL_WorldComp">
            <summary>The world comp for managing faction relations on a given world</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_WorldComp.enabled">
            <summary>Is the world interaction system enabled?</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_WorldComp.strongestFaction">
            <summary>Is the world project stuff enabled?</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_WorldComp.WorldComponentUpdate">
            <summary>Handles all updates / GUI methods</summary>
        </member>
        <member name="T:NQualityOfLife.World.NQoL_Faction_Population_Display_Patch_2">
            <summary>Extends the alternating grey box/line to match the extended height of the interact areas etc</summary>
        </member>
        <member name="M:NQualityOfLife.World.Get_.GetSettlementCountAndTotalPopulation(RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.Get_.GetTotalFactionPop(RimWorld.Faction,RimWorld.TechLevel)">
            <summary></summary>
            <param name="faction"></param>
            <param name="techLevel"></param>
            <returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.InternalDataException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.Get_.StrongestAndWeakestFaction">
            <summary></summary>
            <returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.InternalDataException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.Get_.SettlementCount(RimWorld.Faction)">
            <summary>Get the count of the settlements of the given <paramref name="faction"/></summary>
            <param name="faction"></param>
            <returns></returns>
            <exception cref="T:NQualityOfLife.Exceptions.InternalDataException"></exception>
        </member>
        <member name="M:NQualityOfLife.World.Sites.Get_.IsValidTarget(RimWorld.Planet.Settlement,System.Int32,RimWorld.Faction,RimWorld.Planet.Settlement,RimWorld.Planet.Settlement@,System.Boolean,RimWorld.Planet.WorldObjectsHolder)">
            <summary></summary>
            <param name="targetSettlement"></param>
            <param name="targetTile"></param>
            <param name="attackerFaction"></param>
            <param name="attackingSettlement"></param>
            <param name="validatedTarget"></param>
            <param name="recursion"></param>
            <param name="objectsHolder"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Medical.Hediffs.HediffGiverDormantDisease">
            <summary>Will randomly give the specified <see cref="T:Verse.HediffDef"/> to the <see cref="T:Verse.Pawn"/><para>The <see cref="T:Verse.Hediff"/> must be of the <see cref="T:System.Type"/> <see cref="T:NQualityOfLife.Medical.Hediffs.DormantDisease"/></para></summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.PreCachedMedicalMasks.preCachedApparelThatHelpsGermResistance">
            <summary>This is used for the disease spread message, it does not contain all germ resistant apparel. Helmets are excluded for example.</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.PreCachedMedicalMasks.preCachedMedicalMasks">
            <summary>Contains specifically medical apparel, such as the surgical mask from vanilla expanded. This list is used for extra buffs in calculations.</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.GermMaker.diseaseSpreadEnabled">
            <summary>Is the disease spread system enabled?</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.GermMaker.difficultyRatio">
            <summary>Affects base infection chance</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.GermMaker.MakeOrGetGermForDisease(Verse.HediffDef,System.Boolean@)">
            <summary>Create a filth germ def for the disease, or get a manually defined def</summary>
            <param name="hediffDef"></param>
            <param name="gotExisting"></param>
            <returns><see cref="T:Verse.ThingDef"/> of the germs associated with the <paramref name="hediffDef"/> || <see langword="null"/> only if there was an error</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.TryMakeFilth_Fast(Verse.ThingDef,Verse.IntVec3,Verse.Map,System.Int32,System.UInt16,System.String,Verse.Thing)">
            <summary></summary>
            <param name="filthDef"></param>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="amount"></param>
            <param name="attempts"></param>
            <param name="source"></param>
            <param name="sourceThing"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.PawnCanSpreadAnyDiseaseNow(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> can spread disease, <see langword="false"/> if cant</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.PawnCanSpreadDisease(Verse.Pawn,Verse.Hediff)">
            <summary>Checks if the given pawn can spread germs from the specified disease instance.</summary>
            <param name="pawn"></param>
            <param name="myDisease">The infectious disease the pawn has</param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> can spread the disease, <see langword="false"/> if cant</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.TryGetInfectiousDisease(Verse.Pawn,Verse.ThingDef@)">
            <summary>Gets the first found infectious disease if it exists</summary>
            <param name="pawn">Pawn to check</param>
            <param name="filthDef">The ThingDef Filth that is the germs dropped by the disease, <see langword="null"/> if no disease found</param>
            <returns>The first Hediff or <see langword="null"/> if no disease found.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.IsInfectiousDisease(Verse.HediffDef,Verse.ThingDef@)">
            <summary>Is the given hediff an infectious disease for the purposes of the disease spread system, or other integrated systems.</summary>
            <param name="hediffDef">Is this hediff an infectious disease?</param>
            <param name="filthDef">The Filth (ThingDef) that corresponds to this disease.</param>
            <returns><see langword="true"/> if hediff is an infectious disease. else <see langword="false"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.IsCarryingGerms(Verse.Pawn,Verse.HediffDef@,RimWorld.Filth@)">
            <summary>Returns <see langword="true"/> if the given <paramref name="pawn"/> is carrying (has Filth attached to them) that corresponds to an infectious disease.</summary>
            <param name="pawn">Check this pawn for germs.</param>
            <param name="disease">The disease of the germs that are found, or <see langword="null"/> if no germs are found.</param>
            <param name="germFilth"></param>
            <returns>Returns <see langword="true"/> if the given <paramref name="pawn"/> is carrying germs</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.ShouldInfectPawnWith(Verse.Pawn,Verse.HediffDef,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Percentage@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@,System.Collections.Generic.List{RimWorld.Trait}@,System.Single)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="disease"></param>
            <param name="generalResistance"></param>
            <param name="immunityToThis"></param>
            <param name="negativeModifiers"></param>
            <param name="affectingTraits">A list of traits that contributed to the final chance, or empty list if there were none.</param>
            <param name="baseInfectionChance"></param>
            <param name="positiveModifiers"></param>
            <returns>True if the pawn should be infected with the specified disease.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.InfectionResistCoinFlipWithModifiers(Verse.Pawn,System.Single,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.Factor@,System.Collections.Generic.List{RimWorld.Trait}@)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="baseChance">Base chance that is then modified by traits etc.</param>
            <param name="positiveModifiers"></param>
            <param name="negativeModifiers"></param>
            <param name="affectingTraits">A list of traits that contributed to the calculation. or empty list if none.</param>
            <returns>True if the pawn resisted the infection attempt, else false.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.GetNegativeModifiers(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>a positive float of the negative modifiers for germ resistance for the given pawn.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.GetPositiveModifiers(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>a positive float of the modifiers for germ resistance for the given pawn.</returns>*
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.GetClothingGermResistance(Verse.ThingDef,Verse.BodyDef,System.Boolean)">
            <summary></summary>
            <param name="apparel"></param>
            <param name="raceBody"></param>
            <param name="useToxResistStat"></param>
            <returns>float value in the 0.0f - 1.0f range</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.GetClothingGermResistance(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.DiseaseSpreadUtils.ImmunityToDisease(Verse.Pawn,Verse.HediffDef)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="disease"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> or <paramref name="disease"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Medical.Hediffs.More_VanillaHediffDefOf">
            <summary>Vanilla hediff defs</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.Hediffs.NQoL_CompEggLayer.GestationDaysEach_Compatibility_Patch">
            <summary>Makes the method recognize sub classes of <see cref="T:RimWorld.CompEggLayer"/></summary>
        </member>
        <member name="T:NQualityOfLife.Medical.Hediffs.NQoL_CompEggLayer.GestationDaysLitter_Compatibility_Patch">
            <summary>Makes the method recognize sub classes of <see cref="T:RimWorld.CompEggLayer"/></summary>
        </member>
        <member name="T:NQualityOfLife.Medical.Hediffs.NQoL_CompEggLayer.LitterSizeAverage_Compatibility_Patch">
            <summary>Makes the method recognize sub classes of <see cref="T:RimWorld.CompEggLayer"/></summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.NQoL_CompEggLayer.erroredGlobal">
            <summary>This will be set to <see langword="true"/> if the static constructor fails to get the method and field delegates</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.NQoL_CompEggLayer.activeDelegate">
            <summary>Delegate to the 'Active' property in the base <see cref="T:RimWorld.CompEggLayer"/> comp</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.NQoL_CompEggLayer.unfertilizedDelegate">
            <summary>Delegate to the 'ProgressStoppedBecauseUnfertilized' property in the base <see cref="T:RimWorld.CompEggLayer"/> comp</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.NQoL_CompEggLayer.eggProgressFieldRef">
            <summary><see cref="T:HarmonyLib.AccessTools.FieldRef`2"/> to the 'eggProgress' field in the base <see cref="T:RimWorld.CompEggLayer"/> comp</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediffs.NQoL_CompEggLayer.fertilizationCountFieldRef">
            <summary><see cref="T:HarmonyLib.AccessTools.FieldRef`2"/> to the 'fertilizationCount' field in the base <see cref="T:RimWorld.CompEggLayer"/> comp</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.Hediffs.MoreVanillaXenotypeDefOf">
            <summary>Vanilla <see cref="T:RimWorld.XenotypeDef"/>s</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediffs.NQoL_Hediff_Pregnant.IsVanillaXenotype(RimWorld.XenotypeDef)">
            <summary></summary>
            <param name="xenotypeDef"></param>
            <returns><see langword="true"/> if the <paramref name="xenotypeDef"/> is any of the base game xenotypes, including baseliner || returns <see langword="false"/> if the <paramref name="xenotypeDef"/> is <see langword="null"/></returns>
        </member>
        <member name="T:NQualityOfLife.Medical.NewBedColorsPatch">
            <summary>Adds new colors for quarantine beds</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.SpecialThingFilterWorker_Infectious">
            <summary>Used to filter infected animals in pens</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.SpecialThingFilterWorker_Non_Infectious">
            <summary>Used to filter non infected animals in pens</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.CompQuarantineBed">
            <summary></summary>
        </member>
        <member name="T:NQualityOfLife.Medical.ShouldSeekMedicalRest_Patch">
            <summary>Makes pawns with a death rattle hediff seek bed rest for cpr and life support purposes</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.FlagsAreSet(NQualityOfLife.Medical.Hediffs.NQoL_Hediff_Pregnant.PregnantPawnDetails,NQualityOfLife.Medical.Hediffs.NQoL_Hediff_Pregnant.PregnantPawnDetails)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.AnyFlagIsSet(NQualityOfLife.Medical.Hediffs.NQoL_Hediff_Pregnant.PregnantPawnDetails,NQualityOfLife.Medical.Hediffs.NQoL_Hediff_Pregnant.PregnantPawnDetails)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.HasChildParts(Verse.BodyPartRecord)">
            <summary></summary>
            <param name="part"></param>
            <returns><see langword="true"/> if the given <paramref name="part"/> has child parts</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.GetDirectChildParts(Verse.BodyPartRecord)">
            <summary>Gets the child parts directly attached to this part</summary>
            <param name="part">Get the child parts directly attached to this part</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.SeverityPerDay(Verse.Hediff)">
            <summary>Gets the base severity per day for the hediff</summary>
            <param name="hediff"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="hediff"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.Hediffs(Verse.BodyPartRecord,Verse.Pawn)">
            <summary>Gets all the hediffs affecting the given part on the given pawn</summary>
            <param name="part"></param>
            <param name="pawn"></param>
            <returns>All the hediffs on the given body part of the pawn</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.Hediffs(Verse.BodyPartRecord,Verse.Pawn,System.Int32@)">
            <summary>Get all the <see cref="T:Verse.Hediff"/>s on the given <paramref name="part"/></summary>
            <param name="part"></param>
            <param name="pawn"></param>
            <param name="count"></param>
            <returns>Not null</returns>
        </member>
        <member name="F:NQualityOfLife.Medical.Surgery.SurgerySuccessInfo_Patch_1.report_Quality">
            <summary>The details for the surgery fail letter</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Surgery.Utils_Surgery.CanEverFail(RimWorld.Recipe_Surgery)">
            <summary>Can this surgery ever fail?</summary>
            <param name="surgery">The surgery to perform</param>
            <returns>true if can fail, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Surgery.Utils_Surgery.CanEverFail(NQualityOfLife.Medical.Surgery.RecipeDef)">
            <summary>Can this type of surgery / recipeDef ever fail?</summary>
             <param name="surgery">The surgery recipe</param>
             <returns>true if can fail, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Surgery.Utils_Surgery.RestorePartAndSpawnAllPreviousParts(Verse.Pawn,Verse.BodyPartRecord,Verse.IntVec3,Verse.Map,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:RimWorld.MedicalRecipesUtility.RestorePartAndSpawnAllPreviousParts(Verse.Pawn,Verse.BodyPartRecord,Verse.IntVec3,Verse.Map)"/>
        </member>
        <member name="T:NQualityOfLife.Medical.LocalSettings">
            <summary>Settings on start up</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.LocalSettings.debugMode">
            <summary>debug mode bool</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.LocalSettings.PerformCPR">
            <summary>The <see cref="T:Verse.JobDef"/> of the cpr job added by NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.LocalSettings.myDeathRattleEnabled">
            <summary>Is my stand alone death rattle system enabled?</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.LocalSettings.deathRattle_ClinicalDeathNoHeartbeat">
            <summary>The 'ClinicalDeathNoHeartbeat' hediff from death rattle</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.LocalSettings.deathRattle_ClinicalDeathAsphyxiation">
            <summary>The 'ClinicalDeathAsphyxiation' hediff from death rattle</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.CPR_Utils">
            <summary>CPR related helper functions</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.SomeoneBetterAtCPRIsFree(Verse.Pawn,Verse.Pawn,Verse.Pawn@,System.Boolean@,System.Nullable{System.Single},System.Boolean)">
            <summary></summary>
            <param name="patient"></param>
            <param name="me"></param>
            <param name="betterPawn">The pawn who is better and available to take over</param>
            <param name="otherPawnOnTheWayOrHere">Is the other pawn heading to help?</param>
            <param name="myCPRPower">float of my CPR power, if left to null it will be re calculated</param>
            <param name="orderBetterPawnToHelp">Should we order a better pawn to come help if able?</param>
            <returns><see langword="true"/> if someone is better and able to help</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetCPRStrengthOfPawn(Verse.Pawn)">
            <summary>Get the CPR strength of a pawn</summary>
            <param name="doctor">Get the CPR strength of this pawn</param>
            <returns>float CPRStrength, and float techniqueMultiplier</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetDeathRattleHediffsToTreat(Verse.Pawn)">
            <summary></summary>
            <param name="patient"></param>
            <returns>Not <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.HasAnyApplicableHediff(Verse.Pawn)">
            <summary>Does the pawn have any hediffs that can be treated with CPR?</summary>
            <param name="patient">The pawn who's hediffs to check</param>
            <returns><see langword="true"/> if has any applicable hediff</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetHediffsToTreat(Verse.Pawn)">
            <summary></summary>
            <param name="patient">Pawn to check</param>
            <returns>List of all the hediffs that CPR will treat - Not <see langword="null"/></returns>
        </member>
        <member name="T:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other">
            <summary>Perform CPR on an other pawn</summary>
        </member>
        <member name="P:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.PotentialWorkThingRequest">
            <summary>Pawns only</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.PotentialWorkThingsGlobal(Verse.Pawn)">
            <summary>Only pawns with any hediff</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.GoodLayingStatusForTend(Verse.Pawn)">
            <summary>Determine if GoodLayingStatusForTend</summary>
            <param name="patient">Check if this pawn is in a good position to be tended</param>
            <returns>bool, true if good status</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.HasJobOnThing(Verse.Pawn,Verse.Thing,System.Boolean)">
            <summary>Determine if pawn has a CPR job on an other pawn</summary>
            <param name="pawn">The doctor who is looking for a CPR job</param>
            <param name="t">The pawn to check for a job</param>
            <param name="forced"></param>
            <returns>bool, true if there is a CPR job that needs to be done</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.JobOnThing(Verse.Pawn,Verse.Thing,System.Boolean)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="t">The pawn to check for a job</param>
            <param name="forced">false</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.IsTreating(Verse.Pawn,Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="patient"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> is treating the <paramref name="patient"/> with CPR</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.IsAnyColonistPerformingCPROn(Verse.Pawn,Verse.Map)">
            <summary>Determine if any colonist is performing CPR on the target pawn</summary>
            <param name="patient">check if anyone is performing CPR on this pawn</param>
            <param name="map"></param>
            <returns><see langword="true"/> if someone is doing CPR</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="patient"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Medical.JobDriver_Perform_CPR">
            <summary>CPR job driver</summary>
        </member>
        <member name="P:NQualityOfLife.Medical.JobDriver_Perform_CPR.Patient">
            <summary>The patient is the pawn who needs CPR</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.JobDriver_Perform_CPR.PawnOnTheWay">
            <summary>The pawn who is on the way to help</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.JobDriver_Perform_CPR.TryMakePreToilReservations(System.Boolean)">
            <summary>Determine if possible to do CPR job</summary>
            <param name="errorOnFailed">output error on failed reservations</param>
            <returns>bool true if success</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.JobDriver_Perform_CPR.MakeNewToils">
            <summary>Create the sequence of jobs for CPR</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.NQoLDeathRattle.LocalSettings">
            <summary>
            Settings on startup
            </summary>
        </member>
        <member name="P:NQualityOfLife.MiscFixes.ShowHairWithHats.AllHats">
            <summary>Get all <see cref="T:Verse.ThingDef"/>s that are apparel that covers the head</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.ShowHairWithHats.SaveData">
            <summary>Save data for the show hair with hats feature</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MoreTemperatureFormats">
            <summary>New temperature display modes</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes">
            <summary>The extended modes, the first three are the <see cref="T:Verse.TemperatureDisplayMode"/>s</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.Celsius">
            <summary><see cref="T:NQualityOfLife.Units.Celsius"/> only, <see cref="F:Verse.TemperatureDisplayMode.Celsius"/></summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.Fahrenheit">
            <summary><see cref="T:NQualityOfLife.Units.Fahrenheit"/> only, <see cref="F:Verse.TemperatureDisplayMode.Fahrenheit"/></summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.Kelvin">
            <summary><see cref="T:NQualityOfLife.Units.Kelvin"/> only, <see cref="F:Verse.TemperatureDisplayMode.Kelvin"/></summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.Rankine">
            <summary><see cref="T:NQualityOfLife.Units.Rankine"/> only</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.CelsiusAndKelvin">
            <summary><see cref="T:NQualityOfLife.Units.Celsius"/> (<see cref="T:NQualityOfLife.Units.Kelvin"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.FahrenheitAndRankine">
            <summary><see cref="T:NQualityOfLife.Units.Fahrenheit"/> (<see cref="T:NQualityOfLife.Units.Rankine"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.CelsiusAndFahrenheit">
            <summary><see cref="T:NQualityOfLife.Units.Celsius"/> (<see cref="T:NQualityOfLife.Units.Fahrenheit"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.FahrenheitAndKelvin">
            <summary><see cref="T:NQualityOfLife.Units.Fahrenheit"/> (<see cref="T:NQualityOfLife.Units.Kelvin"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.KelvinAndRankine">
            <summary><see cref="T:NQualityOfLife.Units.Kelvin"/> (<see cref="T:NQualityOfLife.Units.Rankine"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.CelsiusAndRankine">
            <summary><see cref="T:NQualityOfLife.Units.Celsius"/> (<see cref="T:NQualityOfLife.Units.Rankine"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.RankineAndCelsius">
            <summary><see cref="T:NQualityOfLife.Units.Rankine"/> (<see cref="T:NQualityOfLife.Units.Celsius"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.KelvinAndCelsius">
            <summary><see cref="T:NQualityOfLife.Units.Kelvin"/> (<see cref="T:NQualityOfLife.Units.Celsius"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.FahrenheitAndCelsius">
            <summary><see cref="T:NQualityOfLife.Units.Fahrenheit"/> (<see cref="T:NQualityOfLife.Units.Celsius"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.KelvinAndFahrenheit">
            <summary><see cref="T:NQualityOfLife.Units.Kelvin"/> (<see cref="T:NQualityOfLife.Units.Fahrenheit"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.RankineAndKelvin">
            <summary><see cref="T:NQualityOfLife.Units.Rankine"/> (<see cref="T:NQualityOfLife.Units.Kelvin"/>)</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MoreTemperatureFormats.ExtendedTemperatureDisplayModes.RankineAndFahrenheit">
            <summary><see cref="T:NQualityOfLife.Units.Rankine"/> (<see cref="T:NQualityOfLife.Units.Fahrenheit"/>)</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureToString_Patch">
            <summary>Adds the new temperature mode names to the button in the interface menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureToString_Patch.Prefix(System.String@)">
            <summary>Adds the new temperature mode names to the button in the interface menu</summary>
            <param name="__result"></param>
            <returns></returns> 
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureConversion_Patch">
            <summary>Converts the temperature to the selected mode</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureConversion_Patch.Prefix(System.Single@,System.Single)">
            <summary>Converts the temperature to the selected mode</summary>
            <param name="__result"><paramref name="temp"/> converted to the selected unit</param>
            <param name="temp">Temperature in <see cref="T:NQualityOfLife.Units.Celsius"/></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureModeGetter_Patch">
            <summary>Changes the display in the settings to show the correct mode</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureStringRaw_Patch">
            <summary>Gets the <see cref="T:System.String"/> format for the selected temperature</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureStringRaw_Patch.Prefix(System.String@,System.Single,System.String)">
            <summary>Gets the <see cref="T:System.String"/> format for the selected temperature</summary>
            <param name="__result"></param>
            <param name="temp">The temperature in the units of the selected mode</param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureSetting_Patch">
            <summary>Insert the method to add the new options into the float menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MoreTemperatureFormats.TemperatureSetting_Patch.EditOptions(System.Collections.Generic.List{Verse.FloatMenuOption})">
            <summary>Adds the new options to the float menu in the interface settings</summary>
            <param name="options"></param>
            <returns>The <paramref name="options"/> modified to include the new temperature modes</returns>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.MapSettings.TranspilerTriggerMapSize">
            <summary>Map x y size used to tell the <seealso cref="M:NQualityOfLife.MiscFixes.MapSettings.MoreMapSizes_CustomSize_Patch.Transpiler(System.Collections.Generic.IEnumerable{HarmonyLib.CodeInstruction})">transpiler</seealso> that a custom map shape is selected</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MapSettings.LargerTestMap_Patch">
            <summary>Patch for changing the dev quick test map size</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MapSettings.MoreMapSizes_UseSettings_Patch_1">
            <summary>Trigger <see cref="M:NQualityOfLife.MiscFixes.MapSettings.EnforceSettings"/> during game start stuff</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MapSettings.MoreMapSizes_UseSettings_Patch_2">
            <summary>Trigger <see cref="M:NQualityOfLife.MiscFixes.MapSettings.EnforceSettings"/> during game start stuff</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MapSettings.MoreMapSizes_CustomSize_Patch">
            <summary>Insert <see cref="M:NQualityOfLife.MiscFixes.MapSettings.MoreMapSizes_CustomSize_Patch.ReplacementMapSizeVector(System.Int32,System.Int32,System.Int32)"/> method in place of map size vector creation, to allow custom map shapes</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MapSettings.MoreMapSizes_CustomSize_Patch.ReplacementMapSizeVector(System.Int32,System.Int32,System.Int32)">
            <summary>Return a replacement size vector of the desired <see cref="F:NQualityOfLife.MiscFixes.MapSettings.savedCustomMapSize"/> if the input to this method is the <see cref="F:NQualityOfLife.MiscFixes.MapSettings.TranspilerTriggerMapSize"/></summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.AuthorDataComp">
            <summary>This comp stores data about who has worked on the item and for how long, this is then intended to be used in the quality calculations</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2">
            <summary>Changes the <see cref="P:Verse.UnfinishedThing.Creator"/> to <see cref="F:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2.p"/> and then sets <see cref="F:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2.p"/> to <see langword="null"/></summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_3.Prefix(Verse.UnfinishedThing,Verse.Pawn)">
            <summary>Set <see cref="F:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2.p"/> to <paramref name="pawn"/> if <paramref name="__result"/> is not <see langword="null"/></summary>
            <param name="__result"></param>
            <param name="pawn"></param>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_3.Postfix(Verse.UnfinishedThing,Verse.Pawn)">
            <summary>Set <see cref="F:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_2.p"/> to <paramref name="pawn"/> if <paramref name="__result"/> is not <see langword="null"/></summary>
            <param name="__result"></param>
            <param name="pawn"></param>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.NQoL_JobAuthors_Patch_1">
            <summary>This patch is used to track the amount of work done by each pawn, the data is saved in the <see cref="T:NQualityOfLife.MiscFixes.MultipleJobAuthorsCrafting.AuthorDataComp"/> that all <see cref="T:Verse.UnfinishedThing"/>s have</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NoForcedRain_1">
            <summary>Disables the artificial rain commonality/duration increase</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NoForcedRain_2">
            <summary>Disables the artificial rain commonality/duration increase</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NQoL_FixRimAtomicsLogSpam">
            <summary>Temporary patch to fix a spammy Rimatomics log debug message</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.DoNotForbidDroppedWeapon_Patch">
            <summary>Changes it so dropped items are not forbidden</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.OnGameLoad_Patch.NQoLAction_PopNewPlayerInfo">
            <summary>Used to trigger the new player pop up manually, for debugging / translation purposes</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Text_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Text_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_VisibleRaidPoints">
            <summary>Adds the incident points to the end of the letter text</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Text_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Text_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch._invertEnabled">
            <summary>Is the letter stack inversion enabled?</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch._filterByDef">
            <summary>Filter <see cref="T:Verse.Letter"/>s by <see cref="T:Verse.Def"/>?</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch._filterByText">
            <summary>Filter <see cref="T:Verse.Letter"/>s by text?</summary>
        </member>
        <member name="F:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch._parsedBlacklist">
            <summary>The blacklist keywords for the <see cref="T:Verse.Letter"/> text filter</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.Prefix(Verse.Letter,System.Int32,System.Boolean@)">
            <summary></summary>
            <param name="let"></param>
            <param name="delayTicks"></param>
            <param name="__state"><see langword="true"/> if the <see cref="T:Verse.Letter"/> was supressed</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.Postfix(Verse.Letter,System.Int32,System.Collections.Generic.List{Verse.Letter}@,System.Boolean@)">
            <summary></summary>
            <param name="let"></param>
            <param name="delayTicks"></param>
            <param name="___letters"></param>
            <param name="__state"><see langword="true"/> if the letter was suppressed in the <see cref="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.Prefix(Verse.Letter,System.Int32,System.Boolean@)"/></param>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.DismissAllLetters(Verse.Letter)">
            <summary>Sets <see cref="F:NQualityOfLife.MiscFixes.LetterUtility.runLateLetterClose"/> to <see langword="true"/> causing <see cref="M:NQualityOfLife.MiscFixes.LetterUtility.CloseAllLetters"/> to run during the next update</summary>
            <param name="letter"></param>
            <returns><see langword="true"/> if middle click is pressed</returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch">
            <summary>Patch for triggering auto assign stuff when capturing a prisoner</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch.Prefix(RimWorld.JobDriver_TakeToBed,System.Boolean@)">
            <summary></summary>
            <param name="__instance"></param>
            <param name="__state">Will be set to true in the prefix, if the pawn is not yet a prisoner</param>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch.Postfix(RimWorld.JobDriver_TakeToBed,System.Boolean@)">
            <summary></summary>
            <param name="__instance"></param>
            <param name="__state">Will be true here if was not yet prisoner in prefix</param>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NQoL_FoodUtility">
            <summary>Utilities for giving hediffs after food consumption</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.NQoL_FoodUtility.AddRandomFoodParasitesHediff(Verse.Pawn,Verse.Thing,RimWorld.FoodPoisonCause)">
            <summary>50/50 chance to add either the GutWorms or MuscleParasites hediff</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerBedAssignment">
            <summary>This class contains all the relevant patches and code for the prisoner bed assignment feature</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerBedAssignment.NQoL_Prisoner_Bed_Assign_Patch">
            <summary>Show prisoners as valid candidates when selecting owner of prisoner bed</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerBedAssignment.NQoL_Prisoner_Bed_Assign_Patch_2">
            <summary>Enable the owner assignment gizmo for prison beds</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerDoorPatches">
            <summary>The patches related to prisoner door opening</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.Prisoners.PrisonerDoorPatches.NQoL_PrisonersDoor_Patch.Postfix(System.Boolean)">
            <summary>Do not change</summary>
            <param name="__result"></param>
            <returns>Do not change</returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerDoorPatches.NQoL_PrisonersCellDoor_Patch_2">
            <summary>Open all cell doors on prison break start</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerDoorPatches.NQoL_PrisonersCellDoor_Patch_3">
            <summary>Open all cell doors on prison break start - keep open for longer than normal</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.Prisoners.PrisonerSapperPatches.MakeEscapeJob(Verse.Pawn)">
            <summary></summary>
            <param name="prisoner"></param>
            <returns>The escape <see cref="T:Verse.AI.Job"/> if there is one, else <see langword="null"/></returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.Prisoners.PrisonerSapperPatches.NQoL_PrisonerEscape_Patch_2">
            <summary>Changes all the duties to the custom escape duty</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.NQoL_Pawn_Downed_Self_Preservation_Patch.Postfix(System.Boolean,Verse.Pawn_HealthTracker)">
            <summary></summary>
            <param name="__result">ShouldBeDowned return</param>
            <param name="__instance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.NQoL_QuestNode_GetFaction_Patch.Postfix(System.Boolean,RimWorld.Faction)">
            <summary></summary>
            <param name="__result">IsGoodFaction return</param>
            <param name="faction"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.NQoL_IncidentWorker_CanFireNow_Patch.Postfix(System.Boolean,RimWorld.IncidentWorker,RimWorld.IncidentParms)">
            <summary></summary>
            <param name="__result">IncidentWorker.CanFireNow return</param>
            <param name="__instance"></param>
            <param name="parms"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.ShouldSuppressMechIncidentDueToTechLevel(RimWorld.TechLevel,RimWorld.IncidentDef)">
            <summary>Should the given IncidentDef be disallowed from happening?</summary>
            <param name="playerTechLevel"></param>
            <param name="instanceDef"></param>
            <returns><see langword="true"/> if this IncidentDef should not be allowed to fire</returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.ShouldSuppress(RimWorld.IncidentDef,RimWorld.TechLevel,RimWorld.IncidentParms)">
            <summary>Check it the given incident def should be suppressed given the specific params</summary>
            <param name="instanceDef"></param>
            <param name="playerTechLevel"></param>
            <param name="parms"></param>
            <returns><see langword="true"/> if this incident should not be allowed to happen</returns>
        </member>
        <member name="T:NQualityOfLife.Progression.ResearchCleanup">
            <summary>Cleans out redundant and duplicate pre reqs</summary>
        </member>
        <member name="M:NQualityOfLife.Progression.ResearchQueue.GetNextFromQueue(System.Collections.Generic.List{Verse.ResearchProjectDef},System.Boolean)">
            <summary></summary>
            <param name="researchQueue"></param>
            <param name="debugWarningOnFail"></param>
            <returns><see langword="null"/> if nothing to start, or the project to try start from the queue</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.ResearchQueue.TryToStartNextAvailableResearchFromQueue(System.Collections.Generic.List{Verse.ResearchProjectDef},System.Boolean)">
            <summary></summary>
            <param name="researchQueue"></param>
            <param name="debugWarningOnFail"></param>
            <returns>True if research was started, false if not</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.NQoL_Research_Tech_Level_Patch_2.Prefix(Verse.ResearchProjectDef,System.Boolean@,Verse.Pawn,System.Boolean@)">
            <summary>This patch is used to remove the finished <paramref name="proj"/> from the research queue and send a letter if the queue becomes empty</summary>
            <param name="proj"></param>
            <param name="doCompletionDialog"></param>
            <param name="researcher"></param>
            <param name="doCompletionLetter"></param>
        </member>
        <member name="M:NQualityOfLife.Progression.NQoL_Research_Tech_Level_Patch_2.Postfix(Verse.Pawn,Verse.ResearchProjectDef)">
            <summary>This project sets the next <see cref="T:Verse.ResearchProjectDef"/> to be researched from the queue || And to progress the tech level of the player faction || Also used to record player legacy tales for finished projects</summary>
            <param name="researcher"></param>
            <param name="proj"></param>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.DoProgression(NQualityOfLife.Types.Ratio,NQualityOfLife.Types.Ratio,System.Boolean,RimWorld.TechLevel@,RimWorld.TechLevel@,System.Boolean)">
            <summary>Calls all the methods needed to progress the tech level</summary>
            <param name="ratioNeeded">The ratio of completed research projects of a level needed to consider that level completed</param>
            <param name="ratioNeededForSkip">The ratio of tech needed to be completed in a tech level 2 tiers ahead to level up</param>
            <param name="allowRegression"></param>
            <param name="oldLevel"></param>
            <param name="newLevel"></param>
            <param name="suppressMessage">Suppress in game notification message about level progress</param>
            <returns>false if there was an issue</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.GetDesiredTechLevel(NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@,System.Boolean)">
            <summary>Calculate the tech level that the colony should have based on the given parameters</summary>
            <param name="ratioNeeded">The ratio of completed research projects of a level needed to consider that level completed</param>
            <param name="ratioNeededForSkip">The ratio of tech needed to be completed in a tech level 2 tiers ahead to level up</param>
            <param name="debug"></param>
            <returns>Desired tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.SetDesiredTechLevel(RimWorld.TechLevel,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set the colony tech level to the given Int</summary>
            <param name="newTechLevel">The Int of the new tech level</param>
            <param name="allowRegression"></param>
            <param name="suppressMessage">Suppress in game message notification</param>
            <param name="debug"></param>
            <returns><see langword="true"/> if level changed, <see langword="false"/> if level was not changed</returns>
        </member>
        <member name="T:NQualityOfLife.SGUI.ISGUI">
            <summary></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="T:NQualityOfLife.SGUI.SGUIEventArgs">
            <summary>Contains information about a <see cref="T:NQualityOfLife.SGUI.ISGUI"/> event</summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.SGUIEventArgs.handled">
            <summary><see langword="true"/> if this event has already been 'consumed', meaning it has activated or interacted with something already</summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.SGUIEventArgs.delta">
            <summary></summary>
            <remarks>For a mouse wheel event, this is the direction and amount that the mouse wheel was rotated</remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.SGUIEventArgs.#ctor(NQualityOfLife.Types.MouseButtons)">
            <summary>Create <see langword="new"/> <see cref="T:NQualityOfLife.SGUI.SGUIEventArgs"/> that carries mouse button state information</summary>
            <param name="mouseButtons"></param>
        </member>
        <member name="P:NQualityOfLife.SGUI.SGUIEventArgs.LeftMouse">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.LeftMouse(NQualityOfLife.Types.MouseButtons)"/>
            <summary></summary>
        </member>
        <member name="T:NQualityOfLife.SGUI.ISGUIElement">
            <summary><see langword="interface"/> for <see cref="T:NQualityOfLife.SGUI.ISGUI"/> elements that can be interacted with and drawn using <see cref="T:NQualityOfLife.SGUI.IUniversalDraw"/></summary>
            <remarks>Extends <see cref="T:NQualityOfLife.SGUI.ISGUI"/>, <see cref="T:NQualityOfLife.SGUI.IUniversalDraw"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="E:NQualityOfLife.SGUI.ISGUIElement.OnStateChanged">
            <summary>An <see langword="event"/> that is triggered when <see cref="M:NQualityOfLife.SGUI.ISGUIElement.NotifyStateChanged(NQualityOfLife.SGUI.SGUIEventArgs)"/> is called</summary>
        </member>
        <member name="P:NQualityOfLife.SGUI.ISGUIElement.BoundingRect">
            <summary>The bounding box of <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/></summary>
        </member>
        <member name="M:NQualityOfLife.SGUI.ISGUIElement.NotifyStateChanged(NQualityOfLife.SGUI.SGUIEventArgs)">
            <summary></summary>
            <param name="eventArgs">Contains the relevant information about the event</param>
            <remarks>Triggers the <see cref="E:NQualityOfLife.SGUI.ISGUIElement.OnStateChanged"/> <see langword="event"/></remarks>
        </member>
        <member name="T:NQualityOfLife.SGUI.ISGUIInteractable">
            <summary>Represents an interactable <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/>, such as a button or dial</summary>
            <remarks>Extends <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> &lt;- <see cref="T:NQualityOfLife.SGUI.ISGUI"/></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.ISGUIInteractable.NotifyMouseMove(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.SGUI.SGUIEventArgs)">
            <summary>Notify <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> about a mouse move event</summary>
            <param name="mousePos">The current position of the mouse</param>
            <param name="eventArgs">Contains the relevant information about the event</param>
            <remarks>Can be used for things like draggable elements or actions triggered on mouse hover</remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.ISGUIInteractable.NotifyMouseUp(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.SGUI.SGUIEventArgs)">
            <summary>Notify <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> about a mouse (button) up event</summary>
            <param name="mousePos">The current position of the mouse</param>
            <param name="eventArgs">Contains the relevant information about the event</param>
            <remarks></remarks>
            <returns><see langword="true"/> if the click event was consumed, else <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.SGUI.ISGUIInteractable.NotifyMouseDown(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.SGUI.SGUIEventArgs)">
            <summary>Notify <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> about a mouse (button) down event</summary>
            <param name="mousePos">The current position of the mouse</param>
            <param name="eventArgs">Contains the relevant information about the event</param>
            <remarks></remarks>
            <returns><see langword="true"/> if the click event was consumed, else <see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.SGUI.ISGUIInteractable.NotifyMouseWheel(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.SGUI.SGUIEventArgs)">
            <summary>Notify <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> about a mouse wheel event</summary>
            <remarks>The delta of the event are provided in <see cref="T:NQualityOfLife.SGUI.SGUIEventArgs"/></remarks>
            <param name="mousePos"></param>
            <param name="eventArgs">Contains the relevant information about the event</param>
            <returns><see langword="true"/> if the click event was consumed, else <see langword="false"/></returns>
        </member>
        <member name="T:NQualityOfLife.SGUI.ISGUIParent">
            <remarks>Extends <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> &lt;- <see cref="T:NQualityOfLife.SGUI.ISGUI"/>, <see cref="T:NQualityOfLife.SGUI.IUniversalDraw"/></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.ISGUIParent.NotifyStateChanged(NQualityOfLife.SGUI.ISGUIElement@)">
            <summary>Called by a child <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> of <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIParent"/> when the child state changes</summary>
            <param name="callingChild"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="callingChild"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.SGUI.ISGUIContainer">
            <summary>an <see cref="T:System.Object"/> that can contain <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/>s</summary>
            <remarks>See: 'NQualityOfLife.SGUI.Cabinet'
            <para>Extends <see cref="T:NQualityOfLife.SGUI.ISGUIParent"/> &lt;- <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.SGUI.ISGUIContainer.GetCanvasRefObject">
            <summary>Get the canvas ref object used in <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/></summary>
        </member>
        <member name="P:NQualityOfLife.SGUI.ISGUIContainer.ContainerArea">
            <summary>The <see cref="T:NQualityOfLife.Geometry.Rectangle"/> where child elements should be drawn.</summary>
            <remarks><see langword="default"/> value of <see cref="T:NQualityOfLife.Geometry.Rectangle"/> if the container is abstract / has no defined area</remarks>
        </member>
        <member name="P:NQualityOfLife.SGUI.ISGUIContainer.Children">
            <summary>The child elements of <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIContainer"/></summary>
        </member>
        <member name="M:NQualityOfLife.SGUI.ISGUIContainer.DrawAll">
            <summary>Draw all the child elements of <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIContainer"/></summary>
        </member>
        <member name="M:NQualityOfLife.SGUI.ISGUIContainer.EnsureChildAdded(NQualityOfLife.SGUI.ISGUIElement@)">
            <summary>Ensure that a <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> is added to the children of <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.ISGUIContainer"/></summary>
            <param name="childElement"></param>
            <remarks>Recommended to call this inside the constructor of the <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/>, see: '<see cref="M:NQualityOfLife.SGUI.BaseSGUIElement.#ctor(NQualityOfLife.SGUI.ISGUIParent@,NQualityOfLife.Geometry.Rectangle@)"/>'</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="childElement"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.SGUI.BaseStaticSGUIElement">
            <summary>A <see cref="T:NQualityOfLife.SGUI.BaseStaticSGUIElement"/> cannot be interacted with, but it can still change state</summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.BaseStaticSGUIElement.parent_">
            <summary>The SGUI element or <seealso cref="T:NQualityOfLife.SGUI.SGUIContainer">base container</seealso> that contains <see langword="this"/> element</summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.BaseStaticSGUIElement.position_">
            <summary>The on-screen position of <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.BaseSGUIElement"/></summary>
            <remarks>Ideally the visuals of any overriding <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> should scale to fit inside the <see cref="F:NQualityOfLife.SGUI.BaseStaticSGUIElement.position_"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.BaseStaticSGUIElement.#ctor(NQualityOfLife.SGUI.ISGUIParent@,NQualityOfLife.Geometry.Rectangle@)">
            <summary></summary>
            <param name="parent"><see cref="T:NQualityOfLife.SGUI.ISGUIParent"/> / <see cref="T:NQualityOfLife.SGUI.ISGUIContainer"/></param>
            <param name="position">The on-screen position of <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.BaseSGUIElement"/><para>Ideally the visuals of any overriding <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> should scale to fit inside the <see cref="F:NQualityOfLife.SGUI.BaseStaticSGUIElement.position_"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/></para></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.BaseStaticSGUIElement.ReInitialize(NQualityOfLife.Geometry.Rectangle@)">
            <summary>Re-Initialize <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.BaseSGUIElement"/> with the given <paramref name="position"/>
            <para>This is to allow dynamic resizing and moving of the element without having to create a <see langword="new"/> instance</para></summary>
        </member>
        <member name="T:NQualityOfLife.SGUI.BaseSGUIElement">
            <summary>A base class that implements <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/></summary>
        </member>
        <member name="M:NQualityOfLife.SGUI.BaseSGUIElement.#ctor(NQualityOfLife.SGUI.ISGUIParent@,NQualityOfLife.Geometry.Rectangle@)">
            <summary></summary>
            <param name="parent"></param>
            <param name="position">The on-screen position of <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.BaseSGUIElement"/><para>Ideally the visuals of any overriding <see cref="T:NQualityOfLife.SGUI.ISGUIElement"/> should scale to fit inside the <see cref="F:NQualityOfLife.SGUI.BaseStaticSGUIElement.position_"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/></para></param>
        </member>
        <member name="T:NQualityOfLife.SGUI.SGUIContainer">
            <summary>A base class for <see cref="T:NQualityOfLife.SGUI.ISGUIContainer"/>s as a subclass of <see cref="T:NQualityOfLife.SGUI.BaseSGUIElement"/></summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.UniversalDraw.__drawHorizontalLine">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetHorizontalLineDrawMethod(System.Action{NQualityOfLife.Geometry.HorizontalLine,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="F:NQualityOfLife.SGUI.UniversalDraw.__drawLine">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetLineDrawMethod(System.Action{NQualityOfLife.Geometry.Line2D,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="F:NQualityOfLife.SGUI.UniversalDraw.__drawCircle">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetCircleDrawMethod(System.Action{NQualityOfLife.Geometry.Circle,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="F:NQualityOfLife.SGUI.UniversalDraw.__drawRect">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="F:NQualityOfLife.SGUI.UniversalDraw.__drawRectSolid">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetSolidRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="F:NQualityOfLife.SGUI.UniversalDraw.__drawText">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetTextDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,System.String,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="F:NQualityOfLife.SGUI.UniversalDraw.__drawRectHollow">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetHollowRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="P:NQualityOfLife.SGUI.UniversalDraw.CircleDrawMethod">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetCircleDrawMethod(System.Action{NQualityOfLife.Geometry.Circle,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="P:NQualityOfLife.SGUI.UniversalDraw.LineDrawMethod">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetLineDrawMethod(System.Action{NQualityOfLife.Geometry.Line2D,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="P:NQualityOfLife.SGUI.UniversalDraw.HorizontalLineDrawMethod">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetHorizontalLineDrawMethod(System.Action{NQualityOfLife.Geometry.HorizontalLine,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="P:NQualityOfLife.SGUI.UniversalDraw.TextDrawMethod">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetTextDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,System.String,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="P:NQualityOfLife.SGUI.UniversalDraw.RectDrawMethod">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="P:NQualityOfLife.SGUI.UniversalDraw.SolidRectDrawMethod">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetSolidRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="P:NQualityOfLife.SGUI.UniversalDraw.HollowRectDrawMethod">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetHollowRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetLineDrawMethod(System.Action{NQualityOfLife.Geometry.Line2D,NQualityOfLife.SGUI.DrawParams})">
            <summary>Set the method used to draw lines</summary>
            <param name="lineDraw"></param>
            <remarks><b>Required</b>
            <para>Do not use <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods in the definition of this draw method</para>
            <para>Instead define it using the native methods of what ever framework is in use</para></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetHorizontalLineDrawMethod(System.Action{NQualityOfLife.Geometry.HorizontalLine,NQualityOfLife.SGUI.DrawParams})">
            <summary>Set a method used to draw horizontal lines</summary>
            <param name="lineDraw"></param>
            <remarks><b>Optional</b>
            <para>Do not use <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods in the definition of this draw method</para>
            <para>Instead define it using the native methods of what ever framework is in use</para>
            <para><see cref="M:NQualityOfLife.SGUI.UniversalDraw.DrawLine(NQualityOfLife.Geometry.Line2D@,NQualityOfLife.SGUI.DrawParams@)"/> will be used instead if <see cref="P:NQualityOfLife.SGUI.UniversalDraw.HorizontalLineDrawMethod"/> is not set</para></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetTextDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,System.String,NQualityOfLife.SGUI.DrawParams})">
            <summary></summary>
            <param name="textDraw"></param>
            <remarks>The <see cref="F:NQualityOfLife.SGUI.DrawParams.OutlineColor"/> defines the text color, and <see cref="F:NQualityOfLife.SGUI.DrawParams.LineWidth"/> the font size
            <para>the <see cref="F:NQualityOfLife.SGUI.DrawParams.FillColor"/> is used to set the text background</para></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetTextureDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.IO.FilePath,NQualityOfLife.SGUI.DrawParams,NQualityOfLife.Units.Degrees})">
            <summary></summary>
            <param name="textureDraw"><list type="table"><item>Position <see cref="T:NQualityOfLife.Geometry.Rectangle"/></item><item><see cref="T:NQualityOfLife.IO.FilePath"/> to the texture</item><item><see cref="T:NQualityOfLife.SGUI.DrawParams"/></item><item>Rotation offset <see cref="T:NQualityOfLife.Units.Degrees"/></item></list></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetTextureDrawMethod``1(System.Action{NQualityOfLife.Geometry.Rectangle,``0,NQualityOfLife.SGUI.DrawParams,NQualityOfLife.Units.Degrees})">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetTextureDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.IO.FilePath,NQualityOfLife.SGUI.DrawParams,NQualityOfLife.Units.Degrees})"/>
            <summary> </summary>
            <typeparam name="T"></typeparam>
            <param name="textureDraw"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetTextureDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.IO.PNG,NQualityOfLife.SGUI.DrawParams,NQualityOfLife.Units.Degrees})">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetTextureDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.IO.FilePath,NQualityOfLife.SGUI.DrawParams,NQualityOfLife.Units.Degrees})"/>
            <summary></summary>
            <param name="textureDraw"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetCircleDrawMethod(System.Action{NQualityOfLife.Geometry.Circle,NQualityOfLife.SGUI.DrawParams})">
            <remarks><b>Required</b></remarks>
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.DrawCircle(NQualityOfLife.Geometry.Circle@,NQualityOfLife.SGUI.DrawParams@)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetSolidRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})">
            <summary></summary>
            <param name="rectDraw"></param>
            <remarks>
            <see cref="F:NQualityOfLife.SGUI.DrawParams.FillColor"/> defines the fill color of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/>
            <para><b>Required</b></para>
            <para>Do not use <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods in the definition of this draw method</para>
            <para>Instead define it using the native methods of what ever framework is in use</para></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetHollowRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})">
            <summary></summary>
            <param name="rectDraw"></param>
            <remarks>
            <see cref="F:NQualityOfLife.SGUI.DrawParams.LineWidth"/> defines the outline width of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/>
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.OutlineColor"/> defines the outline color of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/></para>
            <para><b>Optional</b></para>
            <para>Do not use <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods in the definition of this draw method</para>
            <para>Instead define it using the native methods of what ever framework is in use</para></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.SetRectangleDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,NQualityOfLife.SGUI.DrawParams})">
            <summary></summary>
            <param name="rectDraw"></param>
            <remarks>
            <see cref="F:NQualityOfLife.SGUI.DrawParams.LineWidth"/> defines the outline width of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/>
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.OutlineColor"/> defines the outline color of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/></para>
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.FillColor"/> defines the fill color of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/></para>
            <para><b>Optional</b></para>
            <para>Do not use <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods in the definition of this draw method</para>
            <para>Instead define it using the native methods of what ever framework is in use</para></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawCircle(NQualityOfLife.Geometry.Circle@,NQualityOfLife.SGUI.DrawParams@)">
            <summary>Draw the given <paramref name="circle"/> using the given <paramref name="drawParams"/> with the currently set <see cref="P:NQualityOfLife.SGUI.UniversalDraw.CircleDrawMethod"/>
            <para><see cref="P:NQualityOfLife.SGUI.UniversalDraw.CircleDrawMethod"/> and <see cref="M:NQualityOfLife.SGUI.UniversalDraw.SetCircleDrawMethod(System.Action{NQualityOfLife.Geometry.Circle,NQualityOfLife.SGUI.DrawParams})"/> are used to set the draw method</para></summary>
            <param name="circle"></param>
            <param name="drawParams"></param>
            <remarks>
            <see cref="F:NQualityOfLife.SGUI.DrawParams.LineWidth"/> defines the width of the outline
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.OutlineColor"/> defines the color of the outline</para>
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.FillColor"/> defines the fill color of the <see cref="T:NQualityOfLife.Geometry.Circle"/></para>
            </remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawLine(NQualityOfLife.Geometry.Line2D@,NQualityOfLife.SGUI.DrawParams@)">
            <summary>Draw a line
            <para><see cref="P:NQualityOfLife.SGUI.UniversalDraw.LineDrawMethod"/> and <see cref="M:NQualityOfLife.SGUI.UniversalDraw.SetLineDrawMethod(System.Action{NQualityOfLife.Geometry.Line2D,NQualityOfLife.SGUI.DrawParams})"/> are used to set the draw method</para></summary>
            <param name="line"></param>
            <param name="drawParams"></param>
            <remarks>
            <see cref="F:NQualityOfLife.SGUI.DrawParams.LineWidth"/> defines the width of the line
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.OutlineColor"/> defines the color of the line</para>
            </remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawLine(NQualityOfLife.Geometry.HorizontalLine@,NQualityOfLife.SGUI.DrawParams@)">
            <summary>Draw a horizontal line
            <para><see cref="P:NQualityOfLife.SGUI.UniversalDraw.HorizontalLineDrawMethod"/> and <see cref="M:NQualityOfLife.SGUI.UniversalDraw.SetHorizontalLineDrawMethod(System.Action{NQualityOfLife.Geometry.HorizontalLine,NQualityOfLife.SGUI.DrawParams})"/> are used to set the draw method</para></summary>
            <param name="line"></param>
            <param name="drawParams"></param>
            <remarks>
            <see cref="F:NQualityOfLife.SGUI.DrawParams.LineWidth"/> defines the width of the line
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.OutlineColor"/> defines the color of the line</para>
            <para>Uses <see cref="M:NQualityOfLife.SGUI.UniversalDraw.DrawLine(NQualityOfLife.Geometry.Line2D@,NQualityOfLife.SGUI.DrawParams@)"/> if no method is set for horizontal lines</para></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawRectangleLines(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.SGUI.DrawParams@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.DrawLine(NQualityOfLife.Geometry.Line2D@,NQualityOfLife.SGUI.DrawParams@)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawRectangle(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.SGUI.DrawParams@)">
            <remarks>
            <see cref="F:NQualityOfLife.SGUI.DrawParams.LineWidth"/> defines the outline width of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/>
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.OutlineColor"/> defines the outline color of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/></para>
            <para><see cref="F:NQualityOfLife.SGUI.DrawParams.FillColor"/> defines the fill color of the <see cref="T:NQualityOfLife.Geometry.Rectangle"/></para>
            </remarks>
            <inheritdoc cref="F:NQualityOfLife.SGUI.UniversalDraw.__drawRect"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawSolidRectangle(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.SGUI.DrawParams@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.DrawRectangle(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.SGUI.DrawParams@)"/>
            <summary></summary>
            <param name="position"></param>
            <param name="drawParams"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawImageTexture(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.IO.FilePath@,NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Units.Degrees@)">
            <summary>Draw a texture/image using a <paramref name="texturePath"/> to a file</summary>
            <param name="position"></param>
            <param name="texturePath"></param>
            <param name="drawParams"></param>
            <param name="rotation">Rotate the image by the given amount, or leave as <see langword="default"/> for no rotation</param>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawImageTexture``1(NQualityOfLife.Geometry.Rectangle@,``0@,NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Units.Degrees@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="position"></param>
            <param name="img"></param>
            <param name="drawParams"></param>
            <param name="rotation"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="img"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawImageTexture(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.IO.PNG@,NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Units.Degrees@)">
            <summary>Draw a texture/image using a <paramref name="png"/></summary>
            <param name="position"></param>
            <param name="png"></param>
            <param name="drawParams"></param>
            <param name="rotation">Rotate the image by the given amount, or leave as <see langword="default"/> for no rotation</param>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.DrawText(NQualityOfLife.Geometry.Rectangle@,System.String,NQualityOfLife.SGUI.DrawParams@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.UniversalDraw.SetTextDrawMethod(System.Action{NQualityOfLife.Geometry.Rectangle,System.String,NQualityOfLife.SGUI.DrawParams})"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.AnyFlagIsSet(NQualityOfLife.SGUI.DrawParams.Layers,NQualityOfLife.SGUI.DrawParams.Layers)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.FlagsAreSet(NQualityOfLife.SGUI.DrawParams.Layers,NQualityOfLife.SGUI.DrawParams.Layers)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.UniversalDraw.UnsetFlags(NQualityOfLife.SGUI.DrawParams.Layers,NQualityOfLife.SGUI.DrawParams.Layers)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0@)"/>
        </member>
        <member name="T:NQualityOfLife.SGUI.DrawParams">
            <summary><see cref="T:NQualityOfLife.SGUI.DrawParams"/> contains information that <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods use to draw shapes</summary>
        </member>
        <member name="T:NQualityOfLife.SGUI.DrawParams.Layers">
            <summary>Render layers</summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.DrawParams.Layers.Debug">
            <summary>Draw debug shapes or what ever else is useful for debugging the draw of a specific element</summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.DrawParams.BaseCanvasObject">
            <summary>A reference <see cref="T:System.Object"/> used in the <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods</summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.DrawParams.OutlineColor">
            <summary>The color of the outline of solid shapes such as a <see cref="T:NQualityOfLife.Geometry.Circle"/> or <see cref="T:NQualityOfLife.Geometry.Rectangle"/><para>or the draw color of <seealso cref="T:NQualityOfLife.Geometry.Line2D">lines</seealso></para></summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.DrawParams.FillColor">
            <summary>The fill color of a solid shape, such as a <see cref="T:NQualityOfLife.Geometry.Circle"/> or <see cref="T:NQualityOfLife.Geometry.Rectangle"/><para>Has no affect on shapes with no area, such as <see cref="T:NQualityOfLife.Geometry.Line2D"/></para></summary>
        </member>
        <member name="F:NQualityOfLife.SGUI.DrawParams.LineWidth">
            <summary>Width of the outline of shapes or of <see cref="T:NQualityOfLife.Geometry.Line2D"/></summary>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@)">
            <summary>Create base <see cref="T:NQualityOfLife.SGUI.DrawParams"/></summary>
            <param name="baseDrawObject">A reference <see cref="T:System.Object"/> used in the <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods<para><see cref="F:NQualityOfLife.SGUI.DrawParams.BaseCanvasObject"/></para></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.SGUI.DrawParams.Layers)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.SGUI.DrawParams"/> with specified <paramref name="layers"/></summary>
            <param name="baseDrawObject"></param>
            <param name="layers"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,System.Single,NQualityOfLife.Colors.IColorImmutable@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.SGUI.DrawParams"/> for a line / shape with an outline</summary>
            <param name="baseDrawObject"></param>
            <param name="outlineWidth"></param>
            <param name="outlineColor"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,System.Single,NQualityOfLife.Colors.RGBA@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,System.Single,NQualityOfLife.Colors.IColorImmutable@)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.IColorImmutable@,NQualityOfLife.Colors.IColorImmutable@,System.Single)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.SGUI.DrawParams"/> for a shape with an outline and a <paramref name="fillColor"/></summary>
            <param name="baseDrawObject"></param>
            <param name="fillColor"></param>
            <param name="outlineColor"></param>
            <param name="outlineWidth"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.Hex@,NQualityOfLife.Colors.Hex@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.IColorImmutable@,NQualityOfLife.Colors.IColorImmutable@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Colors.IColorImmutable@,NQualityOfLife.Colors.IColorImmutable@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.IColorImmutable@,NQualityOfLife.Colors.IColorImmutable@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Colors.RGBA@,NQualityOfLife.Colors.RGBA@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.IColorImmutable@,NQualityOfLife.Colors.IColorImmutable@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Colors.Hex@,NQualityOfLife.Colors.Hex@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.IColorImmutable@,NQualityOfLife.Colors.IColorImmutable@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.IColorImmutable@)">
            <summary>Create <see langword="new"/> <see cref="T:NQualityOfLife.SGUI.DrawParams"/> for a solid shape with a given <paramref name="fillColor"/></summary>
            <param name="fillColor">The <see cref="T:NQualityOfLife.Colors.IColorRGBA"/> that specifies the fill color for a solid shape</param>
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@)"/>
            <param name="baseDrawObject"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.RGBA@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.IColorImmutable@)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.SGUI.DrawParams"/> with the same values as the provided <see cref="T:NQualityOfLife.SGUI.DrawParams"/></summary>
            <param name="copyFrom"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.SGUI.DrawParams.Layers)">
            <summary>Make a copy of the given <see cref="T:NQualityOfLife.SGUI.DrawParams"/> with changed <see cref="T:NQualityOfLife.SGUI.DrawParams.Layers"/></summary>
            <param name="copyFrom"></param>
            <param name="layers"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,System.Single,NQualityOfLife.Colors.IColorImmutable@)">
            <summary>Create <see langword="new"/> <see cref="T:NQualityOfLife.SGUI.DrawParams"/> for a line / shape with an outline</summary>
            <param name="copyFrom"></param>
            <param name="outlineWidth"></param>
            <param name="outlineColor"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,System.Single,NQualityOfLife.Colors.RGBA@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,System.Single,NQualityOfLife.Colors.IColorImmutable@)"/>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Colors.IColorImmutable@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(System.Object@,NQualityOfLife.Colors.IColorImmutable@)"/>
            <summary></summary>
            <param name="copyFrom"></param>
            <param name="fillColor"></param>
        </member>
        <member name="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Colors.RGBA@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.DrawParams.#ctor(NQualityOfLife.SGUI.DrawParams@,NQualityOfLife.Colors.IColorImmutable@)"/>
        </member>
        <member name="P:NQualityOfLife.SGUI.DrawParams.Item(System.Int32)">
            <summary><list type="table"><item>0 - <see cref="F:NQualityOfLife.SGUI.DrawParams.BaseCanvasObject"/></item></list></summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.SGUI.IUniversalDraw">
            <summary>Implementing members should use <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> to draw graphics</summary>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.SGUI.IUniversalDraw.Draw(NQualityOfLife.SGUI.DrawParams@)">
            <summary>Draw <see langword="this"/> <see cref="T:NQualityOfLife.SGUI.IUniversalDraw"/> instance using the currently defined <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods</summary>
            <param name="drawParams">The <see cref="T:NQualityOfLife.SGUI.DrawParams"/> to pass to the <see cref="T:NQualityOfLife.SGUI.UniversalDraw"/> methods and for the internal draw logic of the specific <see cref="T:NQualityOfLife.SGUI.IUniversalDraw"/> member</param>
            <remarks>See '<see cref="M:NQualityOfLife.Geometry.Rectangle.Draw(NQualityOfLife.SGUI.DrawParams@)"/>'</remarks>
        </member>
        <member name="T:NQualityOfLife.SGUI.IUniversalDrawInline`1">
            <remarks>Implements <see cref="T:NQualityOfLife.SGUI.IUniversalDraw"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.SGUI.IUniversalDraw"/>
            <summary></summary>
            <typeparam name="TG"></typeparam>
        </member>
        <member name="M:NQualityOfLife.SGUI.IUniversalDrawInline`1.DrawAndThen(NQualityOfLife.SGUI.DrawParams@)">
            <inheritdoc cref="M:NQualityOfLife.SGUI.IUniversalDraw.Draw(NQualityOfLife.SGUI.DrawParams@)"/>
            <returns>The drawn instance, or a copy in the case of <see langword="struct"/>s</returns>
        </member>
        <member name="P:NQualityOfLife.Sound.IWaveForm.SampleRate">
            <summary>How many audio samples a <see cref="T:NQualityOfLife.Units.Second"/> are played for the <see cref="T:NQualityOfLife.Sound.IWaveForm"/></summary>
        </member>
        <member name="P:NQualityOfLife.Sound.IWaveForm.Duration">
            <summary>The estimated play duration of the <see cref="T:NQualityOfLife.Sound.IWaveForm"/> in <seealso cref="T:NQualityOfLife.Units.Second">seconds</seealso></summary>
        </member>
        <member name="T:NQualityOfLife.Sound.Wave16Bit">
            <summary>16 bit sound wave</summary>
        </member>
        <member name="P:NQualityOfLife.Sound.Wave16Bit.Invalid">
            <summary>Get a <see langword="new"/> instance of an invalid <see cref="T:NQualityOfLife.Sound.Wave16Bit"/></summary>
        </member>
        <member name="M:NQualityOfLife.Sound.Wave16Bit.#ctor">
            <summary><see langword="new"/> invalid <see cref="T:NQualityOfLife.Sound.Wave16Bit"/></summary>
        </member>
        <member name="M:NQualityOfLife.Sound.Wave16Bit.#ctor(NQualityOfLife.Sound.Wave16Bit@)">
            <summary>Make a deep copy of the given <see cref="T:NQualityOfLife.Sound.Wave16Bit"/></summary>
            <param name="copyFrom"></param>
        </member>
        <member name="M:NQualityOfLife.Sound.Wave16Bit.#ctor(System.Int32,System.Int16,System.Int32)">
            <summary>Create an empty <see cref="T:NQualityOfLife.Sound.Wave16Bit"/> with room for the given amount of <paramref name="samples"/>, The wave data can then be written using the indexer <see cref="P:NQualityOfLife.Sound.Wave16Bit.Item(System.Int32)"/></summary>
            <param name="samples"></param>
            <param name="channels"></param>
            <param name="sampleRate"></param>
        </member>
        <member name="M:NQualityOfLife.Sound.Wave16Bit.#ctor(System.Int16[],System.Int16,System.Int32)">
            <summary></summary>
            <param name="wave"></param>
            <param name="channels"></param>
            <param name="sampleRate"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="wave"/> is <see langword="null"/></exception>
        </member>
        <member name="P:NQualityOfLife.Sound.Wave16Bit.Item(System.Int32)">
            <summary>Get the sample at the given <paramref name="index"/></summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Wave16Bit.CopyTo(System.Int16[],System.Int32)">
            <inheritdoc cref="M:System.Array.CopyTo(System.Array,System.Int32)"/>
            <returns><paramref name="target"/></returns>
        </member>
        <member name="T:NQualityOfLife.Sound.Wave24Bit">
            <summary>24 bit sound wave</summary>
        </member>
        <member name="T:NQualityOfLife.Sound.Wav">
            <summary>Represents a .wav sound file in memory</summary>
        </member>
        <member name="M:NQualityOfLife.Sound.Wav.LoadFrom(NQualityOfLife.IO.FilePath@)">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.LoadWavFile(NQualityOfLife.IO.FilePath@)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Wav.#ctor">
            <summary><see langword="new"/> invalid <see cref="T:NQualityOfLife.Sound.Wav"/></summary>
        </member>
        <member name="M:NQualityOfLife.Sound.Wav.#ctor(System.Byte[])">
            <summary></summary>
            <param name="wavStream">The full .wav byte stream</param>
        </member>
        <member name="M:NQualityOfLife.Sound.Wav.#ctor(NQualityOfLife.Sound.Wave16Bit@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wav"/> from a 16 bit <paramref name="wave"/></summary>
            <param name="wave"></param>
        </member>
        <member name="M:NQualityOfLife.Sound.Wav.#ctor(NQualityOfLife.IO.FilePath@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wav"/> from the source file</summary>
            <param name="pathToFile"></param>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Wav.AsRawDataStream">
            <summary></summary>
            <returns>A <see cref="T:System.Byte"/> array that contains the virtual <see cref="T:NQualityOfLife.Sound.Wav"/> file</returns>
        </member>
        <member name="T:NQualityOfLife.Sound.Tools">
            <summary>Utility <see langword="class"/> for loading, saving and modifying sound waves and files</summary>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.NewWithOverride(NQualityOfLife.Sound.Wav,System.Int32)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wav"/> that is a copy of the <paramref name="sourceWav"/>, but with the given value overridden</summary>
            <param name="sourceWav"></param>
            <param name="newSampleRate"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wav"/></returns>
            <remarks>Note that changing values this way will not automatically do resampling or other operations!<para>Thus resulting <see cref="T:NQualityOfLife.Sound.Wav"/> objects could be invalid for playing depending on what values are changed</para></remarks>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.NewStreamWithOverride(NQualityOfLife.Sound.Wav,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.NewWithOverride(NQualityOfLife.Sound.Wav,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.Trim(NQualityOfLife.Sound.Wav,NQualityOfLife.Units.Second@,NQualityOfLife.Units.Second@)">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.Trim(NQualityOfLife.Sound.Wave16Bit@,System.Int32,System.Int32,System.Boolean,System.Int16)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.Trim(NQualityOfLife.Sound.Wav,System.Int32,System.Int32,System.Boolean,System.Int16)">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.Trim(NQualityOfLife.Sound.Wave16Bit@,System.Int32,System.Int32,System.Boolean,System.Int16)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.Trim(NQualityOfLife.Sound.Wave16Bit@,System.Int32,System.Int32,System.Boolean,System.Int16)">
            <summary></summary>
            <param name="wave"></param>
            <param name="removeStart"></param>
            <param name="removeEnd"></param>
            <param name="autoTrimSilence"></param>
            <param name="silenceThreshold"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wave16Bit"/> with the given portion or silence trimmed</returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.AdjustVolume(NQualityOfLife.Sound.Wav,NQualityOfLife.Types.Ratio@)">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wav"/> with adjusted volume</summary>
            <param name="wav"></param>
            <param name="volumeRatio"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="wav"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.AdjustVolume(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Types.Ratio@)">
            <summary></summary>
            <param name="waveRef"></param>
            <param name="volumeRatio"></param>
            <returns></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.MutatesAttribute">Mutates</see> '<paramref name="waveRef"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.AdjustTrackVolumes(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <summary></summary>
            <param name="stereoWaveRef"></param>
            <param name="volumeRatioLeft"></param>
            <param name="volumeRatioRight"></param>
            <returns></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.MutatesAttribute">Mutates</see> '<paramref name="stereoWaveRef"/>'</remarks>
            <exception cref="T:System.ArgumentException"><paramref name="stereoWaveRef"/> is not stereo!</exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.MatchLengthWithPadding(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.AlignLengthWithPadding(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.AlignLengthWithPadding(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)">
            <summary>Pads the shorter of two <see cref="T:NQualityOfLife.Sound.Wave16Bit"/> instances with silence (zeroes) so that both have equal length. Logs warnings for mismatched sample rates.</summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.Splice(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.Concat(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.Concat(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.Mix(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.Combine(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.Combine(NQualityOfLife.Sound.Wave16Bit@,NQualityOfLife.Sound.Wave16Bit@)">
            <summary></summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception><exception cref="T:NQualityOfLife.Exceptions.InternalDataException"></exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.GenerateSineWave(NQualityOfLife.Units.Hertz@,NQualityOfLife.Units.Second@,NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary>Generate a 16 bit mono sine wave</summary>
            <param name="frequency"></param>
            <param name="duration"></param>
            <param name="amplitude"></param>
            <param name="sampleRate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.GenerateSquareWave(NQualityOfLife.Units.Hertz@,NQualityOfLife.Units.Second@,NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary>Generate a 16 bit mono square wave</summary>
            <param name="frequency"></param>
            <param name="duration"></param>
            <param name="amplitude"></param>
            <param name="sampleRate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.GenerateWhiteNoise(NQualityOfLife.Units.Second@,NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary>Generate 16 bit mono white noise</summary>
            <param name="duration"></param>
            <param name="amplitude"></param>
            <param name="sampleRate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.CreateWavStream(System.Byte[],System.Int32,System.Int16,System.Int16,System.Int32,System.Int16)">
            <summary>Create a <see cref="T:System.Byte"/>[] stream that contains the data of a .wav file</summary>
            <param name="binWave">The data section of the .wav file</param>
            <param name="totalSamples"></param>
            <param name="bitsPerSample"></param>
            <param name="channels"></param>
            <param name="sampleRate"></param>
            <param name="audioFormat"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.CreateWav(NQualityOfLife.Sound.Wave16Bit@,System.Int16)">
            <summary>Create a .wav into a <see cref="T:System.IO.MemoryStream"/> from the provided <paramref name="wave"/></summary>
            <param name="wave"></param>
            <param name="audioFormat"></param>
            <returns><see langword="null"/> if creation failed, else a <see cref="T:NQualityOfLife.Sound.Wav"/> <see cref="T:System.Object"/></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.DecodeWavMetadata(System.Byte[],System.Int32@,System.Int16@,System.Int16@,System.Int16@)">
            <summary>Read the meta data from the .wav file stream</summary>
            <param name="wavStream">The raw .wav byte stream</param>
            <param name="sampleRate">The sample rate specified in the <paramref name="wavStream"/></param>
            <param name="numChannels">The number of channels specified in the <paramref name="wavStream"/></param>
            <param name="bitsPerSample">The bits per sample rate specified in the <paramref name="wavStream"/></param>
            <param name="audioFormat">The audio format specified in the <paramref name="wavStream"/></param>
            <returns><see langword="true"/> if the read succeeded</returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.DecodeWavAs16Bit(System.Byte[],NQualityOfLife.Sound.Wave16Bit@,System.Int16@)">
            <summary></summary>
            <param name="wavStream">The .wav file as a array <see cref="T:System.Byte"/>[]</param>
            <param name="wave16"></param>
            <param name="audioFormat"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.DecodeWavAs24Bit(System.Byte[],NQualityOfLife.Sound.Wave24Bit@,System.Int16@)">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.DecodeWavAs16Bit(System.Byte[],NQualityOfLife.Sound.Wave16Bit@,System.Int16@)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.DecodeWav_Internal(System.Byte[],NQualityOfLife.Sound.IWaveForm@,System.Int16@,System.Int16@,System.Int32@,System.Int16@,System.Boolean)">
            <summary></summary>
            <param name="wavStream">The .wav file as an array '<see cref="T:System.Byte"/>[]'</param>
            <param name="wave"></param>
            <param name="bitsPerSampleOriginal">The bits per sample of the original <paramref name="wavStream"/>, this may differ from the output <paramref name="wave"/></param>
            <param name="audioFormat"></param>
            <param name="sampleRate"></param>
            <param name="numChannels"></param>
            <param name="metaDataOnly"></param>
            <returns></returns>
            <exception cref="T:System.IO.InvalidDataException"></exception>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.ResampleMono(NQualityOfLife.Sound.Wave16Bit@,System.Int32)">
            <summary></summary>
            <param name="monoSource"></param>
            <param name="newSampleRate"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"><paramref name="monoSource"/> is not mono</exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.LoadWavAs16Bit(NQualityOfLife.IO.FilePath@)">
            <summary>Load the .wav file at the given location as a <see cref="T:NQualityOfLife.Sound.Wave16Bit"/></summary>
            <param name="filePath"></param>
            <returns></returns>
            <exception cref="T:System.IO.InvalidDataException"></exception>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.LoadWavFile(NQualityOfLife.IO.FilePath@)">
            <summary>Load a <seealso cref="T:NQualityOfLife.Sound.Wav">.wav</seealso> file from disk</summary>
            <param name="wavFilePath">The path to the .wav file on disk</param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wav"/> <see cref="T:System.Object"/> that contains the .wav data</returns>
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.LoadWavFile_Internal(NQualityOfLife.IO.FilePath@)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.LoadWavFile_Internal(NQualityOfLife.IO.FilePath@)">
            <inheritdoc cref="M:System.IO.File.ReadAllBytes(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.SaveWavFile(NQualityOfLife.Sound.Wav,NQualityOfLife.IO.FilePath@)">
            <summary>Save the <paramref name="wav"/> <see cref="T:System.Object"/> onto disk as a .wav file</summary>
            <param name="wav">The <see cref="T:NQualityOfLife.Sound.Wav"/> <see cref="T:System.Object"/> to save</param>
            <param name="wavFilePath">The file path of the file to write</param>
            <inheritdoc cref="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])"/>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.StereoToMono(NQualityOfLife.Sound.Wave16Bit@)">
            <summary>Convert a stereo <see cref="T:NQualityOfLife.Sound.Wave16Bit"/> into mono audio</summary>
            <param name="stereoWave"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wave16Bit"/> mono wave</returns>
            <exception cref="T:System.ArgumentException"><paramref name="stereoWave"/> is not stereo!</exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.MonoToStereo(NQualityOfLife.Sound.Wave16Bit@)">
            <summary>Convert a mono <see cref="T:NQualityOfLife.Sound.Wave16Bit"/> into stereo audio</summary>
            <param name="monoWave"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wave16Bit"/> mono wave</returns>
            <exception cref="T:System.ArgumentException"><paramref name="monoWave"/> is not mono!</exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.ExtractWaveAs16Bit(NQualityOfLife.Sound.Wav)">
            <summary></summary>
            <param name="wav"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Sound.Wave16Bit"/> wave extracted and converted as needed from the <paramref name="wav"/></returns>
        </member>
        <member name="M:NQualityOfLife.Sound.Tools.ExtractWaveAs16Bit(System.Byte[])">
            <inheritdoc cref="M:NQualityOfLife.Sound.Tools.ExtractWaveAs16Bit(NQualityOfLife.Sound.Wav)"/>
        </member>
        <member name="T:NQualityOfLife.Sound.Player">
            <summary>Class for playing sounds</summary>
        </member>
        <member name="M:NQualityOfLife.Sound.Player.PlayWav(NQualityOfLife.Sound.Wave16Bit@)">
            <summary>Play a 16 bit sound wave</summary>
            <param name="wave"></param>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"><paramref name="wave"/> is null or empty!</exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Player.PlayWav(NQualityOfLife.IO.FilePath)">
            <summary>Play a .wav file loaded from disk</summary>
            <param name="wavFilePath">The path to the .wav file to load and play</param>
        </member>
        <member name="M:NQualityOfLife.Sound.Player.PlayWav(NQualityOfLife.Sound.Wav)">
            <summary>Play the given <paramref name="wav"/> audio</summary>
            <param name="wav"></param>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"><paramref name="wav"/> is <see langword="null"/> or empty</exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Player.PlaySineWave(NQualityOfLife.Units.Hertz@,NQualityOfLife.Units.Second@,NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary>Play a sine wave with the given <paramref name="frequency"/>, <paramref name="duration"/> and <paramref name="volume"/></summary>
            <param name="frequency"></param>
            <param name="duration"></param>
            <param name="volume">A <see cref="T:NQualityOfLife.Types.Ratio"/> of the maximum volume</param>
            <param name="sampleRate"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Player.PlaySquareWave(NQualityOfLife.Units.Hertz@,NQualityOfLife.Units.Second@,NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary>Play a square wave with the given <paramref name="frequency"/>, <paramref name="duration"/> and <paramref name="volume"/></summary>
            <param name="frequency"></param>
            <param name="duration"></param>
            <param name="volume">A <see cref="T:NQualityOfLife.Types.Ratio"/> of the maximum volume</param>
            <param name="sampleRate"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Sound.Player.PlayWhiteNoise(NQualityOfLife.Units.Second@,NQualityOfLife.Types.Ratio@,System.Int32)">
            <summary>Play random white noise for the given <paramref name="duration"/> and <paramref name="volume"/></summary>
            <param name="duration"></param>
            <param name="volume">A <see cref="T:NQualityOfLife.Types.Ratio"/> of the maximum volume</param>
            <param name="sampleRate"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.Settings">
            <summary>Home system settings (and some others)</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.Settings.HomeSystemEnabled">
            <summary>Is the home system enabled?</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.CompHomeSeparator">
            <summary>ThingComp for doors that can be used to toggle home separation</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility">
            <summary>Pawn homes</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility.HomeData">
            <summary>Contains all the family homes</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.HomeUtility.HomeData.Homes">
            <summary>List of all active homes</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility.HomeRoom">
            <summary>Contains data for HomeRooms</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.DeleteAllHomes(Verse.Map)">
            <summary>Delete all homes on the given map, or all homes on all maps</summary>
            <param name="map">The Map to limit the deletion to, if null: delete all</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.PrintHomes(Verse.Map)">
            <summary>Print all the homes of a given map to debug log, or all homes if map is not given</summary>
            <param name="map">Only print homes on this Map, if null: print all homes</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.GetPotentialNewHomeOwners(Verse.Map)">
            <summary>Get all pawns on a given map, who can be home owners that are not already owners</summary>
            <returns>A List of all pawns who can create a home</returns>
            <param name="map">The Map to use as a reference, will try to resolve if null, but should be given if possible</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToFillAllRooms(Verse.Map)">
            <summary>Attempt to fill all homes on the given map, or all homes on all maps</summary>
            <param name="map">Only this map, if null: on all maps</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToFillRooms(NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Attempt to add relatives of home owner to given home</summary>
            <param name="home">Try fill the rooms of this home</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.HomeID(Verse.Pawn)">
            <summary>Get the home id of the home this pawn is an occupant of</summary>
            <param name="pawn">Get the home id of this pawn</param>
            <returns>int?, null if not part of any home</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CanBeAHomeOwner(Verse.Pawn,System.Boolean,System.Boolean)">
            <summary>Is this pawn a valid pawn to be a home owner, same result even if already home owner</summary>
            <param name="pawn">Is this pawn a valid pawn to be a home owner</param>
            <param name="ignoreRelatives">Ignore the relative requirement</param>
            <param name="loversCountAsRelatives">Lovers count as relatives for the relative check</param>
            <returns>true if can be home owner</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToCreateAllHomes(Verse.Map,System.Boolean)">
            <summary>Try to create all valid homes on the given map, or on all maps</summary>
            <param name="map">Specific map to apply the method to, can be null</param>
            <param name="annexRooms">Should we attempt to annex all valid rooms after creation?</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToCreateHome(Verse.Map,System.Boolean,Verse.Room,System.Boolean,System.Boolean)">
            <summary>Try to create a home on the given map origination from a specific room, or any valid room</summary>
            <param name="map">The target map, cannot be null!</param>
            <param name="annexRooms">should we attempt to annex all valid rooms to the home?</param>
            <param name="specificRoom">Create the home starting from this specific room, if null, create in a valid room</param>
            <param name="forceCacheUpdate">Force cache updates?</param>
            <param name="ignoreRelatives"></param>
            <returns>bool true if succeeded in creating a home</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TransferHouseOwnershipFrom(Verse.Pawn,Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="newOwner"></param>
            <param name="home"></param>
            <returns>true if ownership was successfully transferred</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CouldBeAPublicHub(Verse.Room,Verse.Map)">
            <summary>Is the given room likely to be a public hallway that connects to multiple homes or public areas</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsDeadEndRoom(Verse.Room)">
            <summary>true if the given room only connects to one other room, door count doesn't matter, as long as they connect to the same room</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.WouldMergeHomes(Verse.Room,Verse.Map)">
            <summary>Would adding this room to a home make two homes touch? (separated only by 1 door)</summary>
            <param name="room"></param>
            <param name="map"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsValidRoomForAHome(Verse.Room,Verse.Map,System.Boolean,System.Boolean,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary></summary>
            <param name="room"></param>
            <param name="map"></param>
            <param name="mustBeBedroom"></param>
            <param name="simplifiedCheck"></param>
            <param name="isDoorway"></param>
            <param name="isPrison"></param>
            <param name="isProperRoom"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.ValidateAllHomes(Verse.Map)">
            <summary>Validate the data on all the homes on a map, or all homes on all maps. Attempts to fix any issues.</summary>
            <param name="map">The Map where we want to validate, if null: validate all</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.ValidateAllRoomsOfHome(NQualityOfLife.HomeSystem.HomeUtility.Home,Verse.Map)">
            <summary>Validate the data on all the rooms of a given home. Attempts to fix any issues.</summary>
            <param name="home">Validate this home</param>
            <param name="map">The Map where the home is located, should be given if possible.</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.AttemptToAnnexAllRooms(Verse.Map)">
            <summary>Attempt to annex all valid rooms to all homes</summary>
            <param name="map">The Map to affect, or all maps if null</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.AttemptToAnnexRoomsToHome(NQualityOfLife.HomeSystem.HomeUtility.Home,Verse.Map,System.Boolean)">
            <summary>Attempt to annex all valid rooms to a home</summary>
            <param name="home">try to add all valid rooms to this home</param>
            <param name="map"></param>
            <param name="forceCacheUpdate">force update caches?</param>
            <returns>bool of success</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CreateNewRoomData(Verse.Room,System.Boolean)">
            <summary></summary>
            <param name="room"></param>
            <param name="isBedroom"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsPartOfAnyHome(Verse.District)">
            <summary>Is the given room already a part of a home?</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsPartOfAnyHome(Verse.Room,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is the given room already a part of a home?</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf">
            <summary>ThoughtDefs related to family homes</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf.NQoL_SleptInAFamilyHome">
            <summary>The thought given to pawns upon sleeping in their own home</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf.NQoL_JoyActivityInImpressiveLivingRoom">
            <summary>The thought given to pawns after playing in their own living room</summary>
        </member>
        <member name="T:NQualityOfLife.Widgets_.Dwellings_Widget">
            <summary>Widget for debugging the animal dwellings</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.BitUtils.BitConcat(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Concatenate the given <see cref="T:System.Boolean">bools</see> such that '<paramref name="a"/>' is the leftmost bit of the returned <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <param name="a">0b_1000</param>
            <param name="b">0b_0100</param>
            <param name="c">0b_0010</param>
            <param name="d">0b_0001</param>
            <returns><see cref="T:NQualityOfLife.Types.Nibble"/> with the bits from the given <see cref="T:System.Boolean">bools</see></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.BitUtils.BitConcat(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Concatenate the given <see cref="T:System.Byte">bytes</see> such that '<paramref name="a"/>' is the leftmost part of the returned <see cref="T:System.UInt32"/></summary>
            <param name="a">0x_FF_00_00_00</param>
            <param name="b">0x_00_FF_00_00</param>
            <param name="c">0x_00_00_FF_00</param>
            <param name="d">0x_00_00_00_FF</param>
            <returns><see cref="T:System.UInt32"/> with the bits from the given <see cref="T:System.Byte">bytes</see></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.BitUtils.BitConcat(System.Byte,System.Byte)">
            <summary>Concatenate the given <see cref="T:System.Byte">bytes</see> such that '<paramref name="a"/>' is the leftmost part of the returned <see cref="T:System.UInt16"/></summary>
            <param name="a">0x_FF_00</param>
            <param name="b">0x_00_FF</param>
            <returns><see cref="T:System.UInt16"/> with the bits from the given <see cref="T:System.Byte">bytes</see></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.BitUtils.BitConcat(System.UInt16,System.UInt16)">
            <summary>Concatenate the given <see cref="T:System.UInt16">ushorts</see> such that '<paramref name="a"/>' is the leftmost part of the returned <see cref="T:System.UInt32"/></summary>
            <param name="a">0x_FF_FF_00_00</param>
            <param name="b">0x_00_00_FF_FF</param>
            <returns><see cref="T:System.UInt32"/> with the bits from the given <see cref="T:System.UInt16">ushorts</see></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.PrimitiveUtils">
            <summary>Utilitites for manipulating primitive value types</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.AsInt(System.Boolean)">
            <summary>Get the given <paramref name="boolean"/> as an integer of 1 or 0</summary>
            <param name="boolean">Get <see langword="this"/> <see cref="T:System.Boolean"/> as an <see cref="T:System.Int32"/></param>
            <returns><see cref="T:System.Int32"/> 1 if <paramref name="boolean"/> == <see langword="true"/><para><see cref="T:System.Int32"/> 0 if <paramref name="boolean"/> == <see langword="false"/></para></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.Bugged(System.Single)">
            <summary></summary>
            <param name="value"></param>
            <returns><see langword="true"/> if the <paramref name="value"/> is <see cref="F:System.Single.NaN"/>, <see cref="F:System.Single.MinValue"/>, <see cref="F:System.Single.MaxValue"/>, <see cref="F:System.Single.NegativeInfinity"/> <see langword="or"/> <see cref="F:System.Single.PositiveInfinity"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.CalculateFloat(System.Boolean,System.Byte,System.Int32)">
            <summary>Create a <see cref="T:System.Single"/> by giving the bit values</summary>
            <param name="signBit">1 bit
            <para>0 (<see langword="false"/>) is used to represent positive values, 1 (<see langword="true"/>) is used to represent negative values</para></param>
            <param name="exponentBits">8 bits - 0~255</param>
            <param name="mantissaBits">23 bits - 0~8_388_607</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="mantissaBits"/> value</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.CalculateDouble(System.Boolean,System.UInt16,System.Int64)">
            <summary>Create a <see cref="T:System.Double"/> by giving the bit values</summary>
            <param name="signBit"></param>
            <param name="exponentBits">0~2_047</param>
            <param name="mantissaBits">52 bits (13 bytes) 0~20282409603651670423947251286015</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="exponentBits"/> or <paramref name="mantissaBits"/> value</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.NextPossibleFloat(System.Single)">
            <summary>Get the next value bigger than '<paramref name="current"/>' that a <see cref="T:System.Single"/> can represent</summary>
            <param name="current">Get the next <see cref="T:System.Single"/> after <see langword="this"/> value</param>
            <returns>A <see cref="T:System.Single"/> that is larger than '<paramref name="current"/>' by the smallest possible amount</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.PrevPossibleFloat(System.Single)">
            <summary>Get the next value smaller than '<paramref name="current"/>' that a <see cref="T:System.Single"/> can represent</summary>
            <param name="current">Get the next <see cref="T:System.Single"/> after <see langword="this"/> value</param>
            <returns>A <see cref="T:System.Single"/> that is smaller than '<paramref name="current"/>' by the smallest possible amount</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.ApproxMaxFloatingPointErrorAtScale(System.Single)">
            <summary></summary>
            <param name="value"></param>
            <returns>A positive <see cref="T:System.Single"/> that represents the predicted maximum conversion error at the given magnitude</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsUint(System.Single)">
            <summary>Map the bits of the given <see cref="T:System.Single"/> into a <see cref="T:System.UInt32"/>, meaning the bits are not changed, only re-interpreted as a <see cref="T:System.UInt32"/> instead of an <see cref="T:System.Single"/></summary>
            <param name="f32">The <see cref="T:System.Single"/> to be re-interpreted as a <see cref="T:System.UInt32"/></param>
            <returns>a <see cref="T:System.UInt32"/> with a value indicated by the bits of the given <see cref="T:System.Single"/></returns>
            <remarks>This operation can be reversed with '<see cref="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsFloat(System.UInt32)"/>'
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsInt(System.Single)">
            <summary>Map the bits of the given <see cref="T:System.Single"/> into a <see cref="T:System.Int32"/>, meaning the bits are not changed, only re-interpreted as a <see cref="T:System.Int32"/> instead of an <see cref="T:System.Single"/></summary>
            <param name="f32">The <see cref="T:System.Single"/> to be re-interpreted as a <see cref="T:System.Int32"/></param>
            <returns>a <see cref="T:System.Int32"/> with a value indicated by the bits of the given <see cref="T:System.Single"/></returns>
            <remarks>This operation can be reversed with '<see cref="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsFloat(System.Int32)"/>'
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsFloat(System.UInt32)">
            <summary>Map the bits of the given <see cref="T:System.UInt32"/> into a <see cref="T:System.Single"/>, meaning the bits are not changed, only re-interpreted as a <see cref="T:System.Single"/> instead of an <see cref="T:System.UInt32"/></summary>
            <param name="ui32">The <see cref="T:System.UInt32"/> to be re-interpreted as a <see cref="T:System.Single"/></param>
            <returns>a <see cref="T:System.Single"/> with a value indicated by the bits of the given <see cref="T:System.UInt32"/></returns>
            <remarks>This operation can be reversed with '<see cref="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsUint(System.Single)"/>'
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsFloat(System.Int32)">
            <summary>Map the bits of the given <see cref="T:System.Int32"/> into a <see cref="T:System.Single"/>, meaning the bits are not changed, only re-interpreted as a <see cref="T:System.Single"/> instead of an <see cref="T:System.Int32"/></summary>
            <param name="i32">The <see cref="T:System.Int32"/> to be re-interpreted as a <see cref="T:System.Single"/></param>
            <returns>a <see cref="T:System.Single"/> with a value indicated by the bits of the given <see cref="T:System.Int32"/></returns>
            <remarks>This operation can be reversed with '<see cref="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsInt(System.Single)"/>'
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsDouble(System.Int64)">
            <summary>Map the bits of the given <see cref="T:System.Int64"/> into a <see cref="T:System.Double"/>, meaning the bits are not changed, only re-interpreted as a <see cref="T:System.Double"/> instead of an <see cref="T:System.Int64"/></summary>
            <param name="i64">The <see cref="T:System.Int64"/> to be re-interpreted as a <see cref="T:System.Double"/></param>
            <returns>a <see cref="T:System.Double"/> with a value indicated by the bits of the given <see cref="T:System.Int64"/></returns>
            <remarks>This operation can be reversed with '<see cref="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsLong(System.Double)"/>'
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsDouble(System.UInt64)">
            <summary>Map the bits of the given <see cref="T:System.UInt64"/> into a <see cref="T:System.Double"/>, meaning the bits are not changed, only re-interpreted as a <see cref="T:System.Double"/> instead of an <see cref="T:System.UInt64"/></summary>
            <param name="ui64">The <see cref="T:System.UInt64"/> to be re-interpreted as a <see cref="T:System.Double"/></param>
            <returns>a <see cref="T:System.Double"/> with a value indicated by the bits of the given <see cref="T:System.UInt64"/></returns>
            <remarks>This operation can be reversed with '<see cref="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsUlong(System.Double)"/>'
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsLong(System.Double)">
            <summary>Map the bits of the given <see cref="T:System.Double"/> into a <see cref="T:System.Int64"/>, meaning the bits are not changed, only re-interpreted as a <see cref="T:System.Int64"/> instead of an <see cref="T:System.Double"/></summary>
            <param name="f64">The <see cref="T:System.Double"/> to be re-interpreted as a <see cref="T:System.Int64"/></param>
            <returns>a <see cref="T:System.Int64"/> with a value indicated by the bits of the given <see cref="T:System.Double"/></returns>
            <remarks>This operation can be reversed with '<see cref="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsDouble(System.Int64)"/>'
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsUlong(System.Double)">
            <summary>Map the bits of the given <see cref="T:System.Double"/> into a <see cref="T:System.UInt64"/>, meaning the bits are not changed, only re-interpreted as a <see cref="T:System.UInt64"/> instead of an <see cref="T:System.Double"/></summary>
            <param name="f64">The <see cref="T:System.Double"/> to be re-interpreted as a <see cref="T:System.UInt64"/></param>
            <returns>a <see cref="T:System.UInt64"/> with a value indicated by the bits of the given <see cref="T:System.Double"/></returns>
            <remarks>This operation can be reversed with '<see cref="M:NQualityOfLife.Utils.PrimitiveUtils.RemappedAsDouble(System.UInt64)"/>'
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.Common">
            <summary>Common utility methods</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.Strings">
            <summary>Commonly used strings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.Redacted">
            <summary>Used to replace user names or other sensitive info from log messages etc..</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.NullSymbol">
            <summary>Used to represent a <see langword="null"/> value in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">
            <summary>Used to represent a <see langword="null"/> value in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">
            <summary>Used to represent an <seealso cref="F:System.String.Empty">empty</seealso> <see cref="T:System.String"/> or collection or a nil <see cref="T:System.Char"/> in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.EmptySymbolForceLowerCase">
            <summary>Used to represent an <seealso cref="F:System.String.Empty">empty</seealso> <see cref="T:System.String"/> in log messages etc...</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Common.Strings.NewLine">
            <summary>The new line symbol <see cref="T:System.String"/> for the current Environment/OS</summary>
            <remarks><see cref="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.OSDependant"/></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.DegreeSymbol">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.DegreesCelsius">
            <summary>C</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.Micro">
            <inheritdoc cref="F:NQualityOfLife.Utils.Common.Chars.Micro"/>
        </member>
        <member name="P:NQualityOfLife.Utils.Common.Strings.WalkingDots">
            <summary>Get a <see cref="T:System.String"/> of dots that iterates through '.' -> '..' -> '...' and repeats at a constant rate<para>Intended to be used in loading animations for async tasks</para></summary>
            <remarks><seealso cref="T:NQualityOfLife.Attributes.ImpureAttribute">Impure</seealso></remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.Chars">
            <summary><see cref="T:System.Char"/> constants etc</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.Micro">
            <summary>'u' with the tail</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.NullSymbol">
            <summary>Used to represent a <see langword="null"/> value</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.EmptySymbol">
            <summary>Symbol for representing an empty <see cref="T:System.String"/> or <see cref="T:System.Collections.Generic.ICollection`1"/>, '' - looks like an inverted 3 or fancy E</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.RegularSpace">
            <summary>The standard white space <see cref="T:System.Char"/> - space bar key</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.EmptyChar">
            <summary>Kind of like the <see langword="null"/> value for <see cref="T:System.Char"/>s</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.NibbleSeperator">
            <summary>The <see cref="T:System.Char"/> used to separate <see cref="T:NQualityOfLife.Types.Nibble">nibbles</see> in binary <see cref="T:System.String">strings</see> such as: "1011_0010"</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.BitTrueChar">
            <summary>The <see cref="T:System.Char"/> used to represent a <see langword="true"/>/1 in binary <see cref="T:System.String">strings</see> such as: "1011_0010"</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.BitFalseChar">
            <summary>The <see cref="T:System.Char"/> used to represent a <see langword="false"/>/0 in binary <see cref="T:System.String">strings</see> such as: "1011_0010"</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.NumericChars">
            <summary>All the arabic numerals <see cref="T:System.Char"/>s (0~9)</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DaysInYear">
            <summary>Days in an in game year (RimWorld)</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.TicksInGameDay">
            <summary>Ticks in an in game day (RimWorld)</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.TicksInGameHour">
            <summary>Ticks in an in game hour (RimWorld)</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.TicksInGameMinute">
            <summary>Ticks in an in game minute (RimWorld) ~= 41.666f...</summary>
            <remarks>41.666f...</remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.TicksInGameSecond">
            <summary>Ticks in an in game second (RimWorld) ~= 0.6944444f...</summary>
            <remarks>0.6944444f...</remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.TicksSecondNormalSpeed">
            <summary>How many ticks pass in one second of gameplay at 1x speed (RimWorld)</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.SecondsInDay">
            <summary>How many (real life) seconds is in one in game day at 1x speed (RimWorld)</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.BaseMalnutritionSeverityPerDay">
            <summary>How much the malnutrition hediff severity rises per day (RimWorld)</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AppendAction(System.Action,System.Action)">
            <summary></summary>
            <param name="firstAction"></param>
            <param name="secondAction"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Action"/> that is a combination of the <paramref name="firstAction"/> and <paramref name="secondAction"/> || or <paramref name="secondAction"/> directly if <paramref name="firstAction"/> is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IsNullOrEmpty``1(System.Nullable{``0}@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.TryParse(System.Char,System.Int32@)">
            <summary>Try parse the <paramref name="c"/> as an <see langword="int"/></summary>
            <remarks>The <see cref="T:System.Char"/> must be a number '0~9' or letter 'A~F' to be successfully parsed
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
            <param name="c">character</param><param name="i">integer <see langword="out"/></param>
            <returns><see langword="true"/> if successfully parsed the <see cref="T:System.Char"/> to <see cref="T:System.Int32"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.TryParse(System.Int32,System.Char@)">
            <summary>Try parse the <paramref name="i"/> as an <see langword="char"/></summary>
            <remarks>The <see cref="T:System.Int32"/> must be a number '0~15' to be successfully parsed, numbers 10~15 will be parsed to the corresponding hexadecimal letter
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
            <param name="c">character <see langword="out"/></param><param name="i">integer</param>
            <returns><see langword="true"/> if successfully parsed the <see cref="T:System.Int32"/> to <see cref="T:System.Char"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSet(System.Byte,System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSet(NQualityOfLife.Settings.NQualityOfLife_Mod.ClearAllExcept,NQualityOfLife.Settings.NQualityOfLife_Mod.ClearAllExcept)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSet(NQualityOfLife.World.NQoL_World_Object_Comp.WantedBuild,NQualityOfLife.World.NQoL_World_Object_Comp.WantedBuild)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AnyFlagIsSet(NQualityOfLife.World.NQoL_World_Object_Comp.WantedBuild,NQualityOfLife.World.NQoL_World_Object_Comp.WantedBuild)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AnyFlagIsSet(NQualityOfLife.Weapons.Comps.WeaponComp.CacheState,NQualityOfLife.Weapons.Comps.WeaponComp.CacheState)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.UnsetFlags(NQualityOfLife.Weapons.Comps.WeaponComp.CacheState,NQualityOfLife.Weapons.Comps.WeaponComp.CacheState)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSet(Verse.WorkTags,Verse.WorkTags)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AnyFlagIsSet(Verse.WorkTags,Verse.WorkTags)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSet(Verse.Gender,Verse.Gender)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AnyFlagIsSet(Verse.Gender,Verse.Gender)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AnyFlagIsSet(NQualityOfLife.Weapons.WeaponType,NQualityOfLife.Weapons.WeaponType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSet(NQualityOfLife.Weapons.WeaponType,NQualityOfLife.Weapons.WeaponType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSet(NQualityOfLife.Types.MouseButtons,NQualityOfLife.Types.MouseButtons)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AnyFlagIsSet(NQualityOfLife.Types.MouseButtons,NQualityOfLife.Types.MouseButtons)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.UnsetFlags(NQualityOfLife.Types.MouseButtons,NQualityOfLife.Types.MouseButtons)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.LeftMouse(NQualityOfLife.Types.MouseButtons)">
            <summary></summary>
            <param name="buttons"></param>
            <returns><see langword="true"/> if the '<see cref="F:NQualityOfLife.Types.MouseButtons.Left"/>' flag is set</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)">
            <summary>Method for checking <seealso cref="T:System.FlagsAttribute">flags</seealso> in an <see cref="T:System.Enum"/>
            <para>It is recommended to create and use a non-generic version of this method for each enum for performance reasons<para>Example implementation: ((<paramref name="mode"/> &amp; <paramref name="flags"/>) == <paramref name="flags"/>)</para></para></summary>
            <typeparam name="TEnum"></typeparam>
            <param name="mode"></param>
            <param name="flags">The <seealso cref="T:System.FlagsAttribute">flags</seealso> to to check for</param>
            <returns><see langword="true"/> if all the <b>given</b> <paramref name="flags"/> are set in <paramref name="mode"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)">
            <summary>Method for checking if any of the given <seealso cref="T:System.FlagsAttribute">flags</seealso> are set in an <see cref="T:System.Enum"/>
            <para>It is recommended to create and use a non-generic version of this method for each enum for performance reasons<para>Example implementation: ((<paramref name="mode"/> &amp; <paramref name="flags"/>) &gt; 0)</para></para></summary>
            <typeparam name="TEnum"></typeparam>
            <param name="mode"></param>
            <param name="flags">The <seealso cref="T:System.FlagsAttribute">flags</seealso> to check for</param>
            <returns><see langword="true"/> if any of the given <paramref name="flags"/> are set in <paramref name="mode"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0@)">
            <summary>Method for un-setting <seealso cref="T:System.FlagsAttribute">flags</seealso> in an <see cref="T:System.Enum"/>
            <para>It is recommended to create and use a non-generic version of this method for each enum for performance reasons<para>Example implementation: (<paramref name="mode"/> &amp; ~<paramref name="flags"/>)</para></para></summary>
            <typeparam name="TEnum"></typeparam>
            <param name="mode"></param>
            <param name="flags">The <seealso cref="T:System.FlagsAttribute">flags</seealso> to un-set</param>
            <returns><see cref="T:System.UInt64"/> of the new value <para>to convert it back to <typeparamref name="TEnum"/> you can do something like this: '<paramref name="mode"/> = (<typeparamref name="TEnum"/>)<paramref name="mode"/>.UnsetFlagsGeneric(<typeparamref name="TEnum"/>.SomeFlag)'</para></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatDate(System.DateTime@)">
            <summary>Formats the given date in the format: DD.MM.YYYY</summary>
            <param name="dateTime"></param>
            <returns>DD.MM.YYYY <see cref="T:System.String"/></returns>
            <remarks>If you want to include a specific time of day; use: '<see cref="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.DateTime@)"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.ReverseFormatDate(System.String)">
            <summary>Gets the <see cref="T:System.DateTime"/> from a: DD.MM.YYYY / DD:MM:YYYY <see cref="T:System.String"/></summary>
            <param name="dateString">a date <see cref="T:System.String"/> formatted as: DD.MM.YYYY or DD:MM:YYYY</param>
            <returns><see cref="T:System.DateTime"/> from the DD.MM.YYYY <see cref="T:System.String"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.FormatException"></exception>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.IFormatMode">
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
            <inheritdoc cref="T:NQualityOfLife.Utils.Common.IFormatMode`1"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode.DisplayFormatFor(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary>Format <see langword="this"/> according to the <paramref name="displayMode"/> - <see cref="F:NQualityOfLife.Utils.Common.DisplayMode.Default"/> should use <see cref="M:System.Object.ToString"/></summary>
            <param name="displayMode"></param>
            <returns>The formatted <see cref="T:System.String"/> representation of <see langword="this"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode.ToStringShortName">
            <summary></summary>
            <returns>A <see cref="T:System.String"/> that is the 'short name' representation of <see langword="this"/></returns>
            <remarks>For example <see cref="T:System.IO.DirectoryInfo"/> may return <see cref="P:System.IO.DirectoryInfo.Name"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode.ToStringLongName">
            <summary></summary>
            <returns>A <see cref="T:System.String"/> that is the 'long name' representation of <see langword="this"/></returns>
            <remarks>For example <see cref="T:System.IO.DirectoryInfo"/> may return <see cref="P:System.IO.DirectoryInfo.FullName"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode.ToStringID">
            <summary>Get an identifier <see cref="T:System.String"/> for <see langword="this"/></summary>
            <returns>An unique id <see cref="T:System.String"/> of this instance</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.IFormatMode`1">
            <remarks>Implements <see cref="T:NQualityOfLife.Utils.Common.IFormatMode"/> &lt;- <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
            <summary>Interface for formatting the given <see cref="T:System.Type"/> '<typeparamref name="T"/>' instance to a <see cref="T:System.String"/></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> that implements <see cref="T:NQualityOfLife.Utils.Common.IFormatMode`1"/></typeparam>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.DisplayFormatFor(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary>Format <see langword="this"/> '<typeparamref name="T"/>' according to the <paramref name="displayMode"/> - <see cref="F:NQualityOfLife.Utils.Common.DisplayMode.Default"/> should use <see cref="M:System.Object.ToString"/></summary>
            <param name="displayMode"></param>
            <returns>The formatted <see cref="T:System.String"/> representation of '<typeparamref name="T"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.ToStringShortName">
            <summary></summary>
            <returns>A <see cref="T:System.String"/> that is the 'short name' representation of '<typeparamref name="T"/>'</returns>
            <remarks>For example <see cref="T:System.IO.DirectoryInfo"/> may return <see cref="P:System.IO.DirectoryInfo.Name"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.ToStringLongName">
            <summary></summary>
            <returns>A <see cref="T:System.String"/> that is the 'long name' representation of '<typeparamref name="T"/>'</returns>
            <remarks>For example <see cref="T:System.IO.DirectoryInfo"/> may return <see cref="P:System.IO.DirectoryInfo.FullName"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.ToStringID">
            <summary>Get an identifier <see cref="T:System.String"/> for <see langword="this"/> '<typeparamref name="T"/>'</summary>
            <returns>An unique id <see cref="T:System.String"/> of this <typeparamref name="T"/> instance</returns>
            <remarks>Can be for example the <see langword="nameof"/>(<typeparamref name="T"/>) + <see cref="M:System.Object.GetHashCode"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.FormatMode">
            <summary>The way that the a collection should be formatted</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.VerticalWithLines">
            <summary><list type="table"><listheader></listheader><item><term></term> a</item><item><term></term> b</item><item><term></term> c</item></list></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.HorizontalWithCommas">
            <summary>a, b, c</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.VerticalNumbered">
            <summary><list type="number"><listheader></listheader><item>a</item><item>b</item><item>c</item></list></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.HorizontalWithArrows">
            <summary>a -> b -> c</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.VerticalLineBreakOnly">
            <summary><list type=""><listheader></listheader><item>a</item><item>b</item><item>c</item></list></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.HorizontalWithPipes">
            <summary>a | b | c</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.VerticalNumberedIndex0">
            <summary><list type=""><listheader></listheader><item>0. a</item><item>1. b</item><item>2. c</item></list></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.HorizontalWithSpaces">
            <summary>a b c</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.FormatMode.HorizontalWithArrowsReversed">
            <summary>a &lt;- b &lt;- c</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AnyFlagIsSet(NQualityOfLife.Utils.Common.DisplayModeFlags,NQualityOfLife.Utils.Common.DisplayModeFlags@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FlagsAreSet(NQualityOfLife.Utils.Common.DisplayModeFlags,NQualityOfLife.Utils.Common.DisplayModeFlags@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.UnsetFlags(NQualityOfLife.Utils.Common.DisplayModeFlags,NQualityOfLife.Utils.Common.DisplayModeFlags@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0@)"/>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.DisplayModeFlags">
            <summary></summary>
            <remarks><see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/> can be easily converted to <see cref="T:NQualityOfLife.Utils.Common.DisplayMode"/> by simply casting it: 'var mode = (<see cref="T:NQualityOfLife.Utils.Common.DisplayMode"/>)flags;'</remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.Default">
            <summary><see cref="M:System.Object.ToString"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.ShortName">
            <summary>A short identifier/name of the item</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.LongName">
            <summary>Display a long / full name <see cref="T:System.String"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.LabelIfPossible">
            <summary>Display the user facing label if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.IDIfPossible">
            <summary>Display the unique id of the item if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.UseDeterministicColors">
            <summary>Should the <see cref="T:System.String"/> be colored before appending it to the final result?</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.DisplayMode">
            <summary></summary>
            <remarks><see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/> can be easily converted to <see cref="T:NQualityOfLife.Utils.Common.DisplayMode"/> by simply casting it: 'var mode = (<see cref="T:NQualityOfLife.Utils.Common.DisplayMode"/>)flags;'</remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.Default">
            <summary><see cref="M:System.Object.ToString"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.ShortName">
            <summary>A short identifier/name of the item</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.LongName">
            <summary>Display a long / full name <see cref="T:System.String"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.LabelIfPossible">
            <summary>Display the user facing label if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.IDIfPossible">
            <summary>Display the unique id of the item if possible</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatAsString``1(System.Collections.Generic.IList{System.Collections.Generic.IList{``0}},NQualityOfLife.Utils.Common.DisplayModeFlags)">
            <summary>Format an array '<typeparamref name="T"/>[][]' or a list of lists as a <see cref="T:System.String"/></summary>
            <typeparam name="T"></typeparam>
            <param name="listOfLists"></param>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatAsString``1(System.Collections.Generic.IList{``0},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})">
            <summary>Format the <paramref name="iList"/> as a <see cref="T:System.String"/> using the provided <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/> and <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="formatMode">Controls how the <paramref name="iList"/> is formatted, such as vertical or horizontal</param>
            <param name="displayMode"></param>
            <param name="specialFormatter">Format the items (<typeparamref name="T"/>) in the <paramref name="iList"/> using this <see cref="T:System.Func`2"/> instead</param>
            <param name="specialSuffixMaker"></param>
            <returns>A <see cref="T:System.String"/> representation of the <paramref name="iList"/> and the contained items (<typeparamref name="T"/>)</returns>
            <remarks>The <paramref name="specialFormatter"/> overrides default and custom formatters<para>Custom formatters for unsupported types (<typeparamref name="T"/>) can be added using <see cref="M:NQualityOfLife.Utils.Common.AddCustomFormatterForType``1(System.Func{``0,NQualityOfLife.Utils.Common.DisplayModeFlags,System.String})"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatAsString(System.Collections.IEnumerable,NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FormatAsString``1(System.Collections.Generic.IEnumerable{``0},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatAsString``2(System.Collections.Generic.IDictionary{``0,``1},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags)">
            <summary>Format the <paramref name="dictionary"/> as a <see cref="T:System.String"/> using the provided <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/> and <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="formatMode"></param>
            <param name="displayMode"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FormatAsString``1(System.Collections.Generic.IList{``0},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatAsString``1(System.Collections.Generic.IEnumerable{``0},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FormatAsString``1(System.Collections.Generic.IList{``0},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatListAsStringFinal``1(System.Collections.Generic.IList{``0},System.Boolean,System.UInt32,System.String,System.String,System.Boolean,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})">
            <summary>Formats all the items in the <paramref name="list"/> into a <see cref="T:System.Text.StringBuilder"/> and uses <see cref="M:NQualityOfLife.Utils.Common.Finalize(System.Text.StringBuilder,System.String,System.Boolean)"/> on it, and returns the resulting <see cref="T:System.String"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="useNumber"></param>
            <param name="c"></param>
            <param name="lineStart"></param>
            <param name="lineEnd"></param>
            <param name="trimLineEndFromLastItem"></param>
            <param name="displayMode"></param>
            <param name="specialFormatter"></param>
            <param name="specialSuffix"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatListAsStringFinal(System.Collections.IEnumerable,System.Boolean,System.UInt32,System.String,System.String,System.Boolean,NQualityOfLife.Utils.Common.DisplayModeFlags)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FormatListAsStringFinal``1(System.Collections.Generic.IList{``0},System.Boolean,System.UInt32,System.String,System.String,System.Boolean,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatItem``1(``0,System.Text.StringBuilder@,System.Boolean,System.UInt32@,System.String,System.String,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})">
            <summary>Add the <paramref name="item"/> to the <paramref name="builder"/> using the best found formatter</summary>
            <typeparam name="T"></typeparam>
            <param name="item"></param>
            <param name="builder"></param>
            <param name="useNumber"></param>
            <param name="c"></param>
            <param name="lineStart"></param>
            <param name="lineEnd"></param>
            <param name="displayMode"></param>
            <param name="specialFormatter"></param>
            <param name="specialSuffix"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatItemString``1(System.String,``0,System.Text.StringBuilder@,System.Boolean,System.UInt32@,System.String,System.String,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="displayedString"></param>
            <param name="item"></param>
            <param name="builder"></param>
            <param name="useNumber"></param>
            <param name="c"></param>
            <param name="lineStart"></param>
            <param name="lineEnd"></param>
            <param name="displayMode"></param>
            <param name="specialSuffix"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.Finalize(System.Text.StringBuilder,System.String,System.Boolean)">
            <summary>Turns the <paramref name="builder"/> into a <see cref="T:System.String"/> and does final formatting steps</summary>
            <param name="builder"></param>
            <param name="lineEnd"></param>
            <param name="trimLineEndFromLastItem"></param>
            <returns>The final <see cref="T:System.String"/> representation of the list we are formatting</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> is <see langword="null"/></exception>
        </member>
        <member name="F:NQualityOfLife.Utils.Common._customFormatters">
            <summary>Custom formatters added during runtime</summary>
            <remarks><see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/NQualityOfLife.Utils.Common.AddCustomFormatterForType"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.AddCustomFormatterForType``1(System.Func{``0,NQualityOfLife.Utils.Common.DisplayModeFlags,System.String})">
            <summary>Add a custom <paramref name="formatter"/> for the given <see cref="T:System.Type"/> (<typeparamref name="T"/>)<para>This formatter is then used in the <see cref="M:NQualityOfLife.Utils.Common.FormatAsString``1(System.Collections.Generic.IList{``0},NQualityOfLife.Utils.Common.FormatMode,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String},System.Func{``0,System.String})"/> method among others</para></summary>
            <typeparam name="T"></typeparam>
            <param name="formatter"><see cref="T:System.Object"/> can be <see langword="null"/>, the <paramref name="formatter"/> must not return <see langword="null"/></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="formatter"/> is <see langword="null"/></exception>
            <remarks>Note that if the <see cref="T:System.Type"/> (<typeparamref name="T"/>) implements <see cref="T:NQualityOfLife.Utils.Common.IFormatMode`1"/>, That implementation supersedes the custom formatter<para>Wiki: <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/NQualityOfLife.Utils.Common.AddCustomFormatterForType"/></para></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.AddOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.DisplayFormatFor``1(``0,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String})">
            <summary>Format the item '<typeparamref name="T"/>' to a <see cref="T:System.String"/> according to the given <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/>, <paramref name="specialFormatter"/> or a <seealso cref="F:NQualityOfLife.Utils.Common._customFormatters">custom formatter</seealso> if one exists for the type (<typeparamref name="T"/>)</summary>
            <param name="t"></param>
            <param name="displayMode"></param>
            <param name="specialFormatter">Use this <see cref="T:System.Func`2"/> to specify how <typeparamref name="T"/> is formatted, or leave <see langword="null"/> to use the best found formatter</param>
            <remarks>If the given <see cref="T:System.Type"/> (<typeparamref name="T"/>) implements <see cref="T:NQualityOfLife.Utils.Common.IFormatMode`1"/>, that implementation is used, unless overridden by the <paramref name="specialFormatter"/></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.DisplayFormatFor``1(``0,NQualityOfLife.Utils.Common.DisplayModeFlags)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.DisplayFormatFor``1(``0,NQualityOfLife.Utils.Common.DisplayModeFlags)">
            <summary>Format the item '<typeparamref name="T"/>' to a <see cref="T:System.String"/> according to the given <see cref="T:NQualityOfLife.Utils.Common.DisplayModeFlags"/> using one of the defined formatters</summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="displayMode"></param>
            <returns>The <see cref="T:System.String"/> representation of the item (<typeparamref name="T"/>) <paramref name="t"/></returns>
            <remarks>If the given <see cref="T:System.Type"/> (<typeparamref name="T"/>) implements <see cref="T:NQualityOfLife.Utils.Common.IFormatMode`1"/>, that implementation is used
            <para>Else uses a <seealso cref="F:NQualityOfLife.Utils.Common._customFormatters">custom formatter</seealso> if one exists for the type (<typeparamref name="T"/>)</para>
            <para>Else uses a predefined formatter if one exists</para>
            <para>Else returns <see cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/></para></remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.CharExtensions">
            <summary>Utilities for <see langword="char"/>s</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.Unicode(System.Char)">
            <summary>Get the unicode of this <paramref name="character"/> as a <see cref="T:System.String"/></summary>
            <param name="character"></param>
            <returns>An unicode <see cref="T:System.String"/> such as "(U+0065)"</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.AsString(System.Char[])">
            <summary>Convert the array of <see cref="T:System.Char"/> into a <see langword="new"/> <see cref="T:System.String"/></summary>
            <param name="chars"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> created from the <paramref name="chars"/> in order</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.Increment(System.Char)">
            <summary>Increment the <see langword="char"/> as if it was an <see langword="int"/>, if the new value is >= 10, returns '0'</summary>
            <remarks>The input <see langword="char"/> must be one of the numbers 0~9</remarks>
            <param name="c">Must be an integer character</param>
            <returns>'0'->'1' | '9'->'0' | '8'->'9'</returns>
            <exception cref="T:System.ArgumentException">The given <see cref="T:System.Char"/> cannot be parsed as <see cref="T:System.Int32"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ToUpper(System.Char)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.Char.ToUpperInvariant(System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ToChar(System.Int32,System.Char)">
            <summary>Returns the corresponding <see cref="T:System.Char"/> for the given <see cref="T:System.Int32"/>, Accepts inputs in the '0 - 9' range! || 10-15 will return the corresponding hex letter</summary>
            <param name="i"><see cref="T:System.Int32"/> in the '0 - 9' range</param>
            <param name="fallBackChar">In case of a failed conversion, use this <see cref="T:System.Char"/></param>
            <returns>'<see cref="T:System.Int32"/> 0 -> <see cref="T:System.Char"/> '0'', '<see cref="T:System.Int32"/> 9 -> <see cref="T:System.Char"/> '9'', '<see cref="T:System.Int32"/> 15 -> <see cref="T:System.Char"/> 'F'', returns '<paramref name="fallBackChar"/>' if input is out of range.</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ToChar(System.Int32,System.Boolean,System.Char)">
            <summary>Returns the corresponding <see cref="T:System.Char"/> for the given <see cref="T:System.Int32"/>, Accepts inputs in the '0 - 9' range! || 10-15 will return the corresponding hex letter</summary>
            <param name="i"><see cref="T:System.Int32"/> in the '0 - 9' range</param>
            <param name="errorOnFail">Log error on fail before returning '<paramref name="fallBackChar"/>'?</param>
            <param name="fallBackChar">In case of a failed conversion, use this <see cref="T:System.Char"/></param>
            <returns>'<see cref="T:System.Int32"/> 0 -> <see cref="T:System.Char"/> '0'', '<see cref="T:System.Int32"/> 9 -> <see cref="T:System.Char"/> '9'', '<see cref="T:System.Int32"/> 15 -> <see cref="T:System.Char"/> 'F'', returns '<paramref name="fallBackChar"/>' if input is out of range.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="i"/> is not in the valid range</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ToInt(System.Char,System.Boolean,System.Int32)">
            <summary>Returns the corresponding <see cref="T:System.Int32"/> for the given <see cref="T:System.Char"/>, Accepts inputs in the '0 - 9' and 'A - F' range!</summary>
            <param name="c"><see cref="T:System.Char"/> in the '0 - 9' range</param>
            <param name="errorOnFail">Log error on fail before returning <paramref name="fallBackInt"/>?</param>
            <param name="fallBackInt"></param>
            <returns>'<see cref="T:System.Char"/> '0' -> <see cref="T:System.Int32"/> 0', '<see cref="T:System.Char"/> '9' -> <see cref="T:System.Int32"/> 9', '<see cref="T:System.Char"/> 'A/a' -> <see cref="T:System.Int32"/> 10', '<see cref="T:System.Char"/> 'F/f' -> <see cref="T:System.Int32"/> 15', returns '<paramref name="fallBackInt"/>' if input is out of range.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ByteToHexLetter(System.Byte)">
            <summary>Returns the corresponding hex symbol for the given <see cref="T:NQualityOfLife.Types.Nibble"/>, Accepts inputs in the '0 - 15' range!</summary>
            <param name="nibble">byte in the '0 - 15' range</param>
            <returns>'((<see cref="T:System.Byte"/>)0) -> ((<see cref="T:System.Char"/>)'0')', '((<see cref="T:System.Byte"/>)15) -> ((<see cref="T:System.Char"/>)'F')'</returns>
            <remarks>Letters are returned in upper case</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.HexCodeToByte(System.String)">
            <summary>Input must be a string with a length of 2, such as 'F2' or '5F'</summary>
            <param name="hexCode">Must be 'FF', '0A', 'A2', '01', '00' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.HexToByte(System.ValueTuple{System.Char,System.Char}@)">
            <summary>Converts the given 2 letter hex code to its byte value</summary>
            <param name="hex">Must be 'FF', 'F0', '1A', '51', 'AB' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.HexToByte(System.Char,System.Char)">
            <summary>Converts the given 2 letter hex code to its byte value</summary>
            <param name="bigger">Must be 'F', '0', 'A', '1', 'B' etc</param>
            <param name="smaller">The less significant letter, Must be 'F', '0', 'A', '1', 'B' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.HexLetterToByte(System.Char,System.Byte)">
            <summary>Convert the given <paramref name="hexLetter"/> <see cref="T:System.Char"/> to its corresponding value</summary>
            <param name="hexLetter">A single hex letter, from 0 -> 9 -> A -> F<para>Letters can be upper case or lower case</para></param>
            <param name="pos">Must be 0 or 1<para>where 0 is the least significant (0~15)</para><para>and 1 is the most significant</para></param>
            <returns>The value of the letter for the given position, for example 'F' pos '0' -> '15' and 'F' pos '1' -> '240'</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.HexLetterToByte(System.Char)">
            <summary></summary>
            <param name="nibble">0~9 / A~F<para>Upper case and lowercase letters are both allowed</para></param>
            <returns>The value represented by the given <seealso href="https://en.wikipedia.org/wiki/Hexadecimal">Hexadecimal</seealso> <see cref="T:System.Char"/> (0~15)</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ByteToHexCode(System.Byte)">
            <summary>Converts a byte value into its corresponding hex code. Such as: '255 -> FF'</summary>
            <param name="b">byte to convert '255 -> FF'</param>
            <returns>a hex code such as 'FF' 'AB' 'F4' etc</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.ByteToHex(System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Utils.CharExtensions.ByteToHexCode(System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsStandardLatinLowercaseLetter(System.Char)">
            <summary>Check if the <paramref name="letterChar"/> is a standard latin ascii lowercase letter (a~z)</summary>
            <param name="letterChar"></param>
            <returns><see langword="true"/> if the '<paramref name="letterChar"/>' is one of the 'a~z' lowercase letter chars</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsStandardLatinUppercaseLetter(System.Char)">
            <summary>Check if the <paramref name="letterChar"/> is a standard latin ascii uppercase letter (A~Z)</summary>
            <param name="letterChar"></param>
            <returns><see langword="true"/> if the '<paramref name="letterChar"/>' is one of the 'A~Z' uppercase letter chars</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsStandardLatinLetter(System.Char)">
            <summary>Check if the <paramref name="letterChar"/> is a standard latin ascii letter (A~Z, a~z)</summary>
            <param name="letterChar"></param>
            <returns><see langword="true"/> if the '<paramref name="letterChar"/>' is one of the 'A~Z, a~z' letter chars</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsStandardLatinNumber(System.Char)">
            <summary>Check if the <paramref name="numChar"/> is a standard latin ascii number (0~9)</summary>
            <param name="numChar"></param>
            <returns><see langword="true"/> if the '<paramref name="numChar"/>' is one of the '0~9' number chars</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsStandardLatinChar(System.Char)">
            <summary>Check if the <paramref name="character"/> is a standard latin ascii letter (A~Z, a~z) or number (0~9)</summary>
            <param name="character"></param>
            <returns><see langword="true"/> if the '<paramref name="character"/>' is one of the 'A~Z, a~z' letter or '0~9' number chars</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsValidHexLetter(System.Char)">
            <summary>Check if the <paramref name="letter"/> is a valid hexadecimal letter</summary>
            <param name="letter"></param>
            <returns><see langword="true"/> if the <paramref name="letter"/> is a valid hexadecimal letter (0~9, a~f, A~F)</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsControlCharacter(System.Char)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.Char.IsControl(System.Char)"/>
            <summary></summary>
            <param name="character"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsNumber(System.Char)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.Char.IsNumber(System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsUpper(System.Char)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.Char.IsUpper(System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsLower(System.Char)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.Char.IsLower(System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsAnyOf(System.Char,System.Char[])">
            <summary>Checks if the provided <seealso cref="T:System.Char">character</seealso> is the same as any of the <seealso cref="T:System.Char">characters</seealso> in the array</summary>
            <param name="character">Check if this <see cref="T:System.Char"/> is any of <paramref name="theseCharacters"/></param><param name="theseCharacters"></param>
            <returns><see langword="true"/> if the <paramref name="character"/> is any of <paramref name="theseCharacters"/> || <see langword="false"/> if <paramref name="theseCharacters"/> is <see langword="null"/>, empty, or does not contain the <paramref name="character"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsAnyOf_Internal(System.Char,System.Char[],System.Int32)">
            <summary>Checks if the provided <paramref name="character"/> is the same as any of the <seealso cref="T:System.Char">characters</seealso> in the array</summary>
            <param name="character">Check if this <see cref="T:System.Char"/> is any of <paramref name="theseCharacters"/></param><param name="theseCharacters"></param>
            <param name="arraySize">The known amount of <seealso cref="T:System.Char">characters</seealso> in the array</param>
            <returns><see langword="true"/> if the <paramref name="character"/> is any of <paramref name="theseCharacters"/> || <see langword="false"/> if <paramref name="theseCharacters"/> is <see langword="null"/>, empty, or does not contain the <paramref name="character"/></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.CharExtensions.IsAnyOf_Internal(System.Char,System.Int32,System.Char[])">
            <summary>Checks if the provided <paramref name="character"/> is the same as any of the <seealso cref="T:System.Char">characters</seealso> in the array</summary>
            <param name="character">Check if this <see cref="T:System.Char"/> is any of <paramref name="theseCharacters"/></param><param name="theseCharacters"></param>
            <param name="arraySize">The known amount of <seealso cref="T:System.Char">characters</seealso> in the array</param>
            <returns><see langword="true"/> if the <paramref name="character"/> is any of <paramref name="theseCharacters"/> || <see langword="false"/> if <paramref name="theseCharacters"/> is <see langword="null"/>, empty, or does not contain the <paramref name="character"/></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.DictExtensions">
            <summary>Extension methods for different kinds of dictionaries</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.NullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Returns <see langword="true"/> if the <paramref name="dictionary"/> is <see langword="null"/> or empty</summary><typeparam name="K">Key</typeparam><typeparam name="V">Value</typeparam><param name="dictionary"></param>
            <returns><see langword="true"/> if the <paramref name="dictionary"/> is <see langword="null"/> or has a Count of 0</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.IsNullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.NullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.Any``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Check if the <paramref name="dictionary"/> is non <see langword="null"/> and contains at least one item</summary><typeparam name="K"></typeparam><typeparam name="V"></typeparam><param name="dictionary"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.Add``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.AddOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.SetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.SetOrAddValue``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.SetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.SetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@)">
            <summary>Set the <paramref name="value"/> of an existing entry || or add new entry with the provided <paramref name="value"/> if there was no existing entry</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="value">The new <paramref name="value"/> for the <paramref name="key"/> to set</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <returns>2 if the <paramref name="value"/> was added as a new <paramref name="key"/>, 1 if the existing <paramref name="value"/> was replaced, 0 on error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.GetAndSetSafe``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@,``1@)">
            <summary>Gets the existing value '<typeparamref name="V"/>' (or <see langword="default"/> if none) from the <paramref name="dictionary"/> and writes the <paramref name="newValue"/> '<typeparamref name="V"/>'</summary>
            <typeparam name="K">The type of the keys</typeparam><typeparam name="V">The type of the values</typeparam>
            <param name="dictionary"></param>
            <param name="key">Get the old value '<typeparamref name="V"/>' of this key (<typeparamref name="K"/>), and set a <paramref name="newValue"/></param>
            <param name="newValue">The <paramref name="newValue"/> to add or set</param>
            <param name="oldValue">The old value if it was found, || or <see langword="default"/> value of '<typeparamref name="V"/>' if there was no old value
            <para>will never be <see langword="null"/> if method returned <see langword="true"/> (Unless the dictionary contains <see langword="null"/> values)</para></param>
            <returns><see langword="true"/> if existing value '<typeparamref name="V"/>' was in the <paramref name="dictionary"/>, <see langword="false"/> if it was added now
            <para>returns <see langword="false"/> on error</para></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@)">
            <summary>Gets the value '<typeparamref name="V"/>' from the <paramref name="dictionary"/> || or adds the provided <paramref name="newValue"/> '<typeparamref name="V"/>' if there was no existing value '<typeparamref name="V"/>' for the <paramref name="key"/> '<typeparamref name="K"/>'</summary>
            <typeparam name="K">The type of the keys</typeparam><typeparam name="V">The type of the values</typeparam>
            <param name="dictionary">The <paramref name="dictionary"/> that we are getting or adding the value from</param>
            <param name="key">The <paramref name="key"/> whose value to add or get</param>
            <param name="newValue">The new <paramref name="newValue"/> to add if there is no existing value</param>
            <returns>The existing value '<typeparamref name="V"/>' if it exists || or the provided <paramref name="newValue"/> '<typeparamref name="V"/>' if there was no existing value '<typeparamref name="V"/>' for the <paramref name="key"/> '<typeparamref name="K"/>'
            <para>returns <paramref name="newValue"/> on error</para></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0@)">
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <returns>The value (<typeparamref name="V"/>) of the <paramref name="key"/> (<typeparamref name="K"/>) or the <see langword="default"/> value of '<typeparamref name="V"/>' if there is no stored value for the given <paramref name="key"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.AssumingPureInterface">AssumingPureInterface</see></remarks>
            <inheritdoc cref="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.AddSafe``2(System.Collections.Generic.IDictionary{``0,``1},``0@,``1@)">
            <summary>Adds the new item only if it doesn't already exist in the <paramref name="dictionary"/></summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns><see langword="true"/> if the <paramref name="key"/>/<paramref name="value"/> was added || <see langword="false"/> if the <paramref name="key"/> already existed in the <paramref name="dictionary"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAddTuple``1(System.Collections.Generic.IDictionary{``0,System.ValueTuple{System.Int32,System.Int32}},``0@,System.Byte,System.ValueTuple{System.Int32,System.Int32},System.Int32)">
            <summary>Increment the existing value of a tuple item or add the <paramref name="startValues"/> for the given <paramref name="key"/></summary>
            <typeparam name="K">The key of the tuple <paramref name="dictionary"/></typeparam>
            <param name="dictionary">A <see cref="T:System.Collections.Generic.IDictionary`2"/> of tuples</param>
            <param name="key"></param>
            <param name="itemIndex">The zero based index of the tuple item</param>
            <param name="startValues">If the <paramref name="key"/> doesn't exist in the <paramref name="dictionary"/> add it with this value</param>
            <param name="incrementBy">Increment the existing value of a tuple item if the <paramref name="key"/> for it already exists</param>
            <returns>The tuple values of the give <paramref name="key"/> after incrementing or adding it to the <paramref name="dictionary"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAdd``1(System.Collections.Generic.IDictionary{``0,System.Int32},``0@,System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAddTuple``1(System.Collections.Generic.IDictionary{``0,System.ValueTuple{System.UInt16,System.UInt16}},``0@,System.Byte,System.ValueTuple{System.UInt16,System.UInt16},System.UInt16)">
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAddTuple``1(System.Collections.Generic.IDictionary{``0,System.ValueTuple{System.Int32,System.Int32}},``0@,System.Byte,System.ValueTuple{System.Int32,System.Int32},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAdd``1(System.Collections.Generic.IDictionary{``0,System.UInt16},``0@,System.UInt16,System.UInt16)">
            <summary>Increments the existing value '<see cref="T:System.UInt16"/>' or adds the <paramref name="startValue"/> if there was no existing value for the <paramref name="key"/> '<typeparamref name="K"/>'</summary>
            <returns>The existing value '<see cref="T:System.UInt16"/>' incremented, or the <paramref name="startValue"/> if there was no existing value</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAdd``1(System.Collections.Generic.IDictionary{``0,System.Int32},``0@,System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAdd``1(System.Collections.Generic.IDictionary{``0,System.UInt32},``0@,System.UInt32,System.UInt32)">
            <summary>Increments the existing value '<see cref="T:System.UInt32"/>' or adds the <paramref name="startValue"/> if there was no existing value for the <paramref name="key"/> '<typeparamref name="K"/>'</summary>
            <returns>The existing value '<see cref="T:System.UInt32"/>' incremented, or the <paramref name="startValue"/> if there was no existing value</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAdd``1(System.Collections.Generic.IDictionary{``0,System.Int32},``0@,System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.IncrementOrAdd``1(System.Collections.Generic.IDictionary{``0,System.Int32},``0@,System.Int32,System.Int32)">
            <summary>Increments the existing value '<see cref="T:System.Int32"/>' or adds the <paramref name="startValue"/> if there was no existing value for the <paramref name="key"/> '<typeparamref name="K"/>'</summary>
            <typeparam name="K"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="startValue">Set the value to this if there was no existing value for the <paramref name="key"/> '<typeparamref name="K"/>'</param>
            <param name="incrementBy">Increment the existing value by this amount</param>
            <returns>The existing value '<see cref="T:System.Int32"/>' incremented, or the <paramref name="startValue"/> if there was no existing value</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="key"/> is <see langword="null"/></exception>
            <remarks>returns <paramref name="startValue"/> on error</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.RemoveAllWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Predicate{System.ValueTuple{``0,``1}})">
            <summary>Remove all entries that match the given <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="where"></param>
            <returns>The amount of entries removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.RemoveAllWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Predicate{``1})">
            <summary>Remove all entries that have a value that matches the given <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="where"></param>
            <returns>The amount of entries removed</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.RemoveAllWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Predicate{System.ValueTuple{``0,``1}})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.RemoveAllWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Predicate{``0})">
            <summary>Remove all entries that have a key that matches the given <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="where"></param>
            <returns>The amount of entries removed</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.DictExtensions.RemoveAllWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Predicate{System.ValueTuple{``0,``1}})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.Copy``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Make a <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</seealso> of the <see cref="T:System.Collections.Generic.Dictionary`2"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <returns></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.FirstOrDefault``2(System.Collections.Generic.Dictionary{``0,``1},System.Predicate{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Get the first <see cref="T:System.Collections.Generic.KeyValuePair`2"/> from the <paramref name="dictionary"/> that matches the <paramref name="predicate"/></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="predicate"></param>
            <returns><see langword="default"/> <see cref="T:System.Collections.Generic.KeyValuePair`2"/> if no match found</returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.GetTypeWithHighestValueInDictionary``1(System.Collections.Generic.IDictionary{``0,System.UInt16},System.UInt16@)">
            <summary>Returns the <typeparamref name="TK"/> instance with the highest value in the input <paramref name="dictionary"/></summary>
            <typeparam name="TK"></typeparam>
            <param name="dictionary"></param>
            <param name="highestFoundValue">The highest value</param>
            <returns>The instance of <typeparamref name="TK"/> with the highest value in the <paramref name="dictionary"/></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.AssumingPureInterface">AssumingPureInterface</see></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.ToList``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Makes a copy of the <paramref name="dictionary"/> as a <see cref="T:System.Collections.Generic.List`1"/></summary>
            <typeparam name="K">Keys</typeparam><typeparam name="V">Values</typeparam>
            <param name="dictionary"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> that is a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</see> of the original <paramref name="dictionary"/> as a <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>s</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="dictionary"/> is <see langword="null"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.ToDictionary``3(System.Collections.Generic.IList{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.ToDictionaryFrom``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1})">
            <summary></summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="TV"></typeparam>
            <param name="keys"></param>
            <param name="values"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="keys"/> or <paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.Transform``3(System.Collections.Generic.IDictionary{``0,``1},System.Converter{``0,``2})">
            <summary>Transform the keys (<typeparamref name="K"/>) of the <paramref name="dict"/> to a new type or value (<typeparamref name="NK"/>)</summary>
            <typeparam name="K">Key</typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="NK">New Key</typeparam>
            <param name="dict"></param>
            <param name="func"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.Dictionary`2"/> with the type of the keys changed from '<typeparamref name="K"/>' to '<typeparamref name="NK"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DictExtensions.Transform``3(System.Collections.Generic.IDictionary{``0,``1},System.Converter{``1,``2})">
            <summary>Transform the values (<typeparamref name="T"/>) of the <paramref name="dict"/> to a new type or value (<typeparamref name="NT"/>)</summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="NT"></typeparam>
            <param name="dict"></param>
            <param name="func"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.Dictionary`2"/> with the type of the values changed from '<typeparamref name="T"/>' to '<typeparamref name="NT"/>'</returns>
        </member>
        <member name="F:NQualityOfLife.Utils.StringMatchMode.OpenCloseTags">
            <summary>Match based on the given start and end tags</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.IParsable`1">
            <summary>The type '<typeparamref name="T"/>' can be parsed from a <see cref="T:System.String"/></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> that implements <see cref="T:NQualityOfLife.Utils.IParsable`1"/></typeparam>
            <remarks>Implements <see cref="T:NQualityOfLife.Types.IInterface"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)">
            <summary>Should be able to create a <see langword="new"/> instance of <typeparamref name="T"/> from a <see cref="M:NQualityOfLife.Utils.IParsable`1.ToString"/></summary>
            <param name="text">The <see cref="T:System.String"/> representation of <typeparamref name="T"/> - <see cref="M:NQualityOfLife.Utils.IParsable`1.ToString"/></param>
            <param name="parsed">The <see langword="new"/> instance of <typeparamref name="T"/> that was extracted from the <see cref="T:System.String"/></param>
            <returns><see langword="true"/> if the '<typeparamref name="T"/>' was successfully parsed from the <see cref="T:System.String"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>It is recommended to have a <see langword="static"/> <see cref="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)"/> helper method inside the given <see cref="T:System.Type"/> '<typeparamref name="T"/>'
            <para>Then the <see cref="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)"/> method can be implemented explicitly</para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.IParsable`1.ToString">
            <summary>Convert the <typeparamref name="T"/> instance to a <see cref="T:System.String"/> that can be converted back to an identical <typeparamref name="T"/> instance using <see cref="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)"/></summary>
            <returns>a <see cref="T:System.String"/> that the <see cref="M:NQualityOfLife.Utils.IParsable`1.TryParse(System.String,`0@)"/> method can decode back into an identical <typeparamref name="T"/> instance</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.IStringEquatable">
            <summary>A <see cref="T:NQualityOfLife.Utils.IStringEquatable"/> represents a non-<see cref="T:System.String"/> <see cref="T:System.Object"/> that can be converted to a <see cref="T:System.String"/> of equal value</summary>
            <remarks>Extends: <see cref="T:System.IEquatable`1"/> where 'T' is <see cref="T:System.String"/>
            <para>Implements <see cref="T:NQualityOfLife.Types.ICastable`1"/> where 'T' is <see cref="T:System.String"/></para></remarks>
        </member>
        <member name="P:NQualityOfLife.Utils.IStringEquatable.Length">
            <inheritdoc cref="P:System.String.Length"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IStringEquatable.ToString">
            <summary>Convert the <see cref="T:NQualityOfLife.Utils.IStringEquatable"/> to <see cref="T:System.String"/></summary>
            <returns><see cref="T:System.String"/></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.IString">
            <summary>Interface for <see cref="T:System.String"/> wrappers that provides additional methods to a <see cref="T:NQualityOfLife.Utils.IStringEquatable"/></summary>
            <remarks>Extends: <see cref="T:System.ICloneable"/>, <see cref="T:System.IComparable`1"/> where 'T' is <see cref="T:System.String"/>
            <para>Implements <see cref="T:NQualityOfLife.Utils.IStringEquatable"/></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.Deconstruct(System.String@)">
            <summary>Deconstructs the <see cref="T:NQualityOfLife.Utils.IString"/> to <see cref="T:System.String"/>, should give the same <see cref="T:System.String"/> as <see cref="M:NQualityOfLife.Utils.IStringEquatable.ToString"/></summary>
            <param name="str"></param>
        </member>
        <member name="T:NQualityOfLife.Utils.IString`1">
            <summary>A wrapper for strings where the <see cref="T:System.Type"/> is specified as '<typeparamref name="TS"/>'</summary>
            <typeparam name="TS"></typeparam>
            <remarks>Implements <see cref="T:NQualityOfLife.Utils.IString"/>, <see cref="T:NQualityOfLife.Types.INewWithValue`2"/> where 'TV' is <see cref="T:System.String"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.IString`1.SetFromString(System.String)">
            <summary>Set <see langword="this"/> <see cref="T:NQualityOfLife.Utils.IString`1"/> instance to the given <paramref name="newValue"/></summary>
            <param name="newValue"></param>
            <returns><see langword="this"/> <see cref="T:NQualityOfLife.Utils.IString`1"/> '<typeparamref name="TS"/>' with the <paramref name="newValue"/> set</returns>
            <remarks>Can return a <see langword="new"/> '<typeparamref name="TS"/>' instance if <see langword="this"/> is a <see langword="readonly"/> <see langword="struct"/>, in that case, it is recommended to implement this method <see langword="explicit"/>ly</remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.StringExtensions">
            <summary>Useful extension methods for <seealso cref="T:System.String">strings</seealso></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.StringExtensions.FormatHexadecimal">
            <summary>Format a number as a 8 character hexadecimal <see cref="T:System.String"/></summary>
            <remarks>Useful for representing a 4 <see cref="T:System.Byte"/> long value</remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.StringExtensions.FormatHexadecimal4">
            <summary>Format a number as a 4 character hexadecimal <see cref="T:System.String"/></summary>
            <remarks>Useful for representing a 2 <see cref="T:System.Byte"/> long value</remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.StringExtensions.InvariantCulture">
            <inheritdoc cref="P:System.Globalization.CultureInfo.InvariantCulture"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.NullIfEmpty(System.String)">
            <summary></summary>
            <param name="text"></param>
            <returns><see langword="null"/> if <paramref name="text"/> is <see cref="F:System.String.Empty"/>, else the <paramref name="text"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLineBreaks(System.String,System.String)">
            <summary></summary>
            <param name="text"></param>
            <param name="andReplaceWith"></param>
            <returns></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.TrimAll(System.Collections.Generic.IList{System.String},System.Boolean)">
            <summary>Create a copy of the input strings as a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with leading and trailing whitespace removed</summary>
            <param name="strings"></param>
            <param name="removeEmpty"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="strings"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstLine(System.String)">
            <summary>Get the first line of a <paramref name="text"/>, if the <paramref name="text"/> is on a single line, returns the <paramref name="text"/></summary>
            <param name="text"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstToUpper(System.String,System.Globalization.CultureInfo)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.CapitalizeFirst(System.String,System.Globalization.CultureInfo)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.CapitalizeFirst(System.String,System.Globalization.CultureInfo)">
            <summary>Capitalize the first letter of the input <paramref name="text"/></summary>
            <param name="text">Capitalize the first <see cref="T:System.Char"/> of this <see cref="T:System.String"/></param>
            <param name="cultureInfo">Leave as <see langword="default"/> for <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/></param>
            <returns><paramref name="text"/> with the first <see cref="T:System.Char"/> converted to upper case</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <remarks>If the input <paramref name="text"/> is empty or the first <see cref="T:System.Char"/> is already upper case, returns it un-changed</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FormatAsString_XML_List(System.String,NQualityOfLife.Utils.Common.FormatMode)">
            <summary>Accepts a <see cref="T:System.String"/> that contains XML '&lt;li&gt;value&lt;/li&gt;' elements.</summary>
            <param name="xmlList">a <see cref="T:System.String"/> made from '&lt;li&gt;value&lt;/li&gt;' elements.</param>
            <param name="formatMode">The format we want to convert the list to</param>
            <returns>The list re-formatted using the selected <see cref="T:NQualityOfLife.Utils.Common.FormatMode"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.XMLToList(System.String,System.Boolean)">
            <summary>Accepts a <see cref="T:System.String"/> that contains XML '&lt;li&gt;value&lt;/li&gt;' elements.</summary>
            <param name="xmlList"></param>
            <param name="keepTags">Include the '&lt;li&gt;&lt;/li&gt;' tags around the values in the output list</param>
            <returns>The values of the xml list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.TranslateOr(System.String,System.String)">
            <summary>Try translate the given <paramref name="translationKey"/> or return <paramref name="fallback"/> if translation fails</summary>
            <param name="translationKey"></param>
            <param name="fallback"></param>
            <returns><paramref name="translationKey"/> translated or <paramref name="fallback"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32@,System.Int32)">
            <param name="startIndex">Start looking for the <paramref name="character"/> starting at this index of the <paramref name="text"/>
            <para>Must be &gt;= 0</para></param>
            <param name="stringLength">The <see cref="P:System.String.Length"/> of the input <paramref name="text"/> <see langword="out"/></param>
            <param name="text">The <see cref="T:System.String"/> that we are looking for the <see cref="T:System.Char"/> in</param>
            <param name="character">The <see cref="T:System.Char"/> whose index to find in <paramref name="text"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is &lt; 0 or after the end of the <paramref name="text"/></exception>
            <returns>the zero based index of the <b>first occurrence</b> of the <paramref name="character"/> || or -1 if not found
            <para><b>Special case:</b> returns -1 if <paramref name="text"/> is <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is 0. <b>else</b> if <paramref name="startIndex"/> is &gt; 0; will error</para></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32)">
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see></remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is invalid</exception>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf_Internal(System.String,System.Char,System.Int32,System.Int32)">
            <param name="text">The <see cref="T:System.String"/> that we are looking for the <see cref="T:System.Char"/> in</param>
            <param name="character">The <see cref="T:System.Char"/> whose index to find in <paramref name="text"/></param>
            <param name="stringLength"><paramref name="text"/> <see cref="P:System.String.Length"/></param>
            <param name="startIndex">Start looking for the <paramref name="character"/> starting at this index of the <paramref name="text"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="stringLength"/> is wrong or <paramref name="startIndex"/> is &lt; 0 or past the end of the <paramref name="text"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32@)">
            <summary>Get the zero based index of the <b>first occurrence</b> of the given <paramref name="character"/> || or -1 if none found.</summary>
            <param name="stringLength">The <see cref="P:System.String.Length"/> of the input <paramref name="text"/> <see langword="out"/></param>
            <param name="text">The <see cref="T:System.String"/> that we are looking for the <see cref="T:System.Char"/> in</param>
            <param name="character">The <see cref="T:System.Char"/> whose index to find in <paramref name="text"/></param>
            <returns>the zero based index of the <b>first occurrence</b> of the <paramref name="character"/> || or -1 if not found
            <para>returns -1 if <paramref name="text"/> is <see cref="F:System.String.Empty"/></para></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOfOrdinal(System.String,System.String)">
            <remarks>Uses '<see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>' / '<see cref="F:System.Globalization.CompareOptions.Ordinal"/>'
            <para>Will always return -1 if <paramref name="subString"/> is <see cref="F:System.String.Empty"/>!</para>
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
            <summary>Find the index of the <b>first occurrence</b> of '<paramref name="subString"/>' inside the '<paramref name="str"/>'</summary>
            <param name="str">The <see cref="T:System.String"/> to search for the given '<paramref name="subString"/>'</param>
            <param name="subString">The <see cref="T:System.String"/> to find the index of</param>
            <returns>The zero based index of the <b>first occurrence</b> of '<paramref name="subString"/>' inside the '<paramref name="str"/>' or -1 if not found
            <para>Always -1 if either '<paramref name="str"/>' or '<paramref name="subString"/>' is <see langword="null"/></para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <summary>Get the zero based index of the <b>first occurrence</b> of the given <paramref name="subString"/> (meaning the index of the first <see cref="T:System.Char"/> of the <paramref name="subString"/>) || or -1 if none found.</summary>
            <param name="str">The <see cref="T:System.String"/> that we are searching for the <paramref name="subString"/> in</param>
            <param name="subString">The <see cref="T:System.String"/> to find inside the given <paramref name="str"/></param>
            <param name="stringLength">The <see cref="P:System.String.Length"/> of the input <paramref name="str"/> <see langword="out"/></param>
            <param name="comparisonType">The <see cref="T:System.StringComparison"/> mode to use</param>
            <returns>the zero based index of the <b>first occurrence</b> of the <paramref name="subString"/> (start index of the <paramref name="subString"/> inside <paramref name="str"/>) || or -1 if not found</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> or <paramref name="subString"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Unsupported <see cref="T:System.StringComparison"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.Int32@,System.StringComparison)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.StringComparison)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.Int32@,System.StringComparison)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOfOrdinal(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.Char,System.Int32@)">
            <summary>Get the zero based index of the <b>last occurrence</b> of the given <paramref name="character"/> || or -1 if none found.</summary>
            <param name="text">The <see cref="T:System.String"/> that we are looking for the <see cref="T:System.Char"/> in</param>
            <param name="character">The <see cref="T:System.Char"/> whose index to find in <paramref name="text"/></param>
            <param name="stringLength">The <see cref="P:System.String.Length"/> of the input <paramref name="text"/> <see langword="out"/></param>
            <returns>the zero based index of the <b>last occurrence</b> of the <paramref name="character"/> || or -1 if not found
            <para>returns -1 if <paramref name="text"/> is <see cref="F:System.String.Empty"/></para></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.Char)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.Char,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf_Internal(System.String,System.Char,System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="stringLength"/> is wrong</exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.Char,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <summary>Get the zero based index of the <b>last occurrence</b> of the given <paramref name="subString"/> (meaning the index of the first <see cref="T:System.Char"/> of the <paramref name="subString"/>) || or -1 if none found.</summary>
            <returns>the zero based index of the <b>last occurrence</b> of the <paramref name="subString"/> (start index of the <paramref name="subString"/> inside <paramref name="str"/>) || or -1 if not found</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.Int32@,System.StringComparison)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitAll(System.Collections.Generic.IList{System.String},System.String,System.StringSplitOptions)">
            <summary></summary>
            <param name="strings"></param><param name="options"></param><param name="separator"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitAll(System.Collections.Generic.IList{System.String},System.String[])">
            <summary></summary>
            <param name="strings"></param><param name="separators"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitAll(System.Collections.Generic.IList{System.String},System.StringSplitOptions,System.String[])">
            <summary></summary>
            <param name="strings"></param><param name="options"></param><param name="separators"></param>
            <returns>a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:System.String"/>s that contains all the outputs from splitting the <paramref name="strings"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="strings"/> or <paramref name="separators"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitByUpper(System.String)">
            <summary>Split the <paramref name="text"/> by upper case letters</summary>
            <param name="text"></param>
            <returns></returns>
            <remarks>Useful for splitting <see href="https://en.wikipedia.org/wiki/Camel_case">camelCase</see> text into the actual words
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitBy(System.String,System.Int32,System.Int32)">
            <summary>Splits the <see cref="T:System.String"/> into chunks of a specified length</summary>
            <param name="text"></param>
            <param name="chunkLength"></param>
            <param name="textLength">text.Length</param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> of strings with a length of '<paramref name="chunkLength"/>'</returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Char)">
            <summary>Count the matching <see cref="T:System.Char">characters</see> in the given <see cref="T:System.String"/></summary>
            <param name="str">Input <see cref="T:System.String"/></param>
            <param name="character">The <see cref="T:System.Char"/> to count occurrences of</param>
            <returns>The count of occurrences of the given <paramref name="character"/> in the input <paramref name="str"/>
            <para>-1 on error</para></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Char,System.Char)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Predicate{System.Char})">
            <summary>Count characters matching a condition</summary>
            <param name="str"></param>
            <param name="predicate"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="str"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count_Substrings_Safe(System.String,System.String)">
            <exception cref="T:System.ArgumentNullException"><paramref name="countInstancesOf"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.String)">
            <summary>Count how many times the <paramref name="subString"/> appears in the <paramref name="text"/></summary>
            <param name="text"></param>
            <param name="subString"></param>
            <returns>The number of matches of <paramref name="subString"/> inside the <paramref name="text"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count_Substrings(System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.CountTill(System.String,System.Int32,System.Predicate{System.Char})">
            <summary>Counts matching characters until the <paramref name="maxCount"/> or end of the <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="maxCount">When to stop counting
            <para>Must be &gt;= 1</para></param>
            <param name="predicate"></param>
            <returns>Matching <see cref="T:System.Char"/> count or <paramref name="maxCount"/> if more matching characters than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.CountTill(System.String,System.Int32,System.Char[])">
            <summary>Counts matching characters until the <paramref name="maxCount"/> or end of the <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="maxCount">When to stop counting
            <para>Must be &gt;= 1</para></param>
            <param name="matchChars"></param>
            <returns>Matching <see cref="T:System.Char"/> count or <paramref name="maxCount"/> if more matching characters than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringInvariant(System.IFormattable)">
            <remarks>Uses the default format
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see></para></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringInvariant(System.IFormattable,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringInvariant(System.IFormattable,System.String)">
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="formattable"/> is <see langword="null"/></exception>
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringInvariant(System.Boolean)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.Boolean.ToString"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToLowerInvariantCulture(System.String)">
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see></para></remarks>
            <inheritdoc cref="M:System.Globalization.TextInfo.ToLower(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToUpperInvariantCulture(System.String)">
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see></para></remarks>
            <inheritdoc cref="M:System.Globalization.TextInfo.ToUpper(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Int32,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Double,System.Char)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Double,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.Char)">
            <summary></summary>
            <param name="num"></param>
            <param name="symbol">The symbol of the unit, such as 'g' 'm' '' etc</param>
            <returns>The number formatted using the kilo, milli, micro etc prefixes.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSI(System.Single,System.String,System.String)">
            <summary></summary>
            <param name="num"></param>
            <param name="symbol">The symbol of the unit, such as 'g' 'm' 'Pa' '' etc</param>
            <param name="format"></param>
            <returns>The number formatted using the kilo, milli, micro etc prefixes.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringTwoDecimals(System.Single)">
            <summary>Format the <paramref name="number"/> to a <see cref="F:NQualityOfLife.Utils.StringExtensions.InvariantCulture">culture invariant</see> <see cref="T:System.String"/> with two decimal places</summary>
            <param name="number"></param><returns>The <paramref name="number"/> formatted</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringFourDecimals(System.Single)">
            <summary>Format the <paramref name="number"/> to a <see cref="F:NQualityOfLife.Utils.StringExtensions.InvariantCulture">culture invariant</see> <see cref="T:System.String"/> with four decimal places</summary>
            <param name="number"></param><returns>The <paramref name="number"/> formatted</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringEightDecimals(System.Single)">
            <summary>Format the <paramref name="number"/> to a <see cref="F:NQualityOfLife.Utils.StringExtensions.InvariantCulture">culture invariant</see> <see cref="T:System.String"/> with eight decimal places</summary>
            <param name="number"></param><returns>The <paramref name="number"/> formatted</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringSixteenDecimals(System.Single)">
            <summary>Format the <paramref name="number"/> to a <see cref="F:NQualityOfLife.Utils.StringExtensions.InvariantCulture">culture invariant</see> <see cref="T:System.String"/> with sixteen decimal places</summary>
            <param name="number"></param><returns>The <paramref name="number"/> formatted</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringHex(System.Single)">
            <summary>Format the <paramref name="number"/> to a <see cref="F:NQualityOfLife.Utils.StringExtensions.InvariantCulture">culture invariant</see> hexadecimal <see cref="T:System.String"/></summary>
            <param name="number"></param><returns>The <paramref name="number"/> formatted</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FloatToBits(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringHex(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(NQualityOfLife.Types.Nibble@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.SByte)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Byte)">
            <summary>Convert the given number into it's bit representation</summary>
            <param name="b"></param>
            <returns>A binary representation of the <see cref="T:System.Byte"/>, such as "1100_1000", "0000_0010" or "1111_1111"</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Int16)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.UInt16)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.UInt32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ToStringBinary(System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.NewLine(System.String,System.String)">
            <summary>Concatenates the <paramref name="stringOnNewLine"/> to the existing <paramref name="text"/> if it exists, else returns <paramref name="stringOnNewLine"/></summary>
            <param name="text"></param>
            <param name="stringOnNewLine"></param>
            <returns><paramref name="stringOnNewLine"/> added on a new line after <paramref name="text"/>, or <paramref name="stringOnNewLine"/> if <paramref name="text"/> was <see langword="null"/> or empty</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Pow(System.String,System.Int32)">
            <summary>Adds the appropriate notation to the end of the string, such as '^6' or '<see cref="F:NQualityOfLife.Utils.Common.Chars.Pow1"/>'</summary>
            <param name="x"></param>
            <param name="toThePower"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> such as: "<paramref name="x"/>", "<paramref name="x"/>", "<paramref name="x"/>^5" etc...</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Pow(System.String,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Pow(System.String,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Dot(NQualityOfLife.Utils.IStringEquatable,System.String)">
            <summary>Concats two strings with a dot between them</summary>
            <param name="stringEquatable"></param>
            <param name="afterDot">Text after the dot</param>
            <returns>{<paramref name="stringEquatable"/>}.{<paramref name="afterDot"/>}</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Dot(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Dot(System.String,System.String)">
            <summary>Concats 2 strings with a dot ('.') between them</summary>
            <param name="text">Text before the dot</param>
            <param name="dotText">Text after the dot</param>
            <returns>{<paramref name="text"/>}.{<paramref name="dotText"/>}</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat``1(``0,``0@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Concat(NQualityOfLife.Utils.IStringEquatable,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat``1(``0,``0,``0[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Concat(NQualityOfLife.Utils.IStringEquatable,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(NQualityOfLife.Utils.IStringEquatable,System.String,System.String[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(NQualityOfLife.Utils.IStringEquatable,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.Char)">
            <summary>Add the provided <see cref="T:System.Char"/> to the end of <paramref name="string1"/></summary><param name="string1"></param><param name="char1"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> with <paramref name="char1"/> appended to the end of it</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.Char,System.Char)">
            <summary>Add the provided characters to the end of <paramref name="string1"/></summary><param name="string1"></param><param name="char1"></param><param name="char2"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> with <paramref name="char1"/> and <paramref name="char2"/> appended to the end of it</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String)">
            <summary>Concat a <see cref="T:System.String"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String)">
            <summary>Concat a <see cref="T:System.String"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param>
            <param name="other2"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String)">
            <summary>Concat a <see cref="T:System.String"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param>
            <param name="other2"></param>
            <param name="other3"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat a <see cref="T:System.String"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat a string to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param><param name="other5"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat the provided strings to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param><param name="other5"></param><param name="other6"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> composed of the input strings</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String[])">
            <summary>Add the provided <paramref name="strings"/> to the end of <see langword="this"/> <see cref="T:System.String"/></summary>
            <param name="str"></param>
            <param name="other"></param>
            <param name="strings"></param>
            <returns></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="strings"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.NullOrEmpty(System.String,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Boolean)">
            <summary>Checks if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></summary>
            <param name="s"><see cref="T:System.String"/></param>
            <param name="treatSymbolsAsValue">Treat the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty symbols</seealso> as if they were the values they represent</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> is <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(NQualityOfLife.Utils.IString,System.Boolean)">
            <summary>Checks if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></summary>
            <param name="s"><see cref="T:System.String"/></param>
            <param name="treatSymbolsAsValue">Treat the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty symbols</seealso> as if they were the values they represent</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> is <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(NQualityOfLife.Utils.IString,System.Int32@,System.Boolean)">
            <summary>Checks if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/> and outputs the <paramref name="length"/> of the input <see cref="T:System.String"/></summary>
            <param name="s"><see cref="T:System.String"/></param>
            <param name="length"></param>
            <param name="treatSymbolsAsValue">Treat the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty symbols</seealso> as if they were the values they represent</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> is <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Int32@,System.Boolean)">
            <summary>Checks if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/> and outputs the <paramref name="length"/> of the input <see cref="T:System.String"/></summary>
            <param name="s"></param>
            <param name="length">Will be -1 if <see cref="T:System.String"/> is <see langword="null"/>, else the Length of the <see cref="T:System.String"/></param>
            <param name="treatSymbolsAsValue">Treat the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty symbols</seealso> as if they were the values they represent</param>
            <returns><see langword="true"/> if <see cref="T:System.String"/> is <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsEmptySymbol(System.String)">
            <summary>Is the given <see cref="T:System.String"/> the value of any of the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty symbols</seealso></summary>
            <param name="s"></param><returns><see langword="true"/> if the input <see cref="T:System.String"/> is one of the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty symbols</seealso></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullSymbol(System.String)">
            <summary>Is the given <see cref="T:System.String"/> the value of any of the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol">null symbols</seealso></summary>
            <param name="s"></param><returns><see langword="true"/> if the input <see cref="T:System.String"/> is one of the <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol">null symbols</seealso></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsOrdinal(System.String,System.String)">
            <remarks>Uses '<see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>' / '<see cref="F:System.Globalization.CompareOptions.Ordinal"/>'
            <para>Will always return <see langword="true"/> if <paramref name="substring"/> is <see cref="F:System.String.Empty"/>!</para>
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
            <summary>Checks if the <see cref="T:System.String"/> contains the given <paramref name="substring"/></summary>
            <param name="text"></param>
            <param name="substring"></param>
            <returns><see langword="true"/> if the <paramref name="text"/> contains or matches the <paramref name="substring"/>
            <para>Always <see langword="false"/> if either '<paramref name="text"/>' or '<paramref name="substring"/>' is <see langword="null"/></para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char)">
            <summary>Checks if the input <see cref="T:System.String"/> contains the specified <paramref name="character"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the <see cref="T:System.Char"/></param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains the <paramref name="character"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char,System.Int32@)">
            <summary>Checks if the input <see cref="T:System.String"/> contains the specific <paramref name="character"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the char</param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <param name="index">The index of the first found matching <see cref="T:System.Char"/> || or -1 if it was not found</param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains the <paramref name="character"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char,System.Int32@,System.Int32@)">
            <summary>Checks if the input <see cref="T:System.String"/> contains the specific <paramref name="character"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the <see cref="T:System.Char"/></param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <param name="index">The index of the first found instance of <paramref name="character"/> || or -1 if it was not found</param>
            <param name="textLength">The <see cref="P:System.String.Length"/> of <paramref name="text"/> || -1 on error</param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains the <paramref name="character"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.AnyOfContain_Internal(System.String,System.StringComparison,System.String[])">
            <summary>Check if any of the <paramref name="strings"/> contain the <paramref name="text"/></summary>
            <param name="text"></param>
            <param name="stringComparison"></param>
            <param name="strings"></param>
            <returns><see langword="true"/> if any of the given <paramref name="strings"/> contains the <paramref name="text"/><para>will always return <see langword="true"/> if <paramref name="text"/> is <see cref="F:System.String.Empty"/> and <paramref name="strings"/> has at least one non <see langword="null"/> <see cref="T:System.String"/></para></returns>
            <remarks><see langword="null"/> strings in <paramref name="strings"/> are skipped
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="strings"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains_Internal(System.String,System.Char,System.Int32)">
            <summary>Checks if the input <see cref="T:System.String"/> contains the specified <paramref name="character"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the <see cref="T:System.Char"/></param>
            <param name="textLength">text.Length</param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains the <paramref name="character"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains_Internal(System.String,System.Char,System.Char,System.Int32)">
            <summary>Checks if the input <see cref="T:System.String"/> contains one of the specified <paramref name="character"/>s || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Check this <see cref="T:System.String"/> for the <see cref="T:System.Char"/>s</param>
            <param name="textLength">text.Length</param><param name="character">The <see cref="T:System.Char"/> to look for</param>
            <param name="orCharacter"></param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains one of the <paramref name="character"/>s</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains_Internal(System.String,System.String,System.Int32,System.StringComparison)">
            <summary>Checks if the <see cref="T:System.String"/> contains the given <paramref name="substring"/></summary>
            <param name="text"></param>
            <param name="substring"></param>
            <param name="textLength">The <see cref="P:System.String.Length"/> of <paramref name="text"/></param>
            <param name="stringComparison"></param>
            <returns><see langword="true"/> if the <paramref name="text"/> contains or matches the <paramref name="substring"/></returns>
            <remarks>Will always return <see langword="true"/> if <paramref name="substring"/> is <see cref="F:System.String.Empty"/>!
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains_Internal(System.String,System.String,System.Int32)">
            <remarks>Uses '<see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>' / '<see cref="F:System.Globalization.CompareOptions.Ordinal"/>'
            <para>Will always return <see langword="true"/> if <paramref name="substring"/> is <see cref="F:System.String.Empty"/>!</para></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Contains_Internal(System.String,System.String,System.Int32,System.StringComparison)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.Char[])">
            <summary>Checks if the input <see cref="T:System.String"/> contains any of the specified <paramref name="characters"/> || input <see cref="T:System.String"/> must not be <see langword="null"/>!</summary>
            <param name="text">Should not be <see langword="null"/></param>
            <param name="characters">Should not be <see langword="null"/></param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains any of the <paramref name="characters"/>
            <para>Always <see langword="false"/> if either <paramref name="text"/> or <paramref name="characters"/> is empty</para></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="characters"/> is <see langword="null"/></exception>
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.String[])">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches any of the <seealso cref="T:System.String">strings</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <remarks>Uses '<see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>' / '<see cref="F:System.Globalization.CompareOptions.Ordinal"/>'
            <para>Will always return <see langword="true"/> if any of the sub-strings is <see cref="F:System.String.Empty"/>!</para>
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
            <returns><see langword="true"/> if the input <paramref name="text"/> matches or contains any of the provided <seealso cref="T:System.String">strings</seealso> || If input <paramref name="text"/> or <see cref="T:System.String"/> array are <see langword="null"/> or empty; returns <see langword="false"/>.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.String[],System.String[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.String[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.Collections.Generic.IList{System.String})">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.Collections.Generic.IList{System.String},System.String@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.Collections.Generic.IList{System.String},System.String@)">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches any of the <seealso cref="T:System.String">strings</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <param name="firstMatch"></param>
            <returns><see langword="true"/> if the input matches or contains any of the provided <seealso cref="T:System.String">strings</seealso>. || If input <paramref name="text"/> or <see cref="T:System.String"/> array are <see langword="null"/> or empty; returns <see langword="false"/></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.AssumingPureInterface">AssumingPureInterface</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAnyOf(System.String,System.String@,System.String[])">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches any of the <seealso cref="T:System.String">strings</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <param name="firstMatch">The first match or <see langword="null"/> if there was none</param>
            <returns><see langword="true"/> if the input <paramref name="text"/> matches or contains any of the provided <seealso cref="T:System.String">strings</seealso>. || If input <paramref name="text"/> or <see cref="T:System.String"/> array are <see langword="null"/> or empty; returns <see langword="false"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAll(System.String,System.String[])">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches all of the <seealso cref="T:System.String">strings</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if the input matches or contains all of the provided <seealso cref="T:System.String">strings</seealso>. || If input text or <see cref="T:System.String"/> array are <see langword="null"/> or empty; returns <see langword="false"/>.</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAll(System.String,System.Char[])">
            <summary>Checks if the provided <see cref="T:System.String"/> contains or matches all of the <seealso cref="T:System.Char">chars</seealso> in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if the input <see cref="T:System.String"/> contains or matches all of the provided <seealso cref="T:System.Char">chars</seealso>. || If input <paramref name="text"/> or <see cref="T:System.Char"/> array are <see langword="null"/> or empty; returns <see langword="false"/>.</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.EndsWith_Fast(NQualityOfLife.Utils.IStringEquatable,System.String)">
            <summary>Checks if the <see cref="T:NQualityOfLife.Utils.IString"/> ends with the given sub-string</summary>
            <param name="stringEquatable"></param><param name="subString"></param>
            <returns><see langword="false"/> if any input is <see langword="null"/> || <see langword="true"/> if <see langword="this"/> <see cref="T:NQualityOfLife.Utils.IString"/> ends with '<paramref name="subString"/>'</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.EndsWith_Fast(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.EndsWith_Fast(System.String,System.String)">
            <summary>Checks if the provided <see cref="T:System.String"/> ends with the given sub-string</summary>
            <param name="text"></param><param name="with"></param>
            <returns><see langword="false"/> if any input is <see langword="null"/> or <see cref="F:System.String.Empty"/><para><see langword="true"/> if '<paramref name="text"/>' ends with '<paramref name="with"/>'</para></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(NQualityOfLife.Utils.IStringEquatable,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(NQualityOfLife.Utils.IStringEquatable,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String)">
            <summary>Check if the <see cref="T:System.String"/> starts with the given <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="with"></param>
            <returns><see langword="false"/> if any input is <see langword="null"/> or <see cref="F:System.String.Empty"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String,System.String)">
            <summary>Check if the <see cref="T:System.String"/> starts with one of the given strings</summary>
            <param name="text"></param>
            <param name="with"></param>
            <param name="or"></param>
            <returns>always <see langword="false"/> if the input <see cref="T:System.String"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast_Internal(System.String,System.Int32,System.String,System.Int32)">
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbol(System.String)">
            <summary>Returns the last <see cref="T:System.Char"/> of a <see cref="T:System.String"/>, or '<seealso cref="F:NQualityOfLife.Utils.Common.Chars.EmptyChar">'\0'</seealso>' if invalid <see cref="T:System.String"/></summary>
            <param name="text">text to check</param>
            <returns>The last <see cref="T:System.Char"/> of the provided <see cref="T:System.String"/> or empty <see cref="T:System.Char"/> <seealso cref="F:NQualityOfLife.Utils.Common.Chars.EmptyChar">('\0')</seealso> if text is <see langword="null"/> or empty</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char)">
            <summary>Checks if the last symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/></summary>
            <param name="text">text to check</param>
            <param name="lastSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> ends with the provided <see cref="T:System.Char"/></returns>
            <remarks>returns <see langword="false"/> if the <paramref name="text"/> is <see langword="null"/> unless:<para>Will return <see langword="true"/> if the <paramref name="text"/> is <see langword="null"/> and the <paramref name="lastSymbol"/> <see cref="T:System.Char"/> == <see cref="F:NQualityOfLife.Utils.Common.Chars.EmptyChar"/></para>
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char,System.Char)">
            <summary>Checks if the last symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/></summary>
            <param name="text">text to check</param>
            <param name="lastSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <param name="or"></param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> ends with the provided <see cref="T:System.Char"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char,System.Char,System.Char)">
            <summary>Checks if the last symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/></summary>
            <param name="text">text to check</param>
            <param name="lastSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <param name="or"></param>
            <param name="orThis"></param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> ends with the provided <see cref="T:System.Char"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbol(System.String)">
            <summary>Returns the first <see cref="T:System.Char"/> of a <see cref="T:System.String"/>, or '\0' if invalid <see cref="T:System.String"/></summary>
            <param name="text">text to check</param>
            <returns>The first <see cref="T:System.Char"/> of the provided <see cref="T:System.String"/> or empty <see cref="T:System.Char"/> ('\0') if text is <see langword="null"/> or empty</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char)">
            <summary>Checks if the first symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></summary>
            <param name="text">text to check - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></param>
            <param name="firstSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> starts with the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char,System.Char)">
            <summary>Checks if the first symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></summary>
            <param name="text">text to check - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></param>
            <param name="firstSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <param name="or"></param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> starts with the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char,System.Char,System.Char)">
            <summary>Checks if the first symbol (<see cref="T:System.Char"/>) of a <see cref="T:System.String"/> is the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></summary>
            <param name="text">text to check - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></param>
            <param name="firstSymbol"><see cref="T:System.Char"/> that we are comparing</param>
            <param name="or"></param>
            <param name="orThis"></param>
            <returns><see langword="true"/> if the <see cref="T:System.String"/> starts with the provided <see cref="T:System.Char"/> - a <see langword="null"/> or empty <see cref="T:System.String"/> will return <see langword="false"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.InternalSubStringUnsafe(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:System.String.Substring(System.Int32,System.Int32)"/>
            <summary></summary>
            <param name="str"></param>
            <param name="startIndex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.CaptureSubstringsInside(System.String,System.Char,System.Char,NQualityOfLife.Utils.StringMatchMode)">
            <summary>Get a list of substring from the <paramref name="source">source</paramref> <see cref="T:System.String"/></summary>
            <param name="source"></param>
            <param name="after"></param>
            <param name="before"></param>
            <param name="matchMode"></param>
            <returns></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterLastOrFallback(System.String,System.Char,System.String)">
            <summary>Gets the substring after the last instance of the specified <seealso cref="T:System.Char">character</seealso>.</summary>
            <param name="text"></param>
            <param name="afterThisChar"></param>
            <param name="fallback">The <see cref="T:System.String"/> to return if the sub-string was not found<para><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</para></param>
            <returns>The substring after the last instance of the specified <see cref="T:System.Char"/> or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para>if the last <see cref="T:System.Char"/> of <paramref name="text"/> is the specified <see cref="T:System.Char"/>; returns <paramref name="fallback"/></para>
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterLast(System.String,System.Char)">
            <summary>Gets the substring after the last instance of the specified <seealso cref="T:System.Char">character</seealso>.</summary>
            <param name="text"></param>
            <param name="afterThisChar">Get the substring after the first instance of this <see cref="T:System.Char"/></param><exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <returns>The substring after the last instance of the specified <see cref="T:System.Char"/> || or '<see cref="F:System.String.Empty"/>' if not found || Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE
            <para>if the last <see cref="T:System.Char"/> of <paramref name="text"/> is the specified <see cref="T:System.Char"/>; returns <see cref="F:System.String.Empty"/></para>
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeLast(System.String,System.Char)">
            <returns>The part of the input <paramref name="text"/> that is before the last instance of <paramref name="beforeThisChar"/> or <see cref="F:System.String.Empty"/> if the <paramref name="beforeThisChar"/> does not appear in the <paramref name="text"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeLastOrFallback(System.String,System.Char,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeLastOrFallback(System.String,System.Char,System.String)">
            <summary>Get the sub-string before the last instance of the specified <see cref="T:System.Char"/></summary>
            <param name="text"></param>
            <param name="beforeThisChar"></param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <returns>The part of the input <paramref name="text"/> that is before the last instance of <paramref name="beforeThisChar"/> or <paramref name="fallback"/> if the <paramref name="beforeThisChar"/> does not appear in the <paramref name="text"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfter(System.String,System.Char)">
            <summary>Gets the substring after the first instance of the specified character. - Excluding the character</summary>
            <param name="text"></param>
            <param name="afterThisChar"></param>
            <returns>The substring after the first found instance of the specified <see cref="T:System.Char"/> || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterOrFallback(System.String,System.Char,System.String)">
            <returns>The substring after the first found instance of the specified <see cref="T:System.Char"/> || or '<paramref name="fallback"/>' if not found</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringAfter(System.String,System.Char)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfter(System.String,System.String)">
            <returns><see cref="F:System.String.Empty"/> if the '<paramref name="after"/>' <see cref="T:System.String"/> was not found inside the '<paramref name="text"/>'</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterOrFallback(System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterOrFallback(System.String,System.String,System.String)">
            <summary>Get a sub-string from '<paramref name="text"/>' directly after a given <see cref="T:System.String"/></summary>
            <param name="text">Must not be <see langword="null"/></param>
            <param name="after">Must not be <see langword="null"/></param>
            <param name="fallback"><see langword="null"/> allowed</param>
            <returns><paramref name="fallback"/> if the '<paramref name="after"/>' <see cref="T:System.String"/> was not found inside the '<paramref name="text"/>'</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="after"/> is <see langword="null"/></exception>
            <remarks><para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterIndex(System.String,System.Int32,System.Int32)">
            <summary>Get the sub-string after the given <paramref name="index"/> - Excluding the <see cref="T:System.Char"/> at the <paramref name="index"/></summary>
            <param name="text">Get the sub-<see cref="T:System.String"/> from this '<paramref name="text"/>'</param><param name="index">Get the sub-string starting after this index
            <para>-1 will return all of <paramref name="text"/></para></param>
            <param name="textLength"><see cref="P:System.String.Length"/> of the input <paramref name="text"/>, leave -1 if not known</param>
            <returns>The part of the input <see cref="T:System.String"/> after the given <paramref name="index"/> || or <see cref="F:System.String.Empty"/> if both '<paramref name="index"/>' and <paramref name="textLength"/> are 0 || or <see cref="F:System.String.Empty"/> (with error or <see cref="T:System.ArgumentOutOfRangeException"/>) if out of bounds and <paramref name="text"/> is not <see cref="F:System.String.Empty"/> and <paramref name="index"/> is not 0</returns>
            <remarks>MUST USE RETURN VALUE
            <para><paramref name="index"/> of -1 will return all of <paramref name="text"/></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is negative or after the end of the <see cref="T:System.String"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Char[][])">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Char[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Char[])">
            <summary>Get all the <seealso cref="T:System.Char">characters</seealso> of the sub-string from start to end until the condition no longer matches or it reaches the end of the input <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="matchChars"></param>
            <returns>The sub-string before the first non-matching <see cref="T:System.Char"/> || <see cref="F:System.String.Empty"/> on error or if the input <paramref name="text"/> is empty or if there were no matching characters</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="matchChars"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Char[],System.Int32)">
            <summary>Get all the <seealso cref="T:System.Char">characters</seealso> of the sub-string from start to end until the condition no longer matches or it reaches the end of the input <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="startIndex">Must be &gt;= 0</param>
            <param name="matchChars"></param>
            <returns>The sub-string before the first non-matching <see cref="T:System.Char"/> || <see cref="F:System.String.Empty"/> on error or if the input <paramref name="text"/> is empty or if there were no matching characters<para>textLength == <paramref name="startIndex"/> will return <see cref="F:System.String.Empty"/></para></returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="matchChars"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative or after the end of the <see cref="T:System.String"/></exception>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentEmptyException"><paramref name="matchChars"/> is empty</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Predicate{System.Char},System.Int32)">
            <summary>Get all the <seealso cref="T:System.Char">characters</seealso> of the sub-string from start to end until the condition no longer matches or it reaches the end of the input <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="predicate"></param>
            <param name="startIndex"></param>
            <returns>The sub-string before the <paramref name="predicate"/> returned <see langword="false"/> || <see cref="F:System.String.Empty"/> on error or if the input <paramref name="text"/> is empty or if there were no matching characters<para>textLength == <paramref name="startIndex"/> will return <see cref="F:System.String.Empty"/></para></returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="predicate"/> is <see langword="null"/></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBefore(System.String,System.Char)">
            <summary>Gets the the first found sub-string before the first instance of the specified <seealso cref="T:System.Char">character</seealso> - <b>Excluding</b> the <seealso cref="T:System.Char">character</seealso></summary>
            <param name="text"></param>
            <param name="beforeThisChar">Get the sub-string before the first instance of this <see cref="T:System.Char"/></param>
            <returns>The sub-string before the first found instance of the specified <see cref="T:System.Char"/> || or '<see cref="F:System.String.Empty"/>' if not found || - Never <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeOrFallback(System.String,System.Char,System.String)">
            <summary>Gets the the first found sub-string before the first instance of the specified <seealso cref="T:System.Char">character</seealso> - <b>Excluding</b> the <seealso cref="T:System.Char">character</seealso> || or <paramref name="fallback"/> if not found</summary>
            <param name="text"></param>
            <param name="beforeThisChar">Try to get the sub-string before the first instance of this <see cref="T:System.Char"/></param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <returns>The sub-string before the first found instance of the specified <see cref="T:System.Char"/> || '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBefore(System.String,System.String)">
            <summary>Get the first found sub-string before the first instance of the given <paramref name="subString"/> in the input <paramref name="text"/> - <b>Excluding</b> the <paramref name="subString"/></summary>
            <param name="text"></param><param name="subString">Get the text before the first instance of this</param>
            <returns>The sub-string before the first found instance of the given <paramref name="subString"/> || '<see cref="F:System.String.Empty"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE<para>Returns <see cref="F:System.String.Empty"/> if: <list type="bullet"><item><paramref name="text"/> <see cref="P:System.String.Length"/> is shorter or equal to <paramref name="subString"/> <see cref="P:System.String.Length"/></item><item><paramref name="text"/> is <see cref="F:System.String.Empty"/></item><item><paramref name="text"/> == <paramref name="subString"/></item><item>The <paramref name="text"/> starts with the <paramref name="subString"/></item></list></para>
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="subString"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeOrFallback(System.String,System.String,System.String)">
            <summary>Get the first found sub-string before the first instance of the given <paramref name="subString"/> in the input <paramref name="text"/> - <b>Excluding</b> the <paramref name="subString"/></summary>
            <param name="text"></param><param name="subString">Get the text before the first instance of this <see cref="T:System.String"/></param>
            <param name="fallback">Return this <see cref="T:System.String"/> instead if no match found<para><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</para></param>
            <returns>The sub-string before the first found instance of the given <paramref name="subString"/> || '<paramref name="fallback"/>' <see cref="T:System.String"/> if not found</returns>
            <remarks>MUST USE RETURN VALUE<para>Returns <paramref name="fallback"/> if: <list type="bullet"><item><paramref name="text"/> <see cref="P:System.String.Length"/> is shorter or equal to <paramref name="subString"/> <see cref="P:System.String.Length"/></item><item><paramref name="text"/> is <see cref="F:System.String.Empty"/></item><item><paramref name="text"/> == <paramref name="subString"/></item><item>The <paramref name="text"/> starts with the <paramref name="subString"/></item></list></para>
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="subString"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeIndex(System.String,System.Int32)">
            <summary>Get the part of the input <see cref="T:System.String"/> before a specific <paramref name="index"/> - <b>Excluding</b> the <see cref="T:System.Char"/> at the <paramref name="index"/></summary>
            <param name="text"></param><param name="index">Get all the text before this <paramref name="index"/> || cannot be &lt; 0!</param>
            <returns>The part of the given <see cref="T:System.String"/> before the given <paramref name="index"/> - <b>Excluding</b> the <see cref="T:System.Char"/> at the <paramref name="index"/> || Never <see langword="null"/> || if <paramref name="index"/> == <paramref name="text"/><seealso cref="P:System.String.Length">.Length</seealso> returns <paramref name="text"/> || if <paramref name="index"/> == 0 returns <see cref="F:System.String.Empty"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index"/> is &lt; 0 or &gt;= <paramref name="text"/>.Length</exception><exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Inclusive(System.String,System.String,System.String,System.String,NQualityOfLife.Utils.StringMatchMode,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified <paramref name="start"/> and <paramref name="end"/> strings - <b>Including</b> the <paramref name="start"/> and <paramref name="end"/> strings</summary>
            <param name="text">Input text</param>
            <param name="start"><paramref name="start"/> string of the target substring</param>
            <param name="end"><paramref name="end"/> string of the target substring</param>
            <param name="settings"></param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <param name="matchMode"></param>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
            <returns>The substring starting with "<paramref name="start"/>" and ending with "<paramref name="end"/>" || or '<paramref name="fallback"/>' if not found</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/>, <paramref name="start"/> or <paramref name="end"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf(System.String,System.String,System.String,System.String,NQualityOfLife.Utils.StringMatchMode,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified <paramref name="start"/> and <paramref name="end"/> strings - <b>Excluding</b> the <paramref name="start"/> and <paramref name="end"/> strings</summary>
            <param name="text">Input text</param>
            <param name="start">The <see cref="T:System.String"/> before the target substring</param>
            <param name="end">The <see cref="T:System.String"/> after the target substring</param>
            <param name="settings"></param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <param name="matchMode"></param>
            <returns>The substring between "<paramref name="start"/>" and "<paramref name="end"/>" || or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/>, <paramref name="start"/> or <paramref name="end"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Invalid <see cref="T:System.StringComparison"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf(System.String,System.String,System.Char,System.String,System.StringComparison)">
            <summary>Gets the first sub-string that is inside the specified <paramref name="start"/> <see cref="T:System.String"/> and <paramref name="end"/> <see cref="T:System.Char"/> - <b>Excluding</b> the <paramref name="start"/> <see cref="T:System.String"/> and <paramref name="end"/> <see cref="T:System.Char"/></summary>
            <param name="text">Input text</param>
            <param name="start">The <see cref="T:System.String"/> before the target sub-string</param>
            <param name="end">The <see cref="T:System.Char"/> after the target substring</param>
            <param name="settings"></param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <returns>The sub-string after the "<paramref name="start"/>" <see cref="T:System.String"/> and before the '<paramref name="end"/>' <see cref="T:System.Char"/> || or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="start"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Invalid <see cref="T:System.StringComparison"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf(System.String,System.Int32,System.Char,System.String)">
            <summary>Gets the first substring that is inside the specified [ <paramref name="startIndex"/> ] and [ 'end' <see cref="T:System.Char"/> ] - <b>Excluding</b> the end <see cref="T:System.Char"/> and the character at the start index</summary>
            <param name="text">Input text</param>
            <param name="startIndex">The index right before the target substring</param>
            <param name="end">The <see cref="T:System.Char"/> right after the target substring</param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <returns>The substring starting after "<paramref name="startIndex"/>" and ending before [ 'end' <see cref="T:System.Char"/> ] || or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf(System.String,System.Int32,System.String,System.String,System.StringComparison)">
            <returns>The sub-string starting after '<paramref name="startIndex"/>' and ending before "<paramref name="end"/>" || or '<paramref name="fallback"/>' if not found</returns>
            <summary>Gets the first sub-string that is inside the specified <paramref name="startIndex"/> and <paramref name="end"/> <see cref="T:System.String"/> - <b>Excluding</b> the <see cref="T:System.Char"/> at the <paramref name="startIndex"/> and the <paramref name="end"/> <see cref="T:System.String"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Inclusive(System.String,System.Int32,System.String,System.String,System.StringComparison)"/>
            <param name="text"></param>
            <param name="startIndex"></param>
            <param name="end"></param>
            <param name="fallback"></param>
            <param name="settings"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/>is negative</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Inclusive(System.String,System.Int32,System.String,System.String,System.StringComparison)">
            <summary>Gets the first sub-string that is inside the specified <paramref name="startIndex"/> and <paramref name="end"/> <see cref="T:System.String"/> - <b>Including</b> the <see cref="T:System.Char"/> at the <paramref name="startIndex"/> and the <paramref name="end"/> <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="startIndex"></param>
            <param name="end"></param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <param name="settings"></param>
            <returns>The sub-string starting at '<paramref name="startIndex"/>' and ending with "<paramref name="end"/>" || or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Internal__(System.String,System.Int32,System.String,System.StringComparison,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Internal__(System.String,System.Int32,System.String,System.StringComparison,System.Boolean)">
            <summary>Gets the first sub-string that is inside the specified <paramref name="startIndex"/> and <paramref name="end"/> <see cref="T:System.String"/></summary>
            <param name="text">Input text</param>
            <param name="startIndex">Start index of the substring</param>
            <param name="end">End <see cref="T:System.String"/> of the substring</param>
            <param name="settings"></param>
            <param name="inclusive"></param>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see></para></remarks>
            <returns>The sub-string starting after or at '<paramref name="startIndex"/>' and ending before or with "<paramref name="end"/>" || or '<see langword="null"/>' if not found</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="end"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf(System.String,System.String,System.Int32,System.String,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified <paramref name="start"/> <see cref="T:System.String"/> and end Index - <b>Excluding</b> the start <see cref="T:System.String"/> and end Index</summary>
            <param name="text">Input text</param>
            <param name="start">The <see cref="T:System.String"/> before the target substring</param>
            <param name="endIndex">The index after the target substring</param>
            <param name="settings"></param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <returns>The first found sub-string between "<paramref name="start"/>" and '<paramref name="endIndex"/>' || or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Internal__(System.String,System.String,System.Int32,System.StringComparison,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Inclusive(System.String,System.String,System.Int32,System.String,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified <paramref name="start"/> <see cref="T:System.String"/> and end Index - <b>Including</b> the start <see cref="T:System.String"/> and end Index</summary>
            <returns>The first found sub-string that starts with "<paramref name="start"/>" and ends at '<paramref name="endIndex"/>' || or '<paramref name="fallback"/>' if not found</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf(System.String,System.String,System.Int32,System.String,System.StringComparison)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Internal__(System.String,System.String,System.Int32,System.StringComparison,System.Boolean)">
            <summary></summary>
            <param name="text"></param>
            <param name="start"></param>
            <param name="endIndex"></param>
            <param name="settings"></param>
            <param name="inclusive"></param>
            <returns>The first found sub-string between (or starting with) "<paramref name="start"/>" and '<paramref name="endIndex"/>' || or '<see langword="null"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">MayThrowOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="start"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOfInclusive(System.String,System.Char,System.Char,System.String)">
            <summary>Gets the first found sub-<see cref="T:System.String"/> that starts and ends with the specified characters - <b>Including the characters</b></summary>
            <param name="text">Input text</param>
            <param name="start">Start <see cref="T:System.Char"/> of the substring</param>
            <param name="end">End <see cref="T:System.Char"/> of the substring</param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <returns>The first found sub-<see cref="T:System.String"/> starting with '<paramref name="start"/>' and ending with '<paramref name="end"/>' || or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf(System.String,System.Char,System.Char,System.String,NQualityOfLife.Utils.StringMatchMode,System.Int32)">
            <summary>Gets the <b>first found</b> substring that is inside the specified characters - <b>Excluding the characters</b></summary>
            <param name="text">Input text</param>
            <param name="start">The <see cref="T:System.Char"/> before the start of the substring</param>
            <param name="end">The <see cref="T:System.Char"/> after the end of the substring</param>
            <param name="fallback"><see langword="null"/> is allowed here, if you are handling a <see langword="null"/> return from this method</param>
            <param name="matchMode"></param>
            <param name="startIndex"></param>
            <returns>The substring between the <paramref name="start"/> and <paramref name="end"/> chars || or '<paramref name="fallback"/>' if not found</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative or after the end of the <paramref name="text"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_FirstSubstringInsideOf_Exclusive(System.String,System.Char,System.Char,System.String)">
            <summary>Replaces the first found sub-string that is inside the specified <seealso cref="T:System.Char">characters</seealso> - <b>Excluding the characters</b> || If no match found, return the input <see cref="T:System.String"/> un-changed</summary>
            <param name="text">Input text</param>
            <param name="startChar">The <see cref="T:System.Char"/> before the start of the substring</param>
            <param name="endChar">The <see cref="T:System.Char"/> after the end of the substring</param>
            <param name="replacement">Replace the substring with this</param>
            <remarks>MUST USE RETURN VALUE
            <para>Please note that with inputs: ("aaa", 'a', 'a'); the first "aa" pair is what is targeted, resulting in nothing getting replaced</para>
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="replacement"/> is <see langword="null"/></exception>
            <returns>A copy of the original <see cref="T:System.String"/> with the first found sub-string between the <paramref name="startChar"/> and <paramref name="endChar"/> replaced || or the original text un-changed if the sub-string is not found || <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol">Null symbol</seealso> if any input is <see langword="null"/> (will error)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceAllCaseInsensitive(System.String,System.String,System.String)">
            <summary>Replaces all occurrences of the specified <see cref="T:System.String"/> (Case insensitive) with a new <see cref="T:System.String"/>.</summary>
            <param name="originalText"></param>
            <param name="stringsToReplace"></param>
            <param name="replacement"></param>
            <returns>The input <see cref="T:System.String"/> with all the substrings replaced</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="originalText"/>, <paramref name="stringsToReplace"/> or <paramref name="replacement"/> is <see langword="null"/></exception>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirstSymbol(System.String,System.Char)">
            <summary>Replace the first <see cref="T:System.Char"/> of the given <see cref="T:System.String"/> with a new character</summary>
            <param name="text">The <see cref="T:System.String"/> whose first <see cref="T:System.Char"/> we want to replace</param><param name="newSymbol">The new start symbol for the <paramref name="text"/></param><returns>The input <see cref="T:System.String"/> with the first <see cref="T:System.Char"/> swapped</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"><paramref name="text"/> is <see langword="null"/> or empty</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_FirstSubstringInsideOf_Inclusive(System.String,System.Char,System.Char,System.String,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Replace_FirstSubstringInsideOf_Inclusive(System.String,System.Char,System.Char,System.String,System.Int32@,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_FirstSubstringInsideOf_Inclusive(System.String,System.Char,System.Char,System.String,System.Int32@,System.Int32)">
            <summary>Replaces the first found substring that starts with "<paramref name="start"/>" and ends with "<paramref name="end"/>" - <b>Including</b> the <paramref name="start"/> and <paramref name="end"/> characters.</summary>
            <param name="text">Input text
            <para>Must not be <see langword="null"/></para></param>
            <param name="start">The first <see cref="T:System.Char"/> of the sub-string to replace</param>
            <param name="end">The last <see cref="T:System.Char"/> of the sub-string to replace</param>
            <param name="replacement">Replace the first found sub-string with this.
            <para>Must not be <see langword="null"/></para></param>
            <param name="startIndexOut">The index of the <paramref name="start"/> <see cref="T:System.Char"/> <see langword="out"/></param>
            <param name="startIndex">Must be &gt;= 0 and &lt; <paramref name="text"/>.<see cref="P:System.String.Length">Length</see></param>
            <returns>The original <see cref="T:System.String"/> with the first found sub-string replaced || or the original <paramref name="text"/> un-changed if the substring is not found || <see cref="F:System.String.Empty"/> if <paramref name="text"/> is <see langword="null"/></returns>
            <remarks>MUST USE RETURN VALUE<para>Note: if <paramref name="start"/> and <paramref name="end"/> are both 'a', <paramref name="text"/> is: "baaab" and <paramref name="replacement"/> is: "c" the result will be: "bcab" instead of: "bacab"! This is because the first match is the two back to back 'a's ("b'aa'ab").</para>
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="replacement"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_AllSubstringsInsideOf_Inclusive(System.String,System.Char,System.Char,System.String,System.Int16)">
            <summary>Replaces all the found substring that are inside the specified characters - <b>Including the characters</b></summary>
            <param name="text">Input text</param>
            <param name="start">The first <see cref="T:System.Char"/> of the substring to replace</param>
            <param name="end">The last <see cref="T:System.Char"/> of the substring to replace || Will match the first instance of this <see langword="char"/> after the <paramref name="start"/> <see langword="char"/></param>
            <param name="replacement">Replace all the found substring with this</param>
            <param name="maxIterations">The maximum amount of sub-strings to replace</param><exception cref="T:System.ArgumentOutOfRangeException">ran out of iterations</exception>
            <returns>The original <see cref="T:System.String"/> with all the found substrings replaced || or the original <paramref name="text"/> un-changed if none of the substrings were found</returns>
            <remarks>MUST USE RETURN VALUE<para>Note: if <paramref name="start"/> and <paramref name="end"/> are both 'a', <paramref name="text"/> is: "baaab" and <paramref name="replacement"/> is: "c" the result will be: "bcab" instead of: "bacab"! This is because the first match is the two back to back 'a's ("b'aa'ab").</para>
            <para>Will return <see cref="F:System.String.Empty"/> with error if input <paramref name="text"/> is <see langword="null"/></para>
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="replacement"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_Internal(System.String,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>Replaces a part of the <see cref="T:System.String"/> from start index to end index with a new value - (to = (from + with.Length - 1))</summary>
            <param name="text">Original <see cref="T:System.String"/></param>
            <param name="fromIndex">Replace starting from index<para>must be &gt;= 0 and &lt;= <paramref name="toIndex"/></para></param>
            <param name="toIndex">to index - (from + with.Length - 1)<para>must be &gt;= <paramref name="fromIndex"/></para></param>
            <param name="with">New value to be placed starting and ending at the specified indexes</param>
            <param name="textLength">Known Length of <paramref name="text"/>, leave -1 if not known</param>
            <returns>The original <see cref="T:System.String"/> with the specified part replaced || - never <see langword="null"/> (returns <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null symbol</seealso> if input <paramref name="text"/> is <see langword="null"/> (with error logged))</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="fromIndex"/> is %gt; <paramref name="toIndex"/> or %lt; 0, or <paramref name="toIndex"/> is %lt; 0</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="with"/> is <see langword="null"/></exception>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_Internal(System.String,System.Int32,System.String,System.Int32)">
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">MayThrowOnIllegalRange</see></para></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.Replace(System.String,System.Int32,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveInsertInternal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>This method combines the code: <code><paramref name="text"/>.Remove(<paramref name="atIndex"/>, 1).Insert(atIndex, <paramref name="with"/>);</code> to accomplish the operation faster with less allocations</summary>
            <param name="text"></param>
            <param name="atIndex"></param>
            <param name="with"></param>
            <param name="withLength"></param>
            <param name="textLength"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace(System.String,System.Int32,System.String)">
            <summary>Replace the <seealso cref="T:System.Char">character</seealso> at the specified index with the given substring</summary>
            <param name="text">Text to modify - Cannot be <see langword="null"/>!</param>
            <param name="atIndex">The index of the <seealso cref="T:System.Char">character</seealso> to replace with a <see cref="T:System.String"/>
            <para>Must be &gt;= 0 and &lt; <paramref name="text"/>.<see cref="P:System.String.Length">Length</see></para></param>
            <param name="with">The <see cref="T:System.String"/> to place at the given index</param>
            <returns>The input <see cref="T:System.String"/> modified with the <seealso cref="T:System.Char">character</seealso> at the given index replaced with the given <see cref="T:System.String"/></returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="atIndex"/> is %lt; 0 or %gt;= <paramref name="text"/>.Length</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="with"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace(System.String,System.Int32,System.Char)">
            <summary>Replace the <seealso cref="T:System.Char">character</seealso> at the specified index with the given <seealso cref="T:System.Char">character</seealso></summary>
            <param name="text">Text to modify - Cannot be <see langword="null"/>!</param><param name="atIndex">The index of the <seealso cref="T:System.Char">character</seealso> to replace</param><param name="with">The new <seealso cref="T:System.Char">character</seealso> to put at the index</param>
            <returns>The input <see cref="T:System.String"/> modified with the <seealso cref="T:System.Char">character</seealso> at the given index swapped</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="atIndex"/> is %lt; 0 or %gt;= <paramref name="text"/>.Length</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirst(System.String,System.String,System.String)">
            <summary>Replaces the first found instance of '<paramref name="subString"/>' with '<paramref name="with"/>'</summary>
            <param name="text">The original text to modify</param>
            <param name="subString">Replace the first instance of this with '<paramref name="with"/>'</param>
            <param name="with">Replace '<paramref name="subString"/>' with this</param>
            <returns>The original <see cref="T:System.String"/> with the first matching <paramref name="subString"/> replaced || or the original <see cref="T:System.String"/> un-changed if none found.</returns>
            <remarks>MUST USE RETURN VALUE<para>Will return <paramref name="text"/> on error, unless it is <see langword="null"/>, in that case <see cref="F:System.String.Empty"/> will be returned</para>
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/>, <paramref name="subString"/> or <paramref name="with"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirstOf(System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirst(System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirst(System.String,System.Char,System.String)">
            <summary>Replace the first found occurrence of the given <paramref name="character"/> with the given <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <param name="character"></param>
            <param name="with"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> that is a copy of '<paramref name="text"/>' with the first occurrence of '<paramref name="character"/>' replaced with '<paramref name="with"/>'</returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="with"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceLast(System.String,System.String,System.String)">
            <summary>Replace the specified substring that is closest to the end of the input <see cref="T:System.String"/> with a new value</summary>
            <param name="text"></param>
            <param name="subString"></param>
            <param name="with"></param>
            <returns><paramref name="text"/> with the last occurrence of <paramref name="subString"/> replaced with '<paramref name="with"/>' || or <paramref name="text"/> un-changed if it did not contain any instances of '<paramref name="subString"/>'</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/>, <paramref name="subString"/> or <paramref name="with"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceLast(System.String,System.Char,System.Char)">
            <summary>Iterates the input <see cref="T:System.String"/> in reverse and replaces the first found <paramref name="oldChar"/> with <paramref name="newChar"/> and returns the modified <see cref="T:System.String"/></summary>
            <param name="text">Input <see cref="T:System.String"/></param>
            <param name="oldChar">Replace last instance of this <see cref="T:System.Char"/> with <paramref name="newChar"/></param>
            <param name="newChar">Replace <paramref name="oldChar"/> with this</param>
            <returns>The input <see cref="T:System.String"/> with the last occurrence of <paramref name="oldChar"/> replaced with <paramref name="newChar"/></returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceLast(System.String,System.Char)">
            <summary>Replaces the last <seealso cref="T:System.Char">character</seealso> of the input <paramref name="text"/> with <paramref name="newChar"/></summary>
            <param name="text"></param>
            <param name="newChar"></param>
            <returns><paramref name="text"/> with the last <see cref="T:System.Char"/> replaced with <paramref name="newChar"/> || or <see cref="F:System.String.Empty"/> (with error) if <paramref name="text"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"><paramref name="text"/> is <see langword="null"/> or empty</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveAll(System.String,System.Char)">
            <inheritdoc cref="M:System.String.Replace(System.String,System.String)"/>
            <summary></summary>
            <param name="text"></param>
            <param name="character"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveAll(System.String,System.Char[])">
            <summary>Remove all the given <paramref name="chars"/> from the input <paramref name="text"/></summary>
            <param name="text"></param>
            <param name="chars"></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> that is the input <paramref name="text"/> with all the instances of the <paramref name="chars"/> removed</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="chars"/> is <see langword="null"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveAll(System.String,System.String)">
            <inheritdoc cref="M:System.String.Replace(System.String,System.String)"/>
            <summary></summary>
            <param name="text"></param>
            <param name="strings"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveFirst(System.String)">
            <summary>Removes the first character from the input <see cref="T:System.String"/></summary>
            <param name="text"></param>
            <returns>The input <see cref="T:System.String"/> with the first letter/<see cref="T:System.Char"/> removed.</returns>
            <remarks>If <paramref name="text"/> is <see langword="null"/> or empty, returns it un-changed
            <para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveFirst(System.String,System.Char)">
            <summary>Removes the first found instance of the given <see cref="T:System.Char"/></summary>
            <param name="text"></param><param name="symbol">The <see cref="T:System.Char"/> to remove</param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> that is the input <see cref="T:System.String"/> with the first occurrence of the given '<paramref name="symbol"/>' removed<para>or <paramref name="text"/> un-changed if it did not contain the '<paramref name="symbol"/>'</para></returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveFirst(System.String,System.String)">
            <summary>Removes the first found instance of the given sub-<see cref="T:System.String"/></summary>
            <param name="text"></param><param name="subString">The sub-<see cref="T:System.String"/> to remove</param>
            <returns>The input <see cref="T:System.String"/> with the first occurrence of the sub-string removed || or the original <see cref="T:System.String"/> un-changed if <paramref name="subString"/> not found.</returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="subString"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveFirstOf(System.String,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.StringExtensions.RemoveFirst(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLast(System.String,System.String)">
            <summary>Removes the last instance of the given <paramref name="subString"/> from the <paramref name="text"/></summary>
            <param name="text"></param><param name="subString">The sub-string to remove</param><exception cref="T:System.ArgumentNullException"></exception>
            <returns>The input <see cref="T:System.String"/> with the last occurrence of the <paramref name="subString"/> removed || or <paramref name="text"/> un-changed if it didn't contain <paramref name="subString"/></returns>
            <remarks>MUST USE RETURN VALUE
            <para><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLast(System.String,System.Char)">
            <summary>Removes the last found instance of the given <see cref="T:System.Char"/></summary>
            <param name="text"></param><param name="symbol">The <see cref="T:System.Char"/> to remove</param>
            <returns>The input <see cref="T:System.String"/> with the last occurrence of <paramref name="symbol"/> removed<para>or <paramref name="text"/> un-changed if it did not contain the <paramref name="symbol"/></para></returns>
            <remarks>MUST USE RETURN VALUE</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLast(System.String)">
            <summary>Removes the last character from the input <see cref="T:System.String"/></summary>
            <param name="text">Remove the last <see cref="T:System.Char"/> from this <see cref="T:System.String"/></param>
            <returns>A <see langword="new"/> <see cref="T:System.String"/> that is the input <see cref="T:System.String"/> with the last letter/<see cref="T:System.Char"/> removed.</returns>
            <remarks>If <paramref name="text"/> is <see langword="null"/> or empty, returns it un-changed
            <para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.TryParseAsInt(System.String,System.Int32@)">
            <inheritdoc cref="M:System.Int32.TryParse(System.String,System.Int32@)"/>
            <summary></summary>
            <param name="text"></param>
            <param name="parsed">0 if parse failed</param>
            <returns></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.TryParseAsFloat(System.String,System.Single@)">
            <inheritdoc cref="M:System.Single.TryParse(System.String,System.Single@)"/>
            <summary></summary>
            <param name="text"></param>
            <param name="parsed"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.TryParseMetric(System.String,System.Single@)">
            <summary></summary>
            <param name="text"></param>
            <param name="parsed"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Redactor">
            <summary>Used for redacting things like personal information from strings</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo(System.String)">
            <summary>Attempts to redact any personal data/information, such as usernames</summary>
            <param name="text"></param>
            <returns>The input <paramref name="text"/> with personal data redacted - Note: is not guaranteed to redact everything!</returns>
            <remarks>MUST USE RETURN VALUE</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo_Linux(System.String)">
            <summary>Attempts to redact any personal data, such as usernames</summary>
            <param name="text"></param>
            <returns>The input text with personal data redacted - Note: is not guaranteed to redact everything!</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo_Windows(System.String)">
            <summary>Attempts to redact any personal data, such as usernames</summary>
            <param name="text"></param>
            <returns>The input text with personal data redacted - Note: is not guaranteed to redact everything!</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Reflection_">
            <summary>Class containing all sorts of utilities and methods for purposes of reflection and dynamic method invocation</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.ComparisonHelper.Compare(System.Object,System.Object,System.String)">
            <summary></summary>
            <param name="varA"></param>
            <param name="varB"></param>
            <param name="operation"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ClearCache">
            <summary>Clear the cache of methods and fields</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_FromString(System.String,System.String,System.Object@,System.Boolean)">
            <summary>Invoke a method or property getter using an input <see cref="T:System.String"/></summary>
            <param name="invoke">The method or property getter and its parameters - The return value (if any) is passed as the first param to the 'postInvoke' method (if given)</param>
            <param name="postInvoke">Invoke a secondary method or property getter using the result from the first invoke as the first param</param>
            <param name="firstInvokeResult">The value returned by the method specified in 'invoke'</param>
            <param name="allowNonPublic"></param>
            <returns>The value returned by the invoked method or property, if 'postInvoke' is given the value of it will be returned instead of 'invoke'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_StringForInvoke(System.String)">
            <summary>Check if the string is illegal</summary>
            <param name="myString"></param>
            <returns>true if ok, false if not allowed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ResolveParameters_FromStrings(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Type}@)">
            <summary>Convert a list of strings into the objects / values that they represent</summary>
            <param name="parameters">The parameter inputs strings</param>
            <param name="parsedAs">The types that the input parameters were parsed as</param>
            <returns>The actual values that the input strings represented</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ResolveParameter_FromString(System.String,System.Type@)">
            <summary>Convert a string into the real value it represents. for example and input parameter of 'A' will be parsed as a char 'A'. input of "ABC" will be parsed as a string etc.</summary>
            <param name="parameter">The string representation of a value. "" for strings, '' for chars, f for floats etc..</param>
            <param name="parsedAs">The type that the input was parsed as.</param>
            <returns>The real value that the input string represents</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.GetTypes(System.Object[])">
            <summary>Get the types of the given objects</summary>
            <param name="parameters"></param>
            <returns>An array of the types in order</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.GetMethod(System.String,System.Object[]@,System.Object@,System.Object,System.Object[])">
            <summary>Try get the MethodInfo for the method or property getter matching the given params</summary>
            <param name="nameSpaceDotTypeColonMethod">NQualityOfLife.Utils.Rand:RandDegrees</param>
            <param name="parametersOut"></param>
            <param name="instanceOut"></param>
            <param name="instance"></param>
            <param name="parameters"></param>
            <returns>The found <see cref="T:System.Reflection.MethodInfo"/> of the specified method or property or <see langword="null"/> if not found.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Method_WithType(System.String,System.String,System.String,System.Boolean,System.Object[])">
            <summary>Invoke a method or property getter of the given type with the given params</summary>
            <param name="type"></param>
            <param name="method"></param>
            <param name="defaultNameSpace"></param>
            <param name="allowNonPublic"></param>
            <param name="parameters"></param>
            <returns>The result of the invoked method or property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Method(System.String,System.Object[],System.Boolean)">
            <summary>Invokes a method or property getter</summary>
            <param name="nameSpaceDotTypeColonMethod">NQualityOfLife.Utils.Rand:RandDegrees</param>
            <param name="parameters">The first parameter is the instance, if the called method or property is not <see langword="static"/></param>
            <param name="allowNonPublic"></param>
            <returns>The return of the invoked method or property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.TryResolveTargetType(System.String,System.String@,System.String)">
            <summary>Resolve the type / namespace of the given type</summary>
            <param name="targetType">NQualityOfLife.Utils.Rand</param>
            <param name="nameSpaceDotType">NQualityOfLife.Utils.Rand</param>
            <param name="defaultNameSpace"></param>
            <returns><see langword="true"/> if the target type was valid and successfully resolved</returns>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"><paramref name="targetType"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_Final_String__(System.String)">
            <summary>Checks for illegal characters or blacklisted namespaces etc</summary>
            <param name="typeColonMethod">NQualityOfLife.Utils.Rand:RandDegrees</param>
            <returns><see langword="false"/> if the provided method or type is not allowed.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_Method(System.Reflection.MethodBase,System.Boolean)">
            <summary>Make sure the specified <paramref name="method"/> is allowed to be invoked</summary>
            <param name="method">The method to validate</param>
            <param name="allowNonPublic">Do we allow non-<see langword="public"/> members to be invoked?</param>
            <returns><see langword="false"/> if the method is not allowed to be invoked</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_PropertyGet_Static(System.String,System.String,System.String,System.Boolean)">
            <summary>Invoke a static property getter</summary>
            <param name="type">The class containing the static property getter</param>
            <param name="propertyGet">The name of the property getter</param>
            <param name="defaultNameSpace"></param>
            <param name="allowNonPublic"></param>
            <returns>The value returned by the static property getter</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_GetFieldValue(System.String,System.Object,System.String)">
            <summary>Get the value stored in the specified field of the instance (or static field if instance is <see langword="null"/>)</summary>
            <param name="fieldName"></param>
            <param name="instance">Get the non static field from this instance, or static field if instance is <see langword="null"/></param>
            <param name="nameSpaceDotType"></param>
            <returns>The value stored in the field</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_GetFieldValue(System.Type,System.String,System.Object,System.String)">
            <summary>Get the value of the given field from the given instance (or static field if instance is <see langword="null"/>)</summary>
            <param name="type">The <see cref="T:System.Type"/> that contains a field with the given name</param>
            <param name="fieldName">The name of the field</param>
            <param name="instance">Instance class to get the field value of, or <see langword="null"/> if the field is <see langword="static"/></param>
            <param name="nameSpaceDotType">NameSpace.Type</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_PropertyGet(System.String,System.Object,System.Boolean)">
            <summary>Invoke a property get of the given instance (or a static property if instance is not given)</summary>
            <param name="typeColonPropertyGet">NameSpace.Type:PropertyGet - If NameSpace not given, will use default</param>
            <param name="instance">Invoke a non static property of this instance, set to <see langword="null"/> if the property is static</param>
            <param name="allowNonPublic">Are non-public property invokes allowed?</param>
            <returns>The returned value of the invoked property getter</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="typeColonPropertyGet"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Static(System.Reflection.ConstructorInfo,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Static(System.Reflection.MethodBase,System.Object[],System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Static(System.Reflection.MethodBase,System.Object[],System.Boolean)">
            <summary>
            Invoke a <see langword="static"/> <paramref name="method"/> or property getter
            <para>
            If the target is a <b><see langword="static"/> constructor</b> (type initializer), it will be invoked using
            <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)"/> to ensure it runs
            only once per <see cref="T:System.AppDomain"/>, as guaranteed by the CLR.
            </para>
            <para>
            Note that <b><see langword="static"/> constructors</b> cannot be invoked directly via <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)"/>,
            and attempting to do so may lead to unexpected behavior or runtime exceptions.
            </para>
            </summary>
            <param name="method">The <see langword="static"/> <paramref name="method"/> to invoke</param>
            <param name="parameters">The parameters to pass into the <paramref name="method"/>, should be set to <see langword="null"/> if the <paramref name="method"/> doesn't have any parameters or it is a property getter</param>
            <param name="allowNonPublic">Allow non-<see langword="public"/> members to be invoked</param>
            <returns>The invoke result / The value returned by the target <paramref name="method"/> or property getter - <see langword="void"/> methods and <see langword="static"/> constructors will return <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke(System.Object,System.Reflection.MethodBase,System.Object[],System.Boolean)">
            <summary>
            Invoke the given <see langword="static"/> or instanced <paramref name="method"/> or property getter of the given <paramref name="instance"/> with the given <paramref name="parameters"/> - <paramref name="instance"/> should be <see langword="null"/> if the method or property is <see langword="static"/>
            <para>
            If the target is a <b><see langword="static"/> constructor</b> (type initializer), it will be invoked using
            <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)"/> to ensure it runs
            only once per <see cref="T:System.AppDomain"/>, as guaranteed by the CLR.
            </para>
            <para>
            Note that <b><see langword="static"/> constructors</b> cannot be invoked directly via <see cref="M:System.Reflection.ConstructorInfo.Invoke(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)"/>,
            and attempting to do so may lead to unexpected behavior or runtime exceptions.
            </para>
            </summary>
            <param name="instance"><paramref name="instance"/> of the non-<see langword="static"/> <see langword="class"/> that contains the non-<see langword="static"/> <paramref name="method"/> or property, set to <see langword="null"/> if the <paramref name="method"/> or property is <see langword="static"/></param>
            <param name="method">The name of the <paramref name="method"/> or property getter</param>
            <param name="parameters">The parameters to invoke the <paramref name="method"/> with, or <see langword="null"/> if no params or the <paramref name="method"/> is a property getter - Should be <see langword="null"/> if no params</param>
            <param name="allowNonPublic">Is invoking non <see langword="public"/> members allowed?</param>
            <returns>The invoke result / The value returned by the target <paramref name="method"/> or property getter - <see langword="void"/> methods and <see langword="static"/> constructors will return <see langword="null"/></returns>
        </member>
        <member name="F:NQualityOfLife.Utils.Reflection_.PropertySetterPrefix">
            <summary>The name prefix given to property <see langword="set"/> accessor <see cref="T:System.Reflection.MethodInfo">methods</see> by the compiler</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Reflection_.PropertyGetterPrefix">
            <summary>The name prefix given to property <see langword="get"/> accessor <see cref="T:System.Reflection.MethodInfo">methods</see> by the compiler</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Reflection_.PropertyAccessorFlags">
            <summary>The <see cref="T:System.Reflection.MethodAttributes"/> that are set for all property accessor methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.ClearCaches">
            <summary>Clear method / field info caches</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsStruct(System.Type)">
            <summary>Check if the given <paramref name="type"/> is a <see langword="struct"/></summary>
            <param name="type"></param>
            <returns><see langword="true"/> if the <paramref name="type"/> is a <see langword="struct"/></returns>
            <remarks>A <see langword="struct"/> is a non primitive value <see cref="T:System.Type"/> that is not an <see cref="T:System.Enum"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsRecursive(System.Reflection.MethodBase)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the given <paramref name="method"/> is recursive on itself</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="method"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsPrimitiveMethod(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the given '<paramref name="method"/>' only uses primitive types as parameters, has atleast one parameter and has a non-<see langword="void"/> primitive return <see cref="T:System.Type"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsVoidReturnType(System.Reflection.MethodInfo)">
            <summary>Check if the given</summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the <paramref name="method"/> has a '<see langword="void"/>' <see langword="return"/> <see cref="T:System.Type"/>
            <para>Else, <see langword="false"/></para></returns>
            <remarks>Does not take <see langword="out"/> / <see langword="ref"/> parameters into account</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsVoidReturnType(System.Reflection.MethodBase)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.IsVoidReturnType(System.Reflection.MethodInfo)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsPropertyMethod(System.Reflection.MethodBase)">
            <summary>Check if the <paramref name="method"/> is a <see langword="get"/> or <see langword="set"/> method of a property</summary>
            <returns><see langword="true"/> if the <paramref name="method"/> is a <see langword="set"/> or <see langword="get"/> method of a property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsPropertySetterMethod(System.Reflection.MethodBase)">
            <summary>Check if the <paramref name="method"/> is a <see langword="set"/> method of a property</summary>
            <returns><see langword="true"/> if the <paramref name="method"/> is a <see langword="set"/> method of a property</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.IsPropertyMethod(System.Reflection.MethodBase)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsPropertyGetterMethod(System.Reflection.MethodBase)">
            <summary>Check if the <paramref name="method"/> is a <see langword="get"/> method of a property</summary>
            <returns><see langword="true"/> if the <paramref name="method"/> is a <see langword="get"/> method of a property</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.IsPropertyMethod(System.Reflection.MethodBase)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsReadonly(System.Reflection.MethodBase)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the given <paramref name="method"/> is marked <see langword="readonly"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsReadonly(System.Reflection.PropertyInfo)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.IsReadonly(System.Reflection.MethodBase)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetCalledMethods(System.Reflection.MethodBase)">
            <summary>Get all the methods that may be called from inside the given <paramref name="method"/></summary>
            <param name="method"></param>
            <returns>A set of the methods that the given <paramref name="method"/> may call directly</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="method"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"><paramref name="method"/> is an interface method and has no default implementation!</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetCalledMethods(System.Reflection.MethodBase,System.Byte[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.GetCalledMethods(System.Reflection.MethodBase)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetCalledMethods(System.Byte[],System.Type)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.GetCalledMethods(System.Reflection.MethodBase)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetCalledMethods(System.Byte[],System.Reflection.Module)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.GetCalledMethods(System.Reflection.MethodBase)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetLoadedCodeModules(System.Reflection.Assembly)">
            <inheritdoc cref="M:System.Reflection.Assembly.GetModules(System.Boolean)"/>
            <summary></summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasMethodBody(System.Reflection.MethodBase)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.HasMethodBody(System.Reflection.MethodBase,System.Reflection.MethodBody@,System.Byte[]@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasMethodBody(System.Reflection.MethodBase,System.Reflection.MethodBody@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.HasMethodBody(System.Reflection.MethodBase,System.Reflection.MethodBody@,System.Byte[]@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasMethodBody(System.Reflection.MethodBase,System.Byte[]@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.HasMethodBody(System.Reflection.MethodBase,System.Reflection.MethodBody@,System.Byte[]@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasMethodBody(System.Reflection.MethodBase,System.Reflection.MethodBody@,System.Byte[]@)">
            <summary>Check if the given <paramref name="member"/> has a valid <see cref="T:System.Reflection.MethodBody"/></summary>
            <param name="member"></param>
            <param name="body">The <see cref="T:System.Reflection.MethodBody"/> given by <see cref="M:System.Reflection.MethodBase.GetMethodBody"/></param>
            <param name="ilBytes">The bytes given by <see cref="M:System.Reflection.MethodBody.GetILAsByteArray"/></param>
            <returns><see langword="true"/> if the given <paramref name="member"/> has a valid <see cref="T:System.Reflection.MethodBody"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="member"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPatchClass(System.Type,HarmonyLib.HarmonyPatch@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPatchClass(System.Type)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPatchClass(System.Type)">
            <summary>Is the given class a harmony patch?</summary><param name="type"></param><returns><see langword="true"/> if the class is a harmony patch</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPatch(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the <paramref name="method"/> is a harmony prefix, postfix or transpiler</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsDestructiveHarmonyPrefix(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the <paramref name="method"/> is a harmony prefix with a <see cref="T:System.Boolean"/> return type</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPrefix(System.Reflection.MethodInfo)">
            <summary>Check if the given method is a harmony Prefix method inside a harmony patch class</summary>
            <param name="method"></param><returns><see langword="true"/> if is a harmony Prefix method</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPostfix(System.Reflection.MethodInfo)">
            <summary>Check if the given method is a harmony Prefix method inside a harmony patch class</summary>
            <param name="method"></param><returns><see langword="true"/> if is a harmony Postfix method</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyTranspiler(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the <paramref name="method"/> is a harmony transpiler</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyFinalizer(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the <paramref name="method"/> is a harmony finalizer</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasConflictingHarmonyAttributeAndOrName(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns><see langword="true"/> if the <paramref name="method"/> has conflicting name and or attributes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetTypes_Safe(System.Reflection.Assembly)">
            <summary>Get <seealso cref="T:System.Type">Types</seealso> from an <see cref="T:System.Reflection.Assembly"/>, <see cref="T:System.Reflection.ReflectionTypeLoadException"/> are handled silently</summary>
            <param name="assembly">the input assembly</param>
            <returns>Array '<see cref="T:System.Type"/>[]' of all the successfully loaded <seealso cref="T:System.Type">Types</seealso></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetTypes(System.Reflection.Assembly,System.Boolean,System.Boolean)">
            <summary>Get Types from an Assembly, <see cref="T:System.Reflection.ReflectionTypeLoadException"/> are handled silently</summary>
            <param name="assembly">the input assembly</param>
            <param name="alwaysPrintExceptions">Always print <see cref="T:System.Reflection.ReflectionTypeLoadException"/> to log as warnings, even if debug mode is off</param>
            <param name="allowUnloaded">Try to get the types from assemblies that are not currently loaded into the <see cref="T:System.AppDomain"/></param>
            <returns>Array 'Type[]' of all the successfully loaded Types</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetTypes(System.Reflection.Assembly,System.Boolean)">
            <inheritdoc cref="M:System.Reflection.Assembly.GetTypes"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetTypes(System.Reflection.Module)">
            <inheritdoc cref="M:System.Reflection.Module.GetTypes"/>
            <summary></summary>
            <param name="module"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetType(NQualityOfLife.Types.MemberName@)">
            <inheritdoc cref="M:System.Type.GetType(System.String,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.RunStaticConstructor(System.Type)">
            <inheritdoc cref="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasAttribute``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary></summary>
            <typeparam name="A"></typeparam>
            <param name="memberInfo"></param>
            <param name="inherit"></param>
            <returns><see langword="true"/> if the member has the attribute '<typeparamref name="A"/>'</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="memberInfo"/> is <see langword="null"/></exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasAttribute__(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalArg">MayThrowOnIllegalArg</see> | <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">MayErrorOnIllegalNull</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.HasAttribute``1(System.Reflection.MemberInfo,System.Boolean)"/>
            <inheritdoc cref="M:System.Attribute.IsDefined(System.Reflection.MemberInfo,System.Type,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetAttribute_Safe``1(System.Reflection.MemberInfo,``0@,System.Boolean)">
            <summary></summary>
            <typeparam name="A"></typeparam>
            <param name="memberInfo"></param>
            <param name="attribute"></param>
            <param name="throwInsteadOfLog">Dont log errors about un-expected reflection exceptions and instead <see langword="throw"/> them</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetAttributes``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>Get all instances of the <see cref="T:System.Attribute"/> '<typeparamref name="A"/>' from the given <paramref name="memberInfo"/></summary>
            <typeparam name="A"></typeparam>
            <param name="memberInfo"></param>
            <param name="inherit"></param>
            <returns>An array of '<typeparamref name="A"/>' or <see langword="null"/> if failed to get the attribute data
            <para>Empty array if the <paramref name="memberInfo"/> doesn't have the <see cref="T:System.Attribute"/> '<typeparamref name="A"/>'</para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetAllAttributes(System.Reflection.MemberInfo,System.Boolean)">
            <summary></summary>
            <param name="memberInfo"></param>
            <param name="inherit"></param>
            <returns>An array of attributes that are applied to the <paramref name="memberInfo"/>
            <para>Empty array if the <paramref name="memberInfo"/> doesn't have any <see cref="T:System.Attribute"/>s</para>
            <para><see langword="null"/> if failed to get the attributes from the <paramref name="memberInfo"/></para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetFirstAttribute``1(System.Reflection.MemberInfo,System.Boolean)">
            <summary>Get the first found <see cref="T:System.Attribute"/> '<typeparamref name="A"/>' from the given <paramref name="memberInfo"/></summary>
            <typeparam name="A"></typeparam>
            <param name="memberInfo"></param>
            <param name="inherit"></param>
            <returns>The first found instance of '<typeparamref name="A"/>' or <see langword="null"/> if none found</returns>
            <remarks>For attributes that allow multiple instances on a single member; it is recommended to use: '<see cref="M:NQualityOfLife.Utils.Reflection_.GetAttributes``1(System.Reflection.MemberInfo,System.Boolean)"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetAttributes_Internal(System.Reflection.MemberInfo,System.Boolean,System.Boolean,System.Boolean,System.Type)">
            <summary></summary>
            <param name="memberInfo">Type, method, field, etc. Whose attributes we want.</param>
            <param name="alwaysPrintExceptions">Always print type load exceptions as warnings. (Normally handled silently)</param>
            <param name="inherit"></param>
            <param name="throwInsteadOfLog">Dont log errors about un-expected reflection exceptions and instead <see langword="throw"/> them</param>
            <param name="ofType"></param>
            <returns><see cref="T:System.Attribute"/> array</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetMethod_Safe(System.Reflection.Assembly,System.String,System.String,System.Reflection.BindingFlags)">
            <summary>Get the <see cref="T:System.Reflection.MethodInfo"/> with the given name and containing type from the given <paramref name="assembly"/></summary>
            <param name="assembly"></param>
            <param name="declaringTypeFullName">Namespace.Namespace.Type/Namespace.Type</param>
            <param name="methodName"></param>
            <param name="bindingFlags"></param>
            <returns><see cref="T:System.Reflection.MethodInfo"/> of the target method if it was found || <see langword="null"/> if it was not found or there was an error.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/>, <paramref name="declaringTypeFullName"/> or <paramref name="methodName"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetMethod_Safe(System.Type,System.String,System.Type[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.GetMethod_Safe(System.Type,System.String,System.Type[],System.Reflection.BindingFlags)"/>
            <summary></summary>
            <param name="declaringType"></param>
            <param name="methodName"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetMethod_Safe(System.Type,System.String,System.Type[],System.Reflection.BindingFlags)">
            <summary>Try to get the method or property getter inside the given type</summary>
            <param name="declaringType"></param>
            <param name="methodName"></param>
            <param name="parameterTypes"></param>
            <param name="bindingFlags"></param>
            <returns><see cref="T:System.Reflection.MethodInfo"/> of the given method or property getter, or <see langword="null"/> if not found</returns>
            <exception cref="T:System.Reflection.AmbiguousMatchException"></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="declaringType"/> is <see langword="null"/></exception>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"><paramref name="methodName"/> is <see langword="null"/> or <see cref="F:System.String.Empty"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetStaticField``1(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>Get the <see cref="T:System.Reflection.FieldInfo"/> of a <see langword="static"/> field inside the given <see cref="T:System.Type"/></summary>
            <param name="containingType"></param>
            <param name="fieldName"></param>
            <param name="bindingFlags"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="containingType"/> or <paramref name="fieldName"/> is <see langword="null"/></exception>
            <typeparam name="TF">Field type</typeparam>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetStaticField(System.Type,System.String,System.Reflection.BindingFlags)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Reflection_.GetStaticField``1(System.Type,System.String,System.Reflection.BindingFlags)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetField(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>Get the <see cref="T:System.Reflection.FieldInfo"/> of a field inside the given <see cref="T:System.Type"/></summary>
            <param name="containingType"></param>
            <param name="fieldName"></param>
            <param name="bindingFlags"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="containingType"/> or <paramref name="fieldName"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetFieldValue(System.Object,System.String,System.Reflection.BindingFlags)">
            <summary>Get the non-<see langword="static"/> field value from the provided instance</summary>
            <param name="instance">The instance that contains the non-static field</param>
            <param name="fieldName">The name of the non-static field</param>
            <param name="bindingFlags"></param>
            <returns>The value stored in the non-<see langword="static"/> field of the given instance</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instance"/> or <paramref name="fieldName"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetFieldValue(System.Type,System.String,System.Reflection.BindingFlags,System.String)">
            <summary>Get the field value of a <see langword="static"/> field</summary>
            <param name="declaringType">One of: 'declaringType' or 'nameSpaceDotType' must be provided</param>
            <param name="fieldName"></param>
            <param name="bindingFlags"></param>
            <param name="nameSpaceDotType">One of: 'declaringType' or 'nameSpaceDotType' must be provided</param>
            <returns>The value of the specified <see langword="static"/> field</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ILDecompiler.DecodeToken(System.Int32,System.Reflection.Emit.OpCode@,System.Reflection.Module)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ILDecompiler.DecodeToken(System.Int32,System.Reflection.Emit.OperandType,System.Reflection.Module)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ILDecompiler.DecodeToken(System.Int32,System.Reflection.Emit.OperandType,System.Reflection.Module)">
            <summary></summary>
            <param name="token"></param>
            <param name="operandType"></param>
            <param name="module"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ILDecompiler.Disassemble(System.Reflection.MethodBase)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ILDecompiler.Disassemble(System.Reflection.MethodBody,System.Reflection.Module)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ILDecompiler.Disassemble(System.Reflection.MethodBody,System.Reflection.Module)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ILDecompiler.Disassemble(System.Byte[],System.Reflection.Module)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ILDecompiler.Disassemble(System.Byte[],System.Reflection.Module)">
            <summary></summary>
            <param name="methodILBytes"></param>
            <param name="module"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="module"/> is <see langword="null"/></exception>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"><paramref name="methodILBytes"/> is <see langword="null"/> or empty</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.SaveFileFixer.SaveFileFixer_RunAction.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Search">
            <summary>Methods for searching for things</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.GetAllPawnsOfFaction(RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param>
            <returns>An <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> of all the pawns (alive or dead) of the given <paramref name="faction"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.GetAllPawnsOfFactionLazy(RimWorld.Faction)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Search.GetAllPawnsOfFaction(RimWorld.Faction)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.ForPawnByName(System.String,RimWorld.Faction,NQualityOfLife.Types.UnOrderedList{Verse.Pawn})">
            <summary>Search for a <see cref="T:Verse.Pawn"/> by name</summary>
            <param name="name"></param>
            <param name="faction"></param>
            <param name="searchSet"></param>
            <returns>The <see cref="T:Verse.Pawn"/> with the given name, or <see langword="null"/> if no matching <see cref="T:Verse.Pawn"/> was found</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.Defs.FindDefInAssembly(System.Reflection.Assembly,System.String,System.String@)">
            <summary>Scans the given <paramref name="assembly"/> for any references to the given <paramref name="defName"/></summary>
            <param name="assembly"></param>
            <param name="defName"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.CheckRegionForThing(Verse.Region,Verse.ThingDef,System.Boolean,RimWorld.Faction,System.Boolean,System.Predicate{Verse.Thing})">
            <summary>Search the <paramref name="region"/> for a <see cref="T:Verse.Thing"/> that matches the given parameters</summary>
            <param name="region"></param>
            <param name="thingToFind"></param>
            <param name="findHostiles"></param>
            <param name="myFaction"></param>
            <param name="findTrader"></param>
            <param name="thingValidator"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.Validator(Verse.Thing,Verse.ThingDef,System.Boolean,RimWorld.Faction,System.Boolean,System.Predicate{Verse.Thing})">
            <summary>Is the given thing the thing we are looking for?</summary>
            <param name="thing">the thing we are comparing to the thing wea are looking for</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as null.</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="thingValidator"></param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing, bool next</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForThingInRegionsSpiralAroundLocation(Verse.IntVec3,Verse.Map,Verse.ThingDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RimWorld.Faction,System.Boolean,System.Boolean,System.Predicate{Verse.Thing})">
            <summary>Search for the given thing around surrounding regions</summary>
            <param name="myLocation">Start location of the search.</param>
            <param name="map">The map to search</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as <see langword="null"/>.</param>
            <param name="findEmptyCell">True if we want to instead find an empty cell.</param>
            <param name="emptyCellMustBeUnroofed">If searching for empty cell, does the cell have to be un-roofed?</param>
            <param name="cellCantBeInMyRegion">If searching for empty cell, does the cell have to be outside the starting region?</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="onlyOurRegion">Check only our region?</param>
            <param name="thingValidator">Custom thing validator if one def is not sufficient</param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForRegionInSpiralAroundLocation(Verse.Region,Verse.Region)">
            <summary></summary>
            <param name="myRegion"></param>
            <param name="otherRegion"></param>
            <returns><see langword="true"/> if the <paramref name="otherRegion"/> is found in the range of the spiral search</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForRegionInSpiralAroundLocation(Verse.Region,System.Predicate{Verse.Region})">
            <summary>Search for a <see cref="T:Verse.Region"/> that matches the <paramref name="predicate"/> in a spiral starting at the given <see cref="T:Verse.Region"/></summary>
            <param name="myRegion"></param>
            <param name="predicate"></param>
            <returns>The first found <see cref="T:Verse.Region"/> that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForThingInRegionsSpiralAroundLocation(Verse.Region,Verse.Map,Verse.ThingDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RimWorld.Faction,System.Boolean,System.Boolean,System.Predicate{Verse.Thing})">
            <summary>Search for the given thing around surrounding regions</summary>
            <param name="myRegion">Start region of the search.</param>
            <param name="map">The map to search</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as null.</param>
            <param name="findEmptyCell">True if we want to instead find an empty cell.</param>
            <param name="emptyCellMustBeUnroofed">If searching for empty cell, does the cell have to be un-roofed?</param>
            <param name="cellCantBeInMyRegion">If searching for empty cell, does the cell have to be outside the starting region?</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="onlyOurRegion">Check only our region?</param>
            <param name="thingValidator">Custom thing validator if one def is not sufficient</param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.FindEmptyCell(Verse.Region,Verse.Map,System.Boolean,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="myRegion"></param>
            <param name="map"></param>
            <param name="emptyCellMustBeUnroofed"></param>
            <param name="cellCantBeInMyRegion"></param>
            <param name="onlyOurRegion"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Session">
            <summary>Stores cached data for faster access, The <see cref="F:NQualityOfLife.Utils.Session.Instance"/> field stores the current <see cref="T:NQualityOfLife.Utils.Session"/> instance</summary>
            <remarks>Only one <see cref="T:NQualityOfLife.Utils.Session"/> should ever exist</remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Session.Instance">
            <summary>The current <see cref="T:NQualityOfLife.Utils.Session"/> instance, only one <see cref="T:NQualityOfLife.Utils.Session"/> should ever exist</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Session.#cctor">
            <summary>Ensure <see cref="F:NQualityOfLife.Utils.Session.Instance"/> is created so it is never <see langword="null"/></summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Session.GetSession">
            <summary>Get the <see cref="F:NQualityOfLife.Utils.Session.Instance"/> or create a <see langword="new"/> <see cref="T:NQualityOfLife.Utils.Session"/> if <see cref="F:NQualityOfLife.Utils.Session.Instance"/> is <see langword="null"/> for some reason</summary>
            <remarks>Also populates some of the fields in the <see cref="F:NQualityOfLife.Utils.Session.Instance"/> if the are <see langword="null"/></remarks>
        </member>
        <member name="P:NQualityOfLife.Utils.Session.NewSession">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Utils.Session"/> <see cref="F:NQualityOfLife.Utils.Session.Instance"/> and return the new <see cref="F:NQualityOfLife.Utils.Session.Instance"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Session.onlyMapTile">
            <summary>The world map tile of the only active <see cref="T:Verse.Map"/>, if there are no maps, or more than one active map, will be -1</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Session.CurrentMap">
            <summary>Cached value of <see cref="P:Verse.Find.CurrentMap"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Session.OnlyMap">
            <summary>The only active <see cref="T:Verse.Map"/>, if there are no maps, or more than one active map, will be <see langword="null"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Sound.PlayOneShot(Verse.SoundDef,Verse.Sound.SoundInfo@)">
            <summary>Play a oneshot sound</summary>
            <param name="soundDef"></param>
            <param name="info"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Sound.PlayRejectInput">
            <summary>Play the standard reject input UI sound</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Sound.PlayRejectInputCrunch">
            <summary>Play a sound that signals that the action is invalid</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Sound.PlayUISound(Verse.SoundDef,NQualityOfLife.Types.Factor@)">
            <summary>Play an UI sound</summary>
            <param name="soundDef"></param>
            <param name="adjustedVolumeFactor">Leave as <see langword="default"/> to use default volume</param>
        </member>
        <member name="P:NQualityOfLife.Utils.Colors.GoodColor">
            <summary>Will give the 'good' color, will differ based on settings. Intended for color blind support etc...</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Colors.BadColor">
            <summary>Will give the 'bad' color, will differ based on settings. Intended for color blind support etc...</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RatioToColor(System.Single,System.Boolean,System.Single)">
            <summary></summary>
            <param name="ratio"></param>
            <param name="highIsBad"></param>
            <param name="alwaysGoodOrBadAbove"></param>
            <returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RatioToColor(NQualityOfLife.Types.Ratio@,System.Boolean,System.Single)">
            <summary></summary>
            <param name="ratio"></param>
            <param name="highIsBad"></param>
            <param name="alwaysGoodOrBadAbove"></param>
            <returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.DeSaturate(NQualityOfLife.Colors.Hex@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorIsTooDark(NQualityOfLife.Colors.Hex@)">
            <summary>Returns <see langword="true"/> if the input hex color is too dark</summary>
            <param name="hex">a hex color like: '#F4A5FF'</param>
            <returns><see langword="true"/> if the input hex color is too dark</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorIsTooBland(NQualityOfLife.Colors.Hex@)">
            <summary></summary>
            <param name="hex">The input color code. for example: '#FF17A7'</param>
            <returns><see langword="true"/> if the given hex color is too 'bland'</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.BrightenIfDark(NQualityOfLife.Colors.Hex@)">
            <summary>Brightens a hex color code if the color is too dark</summary>
            <param name="color"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Colors.Hex"/> color code such as: '#FF9977'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.GenerateDeterministicUniqueColor(System.Int32)">
            <summary>Returns a hex code based on the input hash</summary>
            <param name="hash">the seed for the generated color</param>
            <returns>a hex color code such as: '#AF44FF' || or "#000000FF" if failed to generate the color from the hash</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsGrayscale(NQualityOfLife.Colors.IColorImmutableBasic)">
            <summary>Is the color in pure grayscale?</summary>
            <returns><see langword="true"/> when the <see cref="P:NQualityOfLife.Colors.IColorImmutableBasic.R"/>, <see cref="P:NQualityOfLife.Colors.IColorImmutableBasic.G"/> and <see cref="P:NQualityOfLife.Colors.IColorImmutableBasic.B"/> components all have the same value as each other</returns>
            <remarks>The <see cref="P:NQualityOfLife.Colors.IColorImmutableBasic.A"/> channel is ignored for this value</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToColor(System.String)">
            <summary>Converts a hex code such as '#FF1144FF' into a UnityEngine.Color</summary><param name="colorHexCode"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToColor(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte})">
            <summary>Converts RGBA values to a UnityEngine.Color</summary><param name="color"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBToColor(System.ValueTuple{System.Byte,System.Byte,System.Byte})">
            <summary>Converts RGB values to a UnityEngine.Color</summary><param name="color"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.SetTransparency(NQualityOfLife.Colors.IColorRGBA,NQualityOfLife.Types.Ratio@)">
            <summary>0 is fully transparent (see through) 1 is fully opaque</summary>
            <param name="iColor"></param>
            <param name="transparencyRatio">0 is fully transparent, 1 is opaque</param>
            <returns></returns>
            <remarks><paramref name="iColor"/> is mutated!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.SetTransparency(NQualityOfLife.Colors.Hex,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.SetTransparency(NQualityOfLife.Colors.IColorRGBA,NQualityOfLife.Types.Ratio@)"/>
            <remarks><paramref name="hexColor"/> is mutated!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.SetTransparency(UnityEngine.Color,NQualityOfLife.Types.Ratio@)">
            <summary>1 is fully transparent (see through) 0 is fully opaque</summary>
            <param name="color"></param>
            <param name="transparencyRatio">1 is fully transparent, 0 is opaque</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsFullyTransparent(UnityEngine.Color@)">
            <summary></summary>
            <param name="color"></param>
            <returns><see langword="true"/> if the <paramref name="color"/> is fully transparent</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsFullyTransparent(NQualityOfLife.Colors.IColorImmutableBasic)">
            <summary></summary>
            <param name="color"></param>
            <returns><see langword="true"/> if the <paramref name="color"/> is fully transparent</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="color"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsFullyTransparentInvalidOrNull(NQualityOfLife.Colors.IColorImmutableBasic)">
            <summary></summary>
            <param name="colorImmutableBasic"></param>
            <returns><see langword="true"/> if the <paramref name="colorImmutableBasic"/> is <see langword="null"/>, fully transparent or othervice invalid</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsFullyTransparentInvalidOrNull(NQualityOfLife.Colors.IColorImmutable)">
            <summary></summary>
            <param name="colorImmutable"></param>
            <returns><see langword="true"/> if the <paramref name="colorImmutable"/> is <see langword="null"/>, fully transparent or othervice invalid</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsFullyTransparentInvalidOrNull(NQualityOfLife.Colors.IColor)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.IsFullyTransparentInvalidOrNull(NQualityOfLife.Colors.IColorImmutable)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.IsFullyTransparentInvalidOrNull(NQualityOfLife.Colors.IColorRGBA)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.IsFullyTransparentInvalidOrNull(NQualityOfLife.Colors.IColorImmutable)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToRGB(System.String)">
            <summary>Convert a hex color code such as #FF15AB into its RGB components. If the hex code has an alpha component like in '#FF00AAF6', it will be ignored</summary>
            <param name="hexCode">Valid inputs: '001122', '#112233', '#ff0000f9', 'FF12F0FF'</param>
            <returns>If input is <see langword="null"/> or empty => (0, 0, 0)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToRGBA(System.String)">
            <summary>Convert a hex color code such as #FF15ABFF into its RGBA components. If the hex code doesn't have an alpha component like in '#FF15AB', it will be returned as 255. - The input hex code can start with or without '#'</summary>
            <param name="hexCode">Valid inputs: '001122', '#112233', '#ff0000f9', 'FF12F0FF' where the last two characters represent the <see cref="P:NQualityOfLife.Colors.IColorRGBA.A"/> value</param>
            <returns>If input is <see langword="null"/> or empty => (0, 0, 0, 255)<para>Else the values from the <paramref name="hexCode"/></para> where the last two characters represent the <see cref="P:NQualityOfLife.Colors.IColorRGBA.A"/> value</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorToHexCode(UnityEngine.Color@)">
            <summary>Converts an UnityEngine.Color into a hex code such as '#FF1144FF'</summary><param name="color"></param><returns>A hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorToHex(UnityEngine.Color@)">
            <summary>Converts an UnityEngine.Color into a hex code such as '#FF1144FF'</summary><param name="color"></param><returns>A hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHex(System.Single,System.Single,System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Single,System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Single,System.Single,System.Single,System.Single)">
            <summary>Converts the given floats to a hex color code. If the input values are above 1f max value will be 255f else max will be 1f</summary>
            <param name="R">Red</param>
            <param name="G">Green</param>
            <param name="B">Blue</param>
            <param name="A">lpha - Transparency</param>
            <returns>a hex code such as '#FF3300FF'</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHex(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte}@)">
            <summary></summary><param name="color"></param><returns>a hex code such as '#FF1144FF'</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte}@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Byte,System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBToHex(System.ValueTuple{System.Byte,System.Byte,System.Byte}@)">
            <inheritdoc cref="M:NQualityOfLife.Colors.Hex.#ctor(System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBToHexCode(System.ValueTuple{System.Byte,System.Byte,System.Byte}@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Byte,System.Byte,System.Byte,System.Byte)"/>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHex(System.Byte,System.Byte,System.Byte,System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Byte,System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Converts the given RGBA values into a hex color code, such as: '#FF5BA6FF'</summary>
            <param name="R"></param>
            <param name="G"></param>
            <param name="B"></param>
            <param name="A">Alpha (Transparency)</param>
            <returns>a <see langword="new"/> hex code such as '#FF1144FF'</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Darken(NQualityOfLife.Colors.IColorImmutable,NQualityOfLife.Types.Ratio@)">
            <summary>Darkens a hex color code and returns it as a <see langword="new"/> <see cref="T:NQualityOfLife.Colors.Hex"/></summary>
            <param name="colorIn"></param>
            <param name="amount"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Colors.Hex"/> color code such as: '#FF9977FA'</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="colorIn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Darken(NQualityOfLife.Colors.Hex@,NQualityOfLife.Types.Ratio@)">
            <summary>Darkens a hex color code and returns it as a <see langword="new"/> <see cref="T:NQualityOfLife.Colors.Hex"/></summary>
            <param name="colorIn"></param>
            <param name="amount"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Colors.Hex"/> color code such as: '#FF9977FA'</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Darken(System.Byte,NQualityOfLife.Types.Ratio@)">
            <summary></summary>
            <param name="b"></param>
            <param name="amount"></param>
            <returns></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Brighten(NQualityOfLife.Colors.Hex@,NQualityOfLife.Types.Factor@)">
            <summary></summary>
            <param name="colorIn"></param>
            <param name="multiplier"></param>
            <returns></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Brighten(NQualityOfLife.Types.HexByte@)">
            <summary>Brightens the given color channel</summary>
            <param name="b"></param>
            <returns>0 - 255</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Brighten(System.Byte,NQualityOfLife.Types.Factor@)">
            <summary></summary>
            <param name="b"></param>
            <param name="multiplier"></param>
            <returns></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.MutateColor(NQualityOfLife.Types.HexByte@,NQualityOfLife.Utils.Colors.MutatorMode)">
            <summary></summary>
            <param name="inputColor"></param>
            <param name="mutatorMode"></param>
            <returns></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.MutateColor(NQualityOfLife.Colors.Hex@,NQualityOfLife.Utils.Colors.MutatorMode)">
            <summary></summary>
            <param name="inputColor"></param>
            <param name="mutatorMode"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Colors.Hex"/> color code.</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Colorize(NQualityOfLife.Utils.IStringEquatable,NQualityOfLife.Colors.IColor@)">
            <summary></summary>
            <param name="stringEquatable"></param>
            <param name="color"></param>
            <returns><see langword="this"/> <see cref="M:NQualityOfLife.Utils.IStringEquatable.ToString"/> colorized with the given <paramref name="color"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stringEquatable"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Colorize(NQualityOfLife.Utils.IStringEquatable,NQualityOfLife.Colors.Hex@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Colors.Colorize(NQualityOfLife.Utils.IStringEquatable,NQualityOfLife.Colors.IColor@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IdeoExtensions.GetBelievers(RimWorld.Ideo)">
            <summary></summary>
            <param name="ideo"></param>
            <returns>The <see cref="T:RimWorld.Faction"/>s with the given <paramref name="ideo"/> as their primary</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.IdeoExtensions.GetFirstConflictingPrecept(RimWorld.Ideo,RimWorld.Precept,System.String@,RimWorld.Precept)">
            <summary>Get the first found <see cref="T:RimWorld.Precept"/> of the <paramref name="ideo"/> that conflicts with the provided <paramref name="precept"/></summary>
            <param name="ideo"></param>
            <param name="precept"></param>
            <param name="reason"></param>
            <param name="ignore"></param>
            <returns>The first found <see cref="T:RimWorld.Precept"/> of the <paramref name="ideo"/> that conflicts with the provided <paramref name="precept"/>
            <para><see langword="null"/> if no conflicting precepts found</para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.IdeoExtensions.IsCoreBelief(RimWorld.Ideo,RimWorld.Precept,System.String@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.IdeoExtensions.IsCoreBelief(RimWorld.Ideo,RimWorld.PreceptDef,System.String@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.IdeoExtensions.IsCoreBelief(RimWorld.Ideo,RimWorld.PreceptDef,System.String@)">
            <summary>Check if the given <paramref name="preceptDef"/> is one of the core beliefs of the <paramref name="ideo"/></summary>
            <param name="ideo"></param>
            <param name="preceptDef"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Mods">
            <summary>Data about loaded mods for compatibility and integration</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods._MyMetaData">
            <summary>The instance of my 'ModMetaData'</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Mods.MyMetaData">
            <summary>Get the 'ModMetaData' for the NQoL mod</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutLoadOrder(Verse.ModMetaData,System.String,System.Int32)">
            <summary>Check and warn the user if any mod violates the load order rules</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="loadIndex"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.CheckRules(Verse.ModMetaData,System.String,System.ValueTuple{NQualityOfLife.Utils.Mods.LoadOrderRules,System.String,NQualityOfLife.Utils.Mods.IssueSeverity,System.String},System.Int32)">
            <summary>Check and warn the user if any mod violates the load order rules</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="ruleIn"></param>
            <param name="modLoadIndex"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutCompatibleVersion(Verse.ModMetaData,System.String)">
            <summary>Check the mod version of a mod to the known working version (for compatibility reasons)</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.TestVersionAndWarn(Verse.Mod,NQualityOfLife.IO.VersionInfo,System.Nullable{NQualityOfLife.IO.VersionInfo})">
            <summary>Check the mod version of a mod to the known working version (for compatibility reasons)</summary>
            <param name="mod"></param>
            <param name="testedModVersion"></param>
            <param name="backupTestedModVersion"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="mod"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Check the mod for any suspicious or harmful things such as error suppression</summary>
            <param name="modMetaData">Check this mod for sus stuff</param>
            <param name="modPackageId">Fallback identifier for finding the mod</param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.GetHandleFromPackageID(System.String,System.Boolean)">
            <summary>Get the Mod associated with the given packageid</summary>
            <param name="packageID"></param>
            <param name="errorOnFail"></param>
            <returns>Mod</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(System.IO.DirectoryInfo,Verse.Mod,Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Scan the assemblies of the given mod / root folder for potentially un-wanted stuff.</summary>
            <param name="modRootFolder"></param>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Scan the nested types of the given type for unwanted stuff</summary>
            <param name="type">Type whose nested classes to scan</param>
            <param name="assembly">The assembly that the type is from</param>
            <param name="fromMod">The mod where the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
            <returns><see langword="false"/> if the scanning of the <paramref name="type"/> / <paramref name="assembly"/> runs into issues and should be skipped</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Scan all the types of the given assembly for potentially unwanted harmony patches etc...</summary>
            <param name="assembly">Assembly to scan</param>
            <param name="fromMod">The mod that the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
            <returns><see langword="false"/> if the scanning of the <paramref name="assembly"/> runs into issues and should be skipped</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Type[],System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Scan the given types and their nested types for un-wanted stuff</summary>
            <param name="types">The types to check</param>
            <param name="assembly">The parent assembly of the given types</param>
            <param name="fromMod">The parent mod of the types / assembly</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
            <returns><see langword="false"/> if scanning the <paramref name="types"/> / <paramref name="assembly"/> encounters issues and should be skipped</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusType(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Checks if the given type (class) or any of its nested classes are an error suppression harmony patch, or other potentially un-wanted thing.</summary>
            <param name="type">The type to check (and its nested classes)</param>
            <param name="assembly">The assembly that contanis the type</param>
            <param name="fromMod">The mod that the assembly and type are from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
            <returns><see langword="false"/> if there was an issue scanning the type or assembly and we should abort scanning and skip this one</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusType_ErrorSuppression(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Print a warning if the given type is an error suppressing harmony patch.</summary>
            <param name="type">The type to test</param>
            <param name="assembly"></param>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMethods_AnyDestructivePrefix(System.Type,System.Reflection.MethodInfo@,System.String@)">
            <summary>Checks if any of the method in the given type are destructive prefixes.</summary>
            <param name="type">The type whose methods we want to check.</param>
            <param name="susMethod">The detected sus method or null if none found.</param>
            <param name="reason">The reason why the detected method is 'sus'.</param>
            <returns><see langword="true"/> if any of the methods in the specified type are destructive prefixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMethods_AnyDestructivePrefix(System.Reflection.MethodInfo[],System.Reflection.MethodInfo@,System.String@)">
            <summary>Checks if any of the method in the given array are destructive prefixes.</summary>
            <param name="methods">The array of methods to check.</param>
            <param name="susMethod">The detected sus method or null if none found.</param>
            <param name="reason">The reason why the detected method is 'sus'.</param>
            <returns><see langword="true"/> if any of the given methods is a destructive prefix</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssembly(System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String,System.Boolean,System.Boolean)">
            <summary>Scan all the types in the given assembly for error suppression etc...</summary>
            <param name="assembly">Assembly to scan</param>
            <param name="fromMod">The mod that the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
            <param name="allowUnloaded">Try to scan assemblies not currently loaded into the <see cref="T:System.AppDomain"/></param>
            <returns><see langword="false"/> if we fail to fully scan the <paramref name="assembly"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssemblies(Verse.Mod,Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Scans the loaded assemblies of the given mod for error suppression or other things that are potentially concerning.</summary>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssemblies(System.Collections.Generic.IReadOnlyList{System.Reflection.Assembly},Verse.Mod,Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Scans the given assemblies for error suppression or other things that are potentially concerning.</summary>
            <param name="assemblies">Assemblies to scan</param>
            <param name="fromMod">The mod that the assemblies are from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(Verse.Mod,Verse.ModMetaData,System.String,System.Boolean)">
            <summary>Scans the assemblies of the given mod for error suppression or other things that are potentially concerning.</summary>
            <param name="mod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="silentError">Don't log errors about reflection exceptions unless debug mode</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutOutdated(Verse.Mod,System.String)">
            <summary>Warn the user if the given mod is not updated for the current game version</summary>
            <param name="mod"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutOutdated(Verse.ModMetaData,System.String)">
            <summary>Warn the user if the given mod is not updated for the current game version</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.ModMetaData)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.Mod)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.ModContentPack)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Mods.DeathRattleLoaded">
            <summary>Is the Death Rattle mod loaded?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.BiotechActive">
            <summary>Is the Biotech DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.IdeologyActive">
            <summary>Is the Ideology DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.RoyaltyActive">
            <summary>Is the Royalty DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.AnomalyActive">
            <summary>Is the Anomaly DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.myModName_Release">
            <summary>The name for the release version of NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.myModName_Dev">
            <summary>The name for the pre-release version of NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.myID_Dev">
            <summary>The package id for the pre-release version of NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.myID_Release">
            <summary>The package id for the release version of NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.myPublishedFileID_Dev">
            <summary>The steam workshop id for the pre-release version of NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.myPublishedFileID_Release">
            <summary>The steam workshop id for the release version of NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.myPublishedFileID">
            <summary>The field id of the current build mode</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.skipList">
            <summary>Used by the version check to skip assembles that do not belong to the mod</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.LoadOrderRules.RightAfterCore">
            <summary>Should be loaded right after Core, but before DLC</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.LoadOrderRules.Last">
            <summary>The mod should be loaded last, excluding mods that are marked to load after it, (Rocketman and its translations)</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.LoadOrderRules.NeverActive">
            <summary>The mod should never be active in the mod list (ripmy database for example)</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.IncidentUtils.Artillery.ArtilleryStrike(Verse.Map,System.Int32,RimWorld.Direction8Way,NQualityOfLife.Types.UnOrderedList{Verse.ThingDef})">
            <summary></summary>
            <param name="map"></param>
            <param name="shells">How many shells to launch</param>
            <param name="fromDirection">The direction where the shells will fly from</param>
            <param name="allowedProjectiles">The list of allowed shells || if null select a random shell from all available shells</param>
        </member>
        <member name="M:NQualityOfLife.Utils.IncidentUtils.Artillery.NuclearStrike(System.Int32,RimWorld.Planet.GlobalTargetInfo@,System.Single)">
            <summary>Launch a rimatomics ICBM at the specified target</summary>
            <param name="launchTile"></param>
            <param name="target"></param>
            <param name="warheadYield"></param>
        </member>
        <member name="T:NQualityOfLife.Utils.IComplexNumber`3">
            <summary>Interface for numbers that have a maginitude and angle</summary>
            <typeparam name="TReal"></typeparam>
            <typeparam name="TImaginary"></typeparam>
            <typeparam name="TMagnitude"></typeparam>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.Magnitude">
            <summary>The magnitude <typeparamref name="TMagnitude"/> of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt; when in polar form</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.AngleDeg">
            <summary>The angle of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt; in <see cref="T:NQualityOfLife.Units.Degrees"/> when in polar form</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.AngleRad">
            <summary>The angle of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt; in <see cref="T:NQualityOfLife.Units.Radians"/> when in polar form</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.RealPart">
            <summary>The real part <typeparamref name="TReal"/> of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt;</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.IComplexNumber`3.ImaginaryPart">
            <summary>The imaginary part <typeparamref name="TImaginary"/> of the <seealso cref="T:NQualityOfLife.Utils.IComplexNumber`3">IComplexNumber</seealso>&lt;<typeparamref name="TReal"/>, <typeparamref name="TImaginary"/>, <typeparamref name="TMagnitude"/>&gt;</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.IComplexNumber`3.EqualsExact(NQualityOfLife.Utils.IComplexNumber{`0,`1,`2})">
            <summary></summary><param name="other"></param><returns><see langword="true"/> if the <see cref="T:System.Single"/> values are exactly the same, to the bit level.</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Math">
            <inheritdoc cref="T:System.Math"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.PI">
            <inheritdoc cref="F:System.Math.PI"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.DegToRad">
            <summary><see cref="F:NQualityOfLife.Units.Radians.valueRadians">Radians</see> == <see cref="F:NQualityOfLife.Units.Degrees.valueDegrees">Degrees</see> * <see cref="F:NQualityOfLife.Utils.Math.DegToRad"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.RadToDeg">
            <summary><see cref="F:NQualityOfLife.Units.Degrees.valueDegrees">Degrees</see> == <see cref="F:NQualityOfLife.Units.Radians.valueRadians">Radians</see> * <see cref="F:NQualityOfLife.Utils.Math.RadToDeg"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.SquareRootOf2">
            <summary>Pre-Calculated consant of the square root of 2 in <see cref="T:System.Double"/> precision</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.SquareRootOf3">
            <summary>Pre-Calculated consant of the square root of 3 in <see cref="T:System.Double"/> precision</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.SquareRootOf3_f">
            <summary>Pre-Calculated consant of the square root of 3 in <see cref="T:System.Single"/> precision</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.PI_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.PI"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.DegToRad_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.DegToRad"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.RadToDeg_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.RadToDeg"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.SquareRootOf2_f">
            <summary>Pre-Calculated consant of the square root of 2 in <see cref="T:System.Single"/> precision</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Quetta_d">
            <summary>1_000_000__000_000__000_000__000_000__000_000.0 == 1.0E+30</summary>
            <remarks>Q<para><see cref="F:NQualityOfLife.Utils.Math.Ronna_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Quetta_d"/></para>
            <para>This is the largest metric prefix, and is also getting close to the <see cref="F:System.Single.MaxValue"/> (3.40282347E+38f)</para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Ronna_d">
            <summary>1_000__000_000__000_000__000_000__000_000.0 == 1.0E+27</summary>
            <remarks>R<para><see cref="F:NQualityOfLife.Utils.Math.Yotta_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Ronna_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Quetta_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Yotta_d">
            <summary>1_000_000__000_000__000_000__000_000.0 == 1.0E+24</summary>
            <remarks>Y<para><see cref="F:NQualityOfLife.Utils.Math.Zetta_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Yotta_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Ronna_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Zetta_d">
            <summary>1_000__000_000__000_000__000_000.0 == 1.0E+21</summary>
            <remarks>Z<para><see cref="F:NQualityOfLife.Utils.Math.Exa_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Zetta_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Yotta_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Exa_d">
            <summary>1_000_000__000_000__000_000.0 == 1.0E+18</summary>
            <remarks>E<para><see cref="F:NQualityOfLife.Utils.Math.Peta_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Exa_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Zetta_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Peta_d">
            <summary>1_000__000_000__000_000.0 == 1.0E+15</summary>
            <remarks>P<para><see cref="F:NQualityOfLife.Utils.Math.Tera_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Peta_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Exa_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Tera_d">
            <summary>1_000_000__000_000.0 == 1.0E+12</summary>
            <remarks>T - Trillion<para><see cref="F:NQualityOfLife.Utils.Math.Giga_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Tera_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Peta_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Giga_d">
            <summary>1_000__000_000.0 == 1.0E+9</summary>
            <remarks>G - Billion<para><see cref="F:NQualityOfLife.Utils.Math.Mega_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Giga_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Tera_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Mega_d">
            <summary>1_000_000.0 == 1.0E+6</summary>
            <remarks>M - Million<para><see cref="F:NQualityOfLife.Utils.Math.Kilo_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Mega_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Giga_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Kilo_d">
            <summary>1_000.0 == 1.0E+3</summary>
            <remarks>k - Thousand<para><see cref="F:NQualityOfLife.Utils.Math.Hecto_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Kilo_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Mega_d"/></para>
            <para><see cref="F:NQualityOfLife.Utils.Math.Milli_d"/> == 1.0 / <see cref="F:NQualityOfLife.Utils.Math.Kilo_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Hecto_d">
            <summary>100.0 == 1.0E+2</summary>
            <remarks>h - Hundread<para><see cref="F:NQualityOfLife.Utils.Math.Deca_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Hecto_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Kilo_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Deca_d">
            <summary>10.0 == 1.0E+1</summary>
            <remarks>da - Ten<para><see cref="F:NQualityOfLife.Utils.Math.Deci_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Deca_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Hecto_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Deci_d">
            <summary>0.1 == 1.0E-1</summary>
            <remarks>d - Tenth<para><see cref="F:NQualityOfLife.Utils.Math.Centi_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Deci_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Deca_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Centi_d">
            <summary>0.01 == 1.0E-2</summary>
            <remarks>c - One one hundredth<para><see cref="F:NQualityOfLife.Utils.Math.Milli_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Centi_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Deci_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Milli_d">
            <summary>0.001 == 1.0E-3
            <para>1 <see cref="T:NQualityOfLife.Units.Second"/> == 1000ms * <see langword="this"/></para></summary>
            <remarks>m - One one thousandths<para><see cref="F:NQualityOfLife.Utils.Math.Micro_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Milli_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Centi_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Micro_d">
            <summary>0.000_001 == 1.0E-6</summary>
            <remarks> / u<para><see cref="F:NQualityOfLife.Utils.Math.Nano_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Micro_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Milli_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Nano_d">
            <summary>0.000_000__001 == 1.0E-9</summary>
            <remarks>n<para><see cref="F:NQualityOfLife.Utils.Math.Pico_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Nano_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Micro_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Pico_d">
            <summary>0.000_000__000_001 == 1.0E-12</summary>
            <remarks>p<para><see cref="F:NQualityOfLife.Utils.Math.Femto_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Pico_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Nano_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Femto_d">
            <summary>0.000__000_000__000_001 == 1.0E-15</summary>
            <remarks>f<para><see cref="F:NQualityOfLife.Utils.Math.Atto_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Femto_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Pico_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Atto_d">
            <summary>0.000_000__000_000__000_001 == 1.0E-18</summary>
            <remarks>a<para><see cref="F:NQualityOfLife.Utils.Math.Zepto_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Atto_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Femto_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Zepto_d">
            <summary>0.000__000_000__000_000__000_001 == 1.0E-21</summary>
            <remarks>z<para><see cref="F:NQualityOfLife.Utils.Math.Yocto_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Zepto_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Atto_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Yocto_d">
            <summary>0.000_000__000_000__000_000__000_001 == 1.0E-24</summary>
            <remarks>y<para><see cref="F:NQualityOfLife.Utils.Math.Ronto_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Yocto_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Zepto_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Ronto_d">
            <summary>0.000__000_000__000_000__000_000__000_001 == 1.0E-27</summary>
            <remarks>r<para><see cref="F:NQualityOfLife.Utils.Math.Quecto_d"/> &lt;- <see cref="F:NQualityOfLife.Utils.Math.Ronto_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Yocto_d"/></para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Quecto_d">
            <summary>0.000_000__000_000__000_000__000_000__000_001 == 1.0E-30</summary>
            <remarks>q<para><see cref="F:NQualityOfLife.Utils.Math.Quecto_d"/> -&gt; <see cref="F:NQualityOfLife.Utils.Math.Ronto_d"/></para>
            <para>This is the smallest metric prefix, and is also getting close to the <see cref="F:System.Single.Epsilon"/> (1.401298E-45f)</para></remarks>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Exa_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Exa_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Peta_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Peta_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Tera_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Tera_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Giga_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Giga_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Mega_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Mega_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Kilo_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Kilo_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Hecto_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Hecto_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Deca_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Deca_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Deci_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Deci_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Centi_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Centi_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Milli_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Milli_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Micro_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Micro_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Nano_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Nano_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Pico_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Pico_d"/>
        </member>
        <member name="F:NQualityOfLife.Utils.Math.Femto_f">
            <inheritdoc cref="F:NQualityOfLife.Utils.Math.Femto_d"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Atan(System.Single)">
            <summary>Get the angle in <see cref="T:NQualityOfLife.Units.Radians"/> whose tangent is the given '<paramref name="tangent"/>'</summary>
            <param name="tangent"></param>
            <returns>Angle in <see cref="T:NQualityOfLife.Units.Radians"/> whose tangent is the given '<paramref name="tangent"/>'</returns>
            <inheritdoc cref="M:System.Math.Atan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Atan(System.Double)">
            <summary>Get the angle in <see cref="T:NQualityOfLife.Units.Radians"/> whose tangent is the given '<paramref name="tangent"/>'</summary>
            <param name="tangent"></param>
            <returns>Angle in <see cref="T:NQualityOfLife.Units.Radians"/> whose tangent is the given '<paramref name="tangent"/>'</returns>
            <inheritdoc cref="M:System.Math.Atan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Atan(System.Single,System.Single)">
            <inheritdoc cref="M:System.Math.Atan2(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sin(NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:System.Math.Sin(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SinD(System.Double)">
            <inheritdoc cref="M:System.Math.Sin(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Cos(NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:System.Math.Cos(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Tan(NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:System.Math.Tan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sin(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:System.Math.Sin(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Cos(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:System.Math.Cos(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Tan(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:System.Math.Tan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sin(NQualityOfLife.Units.IAngle)">
            <inheritdoc cref="M:System.Math.Sin(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Cos(NQualityOfLife.Units.IAngle)">
            <inheritdoc cref="M:System.Math.Cos(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Tan(NQualityOfLife.Units.IAngle)">
            <inheritdoc cref="M:System.Math.Tan(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeDegrees(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.Normalize"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeDegreesSigned(NQualityOfLife.Units.Degrees@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.NormalizeSigned"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeRadians(NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Radians.Normalize"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeRadiansSigned(NQualityOfLife.Units.Radians@)">
            <inheritdoc cref="M:NQualityOfLife.Units.Radians.NormalizeSigned"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeDegrees(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.Normalize"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeDegreesSigned(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Degrees.NormalizeSigned"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeRadians(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Radians.Normalize"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.NormalizeRadiansSigned(System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Units.Radians.NormalizeSigned"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Giga(System.Double)">
            <returns><paramref name="number"/> * <see cref="F:NQualityOfLife.Utils.Math.Giga_d"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Giga(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Giga(System.Single)">
            <summary>Multiply the given <paramref name="number"/> by a <seealso cref="F:NQualityOfLife.Utils.Math.Giga_f">billion</seealso></summary>
            <param name="number"></param><returns><paramref name="number"/> * <see cref="F:NQualityOfLife.Utils.Math.Giga_f"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Mega(System.Single)">
            <summary>Multiply the given <paramref name="number"/> by a <seealso cref="F:NQualityOfLife.Utils.Math.Mega_f">million</seealso></summary>
            <param name="number"></param><returns><paramref name="number"/> * <see cref="F:NQualityOfLife.Utils.Math.Mega_f"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Mega(System.Double)">
            <returns><paramref name="number"/> * <see cref="F:NQualityOfLife.Utils.Math.Mega_d"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Mega(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Kilo(System.Single)">
            <returns><paramref name="number"/> * <see cref="F:NQualityOfLife.Utils.Math.Kilo_f"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Kilo(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sqrt(NQualityOfLife.Types.IFloat)">
            <inheritdoc cref="M:System.Math.Sqrt(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Sqrt(System.Single)">
            <summary>Get the square root of a number</summary>
            <param name="value">Get the square root of <see langword="this"/> value</param>
            <returns>The square root of the input number</returns>
            <inheritdoc cref="M:System.Math.Sqrt(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow2(System.Single)">
            <summary>Raise the <paramref name="value"/> to the power of 2</summary>
            <param name="value">Raise <see langword="this"/> <paramref name="value"/> to the second power</param>
            <returns><paramref name="value"/>^2</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow2(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Pow2(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow2(System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Pow2(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow3(System.Single)">
            <summary>Raise the <paramref name="value"/> to the power of 3</summary>
            <param name="value">Raise <see langword="this"/> <paramref name="value"/> to the second power</param>
            <returns><paramref name="value"/>^3</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Double,System.Double)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Single,System.Single)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Double,System.Int32)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Pow(System.Single,System.Int32)">
            <inheritdoc cref="M:System.Math.Pow(System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Get the expected value of Y at the given X</summary>
            <param name="from_X">X before target_X</param><param name="from_Y">Y value at from_X</param><param name="to_X">X after target_X</param><param name="to_Y">Y value at to_X</param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at target_X</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(System.ValueTuple{System.Single,System.Single}@,System.ValueTuple{System.Single,System.Single}@,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Interpolate(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(NQualityOfLife.Geometry.Point2D@,NQualityOfLife.Geometry.Point2D@,System.Single)">
            <summary>Get the expected value of Y at the given <paramref name="target_X"/></summary>
            <param name="from">The point before <paramref name="target_X"/></param><param name="to">The point after <paramref name="target_X"/></param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at <paramref name="target_X"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(UnityEngine.Vector2@,UnityEngine.Vector2@,System.Single)">
            <summary>Get the expected value of Y at the given X</summary>
            <param name="from">The point before target_X</param><param name="to">The point after target_X</param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at target_X</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Single,Verse.FloatRange@)">
            <summary></summary>
            <param name="num"></param><param name="range"></param>
            <returns><see langword="true"/> if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Single,System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Single,System.ValueTuple{System.Single,System.Single}@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Single,System.ValueTuple{System.Single,System.Single}@)">
            <summary></summary>
            <param name="num"></param><param name="range"></param>
            <returns><see langword="true"/> if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Contains(System.ValueTuple{System.Single,System.Single}@,System.Single)">
            <summary></summary>
            <param name="range"></param><param name="num"></param>
            <returns><see langword="true"/> if the given number is inside the min and max range, inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Includes(System.ValueTuple{System.Single,System.Single}@,System.Single)">
            <summary></summary>
            <param name="range"></param><param name="num"></param>
            <returns><see langword="true"/> if the given number is inside the min and max range, inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Contains_Inclusive(Verse.IntRange@,System.Int32)">
            <summary></summary>
            <param name="range"></param>
            <param name="number"></param>
            <returns><see langword="true"/> if the given number is within the range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Int32,Verse.IntRange@)">
            <summary></summary>
            <param name="num"></param>
            <param name="range"></param>
            <returns><see langword="true"/> if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeExclusive(System.Int32,Verse.IntRange@)">
            <summary></summary>
            <param name="num"></param>
            <param name="range"></param>
            <returns><see langword="true"/> if the given number is within the given range - Exclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Int32,System.Int32,System.Int32)">
            <summary></summary>
            <param name="num"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns><see langword="true"/> if the given number is within the given range - Inclusive</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeExclusive(System.Int32,System.Int32,System.Int32)">
            <summary></summary>
            <param name="num"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns><see langword="true"/> if the given number is within the given range - Exclusive</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.RoundToInt(System.Single)">
            <summary>Round the <paramref name="number"/> to the closest valid <see cref="T:System.Int32"/></summary>
            <param name="number"></param>
            <returns>The <paramref name="number"/> rounded to the closest valid <see cref="T:System.Int32"/></returns>
            <inheritdoc cref="M:System.Math.Round(System.Double)"/>
            <remarks>In cases where <paramref name="number"/> is between two valid integers, the <paramref name="number"/> is rounded towards the even <see cref="T:System.Int32"/><para>Examples:<list type="table"><item>0.5f -&gt; 0</item><item>-0.5f -&gt; 0</item><item>-1.5f -&gt; -2</item><item>-2.5f -&gt; -2</item><item>2.5f -&gt; 2</item><item>1.5f -&gt; 2</item></list></para>
            <para>'<see cref="F:System.Single.NaN"/>' will <see langword="return"/> '<see cref="F:System.Int32.MinValue"/>'</para>
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.RoundToInt(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.RoundToInt(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.RoundDown(System.Single)">
            <summary>Round the <paramref name="number"/> down to the nearest valid <see cref="T:System.Int32"/></summary>
            <param name="number"></param>
            <returns></returns>
            <remarks>Numbers are rounded down towards <see cref="F:System.Single.NegativeInfinity"/>
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.RoundUp(System.Single)">
            <summary>Round the <paramref name="number"/> up to the nearest valid <see cref="T:System.Int32"/></summary>
            <param name="number"></param>
            <returns></returns>
            <remarks>Numbers are rounded up towards <see cref="F:System.Single.PositiveInfinity"/>
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Round(System.Single)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.Math.Round(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Round(System.Double)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:System.Math.Round(System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Even(System.Int32)">
            <summary></summary><param name="num"></param>
            <returns><see langword="true"/> if the input <paramref name="num"/> is even</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Odd(System.Int32)">
            <summary></summary><param name="num"></param>
            <returns><see langword="true"/> if the input <paramref name="num"/> is odd</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Byte,System.Byte)">
            <summary>Returns the larger <see cref="T:System.Byte"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the two <see cref="T:System.Byte"/> values</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Byte,System.Byte)">
            <summary>Returns the smaller <see cref="T:System.Byte"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the two <see cref="T:System.Byte"/> values</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Single,System.Single)">
            <summary>Returns the larger <see cref="T:System.Single"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the two <see cref="T:System.Single"/> values</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Max(System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.LargerOf(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Single,System.Single)">
            <summary>Returns the smaller <see cref="T:System.Single"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the two <see cref="T:System.Single"/> values</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Min(System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.SmallerOf(System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Single)">
            <summary></summary>
            <param name="value"></param>
            <param name="otherValue"></param>
            <returns>The larger of the give values as a <see cref="T:System.Single"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.UInt16,System.UInt16)">
            <summary></summary>
            <param name="value"></param>
            <param name="otherValue"></param>
            <returns>The larger of the give values as a <see cref="T:System.UInt16"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.UInt16,System.Int32)">
            <summary></summary>
            <param name="value"></param>
            <param name="otherValue"></param>
            <returns>The larger of the give values as a <see cref="T:System.Int32"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Int32,System.Single)">
            <summary></summary>
            <param name="value"></param>
            <param name="otherValue"></param>
            <returns>The smaller of the give values as a <see cref="T:System.Single"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)">
            <summary>Returns the larger <see cref="T:System.Int32"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the two <seealso cref="T:System.Int32">integer</seealso> values</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Max(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Int64,System.Int64)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Int64,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Int32,System.Int32)">
            <summary>Returns the smaller <see cref="T:System.Int32"/> value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the two <seealso cref="T:System.Int32">integer</seealso> values</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Byte,System.UInt32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.SmallerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Min(System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.SmallerOf(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Min``1(``0,``0@)">
            <inheritdoc cref="M:NQualityOfLife.Types.IMath`1.SmallerOf(`0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Max``1(``0,``0@)">
            <inheritdoc cref="M:NQualityOfLife.Types.IMath`1.LargerOf(`0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.TallerOf(UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary></summary>
            <param name="rect"></param>
            <param name="otherRect"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary></summary>
            <param name="rect"></param>
            <param name="otherRect"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampToIndex``1(System.Int32,System.Collections.Generic.ICollection{``0})">
            <summary>Clamp the <paramref name="value"/> such that it falls into a valid index of the <paramref name="collection"/></summary>
            <remarks>If the <paramref name="collection"/> is empty, this method will return 0, so ensure the collection is not empty!</remarks>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="collection"></param>
            <returns><paramref name="value"/> clamped to the valid indexes of the <paramref name="collection"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Byte,System.Byte,System.Byte)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>A <see cref="T:System.Byte"/> &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.SByte,System.SByte,System.SByte)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Int32,System.Byte,System.Byte)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>A <see cref="T:System.Int32"/> &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>an <see cref="T:System.Int32"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampToRange(System.Single,System.ValueTuple{System.Single,System.Single}@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Byte,System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Byte,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>A <see cref="T:System.Single"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Double,System.Double,System.Double)">
            <returns>A <see cref="T:System.Double"/> that is &gt;= <paramref name="min"/> and &lt;= <paramref name="max"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Double,System.Single,System.Single)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Double,System.Double,System.Double)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single)">
            <summary>Clamps the number to 0f-1f inclusive</summary>
            <param name="value"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,System.Single)">
            <summary>Clamps the <paramref name="value"/> to <paramref name="min"/>~<paramref name="max"/> inclusive || <paramref name="min"/> and <paramref name="max"/> must be &gt;= 0 and &lt;= 1</summary>
            <param name="value"></param>
            <param name="min">must be &gt;= 0 and &lt;= 1</param>
            <param name="max">must be &gt;= 0 and &lt;= 1</param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/> in the specified range</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <summary>Clamps the <paramref name="value"/> to <paramref name="min"/>~<paramref name="max"/> inclusive || <paramref name="min"/> and <paramref name="max"/> must be &gt;= 0 and &lt;= 1</summary>
            <param name="value"></param>
            <param name="min">must be &gt;= 0 and &lt;= 1</param>
            <param name="max">must be &gt;= 0 and &lt;= 1</param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/> in the specified range</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Double,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.Ratio@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Double)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,NQualityOfLife.Types.Ratio@)">
            <returns>a <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/> in the specified range</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,NQualityOfLife.Types.Ratio@,System.Single)">
            <returns>a <see cref="T:NQualityOfLife.Types.Ratio"/> <see cref="T:System.Object"/> in the specified range</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampToRange(System.Single,Verse.FloatRange@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Single,System.Single,System.Single)">
            <summary></summary><param name="f"></param><param name="other"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <paramref name="f"/> is approximately equal to <paramref name="other"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Double,System.Single,System.Single)">
            <summary></summary><param name="d"></param><param name="f"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <paramref name="d"/> is approximately equal to <paramref name="f"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Single,System.Double,System.Single)">
            <summary></summary><param name="d"></param><param name="f"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <paramref name="f"/> is approximately equal to <paramref name="d"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsApprox(System.Double,System.Double,System.Double)">
            <summary></summary><param name="dl"></param><param name="dr"></param><param name="epsilon"></param>
            <returns><see langword="true"/> if <paramref name="dl"/> is approximately equal to <paramref name="dr"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.EqualsExact(System.Single,System.Single)">
            <summary></summary><param name="f"></param><param name="other"></param>
            <returns><see langword="true"/> if the two <see cref="T:System.Single"/> values are exactly equal, down to the bit level</returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Int32)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) value</returns>
            <remarks>y = |x|<para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.SByte)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) value</returns>
            <remarks>y = |x|<para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Single)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) <see cref="T:System.Single"/> value</returns><remarks>y = |x|<para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Double)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) value</returns><remarks>y = |x|<para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Fibonacci(System.UInt64)">
            <summary>Get the number '<paramref name="n"/>' in the <see href="https://en.wikipedia.org/wiki/Fibonacci_sequence">Fibonacci sequence</see> where <paramref name="n"/>0 is 0, n1 is 1, n2 is 1, n3 is 2 and so on</summary>
            <param name="n"></param>
            <returns></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Snap(System.Single,System.Single)">
            <summary>Snap the '<paramref name="value"/>' to the closest value divisible by <paramref name="snapSize"/>
            <para>A <paramref name="snapSize"/> of 1 will perform a <see cref="M:NQualityOfLife.Utils.Math.RoundToInt(System.Single)"/></para>
            <para>A <paramref name="snapSize"/> of 0 will just <see langword="return"/> the '<paramref name="value"/>' un-changed</para></summary>
            <param name="value"></param>
            <param name="snapSize"></param>
            <returns>a <see langword="new"/> <see cref="T:System.Single"/> closest to '<paramref name="value"/>' that is divisible by '<paramref name="snapSize"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.OnesPlace(System.Int32)">
            <summary>Get the number (0~9) at the ones position of the input <paramref name="number"/></summary>
            <param name="number"></param>
            <returns>The digit (0~9) at the ones column</returns>
            <remarks>If the input <paramref name="number"/> is negative, the return value will also be negative
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.TensPlace(System.Int32)">
            <summary>Get the number (0~9) at the tens position of the input <paramref name="number"/></summary>
            <param name="number"></param>
            <returns>The digit (0~9) at the tens column</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.OnesPlace(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.HundreadsPlace(System.Int32)">
            <summary>Get the number (0~9) at the hundreads position of the input <paramref name="number"/></summary>
            <returns>The digit (0~9) at the hundreads column</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.OnesPlace(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ThousandsPlace(System.Int32)">
            <summary>Get the number (0~9) at the thousands position of the input <paramref name="number"/></summary>
            <returns>The digit (0~9) at the thousands column</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.Math.OnesPlace(System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SnapToClosest(System.Single,System.Single,System.Single)">
            <summary>Snap the <paramref name="val"/> to the closer of the two provided values</summary>
            <param name="val"></param>
            <param name="a"></param>
            <param name="b"></param>
            <returns>Either <paramref name="a"/> or <paramref name="b"/> depending which one is closer to <paramref name="val"/></returns>
            <remarks>If both are equally close, returns <paramref name="a"/> - so: (0.5f, 0f, 1f) returns 0f and (0.5f, 1f, 0f) returns 1f
            <para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.CountSurroundingCardinalCells(System.Int32,System.Int32)">
            <summary>Counts how many squares are orthogonally (cardinally) adjacent to the outside edges
            of a rectangle composed of <paramref name="width"/> by <paramref name="height"/> squares.</summary>
            <param name="width">The number of squares along the rectangle's width (must be  1).</param>
            <param name="height">The number of squares along the rectangle's height (must be  1).</param>
            <returns>The number of squares directly touching the rectangle's perimeter via a shared side.
            Diagonal-only (corner) adjacency is not counted.</returns>
            <remarks>For a 1x1 rectangle, the count is 4 (one on each side).  
            For larger rectangles, the total is equal to the perimeter measured in grid-adjacent squares:
            <c>(width + height) * 2</c>.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when <paramref name="width"/> or <paramref name="height"/> is less than 1.</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.CountHexTiles(System.Int32)">
            <summary></summary>
            <param name="distance"></param>
            <returns>The count of hex tiles in the given radius/distance from the center hex tile</returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">MayErrorOnIllegalRange</see></remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.CountHexTilesDonut(System.Int32)">
            <summary></summary>
            <param name="distance"></param>
            <returns>The count of hex tiles in a donut pattern for the given distance from the center</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SyncSeedAndIterations">
            <summary>Sync the NQoL <see cref="T:NQualityOfLife.Utils.Rand"/> seed and iterations with the <see cref="T:Verse.Rand"/> ones.<para>This could be useful to ensure multiplayer compatiblity etc.</para></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="predicate"></param>
            <returns><see langword="default"/> if no element (<typeparamref name="T"/>) is found that satisfies the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceSet"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="sourceIList"></param>
            <param name="predicate"></param>
            <param name="effectiveListSize"></param>
            <returns><see langword="default"/>(<typeparamref name="T"/>) if none of the elements in the set satisfy the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceIList"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhereOrFallback``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhereOrFallback``1(System.Collections.Generic.IList{``0},System.Predicate{``0},``0@,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary>Selects a random item <typeparamref name="T"/> from the <paramref name="set"/>, or returns <paramref name="fallback"/> if the <paramref name="set"/> is <see langword="null"/> or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this <paramref name="set"/> if it is not <see langword="null"/> or empty, else return the <paramref name="fallback"/></param>
            <param name="fallback">Return this if the <paramref name="set"/> is <see langword="null"/> or empty</param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/> or <paramref name="fallback"/> if <paramref name="set"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.List{``0},``0@)">
            <summary>Selects a random item <typeparamref name="T"/> from the <paramref name="set"/>, or returns <paramref name="fallback"/> if the <paramref name="set"/> is <see langword="null"/> or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this <paramref name="set"/> if it is not <see langword="null"/> or empty, else return the <paramref name="fallback"/></param>
            <param name="fallback">Return this if the <paramref name="set"/> is <see langword="null"/> or empty</param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/> or <paramref name="fallback"/> if <paramref name="set"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.IList{``0},``0@)">
            <summary>Selects a random item <typeparamref name="T"/> from the <paramref name="set"/>, or returns <paramref name="fallback"/> if the <paramref name="set"/> is <see langword="null"/> or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this <paramref name="set"/> if it is not <see langword="null"/> or empty, else return the <paramref name="fallback"/></param>
            <param name="fallback">Return this if the <paramref name="set"/> is <see langword="null"/> or empty</param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/> || or <paramref name="fallback"/> if <paramref name="set"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSetWhere``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandomSet``1(System.Collections.Generic.ICollection{``0},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSet``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>if <paramref name="sourceSet" /> is smaller or equal to <paramref name="maxItemsToGet" />, returns a copy of the <paramref name="sourceSet" /> || else creates a new list with random members from the <paramref name="sourceSet" /></summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="maxItemsToGet"></param>
            <returns>A <see langword="new"/> list with randomly selected items from the <paramref name="sourceSet" /></returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.NullReferenceException"/> If <paramref name="sourceSet" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceSet"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxItemsToGet"/> is negative</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSet``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>If source list is smaller or equal to <paramref name="maxItemsToGet"/>, returns a copy of the source list || else creates a new list with random members from the source list</summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="maxItemsToGet"></param>
            <returns>A <see langword="new"/> list with randomly selected items from the source list</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.NullReferenceException"/> If <paramref name="sourceSet" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceSet"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.RemoveRandom``1(System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.RemoveRandom_Internal``1(System.Collections.Generic.IList{``0},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.RemoveRandom_Internal``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Removes a random item from the list</summary>
            <typeparam name="T"></typeparam>
            <param name="set"></param><param name="setSize"></param>
            <remarks><seealso cref="T:NQualityOfLife.Attributes.ImpureAttribute">Impure</seealso>
            <para>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="set" /> is <see langword="null"/></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="setSize"/> is &lt;= 0 or larger than the set</exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(``0)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandom``1"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1">
            <summary></summary>
            <typeparam name="TEnum"></typeparam>
            <returns>A random value from the defined values of the provided <see cref="T:System.Enum"/></returns>
            <remarks><seealso cref="T:NQualityOfLife.Attributes.ImpureAttribute">Impure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(``0,System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandom``1"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.SelectRandom``1"/>
            <exception cref="T:System.InvalidOperationException">No values of enum '<typeparamref name="TEnum"/>' match the predicate.</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Select a random element '<typeparamref name="T"/>' from the <paramref name="set"/> || An empty or <see langword="null"/> <paramref name="set"/> may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/> || or the <see langword="default"/> value of <typeparamref name="T"/> on error, such as if the input <paramref name="set"/> is empty</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(``0[])">
            <summary>Select a random element <typeparamref name="T"/> from the <paramref name="set"/> || a <see langword="null"/> or empty <paramref name="set"/> may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.IList{``0})">
            <summary>Select a random element <typeparamref name="T"/> from the <paramref name="set"/> || a <see langword="null"/> or empty <paramref name="set"/> may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.List{``0})">
            <summary>Select a random element <typeparamref name="T"/> from the <paramref name="set"/> || a <see langword="null"/> or empty <paramref name="set"/> may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item <typeparamref name="T"/> from the <paramref name="set"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom_Internal``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Select a random element <typeparamref name="T"/> from the <paramref name="set"/> || An empty <paramref name="set"/> will error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <param name="setSize">The known size of the list</param>
            <returns>A random item (<typeparamref name="T"/>) from the <paramref name="set" /> || will return <see langword="default"/>(<typeparamref name="T"/>) on error</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentOutOfRangeException"/> If <paramref name="setSize" /> is &lt;= 0</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is <see langword="null"/></exception><exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.RandDegrees">
            <summary></summary>
            <returns>A random <see cref="T:NQualityOfLife.Units.Degrees"/> value between 0~360 inclusive</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Rand.ValueF">
            <summary>Random value between 0f and 1f inclusive</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Rand.ValueFSigned">
            <summary></summary>
            <returns>a <see cref="T:System.Single"/> between -1f~1f inclusive</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Rand.Value">
            <summary>Random value between 0.0 and 1.0 inclusive</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.Range(System.Int32,System.Int32)">
            <summary>Get a random <see cref="T:System.Int32"/> that is >= <paramref name="minInclusive"/> &amp;&amp; &lt;= <paramref name="maxInclusive"/></summary>
            <param name="minInclusive"></param>
            <param name="maxInclusive"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.Range(System.Byte,System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Rand.Range(System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.DefGen.GiveHash``1(``0)">
            <summary>Give the <paramref name="def"/> an unique shortHash, trying to give a hash to a def that already has it will error!</summary>
            <typeparam name="D"></typeparam>
            <param name="def"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefGen.FreeHash``1(``0)">
            <summary>Remove the hash of the given <paramref name="def"/> from the list of taken hashes, Should only be done when removing the def from the database</summary>
            <typeparam name="D"></typeparam>
            <param name="def"></param>
            <returns><see langword="true"/> if the hash was successfully removed, a failure will log an error and return <see langword="false"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefGen.Validate``1(``0)">
            <summary>Validates that the <paramref name="def"/> has been given a valid hash and has been added to the <see cref="T:Verse.DefDatabase`1"/></summary>
            <typeparam name="TDef"></typeparam>
            <param name="def"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="def"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading">
            <summary>Multithreading and async task utils</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.debug">
            <summary>Debug threading</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading.Root_Shutdown_Patch">
            <summary>Used to clean up any threads that could still be running</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading.ShutdownHandler">
            <summary>Handles cleaning up any threads that could cause the game or app to fail to close correctly</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.ShutdownHandler.GetIsShuttingDown">
            <summary>Returns <see langword="true"/> if the game or app is currently in the process of shutting down</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.ShutdownHandler._isShuttingDown">
            <summary>Is the game or app is currently in the process of shutting down?</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.ShutdownHandler.TriggerShutdown">
            <summary>Stop all threads</summary>
            <remarks><see cref="F:NQualityOfLife.Utils.Threading.ShutdownHandler._isShuttingDown"/> is set to <see langword="true"/></remarks>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker">
            <summary>Used to track the progress of background <see cref="T:System.Threading.Tasks.Task">tasks</see> and to trigger actions upon completion</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.#ctor(System.Threading.Tasks.Task,System.Threading.CancellationTokenSource,System.Action,System.Boolean)">
            <summary></summary>
            <param name="asyncTask"></param>
            <param name="cancellationTokenSource"></param>
            <param name="onComplete"><see cref="T:System.Action"/> upon completion of the <paramref name="asyncTask"/></param>
            <param name="startNow">Start the <paramref name="asyncTask"/> as soon as it is created</param>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.WhenCompletedAction">
            <summary>An <see cref="T:System.Action"/> to invoke when the task has completed</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.Working">
            <summary>Check if the task is still in progress</summary>
            <returns><see langword="true"/> if the task is running and not stopped or completed</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.Done">
            <summary></summary>
            <returns><see langword="true"/> if <see cref="P:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.Working"/> is <see langword="false"/></returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.IsCancellationRequested">
            <inheritdoc cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.Abort">
            <summary>Attempt to abort the task, for this to work; the task must be listening to the <see cref="T:System.Threading.CancellationToken"/>!</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.Start">
            <inheritdoc cref="M:System.Threading.Tasks.Task.Start"/>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker`1">
            <summary></summary>
            <typeparam name="R">The result '<typeparamref name="R"/>' of the task</typeparam>
            <inheritdoc cref="T:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker"/>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker`1.WhenCompleted">
            <summary>An <see cref="T:System.Action`1"/> to invoke using the result '<typeparamref name="R"/>' when the task has completed</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker`1.Result">
            <summary>Get the result '<typeparamref name="R"/>' of the completed task</summary>
            <exception cref="T:System.InvalidOperationException">The task is not completed</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.LongTaskHandler.StartLongTask``1(System.String@,System.Func{System.Threading.CancellationToken,``0},System.Action{``0})">
            <summary>Start a long <see cref="T:System.Threading.Tasks.Task"/> to perform in a background thread</summary>
            <typeparam name="R">The result '<typeparamref name="R"/>' of the <paramref name="task"/></typeparam>
            <param name="state"></param>
            <param name="task">The task should listen to the <see cref="T:System.Threading.CancellationToken"/> and return if cancellation has been requested</param>
            <param name="whenCompleted">An <see cref="T:System.Action`1"/> that is called when the <paramref name="task"/> has completed</param>
            <returns>a <see cref="T:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker`1"/> that can be used to track the state of the task and to get the <see cref="P:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker`1.Result"/><para>or <see cref="M:NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker.Abort"/> it if needed</para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.LongTaskHandler.StartLongTask(System.Action{System.Threading.CancellationToken},System.Action)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Threading.LongTaskHandler.StartLongTask(System.String@,System.Action{System.Threading.CancellationToken},System.Action)"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.LongTaskHandler.StartLongTask(System.String@,System.Action{System.Threading.CancellationToken},System.Action)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Threading.LongTaskHandler.StartLongTask``1(System.String@,System.Func{System.Threading.CancellationToken,``0},System.Action{``0})"></inheritdoc>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.SoundThread._workTimeMs">
            <summary>How much time we spend per iteration / how long we sleep with no work</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.SoundThread._soundThread">
            <summary>The background worker <see cref="T:System.Threading.Thread"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.SoundThread._running">
            <summary>The state of the <see cref="F:NQualityOfLife.Utils.Threading.SoundThread._soundThread"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.SoundThread._lock">
            <summary>lock for the <see cref="M:NQualityOfLife.Utils.Threading.SoundThread.Start"/> and <see cref="M:NQualityOfLife.Utils.Threading.SoundThread.Stop"></see> actions</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.SoundThread._workQueue">
            <summary>Queued work to be done in the background</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.SoundThread._sleepTime">
            <summary>How long the thread will sleep after completing the work loop</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.SoundThread.Load">
            <summary>How much load is the <see cref="T:NQualityOfLife.Utils.Threading.SoundThread"/> under?</summary>
            <returns>A <see cref="T:NQualityOfLife.Types.Percentage"/> of the utilization</returns>
            <remarks>Note that the value given is for the last iteration/work loop</remarks>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.SoundThread.QueueSize">
            <summary>Check how many tasks are currently queued</summary>
            <returns>The amount of tasks in the work queue</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.SoundThread.Running">
            <summary>Check if the <see cref="T:NQualityOfLife.Utils.Threading.SoundThread"/> is currently running</summary>
            <returns><see langword="true"/> if the <see cref="T:NQualityOfLife.Utils.Threading.SoundThread"/> has been started</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.SoundThread.Start">
            <summary>Start the background worker until its stopped with <see cref="M:NQualityOfLife.Utils.Threading.SoundThread.Stop"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.SoundThread.Stop">
            <summary>Stop the <see cref="F:NQualityOfLife.Utils.Threading.SoundThread._soundThread"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.SoundThread.AddWorkToQueue(System.Action,System.String)">
            <summary>Add the given <paramref name="work"/> to be performed in the background</summary>
            <param name="work"></param>
            <param name="caller"></param>
            <returns><see langword="true"/> if the work was added to the queue, <see langword="false"/> if it was not</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="work"/> is <see langword="null"/></exception>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.SoundThread._stopwatch">
            <summary>Used to get the time spent in the <see cref="M:NQualityOfLife.Utils.Threading.SoundThread.WorkLoop"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.SoundThread.WorkLoop">
            <summary>The work we are performing in the background <see cref="F:NQualityOfLife.Utils.Threading.SoundThread._soundThread"/></summary>
            <returns>The amount of <see cref="P:System.Diagnostics.Stopwatch.ElapsedMilliseconds"/> spent in the <see cref="M:NQualityOfLife.Utils.Threading.SoundThread.WorkLoop"/> and how many tasks were successfully completed from the <see cref="F:NQualityOfLife.Utils.Threading.SoundThread._workQueue"/></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Threading.BackgroundWorker">
            <summary>Manages background threads and tasks</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._thread">
            <summary>The background worker <see cref="T:System.Threading.Thread"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._threadBeta">
            <summary>Secondary background worker thread</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._running">
            <summary>The state of the <see cref="F:NQualityOfLife.Utils.Threading.BackgroundWorker._thread"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._lock">
            <summary>lock for the <see cref="M:NQualityOfLife.Utils.Threading.BackgroundWorker.Start"/> and <see cref="M:NQualityOfLife.Utils.Threading.BackgroundWorker.Stop"></see> actions</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._workQueue">
            <summary>Queued work to be done in the background</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.BackgroundWorker.Running">
            <summary>Check if the <see cref="T:NQualityOfLife.Utils.Threading.BackgroundWorker"/> is currently running</summary>
            <returns><see langword="true"/> if the <see cref="T:NQualityOfLife.Utils.Threading.BackgroundWorker"/> has been started</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Threading.BackgroundWorker.QueueSize">
            <summary>Check how many tasks are currently queued</summary>
            <returns>The amount of tasks in the work queue</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.BackgroundWorker.AddWorkToQueue(System.Action,System.String)">
            <summary>Add the given <paramref name="work"/> to be performed in the background</summary>
            <param name="work"></param>
            <param name="caller">This should be left as <see langword="default"/>, as this parameter uses the <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/></param>
            <returns><see langword="true"/> if the work was added to the queue, <see langword="false"/> if it was not</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="work"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.BackgroundWorker.Start">
            <summary>Start the background worker until its stopped with <see cref="M:NQualityOfLife.Utils.Threading.BackgroundWorker.Stop"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.BackgroundWorker.Stop">
            <summary>Stop the <see cref="F:NQualityOfLife.Utils.Threading.BackgroundWorker._thread"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Threading.BackgroundWorker._stopwatch">
            <summary>Used to get the time spent in the <see cref="M:NQualityOfLife.Utils.Threading.BackgroundWorker.WorkLoop"/></summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.BackgroundWorker.WorkLoop">
            <summary>The work we are performing in the background <see cref="F:NQualityOfLife.Utils.Threading.BackgroundWorker._thread"/></summary>
            <returns>The amount of <see cref="P:System.Diagnostics.Stopwatch.ElapsedTicks"/> spent in the <see cref="M:NQualityOfLife.Utils.Threading.BackgroundWorker.WorkLoop"/> and how many tasks were successfully completed from the <see cref="F:NQualityOfLife.Utils.Threading.BackgroundWorker._workQueue"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Threading.StartTask(System.Action)">
            <inheritdoc cref="M:System.Threading.Tasks.Task.Run(System.Action)"/>
            <summary></summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.RectExtensions">
            <summary>Extensions for <see cref="T:UnityEngine.Rect"/>s and <see cref="T:NQualityOfLife.Geometry.Rectangle"/>s</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Transposed(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Vector2Float@)">
            <inheritdoc cref="M:NQualityOfLife.Geometry.Rectangle.MovedBy(NQualityOfLife.Types.Vector2Float@)"/>
            <summary></summary>
            <param name="rectangle"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Split the <paramref name="rect"/> into the left and right halfs</summary>
            <param name="rect"></param>
            <param name="coordinateContext"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Splits the input <paramref name="rect"/> into two parts</summary>
            <param name="rect">Original <paramref name="rect"/> to split</param><param name="left">The left part of the original <paramref name="rect"/></param><param name="right">The right part of the original <paramref name="rect"/></param>
            <param name="rightSideRatio">The size of the right side <paramref name="rect"/> (Ratio) 0.5f means an equal split</param>
            <param name="coordinateContext"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Splits the input rect into two equal parts</summary>
            <param name="rect">Original rect to split</param><param name="left">The left half of the original rect</param><param name="right">The right half of the original <paramref name="rect"/></param>
            <param name="coordinateContext"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Splits the input <paramref name="rect"/> into two equal parts</summary>
            <param name="rect">Original <paramref name="rect"/> to split</param><param name="top">The top half of the original <paramref name="rect"/></param><param name="bottom">The bottom half of the original rect</param>
            <param name="coordinateContext"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Splits the input <paramref name="rect"/> into two parts</summary>
            <param name="rect">Original <paramref name="rect"/> to split</param><param name="top">The left part of the original <paramref name="rect"/></param><param name="bottom">The right part of the original <paramref name="rect"/></param>
            <param name="bottomRatio">The size of the bottom half <paramref name="rect"/> (Ratio) 0.5f means an equal split</param>
            <param name="coordinateContext"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the bottom half of the <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="coordinateContext"></param>
            <returns>The bottom 50% of the given <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomPart(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the bottom part of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the bottom?</param>
            <param name="coordinateContext"></param>
            <returns>The bottom part of the original <paramref name="rect"/> with a height of the original * <paramref name="ratio"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomPart(NQualityOfLife.Geometry.IRectangle,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the bottom part of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the bottom?</param>
            <param name="coordinateContext"></param>
            <returns>The bottom part of the original <paramref name="rect"/> with a height of the original * <paramref name="ratio"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomPartPixels(NQualityOfLife.Geometry.Rectangle@,System.Single,NQualityOfLife.Types.CoordinateContext)">
            <summary></summary>
            <param name="rect"></param>
            <param name="height"></param>
            <param name="coordinateContext"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that has the given <paramref name="height"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the top half of the <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="coordinateContext"></param>
            <returns>The top 50% of the given <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopHalf(NQualityOfLife.Geometry.Square@,NQualityOfLife.Types.CoordinateContext)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.TopHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopPart(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the top part of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the top?</param>
            <param name="coordinateContext"></param>
            <returns>The top part of the original <paramref name="rect"/> with a height of the original * <paramref name="ratio"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopPart(NQualityOfLife.Geometry.IRectangle,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the top part of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the top?</param>
            <param name="coordinateContext"></param>
            <returns>The top part of the original <paramref name="rect"/> with a height of the original * <paramref name="ratio"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopPartPixels(NQualityOfLife.Geometry.Rectangle@,System.Single,NQualityOfLife.Types.CoordinateContext)">
            <summary></summary>
            <param name="rect"></param>
            <param name="height"></param>
            <param name="coordinateContext"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that has the given <paramref name="height"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the left half of the given <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="coordinateContext"></param>
            <returns>The left half of the original <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftPart(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the left side of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the left side?</param>
            <param name="coordinateContext"></param>
            <returns>The left side of the original <paramref name="rect"/> with a width of the original * <paramref name="ratio"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftSegment(NQualityOfLife.Geometry.Rectangle@,System.Single,NQualityOfLife.Types.CoordinateContext)">
            <summary>Get a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that is aligned to the right edge of the source <paramref name="rect"/> and has the given <paramref name="width"/></summary>
            <param name="rect"></param>
            <param name="width"></param>
            <param name="coordinateContext"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the right half of the given <paramref name="rect"/></summary>
            <param name="rect"></param>
            <param name="coordinateContext"></param>
            <returns>The right half of the original <paramref name="rect"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightPart(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)">
            <summary>Gets the right side of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the right side?</param>
            <param name="coordinateContext"></param>
            <returns>The right side of the original <paramref name="rect"/> with a width of the original * <paramref name="ratio"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightSegment(NQualityOfLife.Geometry.Rectangle@,System.Single,NQualityOfLife.Types.CoordinateContext)">
            <summary>Get a <see langword="new"/> <see cref="T:NQualityOfLife.Geometry.Rectangle"/> that is aligned to the right edge of the source <paramref name="rect"/> and has the given <paramref name="width"/></summary>
            <param name="rect"></param>
            <param name="width">The width of the right segment to get</param>
            <param name="coordinateContext"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Squeeze(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@)">
            <summary>Gets a rect between the given two</summary>
            <param name="rect"></param>
            <param name="top">The top part of the rect</param>
            <param name="bottom">The bottom part of the rect</param>
            <returns>Rect fitted between the <paramref name="top"/> and <paramref name="bottom"/> parts</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect@)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect@,UnityEngine.Color@)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="color"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect@,System.String)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="additionalInfoString"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(NQualityOfLife.Geometry.Rectangle@,System.Nullable{UnityEngine.Color}@,System.String,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect@,System.Nullable{UnityEngine.Color}@,System.String,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect@,System.Nullable{UnityEngine.Color}@,System.String,System.Boolean,System.Boolean)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="color"></param>
            <param name="additionalInfoString">Additional info to show on hover</param>
            <param name="stable"></param>
            <param name="debugMouse"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect@,NQualityOfLife.Colors.IColorImmutable@,System.String,System.Boolean,System.Boolean)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="iColor"></param>
            <param name="additionalInfoString">Additional info to show on hover</param>
            <param name="stable"></param>
            <param name="debugMouse"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Ratio@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Types.Ratio@,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Types.Ratio@,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomHalf(UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.BottomHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomPart(UnityEngine.Rect@,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.BottomPart(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopHalf(UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.TopHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopPart(UnityEngine.Rect@,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.TopPart(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightHalf(UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.RightHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightSide(UnityEngine.Rect@,NQualityOfLife.Types.Ratio@)">
            <summary>Gets the right side of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the right side?</param>
            <returns>The right side of the original <paramref name="rect"/> with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightPart(UnityEngine.Rect@,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.RightPart(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftHalf(UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.LeftHalf(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftSide(UnityEngine.Rect@,NQualityOfLife.Types.Ratio@)">
            <summary>Gets the left side of the given <paramref name="rect"/></summary>
            <param name="rect"></param><param name="ratio">How much of the original <paramref name="rect"/> we consider the left side?</param>
            <returns>The left side of the original <paramref name="rect"/> with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftPart(UnityEngine.Rect@,NQualityOfLife.Types.Ratio@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.LeftPart(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Factor@,NQualityOfLife.Types.CoordinateContext)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftBottomCorner(UnityEngine.Rect@)">
            <summary>Get the bottom left corner of the <paramref name="rect"/> (in screen coordinates)</summary>
            <param name="rect"></param>
            <returns>The left bottom corner of the <paramref name="rect"/> (in screen coordinates)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(UnityEngine.Vector2@,UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.IsInside(NQualityOfLife.Geometry.Point2D@,UnityEngine.Rect@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(System.ValueTuple{System.Single,System.Single}@,UnityEngine.Rect@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RectExtensions.IsInside(NQualityOfLife.Geometry.Point2D@,UnityEngine.Rect@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(NQualityOfLife.Geometry.Point2D@,UnityEngine.Rect@)">
            <summary>Is this point inside the given rect?</summary>
            <param name="point"></param><param name="rect"></param>
            <returns><see langword="true"/> if the point is inside the rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.OnScreen(UnityEngine.Rect@,NQualityOfLife.Types.Vector2Float@,System.Boolean)">
            <summary></summary><param name="rect"></param>
            <param name="debug"></param>
            <param name="positionOffset"></param>
            <returns><see langword="true"/> if the input rect is partly or fully visible on screen (Assuming the rect is drawn) / in bounds of the screen </returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.OnScreen(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Types.Vector2Float@,System.Boolean)">
            <summary></summary><param name="rect"></param>
            <param name="debug"></param>
            <param name="positionOffset"></param>
            <returns><see langword="true"/> if the input rect is partly or fully visible on screen (Assuming the rect is drawn) / in bounds of the screen </returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.FullyOnScreen(NQualityOfLife.Geometry.Rectangle@)">
            <summary>Is the input rect fully inside the bounds of the screen?</summary>
            <param name="rect"></param><returns><see langword="true"/> if the input rect is fully inside the bounds of the screen</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.RectExtensions.FullScreenRect">
            <summary>Gets a Rect that is the size, shape and position of the screen</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.ContainsOrOverlaps(UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Types.Vector2Float@,System.Boolean)">
            <summary></summary>
            <param name="rect"></param><param name="innerRect"></param>
            <param name="positionOffset"></param>
            <param name="debug"></param>
            <returns><see langword="true"/> if the rects fully or partly overlap each other</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.FullyContains(UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Does this Rect fully contain innerRect?</summary>
            <param name="rect"></param><param name="innerRect"></param>
            <returns><see langword="true"/> if all parts of innerRect are inside this rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.InnerSquare(UnityEngine.Rect@)">
            <summary>Get a square rect fitted inside the input rect</summary>
            <param name="rect"></param>
            <returns>Square</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Squeeze(UnityEngine.Rect@,System.Single)">
            <summary>Reduces the height of the Rect, anchoring position on the center</summary>
            <param name="rect"></param><param name="amount">pixels</param>
            <returns>The input rect squeezed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SqueezeHorizontal(UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Gets a rect between the given two</summary>
            <param name="rect"></param>
            <param name="left">The left part of the rect</param>
            <param name="right">The right part of the rect</param>
            <returns>Rect between the left and right parts</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Segment(NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,NQualityOfLife.Geometry.Rectangle@,System.Single,System.Single,System.Boolean)">
            <summary>Segments the given rect into 3 parts</summary>
            <param name="rect"></param>
            <param name="top"></param>
            <param name="middle"></param>
            <param name="bottom"></param>
            <param name="topHeightPixels"></param>
            <param name="bottomHeightPixels"></param>
            <param name="debug">Draw colored debug rectangles</param>
        </member>
        <member name="T:NQualityOfLife.Utils.DefExtensions">
            <summary><see cref="T:Verse.Def"/> extension utils</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.HasOnCameraSubSounds(Verse.SoundDef)">
            <summary>Can this <paramref name="soundDef"/> be played without a source <see cref="T:Verse.Thing"/> on a <see cref="T:Verse.Map"/>?</summary>
            <param name="soundDef"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsGrave(Verse.ThingDef)">
            <summary>Is the given <paramref name="thingDef"/> a grave? (or sarcophagi)</summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if the <paramref name="thingDef"/> is the final resting place of a <see cref="T:Verse.Pawn"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsChair(Verse.ThingDef)">
            <summary>Is the given <paramref name="thingDef"/> a chair/seat/stool used for comfort?</summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if the <paramref name="thingDef"/> is a building <seealso cref="P:Verse.ThingDef.IsBed">(that is not a bed)</seealso> that <seealso cref="T:Verse.Pawn">pawns</seealso> can sit on to gain comfort</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>Returns <see langword="false"/> for beds even if they can be used as a seat</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsGlower(Verse.ThingDef)">
            <summary>Does the given <paramref name="thingDef"/> glow?</summary>
            <param name="thingDef"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsLamp(Verse.ThingDef)">
            <summary>Is the given <paramref name="thingDef"/> a lamp?</summary>
            <param name="thingDef"></param>
            <returns><see langword="false"/> for <seealso cref="T:Verse.ThingDef">things</seealso> that glow but are not 'lamps'</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsFurniture(Verse.ThingDef)">
            <summary>Is the given <paramref name="thingDef"/> a furniture item?</summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if chair, table, bed, etc..</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="thingDef"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsSpot(Verse.ThingDef,System.Boolean,System.Boolean)">
            <summary>Is the given <paramref name="thingDef"/> a spot, for the purposes of the spots tab, minification or research changes?</summary>
            <param name="thingDef"></param>
            <param name="allowBlueprints"></param>
            <param name="allowFrames"></param>
            <remarks>a <see cref="T:Verse.ThingDef"/> is a spot if it can be placed instantly by the player without needing a <see cref="T:Verse.Pawn"/> to interact with it and it requires no resources<para>This method will also consider a <see cref="T:Verse.ThingDef"/> a spot if it uses no resources and requires less than '5' work to build</para></remarks>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.CanBeCreatedByPlayer(Verse.ThingDef,System.Boolean)">
            <summary>Can the given thing be created by the player? (crafted / built)</summary>
            <param name="thingDef"></param>
            <param name="searchIndirectRecipesIfNeeded">Check recipe defs if result was inconclusive? - This could be relatively slow!</param>
            <returns><see langword="true"/> if the thing can be crafted or built by the player, <see langword="false"/> if not.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsInstantlyPlaceable(Verse.ThingDef)">
            <summary>Can this <paramref name="thingDef"/> be placed without requiring a <see cref="T:Verse.Pawn"/> to build it?</summary>
            <param name="thingDef"><see cref="T:Verse.ThingDef"/> we are testing.</param>
            <returns><see langword="true"/> if can be placed instantly without needing a <see cref="T:Verse.Pawn"/> to work on it, else <see langword="false"/>. also returns <see langword="false"/> if thing is not a building.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.UsesNoMaterialsToMake(Verse.ThingDef)">
            <summary>Check if the <paramref name="thingDef"/> uses no materials to build</summary>
            <remarks>Note: Returns <see langword="false"/> for things that are not buildable by the player!</remarks>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if thing uses no materials to build. Returns <see langword="false"/> for things that cannot be built or crafted.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsFleshMassThing(Verse.ThingDef)">
            <summary></summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if the <paramref name="thingDef"/> is part of the flesh mass entity</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsNatural(Verse.ThingDef)">
            <summary></summary>
            <param name="thingDef"></param>
            <remarks>Natural things include animal products, plants, animals, natural terrain etc<para>The definition of natural that is used here is subjective!</para></remarks>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsMetaElement(Verse.ThingDef)">
            <summary></summary>
            <param name="thingDef"></param>
            <remarks>Meta elements include blueprints, <see cref="T:Verse.Mote"/>, <see cref="T:Verse.Projectile"/>, <see cref="T:RimWorld.Fire"/>, <see cref="T:RimWorld.Spark"/>, <see cref="T:RimWorld.Skyfaller"/> etc</remarks>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsWall(Verse.ThingDef)">
            <summary>Check if the given <paramref name="thingDef"/> is a wall</summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if yes</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.ShouldBeAbleToMinify(Verse.ThingDef)">
            <summary>Is this <paramref name="thingDef"/> something that should logically (or for gameplay reasons) be able to be moved?</summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if the <paramref name="thingDef"/> should be able to be moved</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.ShouldNeverBeAbleToMinify(Verse.ThingDef)">
            <summary>Checks if the <see cref="T:Verse.ThingDef"/> is something that should logically or for gameplay reasons not be able to be minified<para>This is things like the <see cref="F:RimWorld.ThingDefOf.Snowman"/>, <see cref="F:RimWorld.ThingDefOf.Grave"/> and <see cref="F:RimWorld.ThingDefOf.Fire"/> etc</para></summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if the <paramref name="thingDef"/> is something that should not be able to be moved</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.CanMinify(Verse.ThingDef)">
            <summary>Is the given thing a valid minifiable thing?</summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if minifiable and valid</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsUnderground(Verse.ThingDef)">
            <summary>Is the given thing 'underground'</summary>
            <param name="thingDef"></param>
            <returns><see langword="true"/> if the <paramref name="thingDef"/> is partly or fully buried or underground</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.ThingExtensions">
            <summary>Thing def utils WIP</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.IsQuarantineBed(RimWorld.Building_Bed,System.Boolean)">
            <summary>Check if the bed is a quarantine bed (disease spread system)</summary>
            <param name="bed"></param>
            <param name="bedIsKnownToBeMedical"></param>
            <returns><see langword="true"/> if the <paramref name="bed"/> is a medical bed set to be a quarantine bed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.MakeThing(Verse.ThingDef,Verse.ThingDef)">
            <inheritdoc cref="M:Verse.ThingMaker.MakeThing(Verse.ThingDef,Verse.ThingDef)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.MakeThing(Verse.ThingDef)">
            <summary>Make a new Thing of the given def</summary>
            <param name="def"></param>
            <returns>The newly created Thing</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.NameWithFactionColor(RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param>
            <returns>The player facing name colored with the color of the <paramref name="faction"/> (the color of their icon / base icons)</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrFriendlyFaction(Verse.Thing,Verse.Thing)">
            <summary></summary>
            <param name="thing"></param><param name="other"></param>
            <returns>always <see langword="false"/> if either <see cref="T:RimWorld.Faction"/> is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrAllyFaction(RimWorld.Faction,RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param><param name="other"></param>
            <returns>always <see langword="false"/> if either <see cref="T:RimWorld.Faction"/> is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrFriendlyFaction(RimWorld.Faction,RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param><param name="other"></param>
            <returns>always <see langword="false"/> if either <see cref="T:RimWorld.Faction"/> is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.RottenOrRotsInHours(Verse.Corpse,System.Single)">
            <summary></summary>
            <param name="corpse"></param>
            <param name="hours"></param>
            <returns><see langword="true"/> if the <paramref name="corpse"/> is rotten, or will be rotten in <paramref name="hours"/></returns>
            <remarks><see cref="F:RimWorld.RotStage.Dessicated"/> is not considered rotten by this method</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetComp_Fast``1(System.Collections.Generic.List{Verse.CompProperties})">
            <summary>Get the first found <see cref="T:Verse.CompProperties"/> of type '<typeparamref name="TCompProps"/>'</summary>
            <typeparam name="TCompProps"></typeparam>
            <param name="comps"></param>
            <returns>The first found <see cref="T:Verse.CompProperties"/> that '<see langword="is"/>' '<typeparamref name="TCompProps"/>' || or <see langword="null"/> if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.IEnumerable{RimWorld.Apparel},Verse.BodyPartRecord)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.List{RimWorld.Apparel},Verse.BodyPartRecord,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.List{RimWorld.Apparel},Verse.BodyPartRecord)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.List{RimWorld.Apparel},Verse.BodyPartRecord,System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetApparelCoveringPart(System.Collections.Generic.List{RimWorld.Apparel},Verse.BodyPartRecord,System.Int32@)">
            <summary>Get all the <see cref="T:RimWorld.Apparel"/> that is covering the given body part</summary>
            <param name="apparel"></param>
            <param name="bodyPart"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.OtherSide(RimWorld.Building_Door,Verse.Room,Verse.Map)">
            <summary></summary>
            <param name="door"></param>
            <param name="from"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetRegion(Verse.Thing,Verse.Map,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValuesFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="stat4"></param>
            <param name="stat5"></param>
            <param name="stat6"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValuesFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="stat4"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="defaultValue"></param>
            <returns><paramref name="defaultValue"/> if the <paramref name="statList"/> is <see langword="null"/>, empty or does not contain the <see cref="T:RimWorld.StatDef"/> we are looking for or <paramref name="stat1"/> is <see langword="null"/>, else the value of the stat.</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.ZoneExtensions">
            <summary>Zone extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.IsPolluted(Verse.IntVec3@,Verse.Map)">
            <summary></summary><param name="cell"></param><param name="map"></param><returns><see langword="true"/> if the <paramref name="cell"/> is in bounds and polluted</returns>
            <remarks>Will always be <see langword="false"/> if <see cref="F:NQualityOfLife.Utils.Mods.BiotechActive"/> is <see langword="false"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFertility(Verse.IntVec3@,Verse.Map)">
            <summary>Get the fertility of the given <paramref name="cell"/> from the <see cref="F:Verse.Map.fertilityGrid"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetZone(Verse.IntVec3@,Verse.Map)">
            <summary>Get the <see cref="T:Verse.Zone"/> at the specified <paramref name="cell"/></summary>
            <param name="cell"></param><param name="map"></param>
            <returns>The <see cref="T:Verse.Zone"/> on the <paramref name="cell"/> or <see langword="null"/> if there is no zone on the <paramref name="cell"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InvalidOrZero(Verse.IntVec3@)">
            <summary>Is the <paramref name="cell"/> <see cref="F:Verse.IntVec3.Invalid"/>/out of bounds or 0 (0 is bottom left corner of the map)</summary><param name="cell"></param><returns><see langword="true"/> if is invalid or zero</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetAirTemperature_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Get the temperature in the <see cref="T:Verse.Room"/> at the given <paramref name="cell"/> on the given <paramref name="map"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTemperature(Verse.IntVec3@,Verse.Map)">
            <summary>Get the temperature at the <paramref name="cell"/> on the given <paramref name="map"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>Temperature in <see cref="T:NQualityOfLife.Units.Celsius"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.UsesOutdoorTemperature(Verse.IntVec3@,Verse.Map)">
            <summary>Does the given <paramref name="cell"/> use the outdoor <paramref name="map"/> temperature</summary><param name="cell"></param><param name="map"></param><returns><see langword="true"/> if the <paramref name="cell"/> uses the <paramref name="map"/> temperature</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover(Verse.Map,Verse.IntVec3@)">
            <summary>Get the cover at the cell</summary><param name="cell"></param><param name="map"></param><returns>null if no cover at '<paramref name="cell"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover(Verse.IntVec3@,Verse.Map)">
            <summary>Get the cover at the cell</summary><param name="c"></param><param name="map"></param><returns>null if no cover at '<paramref name="c"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Get the cover at the cell</summary>
            <param name="c"></param><param name="map"></param>
            <param name="mapSize"></param>
            <returns><see langword="null"/> if no cover at '<paramref name="c"/>'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged(Verse.Thing,Verse.Map)">
            <summary></summary>
            <param name="thing"></param><param name="map"></param>
            <returns><see langword="true"/> if the fog grid is fogged at thing</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="thing"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.Fogged_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary></summary>
            <param name="cell"></param><param name="map"></param><param name="mapSize"></param>
            <returns><see langword="true"/> if the fog grid is fogged at <paramref name="cell"/> and the <paramref name="cell"/> is in bounds of the <paramref name="mapSize"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Roofed(Verse.IntVec3@,Verse.Map,Verse.RoofDef@)">
            <summary>Returns <see langword="true"/> if the <see cref="T:Verse.RoofDef"/> at the <paramref name="cell"/> is not <see langword="null"/></summary>
            <param name="cell"></param><param name="map"></param><param name="roofDef"><see langword="null"/> if this method returned <see langword="false"/></param>
            <returns><see langword="true"/> if the <paramref name="cell"/> has a roof</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Roofed(Verse.IntVec3@,Verse.Map)">
            <summary>Returns <see langword="true"/> if <see cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof(Verse.IntVec3@,Verse.Map)"/> is <see langword="null"/> at the given <paramref name="cell"/></summary>
            <param name="cell"></param><param name="map"></param>
            <returns><see langword="true"/> if the <paramref name="cell"/> has a roof - Use <see cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof(Verse.IntVec3@,Verse.Map)"/> if you need to get the <see cref="T:Verse.RoofDef"/> anyways</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Roofed_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Returns <see langword="true"/> if <see cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof(Verse.IntVec3@,Verse.Map)"/> is <see langword="null"/> at the given <paramref name="cell"/></summary>
            <param name="cell"></param><param name="map"></param>
            <param name="mapSize"></param>
            <returns><see langword="true"/> if the <paramref name="cell"/> has a roof - Use <see cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof(Verse.IntVec3@,Verse.Map)"/> if you need to get the <see cref="T:Verse.RoofDef"/> anyways</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof(Verse.IntVec3@,Verse.Map)">
            <summary>Get the roof def from the roof grid</summary>
            <param name="cell"></param><param name="map"></param><returns></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Get the <see cref="T:Verse.RoofDef"/> from the roof grid</summary>
            <param name="cell"></param><param name="map"></param>
            <param name="mapSize"></param><returns></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain(Verse.Map,Verse.IntVec3)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Gets the terrain def directly from the terrainGrid - Normally non <see langword="null"/></summary>
            <param name="map"></param><param name="mapSize"></param><param name="cell"></param>
            <returns>The terrainGrid <see cref="T:Verse.TerrainDef"/> at <paramref name="cell"/> - Normally non <see langword="null"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt(Verse.Map,Verse.IntVec3@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt_Internal(Verse.Map,Verse.IntVec3@,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt_Internal(Verse.Map,Verse.IntVec3@,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt_Internal(Verse.Map,Verse.IntVec3@,Verse.IntVec3@)">
            <summary>Gets the terrain def directly from the terrainGrid - Normally non-<see langword="null"/></summary>
            <param name="map"></param><param name="at"></param>
            <param name="mapSize"></param>
            <returns>The terrainGrid <see cref="T:Verse.TerrainDef"/> at '<paramref name="at"/>' - Normally non-<see langword="null"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3@,Verse.MapInfo)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapInfo"></param><returns>c.z * mapInfo.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3@,Verse.Map)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="map"></param><returns>c.z * map.info.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.Map,Verse.IntVec3@)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="map"></param><returns>c.z * map.info.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3@,Verse.IntVec3@)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapSize"></param><returns>c.z * mapSize.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3@,System.Int32)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapSizeX"></param><returns>c.z * mapSizeX + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RegionAt(Verse.Map,Verse.IntVec3,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RegionAt(Verse.IntVec3@,Verse.Map,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion(Verse.IntVec3@,Verse.Map,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@,Verse.RegionType)">
            <summary>Get the <see cref="T:Verse.Region"/> at the given <paramref name="cell"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <param name="allowedRegionTypes"></param>
            <returns>The <see cref="T:Verse.Region"/> at the <paramref name="cell"/>, or <see langword="null"/> if out of bounds or not valid type</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion_InternalDirect(Verse.IntVec3@,Verse.Map,Verse.IntVec3@,Verse.RegionType)">
            <summary>Get the <see cref="T:Verse.Region"/> at the given <paramref name="cell"/> || the <paramref name="cell"/> must be in bounds of the <paramref name="map"/> or this method will <see langword="throw"/> an <see cref="T:System.Exception"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <param name="allowedRegionTypes"></param>
            <returns>The <see cref="T:Verse.Region"/> at the <paramref name="cell"/>, or <see langword="null"/> if not valid type</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoomOrAdjacent(Verse.IntVec3@,Verse.Map,Verse.RegionType)">
            <summary></summary>
            <param name="loc"></param>
            <param name="map"></param>
            <param name="allowedRegionTypes"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoom(Verse.Thing,Verse.Map,Verse.RegionType)">
            <summary></summary>
            <param name="thing"></param>
            <param name="map"></param>
            <param name="allowedRegionTypes"></param>
            <returns>the <see cref="T:Verse.Room"/> at the given <paramref name="thing"/>s position on the given <paramref name="map"/> that is of the <paramref name="allowedRegionTypes"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoom(Verse.IntVec3@,Verse.Map,Verse.RegionType)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="allowedRegionTypes"></param>
            <returns>the <see cref="T:Verse.Room"/> at the given <paramref name="cell"/> on the given <paramref name="map"/> that is of the <paramref name="allowedRegionTypes"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoom_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetRoom(Verse.IntVec3@,Verse.Map,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetDistrict(Verse.IntVec3@,Verse.Map,Verse.RegionType)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="allowedRegionTypes"></param>
            <returns>the <see cref="T:Verse.District"/> at the given <paramref name="cell"/> on the given <paramref name="map"/> that is of the <paramref name="allowedRegionTypes"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetDistrict_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@,Verse.RegionType)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetDistrict(Verse.IntVec3@,Verse.Map,Verse.RegionType)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstPawn(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstPawn_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstPawn_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <returns>The first found <see cref="T:Verse.Thing"/> of type <see cref="T:Verse.Pawn"/> at the <paramref name="cell"/> || or <see langword="null"/> if there are no pawns at the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWhere(Verse.IntVec3@,Verse.Map,System.Predicate{Verse.Thing})">
            <returns>The first <see cref="T:Verse.Thing"/> that is found on the <paramref name="cell"/> that passes the <paramref name="validator"/> or <see langword="null"/> if none found</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing_Internal(Verse.IntVec3@,Verse.Map,Verse.ThingDef,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing(Verse.IntVec3@,Verse.Map,Verse.ThingDef)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing_Internal(Verse.IntVec3@,Verse.Map,Verse.ThingDef,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing_Internal(Verse.IntVec3@,Verse.Map,Verse.ThingDef,Verse.IntVec3@)">
            <summary></summary>
            <param name="cell"></param><param name="map"></param><param name="ofDef"></param>
            <param name="mapSize"></param>
            <returns>The first found '<see cref="T:Verse.Thing"/>' of the provided '<see cref="T:Verse.ThingDef"/>' on the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstBed(Verse.IntVec3@,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first found thing of type <see cref="T:RimWorld.Building_Bed"/> at the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstBuilding(Verse.IntVec3@,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first found thing of type <see cref="T:Verse.Building"/> at the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing``1(Verse.IntVec3@,Verse.Map)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first <see cref="T:Verse.Thing"/> of type <typeparamref name="T"/> that is found on the <paramref name="cell"/> || <see langword="null"/> if none found on the <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWithComp``1(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWithComp``1(Verse.IntVec3@,Verse.Map,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWithComp``1(Verse.IntVec3@,Verse.Map,``0@)">
            <summary></summary>
            <typeparam name="TC"></typeparam>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="comp"></param>
            <returns>The first found <see cref="T:Verse.ThingWithComps"/> with the specified <see cref="T:Verse.ThingComp"/> type || or <see langword="null"/> if none found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingListAt(Verse.Map,Verse.IntVec3@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Get the things at the specified cell</summary>
            <param name="c"></param><param name="map"></param><param name="mapSize"></param>
            <returns><see langword="ref"/> to the <see cref="T:Verse.Thing"/> list || not <see langword="null"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CanZone(Verse.IntVec3@,Verse.Map)">
            <summary>Can the cell be zoned right now?</summary>
            <param name="c"></param><param name="map"></param>
            <returns><see langword="true"/> if the cell can be zoned</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CanZone_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Can the cell be zoned right now?</summary>
            <param name="c"></param><param name="map"></param>
            <param name="mapSize"></param>
            <returns><see langword="true"/> if the cell can be zoned</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Neighbors(Verse.District)">
            <summary></summary>
            <param name="district"></param>
            <returns>a read only <see cref="T:NQualityOfLife.Types.HashList`1"/> of all the <see cref="T:Verse.District"/>s that border the given <paramref name="district"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Neighbors(Verse.Region)">
            <summary></summary>
            <param name="region"></param>
            <returns>a read only <see cref="T:NQualityOfLife.Types.HashList`1"/> of all the <see cref="T:Verse.Region"/>s that border the given <paramref name="region"/></returns>
            <remarks>Note that these are the regions that are linked to the given <paramref name="region"/><para>Fully enclosed regions have no neighbors</para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InBounds(Verse.IntVec3@,Verse.IntVec3@)">
            <summary>Is the given <paramref name="cell"/> in bounds of the <see cref="T:Verse.Map"/> (size)</summary><param name="cell"></param><param name="mapSize"></param><returns><see langword="true"/> if in bounds</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InBounds(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.InBounds(Verse.IntVec3@,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InNoZoneEdgeArea(Verse.IntVec3@,Verse.IntVec3@)">
            <summary>Is the cell too close to the map edge to allow zoning</summary>
            <param name="c"></param><param name="mapSize"></param>
            <returns>True if too close to edge</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InNoZoneEdgeArea(Verse.IntVec3@,Verse.Map)">
            <summary>Is the cell too close to the map edge to allow zoning</summary>
            <param name="c"></param><param name="map"></param>
            <returns>True if too close to edge</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CloseToEdge(Verse.IntVec3@,Verse.IntVec3@,System.Int32)">
            <summary></summary>
            <param name="c"></param>
            <param name="mapSize"></param>
            <param name="edgeDist"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Impassable(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.Impassable_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Impassable_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Check if the <paramref name="cell"/> is <see cref="F:Verse.Traversability.Impassable"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Standable(Verse.IntVec3@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.Standable_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Standable_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Check if <see cref="T:Verse.Pawn"/>s can stand on the <paramref name="cell"/></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <returns><see langword="true"/> if the <paramref name="cell"/> is in-bounds and a <see cref="T:Verse.Pawn"/> can stand on it</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Walkable(Verse.IntVec3@,Verse.Map)">
            <summary>Check if the <paramref name="cell"/> is in bounds of the <paramref name="map"/> and walkable</summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns><see langword="true"/> if the <paramref name="cell"/> is in bounds and walkable</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Walkable_Internal(Verse.IntVec3@,Verse.Map,Verse.IntVec3@)">
            <summary>Check if the <paramref name="cell"/> is <see cref="M:NQualityOfLife.Utils.ZoneExtensions.InBounds(Verse.IntVec3@,Verse.IntVec3@)"/> and walkable by <see cref="T:Verse.Pawn"/>s</summary>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <returns><see langword="true"/> if the <paramref name="cell"/> is walkable</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Walkable_Internal_Direct(Verse.AI.PathGrid,Verse.IntVec3@,Verse.IntVec3@)">
            <summary></summary>
            <param name="pathGrid"></param>
            <param name="cell"></param>
            <param name="mapSize"></param>
            <returns></returns>
            <remarks>No in-bounds or <see langword="null"/> checks!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.OnEdge(Verse.IntVec3@,Verse.IntVec3@,RimWorld.Direction8Way@)">
            <summary>Is this <paramref name="cell"/> right on the edge of the <see cref="T:Verse.Map"/>?</summary>
            <param name="cell">Cell</param><param name="mapSize"><see cref="P:Verse.Map.Size"/></param>
            <param name="dir">The map edge (or corner) of the <paramref name="cell"/>, or <see cref="F:RimWorld.Direction8Way.Invalid"/> if not on any edge</param>
            <returns><see langword="true"/> if the <paramref name="cell"/> is right on the edge of the <see cref="T:Verse.Map"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.OnEdge(Verse.IntVec3@,Verse.IntVec3@)">
            <summary>Is this cell right on the edge of the map?</summary>
            <param name="c">Cell</param><param name="mapSize">Map.Size</param>
            <returns><see langword="true"/> if the cell is right on the edge of the map || also returns <see langword="true"/> if out of bounds</returns>
            <remarks>Also returns <see langword="true"/> if out of bounds!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.DirectionAwayFrom(Verse.IntVec3@,Verse.IntVec3@,System.Boolean)">
            <summary>Get the direction from one cell to another, if 'from' and 'to' are the same, or one of them is 'IntVec3.Invalid', returns 'Direction8Way.Invalid'</summary>
            <param name="from">Direction 'from' this cell away 'awayFrom'</param><param name="awayFrom">Direction 'from' cell away from cell 'awayFrom'</param>
            <param name="errorOnInvalidInput">Log error if one of the input cells is 'IntVec3.Invalid' - Set to false if invalid cells are to be expected in normal operation.</param>
            <returns>Direction8Way of the direction, or 'Direction8Way.Invalid'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.DirectionTo(Verse.IntVec3@,Verse.IntVec3@,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ZoneExtensions.DirectionTo(Verse.IntVec3@,Verse.IntVec3@,NQualityOfLife.Units.Degrees@,System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.DirectionTo(Verse.IntVec3@,Verse.IntVec3@,NQualityOfLife.Units.Degrees@,System.Boolean,System.Boolean)">
            <summary>Get the direction from one cell to another, if 'from' and 'to' are the same, or one of them is 'IntVec3.Invalid', returns 'Direction8Way.Invalid'</summary>
            <param name="from">Direction 'from' this cell towards 'to'</param><param name="to">Direction 'from' cell towards 'to'</param>
            <param name="degrees"></param>
            <param name="errorOnInvalidInput">Log error if one of the input cells is 'IntVec3.Invalid' - Set to false if invalid cells are to be expected in normal operation.</param>
            <param name="debug"></param>
            <returns>Direction8Way of the direction, or 'Direction8Way.Invalid'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.ToCardinal(RimWorld.Direction8Way)">
            <summary>Ensures Direction8Way is cardinal - Chooses closest random cardinal if direction is not cardinal</summary>
            <param name="direction8Way"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.ToCardinal_Rot4(RimWorld.Direction8Way)">
            <summary>Converts Direction8Way to Rot4 - Chooses closest random cardinal if direction is not cardinal</summary>
            <param name="direction8Way"></param>
            <returns>The Rot4 equivalent of the given Direction8Way</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.Thing,System.Int32@,Verse.Map)">
            <summary>Gets all the valid cardinal cells for the given <paramref name="thing"/></summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>A list of all the cardinals in bounds of the <paramref name="map"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.Thing,Verse.Map,System.Int32@)">
            <summary>Gets all the valid cardinal cells for the given <paramref name="thing"/></summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>A list of all the cardinals in bounds of the <paramref name="map"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.IntVec3@,Verse.Map,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide <see cref="P:Verse.Map.Size"/> for better performance if this method is called multiple times for the same <paramref name="map"/></param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.IntVec3@,Verse.IntVec3@,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="mapSize">Provide for better performance if this method is called multiple times for the same <see cref="T:Verse.Map"/></param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the <see cref="T:Verse.Map"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.Thing,System.Int32@,Verse.Map)">
            <summary>Gets all the valid cardinal cells for the given <paramref name="thing"/>'s position</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>An array of the 4 cardinals from the given thing's position (or less if on map edge)</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.Thing,Verse.Map,System.Int32@)">
            <summary>Gets all the valid cardinal cells for the given thing</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>An array of the 4 cardinals from the given thing's position (or less if on map edge)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3@,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide Map.Size for better performance if this method is called multiple times for the same map</param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3@,Verse.Map,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide Map.Size for better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3@,Verse.IntVec3@,System.Int32@)">
            <summary>Get the direct cardinal neighbours of the given <paramref name="cell"/></summary>
            <param name="cell"></param>
            <param name="mapSize">For better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbourCells(Verse.Thing,System.Int32@,Verse.Map)">
            <summary></summary>
            <param name="t"></param>
            <param name="cardinalCount"></param>
            <param name="map">The map of <paramref name="t"/>, provide it here if it is already known</param>
            <returns>All the cells directly bordering the given thing, The size of the <see cref="T:Verse.Thing"/> is taken into account</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <remarks>Returned cells could be out of bounds!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbourCells(Verse.Thing)">
            <summary></summary>
            <param name="t"></param>
            <returns>All cells next to <paramref name="t"/> including corners, that are in bounds of the map
            <para>The size of <paramref name="t"/> is taken into account</para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCells(Verse.Thing)">
            <summary>Get all the cells that the given <see cref="T:Verse.Thing"/> occupies</summary>
            <param name="t"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbours(Verse.IntVec3@,Verse.Map)">
            <summary>Get all valid neighbouring cells of the given cell</summary>
            <param name="cell"></param><param name="map">used for Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbours(Verse.IntVec3@,Verse.IntVec3@)">
            <summary>Get all valid neighbouring cells of the given <paramref name="cell"/> that are in bounds of the map</summary>
            <param name="cell"></param><param name="mapSize">Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighboursArray(Verse.IntVec3@,Verse.IntVec3@)">
            <summary>Get all valid neighbouring cells of the given <paramref name="cell"/> including corners</summary>
            <param name="cell"></param><param name="mapSize">Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.North(Verse.IntVec3@)">
            <summary>Get the cell to the north of the given <paramref name="cell"/></summary>
            <param name="cell"></param><returns></returns>
            <remarks>Input and output cells are not validated in any way!
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.South(Verse.IntVec3@)">
            <summary>Get the cell to the south of the given <paramref name="cell"/></summary>
            <param name="cell"></param><returns></returns><remarks>Input and output cells are not validated in any way!
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.East(Verse.IntVec3@)">
            <summary>Get the cell to the east of the given <paramref name="cell"/></summary>
            <param name="cell"></param><returns></returns><remarks>Input and output cells are not validated in any way!
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.West(Verse.IntVec3@)">
            <summary>Get the cell to the west of the given <paramref name="cell"/></summary>
            <param name="cell"></param><returns></returns><remarks>Input and output cells are not validated in any way!
            <para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CloserAxisIsX(Verse.IntVec3@,Verse.IntVec3@)">
            <summary></summary>
            <param name="from"></param><param name="to"></param>
            <returns><see langword="true"/> if x axis is closer than y, <see langword="null"/> if equal</returns>
            <remarks><para><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Opposite(RimWorld.Direction8Way)">
            <summary>Get the opposite direction of the given direction</summary>
            <param name="direction8Way"></param>
            <returns>'<see cref="F:RimWorld.Direction8Way.North"/> -> <see cref="F:RimWorld.Direction8Way.South"/>' etc</returns>
            <remarks>Will return <see cref="F:RimWorld.Direction8Way.Invalid"/> if the input <paramref name="direction8Way"/> is <see cref="F:RimWorld.Direction8Way.Invalid"/><para><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RotateClockwise(RimWorld.Direction8Way)">
            <summary></summary>
            <param name="direction8Way"></param>
            <returns>The input rotation rotated, if input is '<see cref="F:RimWorld.Direction8Way.Invalid"/>' -> returns '<see cref="F:RimWorld.Direction8Way.Invalid"/>'</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RotateCounterClockwise(RimWorld.Direction8Way)">
            <summary></summary>
            <param name="direction8Way"></param>
            <returns>The input rotation rotated, if input is '<see cref="F:RimWorld.Direction8Way.Invalid"/>' -> returns '<see cref="F:RimWorld.Direction8Way.Invalid"/>'</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbourInDirection(Verse.IntVec3@,RimWorld.Direction8Way,System.Boolean,System.Nullable{System.Boolean})">
            <summary>Gets the cell in the specified direction from the current cell - The returned cell could be out of bounds!</summary>
            <param name="cell"></param><param name="direction"></param>
            <param name="onlyCardinals">Only return cardinals</param><param name="preferXOverZOrRandom">Cardinal preference</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RandomCellInRadiusWhere(Verse.IntVec3@,System.Single,System.Predicate{Verse.IntVec3})">
            <summary></summary>
            <param name="root"></param>
            <param name="radius"></param>
            <param name="predicate"></param>
            <returns>A random cell in the given <paramref name="radius"/> that satisfies the <paramref name="predicate"/>, or <see cref="F:Verse.IntVec3.Invalid"/> if none found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CanWanderTo(Verse.Pawn,Verse.IntVec3@,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="cell"></param>
            <param name="map"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> can wander to the given <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.SoilStability(Verse.Region,Verse.Map)">
            <summary>Gets the soil stability of a given <paramref name="region"/> (terrain affordance) 0f is 100% water, 1f is max soil stability</summary>
            <param name="region"></param><param name="map"></param>
            <returns>0f-1f as a <see cref="T:NQualityOfLife.Types.Ratio"/> of soil stability</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.LogParamExtensions">
            <summary>Methods used for easier debug log message creation, error logging and debugging</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.Diagnostics.Stopwatch)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.Int64)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.Int64)">
            <summary>Format the given <paramref name="timerTicks"/>(<see cref="T:System.Int64"/>) or <see cref="T:System.Diagnostics.Stopwatch"/> as time</summary>
            <param name="timerTicks"></param>
            <returns>A <see cref="T:System.String"/> formatted according to the scale of the time: 4s | 23ms | 2ms etc</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.Diagnostics.Stopwatch)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.DateTime@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.DateTime@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.FormatAsTime(System.DateTime@)">
            <summary>Formats the given date in the format: 'DD.MM.YYYY' or 'DD.MM.YYYY - Time'</summary>
            <param name="dateTime"></param>
            <returns>'DD.MM.YYYY' if <see cref="P:System.DateTime.TimeOfDay"/> is not specified || else 'DD.MM.YYYY - Time'</returns>
            <remarks>If you only ever want to display the calendar date, you can use: '<see cref="M:NQualityOfLife.Utils.Common.FormatDate(System.DateTime@)"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(RimWorld.TechLevel)">
            <summary></summary>
            <param name="techLevel"></param>
            <returns>The value translated</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``2(System.Nullable{System.ValueTuple{``0,``1}}@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``2(System.ValueTuple{``0,``1}@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``2(System.ValueTuple{``0,``1}@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Text.RegularExpressions.GroupCollection)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.RuntimeTypeHandle@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``2(System.Nullable{System.Collections.Generic.KeyValuePair{``0,``1}}@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``2(System.Collections.Generic.KeyValuePair{``0,``1}@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``2(System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Xml.XmlNode)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Xml.XmlAttribute)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Threading.Tasks.Task)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String)">
            <summary>Returns the input <see cref="T:System.String"/> if it is not <see langword="null"/> or empty || else returns a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty</seealso> symbol</summary>
            <returns>the input <see cref="T:System.String"/>, a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null symbol</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty symbol</seealso> - Never <see langword="null"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Char[])">
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String,System.String)">
            <summary>Returns <paramref name="s1"/> if it is not <see langword="null"/> or <seealso cref="F:System.String.Empty">empty</seealso>, else returns <paramref name="s2"/><seealso cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String)">.OrNull()</seealso></summary>
            <param name="s1">primary string</param><param name="s2">back up string</param>
            <returns>Never <see langword="null"/></returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Nullable{System.Char},System.Nullable{System.Char})">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Nullable{System.Char})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Nullable{System.Char})">
            <summary>Returns the input <see cref="T:System.Char"/> if it is not <see langword="null"/> or empty || else returns a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty</seealso> symbol</summary>
            <returns>the input <see cref="T:System.Char"/> as a <see cref="T:System.String"/>, a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol2">null symbol</seealso> or <seealso cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbol">empty symbol</seealso> - Never <see langword="null"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Char,System.Char)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Nullable{System.Char},System.Nullable{System.Char})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.Char)">
            <summary></summary>
            <param name="c"></param>
            <returns>The <see cref="T:System.Char"/> as a <see cref="T:System.String"/>
            <para>if the <see cref="T:System.Char"/> == '<see cref="F:NQualityOfLife.Utils.Common.Chars.EmptyChar"/>' returns '<see cref="F:NQualityOfLife.Utils.Common.Strings.EmptySymbolForceLowerCase"/>'</para></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(System.String,``0)">
            <summary>Never <see langword="null"/></summary>
            <typeparam name="T2"></typeparam>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns><paramref name="t1"/> if it is not <see langword="null"/> or empty, else <paramref name="t2"/>.<see cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)">OrNull</see>() - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0,System.Object)">
            <summary>Return is never <see langword="null"/></summary>
            <typeparam name="T1"></typeparam>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns>The input as a string if its not null else: t2.OrNull() - Never <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamArrayInternal``1(``0[],System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)">
            <summary>The generic 'OrNull' method || Never <see langword="null"/></summary>
            <typeparam name="T"></typeparam><param name="classOrStruct"></param>
            <returns>The input converted to a <see cref="T:System.String"/>, or a <seealso cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol">null symbol</seealso> <see cref="T:System.String"/> || Never <see langword="null"/></returns>
            <remarks><list type="table">
            <listheader>Examples:</listheader>
            <item><typeparamref name="T"/> is <see langword="null"/> -&gt; <see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/> -&gt; "null"</item>
            <item><typeparamref name="T"/> is <see cref="T:System.String"/> -&gt; <see cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String)"/></item>
            <item><typeparamref name="T"/> is <see cref="T:System.IFormattable"/> -&gt; <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/> using <see cref="F:NQualityOfLife.Utils.StringExtensions.InvariantCulture"/></item>
            <item>...</item>
            <item>Else -&gt; <see cref="M:System.Object.ToString"/> -&gt; <see cref="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String)"/></item>
            </list></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AndDataDump``1(``0,NQualityOfLife.Utils.Log.LogMode)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.DataDump``1(``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.DataDump``1(``0)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="instance"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.Details(System.Type)">
            <summary></summary>
            <param name="type"></param>
            <returns>A <see cref="T:System.String"/> with all the detailed information about the given <see cref="T:System.Type"/></returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="type" /> is <see langword="null"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.Details(Verse.FloatMenuOption)">
            <summary>Get a detailed info <see cref="T:System.String"/> for the <paramref name="floatMenuOption"/></summary>
            <param name="floatMenuOption"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.Details(System.Char)">
            <summary></summary>
            <param name="character"></param>
            <returns>A <see cref="T:System.String"/> with all the detailed information about the given <see cref="T:System.Char"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam(System.String,System.String)">
            <summary>Format the string in a method parameter format, intended to be used in log messages</summary><param name="str"></param><param name="paramName"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam(System.Object,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamInternal``1(``0,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam(System.Object,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamInternal``1(``0,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(``0,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamInternal``1(``0,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamInternal``1(``0,System.String,System.String)">
            <summary>Generic method for formatting objects for log messages</summary>
            <typeparam name="T"></typeparam>
            <param name="t">The instance of '<typeparamref name="T"/>'</param>
            <param name="typeName">The name of the type '<typeparamref name="T"/>'</param>
            <param name="paramName">The name of the parameter that '<paramref name="t"/>' was passed to</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(``0[],System.String)">
            <summary>Format '<typeparamref name="T"/>' array AsParam</summary>
            <typeparam name="T">The type of the array</typeparam>
            <param name="array">The array</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <returns>The input array formatted as a param.</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamArrayInternal``1(``0[],System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.IReadOnlyList{``0},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIReadOnlyListInternal``1(System.Collections.Generic.IReadOnlyList{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.List{``0},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamListInternal``1(System.Collections.Generic.List{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.IList{``0},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIListInternal``1(System.Collections.Generic.IList{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(NQualityOfLife.Types.IListInterface{``0},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIListInterfaceInternal``1(NQualityOfLife.Types.IListInterface{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(NQualityOfLife.Types.OrderedList{``0},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamOrderedListInternal``1(NQualityOfLife.Types.OrderedList{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(NQualityOfLife.Types.UnOrderedList{``0},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamUnOrderedListInternal``1(NQualityOfLife.Types.UnOrderedList{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.ICollection{``0},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamICollectionInternal``1(System.Collections.Generic.ICollection{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIEnumerableInternal``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam(System.Collections.Generic.IEnumerable{System.IO.FileInfo},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIEnumerableInternal``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam(System.Collections.Generic.List{System.String},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamListInternal``1(System.Collections.Generic.List{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIEnumerableInternal``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIEnumerableInternal``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>Format '<see cref="T:System.Collections.Generic.IEnumerable`1"/>' AsParam</summary>
            <typeparam name="T"></typeparam>
            <param name="iEnumerable"></param>
            <param name="typeName">Name of the type '<typeparamref name="T"/>'</param>
            <param name="paramName"></param>
            <returns></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.EagerAttribute">Eager</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamListInternal``1(System.Collections.Generic.List{``0},System.String,System.String,System.String)">
            <summary>Format '<see cref="T:System.Collections.Generic.List`1"/>' AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="typeName">The type of <typeparamref name="T"/> if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamArrayInternal``1(``0[],System.String,System.String)">
            <summary>Format the '<typeparamref name="T"/>[]' <paramref name="array"/> AsParam</summary>
            <typeparam name="T">The name of the type of the array</typeparam>
            <param name="array">The array '<typeparamref name="T"/>[]'</param>
            <param name="typeName">The name of the type '<typeparamref name="T"/>' if <see langword="null"/> it will be auto resolved</param>
            <param name="paramName">The custom name of the param, such as 'targets'
            <para>can be left <see langword="null"/></para></param>
            <returns>The input <paramref name="array"/> formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIListInterfaceInternal``1(NQualityOfLife.Types.IListInterface{``0},System.String,System.String,System.String)">
            <summary>Format '<see cref="T:NQualityOfLife.Types.IListInterface`1"/>' AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="typeName">The name of the type '<typeparamref name="T"/>' if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamOrderedListInternal``1(NQualityOfLife.Types.OrderedList{``0},System.String,System.String,System.String)">
            <summary>Format '<see cref="T:NQualityOfLife.Types.OrderedList`1"/>' AsParam</summary>
            <typeparam name="T">The type of the <paramref name="list"/></typeparam>
            <param name="list">The list</param>
            <param name="typeName">The name of the type '<typeparamref name="T"/>' if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input <paramref name="list"/> formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamUnOrderedListInternal``1(NQualityOfLife.Types.UnOrderedList{``0},System.String,System.String,System.String)">
            <summary>Format '<see cref="T:NQualityOfLife.Types.UnOrderedList`1"/>' AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="typeName">The name of the type '<typeparamref name="T"/>' if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamICollectionInternal``1(System.Collections.Generic.ICollection{``0},System.String,System.String,System.String)">
            <summary>Format '<see cref="T:System.Collections.Generic.ICollection`1"/>' AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="typeName">The name of the type '<typeparamref name="T"/>' if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIListInternal``1(System.Collections.Generic.IList{``0},System.String,System.String,System.String)">
            <summary>Format '<see cref="T:System.Collections.Generic.IList`1"/>' AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="typeName">The name of the type '<typeparamref name="T"/>' if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'
            <para>can be left <see langword="null"/></para></param>
            <param name="listType"></param>
            <returns>The input <paramref name="list"/> formatted as a param</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIListInternal(System.Collections.IList,System.String,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIListInternal``1(System.Collections.Generic.IList{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIListInternal(System.Collections.IList,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIListInternal``1(System.Collections.Generic.IList{``0},System.String,System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParamIReadOnlyListInternal``1(System.Collections.Generic.IReadOnlyList{``0},System.String,System.String,System.String)">
            <summary>Format '<see cref="T:System.Collections.Generic.IReadOnlyList`1"/>' AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="typeName">The name of the type '<typeparamref name="T"/>' if <see langword="null"/> it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left <see langword="null"/>.</param>
            <param name="listType"></param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.EventExtensions">
            <summary>Extension methods for unity events and utilities for different input keys and events</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Undo(UnityEngine.Event)">
            <summary>Returns true if the user is pressing control z, and consumes the event - Does not consume non undo events</summary>
            <param name="event">The event is consumed if it is an undo event</param>
            <returns>True if pressing control + Z, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ReDo(UnityEngine.Event)">
            <summary>Returns true if the user is pressing control y, and consumes the event - Does not consume non redo events</summary>
            <param name="event">The event is consumed if it is a redo event</param>
            <returns>True if pressing control + Y, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Escape(UnityEngine.Event)">
            <summary></summary>
            <param name="event"></param>
            <returns>True if escape is pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlAlt(UnityEngine.Event)">
            <summary></summary>
            <param name="event"></param>
            <returns><see langword="true"/> if control and alt are pressed at the same time or the 'ALT GR' button is pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.MiddleClickPress(UnityEngine.Event)">
            <summary></summary>
            <param name="event"></param>
            <returns><see langword="true"/> if the given <paramref name="event"/> is a <see cref="F:UnityEngine.EventType.MouseDown"/> with the scroll wheel / middle mouse button</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftAltOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Shift and Alt pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlAltOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Control and Alt pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if control and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShiftOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Control and Shift pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if control and shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Shift pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Control pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if control pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.AltOnly(NQualityOfLife.Types.KeyCombination)">
            <summary>Alt pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftAlt(NQualityOfLife.Types.KeyCombination)">
            <summary>Shift and Alt pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShiftAlt(NQualityOfLife.Types.KeyCombination)">
            <summary>Control, Shift and Alt pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if control, shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlAlt(NQualityOfLife.Types.KeyCombination)">
            <summary>Control and Alt pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if control and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShift(NQualityOfLife.Types.KeyCombination)">
            <summary>Control and Shift pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if control and shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Shift(NQualityOfLife.Types.KeyCombination)">
            <summary>Shift pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Control(NQualityOfLife.Types.KeyCombination)">
            <summary>Control pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if control pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Alt(NQualityOfLife.Types.KeyCombination)">
            <summary>Alt pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.None(NQualityOfLife.Types.KeyCombination)">
            <summary>No modifier keys pressed?</summary><param name="keyCombination"></param><returns><see langword="true"/> if none of the modifier keys are pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ModifierKeys(UnityEngine.Event)">
            <summary>Get the held modifier keys (shift, control, alt)</summary>
            <param name="event"></param>
            <returns>The key combination of the held modifier keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ModifierKeys(UnityEngine.Event,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>Get the held modifier keys (shift, control, alt)</summary>
            <param name="event"></param>
            <param name="control"></param>
            <param name="alt"></param>
            <param name="shift"></param>
            <returns>The key combination of the held modifier keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollUp(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll up event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (positive float)</param>
            <returns>True if event is scroll up</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollWheel(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (positive float for up, negative for down)</param>
            <returns>True if event is scroll up or down</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollDown(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll down event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (negative float)</param>
            <returns>True if event is scroll down</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.AnyMouseButtonPress(UnityEngine.Event)">
            <summary></summary><param name="ev"></param>
            <returns>><see langword="true"/> if any of the 3 main mouse buttons are clicked (L, R, M)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.LeftClickPress(UnityEngine.Event)">
            <summary></summary><param name="event"></param>
            <returns><see langword="true"/> when left click is pressed</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.PawnExtensions">
            <summary>Pawn extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.SafeTemperatureRange(Verse.Pawn)">
            <inheritdoc cref="M:NQualityOfLife.Utils.PawnExtensions.SafeTemperatureRangeForPawn(Verse.Pawn)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.SafeTemperatureRangeForPawn(Verse.Pawn)">
            <summary>Get the safe temperature range for the <paramref name="pawn"/></summary>
            <param name="pawn"></param>
            <returns>the minimum and maximum safe temperatures for the <paramref name="pawn"/> in <see cref="T:NQualityOfLife.Units.Celsius"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetFactionlessLord(Verse.Pawn,Verse.Map)">
            <summary>Returns the factionless <see cref="T:Verse.AI.Group.Lord"/> of the given factionless <paramref name="pawn"/> || or <see langword="null"/> if the <paramref name="pawn"/> is not a member of any lord <see cref="T:Verse.AI.Group.Lord"/> or the <see cref="T:Verse.AI.Group.Lord"/> has a <see cref="T:RimWorld.Faction"/></summary>
            <param name="pawn"></param><param name="map"></param><exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
            <returns>The <see cref="T:Verse.AI.Group.Lord"/> of the <paramref name="pawn"/> if the <see cref="T:RimWorld.Faction"/> of the <see cref="T:Verse.AI.Group.Lord"/> is <see langword="null"/> and the <paramref name="pawn"/> <see cref="T:RimWorld.Faction"/> is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetLord(Verse.Pawn,Verse.Map,System.Predicate{Verse.AI.Group.Lord})">
            <summary></summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <param name="predicate"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetLord(Verse.Pawn)">
            <inheritdoc cref="M:NQualityOfLife.Utils.PawnExtensions.GetLord(Verse.Pawn,Verse.Map)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetLord(Verse.Pawn,Verse.Map)">
            <summary>Find the <see cref="T:Verse.AI.Group.Lord"/> that the <paramref name="pawn"/> is controlled by on the given <paramref name="map"/>, or <see langword="null"/> if the <paramref name="pawn"/> is not in any <see cref="T:Verse.AI.Group.Lord"/> of the <paramref name="map"/></summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
            <returns>the <see cref="T:Verse.AI.Group.Lord"/> that the <paramref name="pawn"/> is controlled by on the given <paramref name="map"/>, or <see langword="null"/> if the <paramref name="pawn"/> is not in any <see cref="T:Verse.AI.Group.Lord"/> of the <paramref name="map"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetLordOnMap(Verse.Pawn,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetLordOf(Verse.AI.Group.LordManager,Verse.Pawn)">
            <summary></summary>
            <param name="lordManager"></param>
            <param name="pawn"></param><exception cref="T:System.ArgumentNullException"><paramref name="lordManager"/> or <paramref name="pawn"/> is <see langword="null"/></exception>
            <returns>The <see cref="T:Verse.AI.Group.Lord"/> that the given <paramref name="pawn"/> is a member of || <see langword="null"/> if the <paramref name="pawn"/> is not a member of any of the lords in the given <paramref name="lordManager"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetLord_Internal(Verse.Pawn,System.Collections.Generic.List{Verse.AI.Group.Lord},System.Int32)">
            <summary>Find the <see cref="T:Verse.AI.Group.Lord"/> that contains the <paramref name="pawn"/></summary>
            <param name="pawn"></param>
            <param name="lords"></param>
            <param name="lordsCount"></param>
            <returns>the <see cref="T:Verse.AI.Group.Lord"/> that contains the <paramref name="pawn"/> or <see langword="null"/> if none of the <paramref name="lords"/> contain the <paramref name="pawn"/></returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetFactionLord(Verse.Pawn,RimWorld.Faction,Verse.Map)">
            <summary>Returns the <see cref="T:Verse.AI.Group.Lord"/> of the given <paramref name="pawn"/> if the <paramref name="faction"/> of the <see cref="T:Verse.AI.Group.Lord"/> matches || or <see langword="null"/> if no <see cref="T:Verse.AI.Group.Lord"/> or the <see cref="T:Verse.AI.Group.Lord"/> has a different or <see langword="null"/> <see cref="T:RimWorld.Faction"/></summary>
            <param name="pawn"></param><param name="faction"></param><param name="map"></param>
            <returns>The <see cref="T:Verse.AI.Group.Lord"/> of the <paramref name="pawn"/> if the <see cref="T:RimWorld.Faction"/> of the <see cref="T:Verse.AI.Group.Lord"/> is the same as the provided <paramref name="faction"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> or <paramref name="faction"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetLord_Internal_Faction(Verse.Pawn,System.Collections.Generic.List{Verse.AI.Group.Lord},RimWorld.Faction,System.Int32)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="lords"></param>
            <param name="faction"></param>
            <param name="lordsCount"></param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetOrAddHediffIf(Verse.Pawn_HealthTracker,Verse.HediffDef,Verse.Hediff@,Verse.HediffDef,System.Boolean)">
            <summary>Add or get the <paramref name="hediffDefToAddOrGet"/> to/from the <see cref="T:Verse.Pawn"/> if they do not have the '<paramref name="ifDoesNotHave"/>' <see cref="T:Verse.HediffDef"/></summary>
            <param name="healthTracker"></param>
            <param name="hediffDefToAddOrGet">Add or get this <see cref="T:Verse.Hediff"/></param>
            <param name="hediffBlack"></param>
            <param name="ifDoesNotHave">Do not add <paramref name="hediffDefToAddOrGet"/> if the <see cref="T:Verse.Pawn"/> has this hediff || remove <paramref name="hediffDefToAddOrGet"/> if the <see cref="T:Verse.Pawn"/> has both and <paramref name="removeIfHasBoth"/> is <see langword="true"/></param>
            <param name="removeIfHasBoth">Remove the <paramref name="hediffDefToAddOrGet"/> from the <see cref="T:Verse.Pawn"/> if it exists and they also have the '<paramref name="ifDoesNotHave"/>' <see cref="T:Verse.HediffDef"/></param>
            <returns>The existing or added <see cref="T:Verse.Hediff"/> or <see langword="null"/> if it did not exist and was not added or was removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast``1(Verse.HediffSet,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast``1(System.Collections.Generic.List{Verse.Hediff},System.Boolean)"/>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast``1(System.Collections.Generic.List{Verse.Hediff},System.Boolean)">
            <summary></summary>
            <typeparam name="THediff"></typeparam>
            <param name="hediffs"></param>
            <param name="mustBeVisible"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast(Verse.HediffSet,Verse.HediffDef,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast(System.Collections.Generic.List{Verse.Hediff},Verse.HediffDef,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetHediff_Fast(System.Collections.Generic.List{Verse.Hediff},Verse.HediffDef,System.Boolean)">
            <summary></summary>
            <param name="hediffs"></param>
            <param name="def"></param>
            <param name="mustBeVisible"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Starving(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param><exception cref="T:System.ArgumentNullException"></exception>
            <returns><see langword="true"/> if the given <paramref name="pawn"/> has a food need and the food need level is &lt;= 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.FlagsAreSet(NQualityOfLife.Utils.PawnExtensions.Capabilities,NQualityOfLife.Utils.PawnExtensions.Capabilities)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.AnyFlagIsSet(NQualityOfLife.Utils.PawnExtensions.Capabilities,NQualityOfLife.Utils.PawnExtensions.Capabilities)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.DraftIfCan(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> was drafted or was already drafted</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasAWeapon(Verse.Pawn)">
            <summary>Is this <paramref name="pawn"/> equipped with a weapon?</summary>
            <param name="pawn">this pawn</param>
            <returns><see langword="true"/> if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.CapableOfViolence(Verse.Pawn)">
            <summary>Is <see langword="this"/> <paramref name="pawn"/> capable of violence?</summary>
            <param name="pawn">this <see cref="T:Verse.Pawn"/></param>
            <returns><see langword="true"/> if yes</returns><exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.CanReach_Fast(Verse.Pawn,Verse.IntVec3,Verse.AI.PathEndMode,Verse.Danger,Verse.Map,System.Boolean)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="cell"></param>
            <param name="pathEndMode"></param>
            <param name="maxDanger"></param>
            <param name="map"></param>
            <param name="ignoreAllowedAreas"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> can reach the target <paramref name="cell"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsNightOwl(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> has the NightOwl trait</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsBrawler(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> has the brawler trait</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasTrait(Verse.Pawn,RimWorld.TraitDef)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="trait"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> has the specified <paramref name="trait"/> - returns <see langword="false"/> if the <paramref name="trait"/> is <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPregnant(Verse.Pawn)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPregnant(Verse.Pawn,Verse.Hediff@)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <param name="pregnancyHediff"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Pregnancy(Verse.Pawn)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsHomeOwner(Verse.Pawn)">
            <summary>Check if the pawn is currently a home owner</summary>
            <param name="pawn">The pawn to check</param>
            <returns>bool, true if is home owner</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Home(Verse.Pawn)">
            <summary>Get the home of this pawn</summary>
            <param name="pawn">Get home of this pawn</param>
            <returns>bool = true if found the home. and the Home or (false, null)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsRelatedToAnyHomeOwner(Verse.Pawn)">
            <summary>Is this pawn related to any home owner</summary>
            <param name="pawn">Is this pawn related to any home owner</param>
            <returns>true if is related</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsOccupantOf(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is this pawn an occupant of the given home</summary>
            <param name="pawn">Is this pawn an occupant of the given home</param>
            <param name="home">The home to check</param>
            <returns>true if is an occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsLoverOfAnyOccupant(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home,System.Boolean)">
            <summary>Is this pawn a lover of any occupant in the given home</summary>
            <param name="pawn">Is this pawn a lover of any occupant in the given home</param>
            <param name="home">The home to check</param>
            <param name="forceUpdateCache">Update cache</param>
            <returns>true if is lover of any occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPetOfFamily(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is this pawn a bonded animal of a family member</summary>
            <param name="pawn">Is this pawn a bonded animal of a family member</param>
            <param name="home">The home to check</param>
            <returns>true if is pet of any occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.MyLoverHasAHome(Verse.Pawn)">
            <summary>Is my lover a home owner or living in a home</summary>
            <param name="pawn">Me</param>
            <returns>true if lover has home</returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsRelatedTo(Verse.Pawn,Verse.Pawn)">
            <summary>Check if this pawn is blood related to other pawn</summary>
            <param name="thisPawn">Is this pawn related to otherPawn</param>
            <param name="otherPawn">The pawn to check</param>
            <returns><see langword="true"/> if is blood related</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasLoveRelationWith(Verse.Pawn,Verse.Pawn)">
            <summary>Is the given pawn my lover</summary>
            <param name="pawn">Me</param>
            <param name="lover">Is this pawn my lover</param>
            <returns><see langword="true"/> if the given pawn is lover of this pawn</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasALoverOnMap(Verse.Pawn,Verse.Pawn@,System.Boolean,Verse.Map)">
            <summary>Is my lover on the same map as me</summary>
            <param name="pawn">Is my lover on the same map as me</param>
            <param name="lover">The lover that was found, if method returns false => null</param>
            <param name="sortByCommitment">Sort the list of lovers if exists and more than 1</param>
            <param name="map">This map, or my map if null</param>
            <returns>true if lover is on map</returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.SortByCommitment(System.Collections.Generic.List{RimWorld.DirectPawnRelation},Verse.Pawn)">
            <summary>This is / should be the same as the sort logic in: <see cref="M:RimWorld.SpouseRelationUtility.GetLoveRelations(Verse.Pawn,System.Boolean,System.Boolean)"/></summary>
            <param name="loveRelations"></param>
            <param name="pawn"></param>
        </member>
        <member name="T:NQualityOfLife.Utils.ListExtensions">
            <summary>Extension methods for different kinds of lists and collections</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Sort``1(System.Collections.Generic.IList{``0})">
            <summary>Sort the <paramref name="comparables"/> into ascending order using the <see cref="T:System.IComparable`1"/> implementation</summary>
            <typeparam name="TC"></typeparam>
            <param name="comparables"></param>
            <returns>The input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.DataEquals``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Check if two collections have equal data</summary>
            <typeparam name="T"></typeparam>
            <param name="values1"></param>
            <param name="values2"></param>
            <param name="specificComparer">leave as <see langword="default"/> to use '<see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>'</param>
            <returns><see langword="true"/> if any: <list type="bullet">
            <item><paramref name="values1"/> is the same <see cref="T:System.Object"/> (reference) as <paramref name="values2"/></item>
            <item>Both are <see langword="null"/></item>
            <item>Both are empty</item>
            <item>The lists are the same size and all the elements in them are the same and in the same order (Equality is compared with <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>) by <see langword="default"/></item>
            </list></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Split``1(System.Collections.Generic.IList{``0},System.Collections.Generic.List{``0}@,System.Collections.Generic.List{``0}@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="evens"></param>
            <param name="odds"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="iList"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.PrependAsNew``1(System.Collections.Generic.IList{``0},``0@)">
            <inheritdoc cref="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Min``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Int32})">
            <summary>Get the smallest '<see cref="T:System.Int32"/>' from a list of '<typeparamref name="T"/>' where the <paramref name="selector"/> is used to get the '<see cref="T:System.Int32"/>' from a '<typeparamref name="T"/>' to compare</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="selector">Used to select an '<see cref="T:System.Int32"/>' from a '<typeparamref name="T"/>'</param>
            <returns>The smallest found '<see cref="T:System.Int32"/>' or '<see cref="F:System.Int32.MaxValue"/>' if <paramref name="values"/> is empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Max``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Int32})">
            <summary>Get the largest '<see cref="T:System.Int32"/>' from a list of '<typeparamref name="T"/>' where the <paramref name="selector"/> is used to get the '<see cref="T:System.Int32"/>' from a '<typeparamref name="T"/>' to compare</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="selector">Used to select an '<see cref="T:System.Int32"/>' from a '<typeparamref name="T"/>'</param>
            <returns>The largest found '<see cref="T:System.Int32"/>' or '<see cref="F:System.Int32.MinValue"/>' if <paramref name="values"/> is empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Cast``1(System.Collections.IEnumerable)">
            <inheritdoc cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Perform an <see cref="T:System.Action`1"/> for each element in the <paramref name="values"/></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="func">An <see cref="T:System.Action`1"/> that is called for each item '<typeparamref name="T"/>' in <paramref name="values"/></param>
            <returns>The input <paramref name="values"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> or <paramref name="func"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ForEach``2(``0,System.Func{``1,``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ForEach``1(System.Collections.Generic.IList{``0},System.Func{``0,``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ForEach``1(System.Collections.Generic.IList{``0},System.Func{``0,``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>Get the total value (sum) from the input <paramref name="values"/> using the given <paramref name="valueGetter"/></summary>
            <typeparam name="T"></typeparam>
            <param name="values">Get the sum from these '<typeparamref name="T"/>' values</param>
            <param name="valueGetter">Extracts the value from the <typeparamref name="T"/></param>
            <returns>The total summed value (<see cref="T:System.Single"/>) from all the items '<typeparamref name="T"/>'</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueGetter"/> or <paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OrderBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OrderByDescending``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Reverse``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Reverse``1(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Reverse``1(System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Reverse``1(``0[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Reverse``1(System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Reverse``1(System.Collections.Generic.IList{``0})">
            <summary>Reverse the order of the <paramref name="iList"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iList">The <see cref="T:System.Collections.IList"/> to reverse the order of</param>
            <returns>The <paramref name="iList"/> mutated</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="iList"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">The <paramref name="iList"/> is <see cref="P:System.Collections.IList.IsReadOnly"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OfType``1(System.Collections.IEnumerable)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <returns><see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> of all the items in <paramref name="values"/> that are of the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OfType``2(System.Collections.Generic.IEnumerable{``1})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TB"></typeparam>
            <param name="values"></param>
            <returns><see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> of all the items in the input list of <typeparamref name="TB"/> that are of the type <typeparamref name="T"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CopyTo(System.Array,System.Array,System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/>
            <summary></summary>
            <param name="sourceArray"></param>
            <param name="destinationArray"></param>
            <param name="sourceIndex"></param>
            <param name="length"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Copy``1(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Count how many items in the <paramref name="iList"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountAllWhere``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.List{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary>Count how many items in the <paramref name="list"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(``0[],System.Predicate{``0})">
            <summary>Count how many items in the <paramref name="array"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountAllWhere``1(System.Collections.Generic.IReadOnlyList{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IReadOnlyList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IReadOnlyList{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Get the count of items in the collection, tries to use the best count method or property available for the input type</summary>
            <typeparam name="T"></typeparam><param name="list"></param><returns>How many items are in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>/<see cref="T:System.Collections.Generic.ICollection`1"/>/<see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountAllWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Count how many items in the list match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Count how many items in the <paramref name="list"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The count of items that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(``0[],System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount. || -1 on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the <paramref name="maxCount"/> or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Matching element count or <paramref name="maxCount"/> if more matching elements than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount. || -1 on error</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill_Internal``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0},System.Int32)">
            <summary>Counts matching items until the <paramref name="maxCount"/> or the end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting || must be greater than 0</param>
            <param name="predicate"></param>
            <param name="knownSize">The total size of the list</param>
            <returns>Matching element count or <paramref name="maxCount"/> if more matching elements than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.List{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the <paramref name="maxCount"/> or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or <paramref name="maxCount"/> if more elements than <paramref name="maxCount"/>. || -1 on error</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAllWhereLazy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <remarks><seealso cref="T:NQualityOfLife.Attributes.LazyAttribute">Lazy</seealso></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FindAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Where``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with all the members from the input <paramref name="list"/> that matched the <paramref name="predicate"/></returns>
            <remarks><seealso cref="T:NQualityOfLife.Attributes.EagerAttribute">Eager</seealso>
            <para><seealso cref="T:NQualityOfLife.Attributes.ThreadUnsafeAttribute">ThreadUnsafe</seealso></para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.WhereSafe``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Collections.Generic.List{System.ValueTuple{``0,System.Exception}}@)">
            <summary>Try to use the <paramref name="predicate"/> on the items of the <paramref name="list"/>, and return all that passed and did not <see langword="throw"/> an <see cref="T:System.Exception"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list">The list of items to filter using the <paramref name="predicate"/></param>
            <param name="predicate">Try to filter the items of the <paramref name="list"/> using this <see cref="T:System.Predicate`1"/></param>
            <param name="exceptions">a <see cref="T:System.Collections.Generic.List`1"/> of the items '<typeparamref name="T"/>' and the <see cref="T:System.Exception"/>s that they threw</param>
            <returns>Items '<typeparamref name="T"/>' matching the <paramref name="predicate"/> that did not <see langword="throw"/> an <see cref="T:System.Exception"/></returns>
            <remarks>The items of the <paramref name="list"/> that encountered an <see cref="T:System.Exception"/> with the <paramref name="predicate"/> are given in <paramref name="exceptions"/> along with the actual <see cref="T:System.Exception"/> that was thrown
            <para><seealso cref="T:NQualityOfLife.Attributes.EagerAttribute">Eager</seealso></para></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Where``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.WhereLazy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Lazily filter the input elements</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns></returns>
            <remarks><seealso cref="T:NQualityOfLife.Attributes.LazyAttribute">Lazy</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAllWhere_ToArray``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="toArray"></param>
            <param name="predicate"></param>
            <returns>A <see langword="new"/> array with all the members from the input list that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToReadOnlyListWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Types.IReadOnlyListInterface`1"/> from the <paramref name="values"/> that match the <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="predicate"></param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.IReadOnlyListInterface`1"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Select``3(System.Collections.Generic.IList{``0},System.Converter{``0,``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IList{``0},System.Converter{``0,``1})">
            <summary>Transform the values (<typeparamref name="T"/>) in the input <paramref name="list"/> from '<typeparamref name="T"/>' to '<typeparamref name="TNew"/>' using the given <paramref name="func"/>(<typeparamref name="T"/> => <typeparamref name="TNew"/>)</summary>
            <typeparam name="T">Input <paramref name="list"/> contained type '<typeparamref name="T"/>'</typeparam>
            <typeparam name="TNew">Output list contained type '<typeparamref name="TNew"/>'</typeparam>
            <typeparam name="TNListOut">The <see cref="T:System.Type"/> of the returned <see cref="T:System.Collections.ICollection"/> '<typeparamref name="TNListOut"/>' that contains the transformed '<typeparamref name="TNew"/>' values</typeparam>
            <param name="list"></param>
            <param name="func">The <see cref="T:System.Func`2"/> used to transform the input '<typeparamref name="T"/>' values to '<typeparamref name="TNew"/>'</param>
            <returns>A <see langword="new"/> '<typeparamref name="TNListOut"/>' with the values that the <paramref name="func"/> transformed from the input <paramref name="list"/></returns>
            <exception cref="T:System.NotSupportedException">The '<typeparamref name="TNListOut"/>' <see cref="T:System.Type"/> does not support <see cref="M:System.Collections.Generic.ICollection`1.Add(`0)"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="func"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Select``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.TransformLazy``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.TransformLazy``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
            <returns><see cref="T:System.Collections.IEnumerable"/> <typeparamref name="TNew"/> with the values that the <paramref name="func"/> transformed from the input <paramref name="list"/></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``3(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})">
            <summary>Transform the input <paramref name="list"/> from a list of '<typeparamref name="T"/>' to a list of '<typeparamref name="TNew"/>' using the given <paramref name="func"/></summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the values in the input <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> of the values in the <paramref name="list"/> after the transform</typeparam>
            <param name="list"></param>
            <param name="func">The <see cref="T:System.Func`2"/> used to transform the input '<typeparamref name="T"/>' values to '<typeparamref name="TNew"/>'</param>
            <returns>a <see langword="new"/> <see cref="T:NQualityOfLife.Types.OrderedList`1"/> containing all the transformed '<typeparamref name="TNew"/>' values</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="func"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,System.ValueTuple{``1,``1}})">
            <summary>Split one '<typeparamref name="T"/>' into 2 instances of '<typeparamref name="TNew"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,System.ValueTuple{``1,``1,``1}})">
            <summary>Split one '<typeparamref name="T"/>' into 3 instances of '<typeparamref name="TNew"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,System.ValueTuple{``1,``1,``1,``1}})">
            <summary>Split one '<typeparamref name="T"/>' into 4 instances of '<typeparamref name="TNew"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,System.ValueTuple{``1,``1,``1,``1,``1}})">
            <summary>Split one '<typeparamref name="T"/>' into 5 instances of '<typeparamref name="TNew"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,System.ValueTuple{``1,``1,``1,``1,``1,``1}})">
            <summary>Split one '<typeparamref name="T"/>' into 6 instances of '<typeparamref name="TNew"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,System.ValueTuple{``1,``1,``1,``1,``1,``1,``1}})">
            <summary>Split one '<typeparamref name="T"/>' into 7 instances of '<typeparamref name="TNew"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,System.ValueTuple{``1,``1,``1,``1,``1,``1,``1,System.ValueTuple{``1}}})">
            <summary>Split one '<typeparamref name="T"/>' into 8 instances of '<typeparamref name="TNew"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,System.ValueTuple{``1,``1,``1,``1,``1,``1,``1,System.ValueTuple{``1,``1}}})">
            <summary>Split one '<typeparamref name="T"/>' into 9 instances of '<typeparamref name="TNew"/>'</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1[]})">
            <summary>Split one '<typeparamref name="T"/>' into some amount of instances of '<typeparamref name="TNew"/>' returned from the <paramref name="func"/> as an array</summary>
            <typeparam name="T">The <see cref="T:System.Type"/> of the items '<typeparamref name="T"/>' in the <paramref name="list"/></typeparam>
            <typeparam name="TNew">The <see cref="T:System.Type"/> '<typeparamref name="TNew"/>' returned by the <paramref name="func"/></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Transform``2(System.Collections.Generic.IList{``0},System.Converter{``0,``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.EvensToList``1(System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="iList"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.OddsToList``1(System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="iList"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})">
            <summary>Makes a <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</seealso> of the given <paramref name="list"/></summary>
            <typeparam name="T"></typeparam><param name="list">The list to copy</param>
            <returns>A <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">(shallow) copy</seealso> of the original <paramref name="list"/> as a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the same items in the same order || Never <see langword="null"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>Makes a <seealso href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#shallow-copy">shallow copy</seealso> of the <paramref name="list"/> starting at the given index</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="startingFrom">Start at this index inside the input <paramref name="list"/>
            <para>Must be &gt;= 0</para></param>
            <param name="count">How many items to copy from the input <paramref name="list"/>
            <para>Must be &gt;= 1</para></param>
            <returns>A <see langword="new"/> list with the elements from the input <paramref name="list"/> starting at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.IList{``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TL"></typeparam>
            <param name="iList"></param>
            <returns>A <see langword="new"/> list of type <typeparamref name="TL"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.List{``1})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.IList{``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.IList{``1})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TL"></typeparam>
            <param name="iList"></param>
            <returns>A <see langword="new"/> list of type <typeparamref name="TL"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(``0)">
            <summary>Create a <see langword="new"/> instance of '<typeparamref name="TL"/>' and populate it with the items '<typeparamref name="T"/>' from the source <paramref name="listT"/></summary>
            <typeparam name="TL"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="listT"></param>
            <returns>The <see langword="new"/> <typeparamref name="TL"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(``0[])">
            <summary>Makes a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the <paramref name="array"/></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the same items in the same order as the source <paramref name="array"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> of all the items (<typeparamref name="T"/>) in the input <paramref name="list"/> that match the given <paramref name="predicate"/>(<typeparamref name="T"/>)</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param><exception cref="T:System.ArgumentNullException"></exception>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with all the members (<typeparamref name="T"/>) from the input <paramref name="list"/> (<typeparamref name="T"/>) that matched the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with all the members from the input list that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with all the members from the input <paramref name="list"/> that matched the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="where"></param>
            <returns>The matching input elements to a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="iList"/> or <paramref name="where"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the predicate || The <see cref="T:System.Int32"/> in the predicate is the index of the item</summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="where">Func&lt;<typeparamref name="T"/> item, <see cref="T:System.Int32"/> index, <see cref="T:System.Boolean"/> mathes&gt;</param>
            <returns>The matching input elements to a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns the <paramref name="values"/> as a <see cref="T:System.Collections.Generic.List`1"/>.  
            If <paramref name="values"/> is already a <see cref="T:System.Collections.Generic.List`1"/>, no new allocation occurs;  
            otherwise, a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> containing the values is returned.</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <returns>The <paramref name="values"/> <see langword="as"/> a <see langword="ref"/> <see cref="T:System.Collections.Generic.List`1"/> or a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the <paramref name="values"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="count">the count of elements</param>
            <returns>The input elements to a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.EagerAttribute">Eager</see></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Make a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> from the given collection where the items satisfy the <see cref="T:System.Predicate`1"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where"></param>
            <returns>The matching input elements to a <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="where"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.Dictionary{``0,``1}.KeyCollection,System.Int32@)">
            <summary>Copies all the keys to a <see langword="new"/> list</summary>
            <typeparam name="K">Keys</typeparam>
            <typeparam name="V">Values</typeparam>
            <param name="keyCollection"></param>
            <param name="count"></param>
            <returns>A <see langword="new"/> list of the keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Check if the collection is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="iEnumerable"></param>
            <returns><see langword="true"/> if the collection is <see langword="null"/> or has no items</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(``0[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(``0[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(``0[])">
            <summary>Check if the <paramref name="array"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="array"></param>
            <returns><see langword="true"/> if the <paramref name="array"/> is <see langword="null"/> or has a <see cref="P:System.Array.Length">Length</see> of 0</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>Check if the <paramref name="list"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="count">How many items the <paramref name="list"/> has, <see langword="null"/> <paramref name="list"/> will return 0 here</param>
            <returns><see langword="true"/> if the <paramref name="list"/> is <see langword="null"/> or has a <see cref="P:System.Collections.Generic.ICollection`1.Count">Count</see> of 0</returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.AssumingPureInterface">AssumingPureInterface</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.List{``0},System.Int32@)">
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(``0[],System.Int32@)">
            <summary>Check if the <paramref name="array"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="array"></param>
            <param name="count">The amount of items || 0 if the <paramref name="array"/> is <see langword="null"/></param>
            <returns><see langword="true"/> if the <paramref name="array"/> is <see langword="null"/> or has a <see cref="P:System.Array.Length">Length</see> of 0</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0},System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.List{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.List{``0})">
            <summary>Check if the <paramref name="list"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if the list is <see langword="null"/> or has a <see cref="P:System.Collections.Generic.List`1.Count">Count</see> of 0</returns>
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>Check if the <paramref name="list"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if the list is <see langword="null"/> or has a <see cref="P:System.Collections.Generic.ICollection`1.Count">Count</see> of 0</returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> -&gt; <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.AssumingPureInterface">AssumingPureInterface</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(NQualityOfLife.Types.IListInterface{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(NQualityOfLife.Types.IListInterface{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(NQualityOfLife.Types.IListInterface{``0})">
            <summary>Check if the <paramref name="list"/> is <see langword="null"/> or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if the <paramref name="list"/> is <see langword="null"/> or has a <see cref="P:System.Collections.Generic.ICollection`1.Count">Count</see> of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(NQualityOfLife.Types.HashList{``0})">
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(NQualityOfLife.Types.HashList{``0},System.Int32@)">
            <remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.ISet{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.ISet{``0},System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny(NQualityOfLife.Types.INullableCollection)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(NQualityOfLife.Types.ISimpleList{``0},System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(NQualityOfLife.Types.IReadOnlyListInterface{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(NQualityOfLife.Types.IReadOnlyListInterface{``0},System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(``0[])">
            <summary></summary><typeparam name="T"></typeparam><param name="array"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IEnumerable{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="enumerable"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny(System.Collections.IEnumerable)">
            <remarks></remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="iList"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary></summary><typeparam name="T"></typeparam><param name="iList"></param>
            <param name="count"></param>
            <returns><see langword="true"/> if the <paramref name="iList"/> is <see langword="not"/> <see langword="null"/> and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.List{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns><remarks><seealso cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IEnumerable{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item</returns>
            <remarks></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary>Check if the <paramref name="list"/> contains any items that satisfy the <paramref name="predicate"/></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item that satisfies the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)">
            <summary>Check if the <paramref name="list"/> contains any items that satisfy the <paramref name="predicate"/></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <param name="count">Treat the <paramref name="list"/> as having this many items, -1 to use the actual count</param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item that satisfies the <paramref name="predicate"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.ValueTuple{``0,``0,``0}@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="triple"></param>
            <returns><see langword="true"/> of any of the items of the <see cref="T:System.Tuple`3"/> is not <see langword="null"/></returns>
            <remarks><see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.All``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Int32)">
            <summary>Checks if all the elements in the <paramref name="list"/> match the given <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <param name="count"></param>
            <remarks>An empty <paramref name="list"/> will always return <see langword="true"/>!</remarks>
            <returns><see langword="true"/> if all elements in the <paramref name="list"/> satisfy the condition || An empty <paramref name="list"/> will always return <see langword="true"/>!</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``1(System.Collections.Generic.IList{``0},``0@)">
            <summary>Adds the new item only if it doesn't already exist in the list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
            <exception cref="T:System.ArgumentNullException"></exception><exception cref="T:System.NotSupportedException"></exception>
            <returns><see langword="true"/> if the <paramref name="value"/> was added to the <paramref name="list"/> || <see langword="false"/> if it was not added || <see langword="false"/> on error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},``0,``1@)">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},System.ValueTuple{``0,``1},System.Boolean)">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
            <param name="kIsKey"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="range">Items to add to <paramref name="values"/></param>
            <param name="startingFrom">Add items starting from the given index of <paramref name="range"/></param>
            <param name="count">How many items from <paramref name="range"/> to add to <paramref name="values"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>Add the given items to the end of the <paramref name="iList"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="range"></param>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Add``1(System.Collections.Generic.IList{``0},``0[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <summary></summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="value"></param><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Add``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}},System.ValueTuple{``0,``1}@)">
            <summary>Add the given <paramref name="value"/> tuple to the <paramref name="list"/> of tuples</summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="list"></param>
            <param name="value"></param><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Merge``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})">
            <summary>Add the contents of all the <paramref name="otherLists"/> (<typeparamref name="TL"/>) to <paramref name="list"/> and return <paramref name="list"/></summary>
            <typeparam name="TL"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="otherLists"></param>
            <returns>a <see langword="new"/> <paramref name="list"/> of <see cref="T:System.Type"/> '<typeparamref name="TL"/>' after all the <paramref name="otherLists"/> containing '<typeparamref name="TL"/>' have been added to it</returns>
            <remarks><paramref name="list"/> is mutated</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Merge``1(``0[],``0[])">
            <summary>Create a <see langword="new"/> array from the two source arrays</summary>
            <typeparam name="T"></typeparam>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns>A <see langword="new"/> array that starts with <paramref name="array1"/> and ends with <paramref name="array2"/></returns>
            <exception cref="T:NQualityOfLife.Exceptions.InternalLogicException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.MergeAll``2(System.Collections.Generic.IList{``0})">
            <summary>Merge all the given '<typeparamref name="TL"/>' <paramref name="lists"/> into a <see langword="new"/> '<typeparamref name="TL"/>'</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TL"></typeparam>
            <param name="lists"></param>
            <returns>A <see langword="new"/> '<typeparamref name="TL"/>'</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="lists"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.MergeAll``1(``0[][])">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="arrays"></param>
            <returns>A <see langword="new"/> array <typeparamref name="T"/>[]</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.MergeLazy``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})">
            <remarks>Iterates lazily</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Merge``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.MergeLazy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <remarks>Iterates lazily</remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Merge``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.MergeLazy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <remarks>Iterates lazily</remarks>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Merge``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Merge``2(``0,System.Collections.Generic.IList{``1})">
            <summary>Merges the contents of the <paramref name="otherList"/> (<typeparamref name="T"/>) to this <paramref name="list"/> (<typeparamref name="TL"/>)</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TL"></typeparam>
            <param name="list"></param>
            <param name="otherList"></param>
            <returns>The input <paramref name="list"/> (<typeparamref name="TL"/>) after the merge</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks><paramref name="list"/> is mutated</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Merge``1(NQualityOfLife.Types.HashList{``0},System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Merge``2(``0,System.Collections.Generic.IList{``1})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(NQualityOfLife.Types.UnOrderedList{System.ValueTuple{``0,``1}})">
            <summary>Gets the first items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> with the first items (<typeparamref name="T"/>) from the input <paramref name="tupleList"/> (<typeparamref name="T"/>, <typeparamref name="B"/>) - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(NQualityOfLife.Types.UnOrderedList{System.ValueTuple{``0,``1}})">
            <summary>Gets the second items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> with the second items (<typeparamref name="B"/>) from the input <paramref name="tupleList"/> (<typeparamref name="T"/>, <typeparamref name="B"/>) - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(NQualityOfLife.Types.OrderedList{System.ValueTuple{``0,``1}})">
            <summary>Gets the first items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> list with the first items from the input tuple list - The returned list has a capacity equal to the size of the input list</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="tupleList"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(NQualityOfLife.Types.OrderedList{System.ValueTuple{``0,``1}})">
            <summary>Gets the second items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:NQualityOfLife.Types.OrderedList`1"/> with the first items (<typeparamref name="T"/>) from the input <paramref name="tupleList"/> (<typeparamref name="T"/>, <typeparamref name="B"/>) - The returned list has a capacity equal to the size of the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})">
            <summary>Gets the first items (<typeparamref name="T"/>) in a tuple list (<typeparamref name="T"/>, <typeparamref name="B"/>)</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the first items (<typeparamref name="T"/>) from the input tuple list (<typeparamref name="T"/>, <typeparamref name="B"/>) - The returned list has a capacity equal to the size of the input list</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="tupleList"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(System.Collections.Generic.List{System.ValueTuple{``0,``1}})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})">
            <summary>Gets the second items (<typeparamref name="B"/>) in a tuple list (<typeparamref name="T"/>, <typeparamref name="B"/>)</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A <see langword="new"/> <see cref="T:System.Collections.Generic.List`1"/> with the second items from the input tuple list - The returned list has a capacity equal to the size of the input list</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="tupleList"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(System.Collections.Generic.List{System.ValueTuple{``0,``1}})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct``1(System.Collections.Generic.KeyValuePair{``0,System.UInt16}@,``0@,System.UInt16@)">
            <summary><see cref="T:System.Collections.Generic.KeyValuePair`2"/> deconstruct for a generic <paramref name="key"/> and <see cref="T:System.UInt16"/></summary>
            <typeparam name="K"></typeparam><param name="tuple"></param><param name="key"></param><param name="value"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1}@,``0@,``1@)">
            <summary><see cref="T:System.Collections.Generic.KeyValuePair`2"/> deconstruct for a generic <paramref name="key"/> and <paramref name="value"/></summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam><param name="tuple"></param><param name="key"></param><param name="value"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1}@,System.ValueTuple{``0,``1}@)">
            <summary><see cref="T:System.Collections.Generic.KeyValuePair`2"/> deconstruct for a generic <paramref name="pair"/> of '<typeparamref name="K"/>' and '<typeparamref name="V"/>'</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam><param name="tuple"></param><param name="pair"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct(System.Byte,NQualityOfLife.Types.Nibble@,NQualityOfLife.Types.Nibble@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Split(System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Split(System.Byte)">
            <summary>Split the <see cref="T:System.Byte"/> into two <see cref="T:NQualityOfLife.Types.Nibble"/></summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Remove``1(System.Collections.Generic.ICollection{``0},``0,System.Int32)">
            <summary>Remove the specified <paramref name="amount"/> of the <paramref name="item"/> || or until there are none left.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="item"></param>
            <param name="amount">The amount of items to remove.</param>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Remove``1(System.Collections.Generic.IList{``0},``0@,System.Int32,System.Boolean)">
            <summary>Remove the specified <paramref name="amount"/> of the <paramref name="item"/> || or until there are none left.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="item"></param>
            <param name="amount">The amount of items to remove.</param>
            <param name="removeLastFirst">set to <see langword="true"/> to iterate the list in reverse instead</param>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAll``1(``0[],``0@)">
            <summary>Remove all the instances of the given <paramref name="item"/></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="item"></param>
            <returns>A <see langword="new"/> array with all instances of the specified <paramref name="item"/> (<typeparamref name="T"/>) removed</returns>
            <remarks>MUST USE RETURN VALUE<para>Order of elements is preserved</para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAll``1(System.Collections.Generic.IList{``0},``0@)">
            <summary>Remove all the instances of the given <paramref name="item"/></summary>
            <typeparam name="T"></typeparam>
            <param name="iListRef"><see cref="T:NQualityOfLife.Attributes.MutatedAttribute">Mutated</see></param>
            <param name="item"></param>
            <returns>The amount of items removed</returns>
            <remarks><see cref="T:NQualityOfLife.Attributes.MutatesAttribute">Mutates</see> <paramref name="iListRef"/></remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveLastSafe``1(System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns><see langword="true"/> if there was something to remove || <see langword="false"/> if the <paramref name="list"/> is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveLast``1(System.Collections.Generic.IList{``0})">
            <summary>Remove the last element from the <paramref name="list"/> - a <see langword="null"/> or empty list will cause an exception</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.NullReferenceException"><paramref name="list"/> is <see langword="null"/></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveLast``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Remove the last found instance of the given <paramref name="item"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="item"></param>
            <returns><see langword="true"/> if the <paramref name="item"/> was found and removed</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.TryGetItemAtIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.TryGetItemAtIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.TryGetItemAtIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32,``0@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.GetItemAtIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetItemAtIndex``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Get the item (<typeparamref name="T"/>) at the given <paramref name="index"/> in the <paramref name="values"/></summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="index"></param>
            <returns>The item '<typeparamref name="T"/>' at the given <paramref name="index"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> was negative or &gt;= the size of the collection</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Find``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Find``1(System.Collections.Generic.IList{``0},System.Func{``0,``0,``0})">
            <inheritdoc cref="M:NQualityOfLife.Types.OrderedList`1.Find(System.Func{`0,`0,`0})"/>
            <exception cref="T:NQualityOfLife.Exceptions.ArgumentEmptyException"><paramref name="list"/> is empty</exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Last``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Last``1(System.Collections.Generic.IList{``0})"/>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.First``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.First``1(System.Collections.Generic.IList{``0})"/>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Last``1(System.Collections.Generic.IList{``0})">
            <summary>Get the last item (<typeparamref name="T"/>) of the <paramref name="list"/> - Will error if the <paramref name="list"/> is <see langword="null"/> or empty!</summary>
            <typeparam name="T"></typeparam><param name="list"></param>
            <returns>The last item (<typeparamref name="T"/>) in the <paramref name="list"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.First``1(System.Collections.Generic.IList{``0})">
            <summary>Get the first item (<typeparamref name="T"/>) of the <paramref name="list"/> - Will error if the <paramref name="list"/> is <see langword="null"/> or empty!</summary>
            <typeparam name="T"></typeparam><param name="list"></param>
            <returns>The first item (<typeparamref name="T"/>) in the <paramref name="list"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrFallBack``1(``0[],System.Predicate{``0},``0@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param><param name="predicate"></param><param name="fallback"></param>
            <returns>The first found item '<typeparamref name="T"/>' that matches the <paramref name="predicate"/>, or <paramref name="fallback"/> if none</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrFallBack``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary>Get the first item '<typeparamref name="T"/>' in the <paramref name="list"/> or <paramref name="fallback"/> if the <paramref name="list"/> contains no items</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="fallback"></param>
            <returns>First item '<typeparamref name="T"/>' of the <paramref name="list"/> or <paramref name="fallback"/> if the <paramref name="list"/> is empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrFallBack``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param><param name="predicate"></param><param name="fallback"></param>
            <returns>The first found thing that matches the <paramref name="predicate"/>, or <paramref name="fallback"/> if none</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(``0[],System.Predicate{``0},System.Int32)">
            <summary>Get the first match in the array or the '<see langword="default"/>' value of the type '<typeparamref name="T"/>'</summary>
            <typeparam name="T"></typeparam><param name="array"></param><param name="predicate"></param>
            <param name="count"></param>
            <returns>The first found thing that matches the <paramref name="predicate"/> || or <see langword="default"/> value of <typeparamref name="T"/> if none</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Get the first match in the <paramref name="list"/> or the '<see langword="default"/>' value of the type '<typeparamref name="T"/>'</summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <returns>The first found thing that matches the <paramref name="predicate" />, or <see langword="default"/> if none</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastOrFallBack``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary>Get the last item '<typeparamref name="T"/>' from the <paramref name="list"/>, or <paramref name="fallback"/> if the <paramref name="list"/> is empty</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="fallback"></param>
            <returns>The last item '<typeparamref name="T"/>' from the <paramref name="list"/>, or <paramref name="fallback"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastOrFallBack``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0@)">
            <summary>Get the last match of '<typeparamref name="T"/>' in the <paramref name="list"/> or the '<paramref name="fallback"/>' if no match found</summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <param name="fallback"></param>
            <returns>The last found item '<typeparamref name="T"/>' that matches the <paramref name="predicate" />, or <paramref name="fallback"/> if none found</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list"/> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Get the last item '<typeparamref name="T"/>' from the <paramref name="list"/>, or <see langword="default"/> value of '<typeparamref name="T"/>' if the <paramref name="list"/> contains no elements</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns>Last item '<typeparamref name="T"/>' from <paramref name="list"/> or <see langword="default"/> '<typeparamref name="T"/>'</returns>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Get the last match in the <paramref name="list"/> or the '<see langword="default"/>' value of the type '<typeparamref name="T"/>' if no match found</summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <returns>The last found thing (<typeparamref name="T"/>) that matches the <paramref name="predicate" />, or <see langword="default"/> value of <typeparamref name="T"/> if none found</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list"/> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)">
            <summary>Get the index of the first found match in the <paramref name="list"/> || or -1 if there were no matches</summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <param name="maxIndex">Return -1 if a matching item '<typeparamref name="T"/>' is not found before or at '<paramref name="maxIndex"/>'
            <para>&lt;= -1 to check all items</para></param>
            <returns>The index of the first found thing that matches the <paramref name="predicate" />, or -1 if none</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list" /> or <paramref name="predicate" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> or <paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="match"></param>
            <returns>The index of the first found thing that equals the given item, or -1 if none</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list" /> is <see langword="null"/></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The index of the last found thing that matches the <paramref name="predicate" />, or -1 if none</returns>
            <remarks>Will <see cref="T:NQualityOfLife.Utils.Log"/> (not <see langword="throw"/>) a <see cref="T:System.ArgumentNullException"/> If <paramref name="list" /> or <paramref name="predicate" /> is <see langword="null"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastIndexOf``1(System.Collections.Generic.IList{``0},``0@)">
            <summary>Get the index of the last instance of the given <paramref name="match"/> (<typeparamref name="T"/>) in the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="match"></param>
            <returns>The index of the last found instance of the given item (<typeparamref name="T"/>) || or -1 if none found</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"><see cref="T:NQualityOfLife.Attributes.MutatedAttribute">Mutated</see></param>
            <param name="where"></param>
            <returns>The input <paramref name="list"/> with the matching items removed || Not a copy of the input <paramref name="list"/>!</returns>
            <exception cref="T:System.NotSupportedException"><paramref name="list"/> does not support removal</exception>
            <remarks><see cref="T:NQualityOfLife.Attributes.MutatesAttribute">Mutates</see> <paramref name="list"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetTypeWithMostDuplicates``1(System.Collections.Generic.IList{``0},System.UInt16@)">
            <summary>Returns the <typeparamref name="T"/> instance with the highest number of duplicates in the input <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="instancesFoundInList">How many of the most common type were found</param>
            <returns>The instance of <typeparamref name="T"/> with the most appearances in the <paramref name="list"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountDuplicatesInAList``1(System.Collections.Generic.IList{``0})">
            <summary>Count how many times each item '<typeparamref name="T"/>' appears in the <paramref name="list"/>.</summary>
            <typeparam name="T"></typeparam>
            <param name="list">Count duplicates in this <paramref name="list"/></param>
            <returns>a <see langword="new"/> <see cref="T:System.Collections.Generic.Dictionary`2"/> of instances of <typeparamref name="T"/> and how many of them were in the original <paramref name="list"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates_ToList``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary>Remove duplicates so that only one of each item is on the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="removeLastFirst"></param>
            <returns>A copy of the <paramref name="list"/> with duplicates removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0})">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Boolean,System.Collections.Generic.EqualityComparer{``0})"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Boolean,System.Collections.Generic.EqualityComparer{``0})">
            <summary>Remove duplicates so that only one of each item is on the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="removeLastFirst">set to <see langword="true"/> to iterate in reverse</param>
            <param name="comparer"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception><exception cref="T:System.NotSupportedException"></exception>
            <returns>The total amount of items removed from the <paramref name="list"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllInstancesWithDuplicates``1(System.Collections.Generic.IList{``0},System.Boolean)">
            <summary>Removes all instances of the items that have any duplicates in the <paramref name="list"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="removeLastFirst">set to <see langword="true"/> to iterate in reverse</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean},System.Boolean)">
            <summary>Remove all duplicate items from the <paramref name="list"/> using the given <paramref name="equalityComparer"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="equalityComparer">Should return <see langword="true"/> if the two <typeparamref name="T"/> instances are equal</param>
            <param name="removeLastFirst">set to <see langword="true"/> to iterate the <paramref name="list"/> in reverse instead</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null"/></exception>
            <returns>The total amount of items removed from the <paramref name="list"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Boolean)">
             <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean},System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AnyWhere``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item that satisfies the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AnyWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if not <see langword="null"/> and has at least 1 item that satisfies the <paramref name="predicate"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Checks if the <paramref name="list"/> contains any elements that satisfy the <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if any of the elements satisfy the <paramref name="predicate"/> || Always <see langword="false"/> if <paramref name="list"/> is <see langword="null"/> or empty</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyWhere``1(``0[],System.Predicate{``0})">
            <summary>Checks if the <paramref name="array"/> contains any elements that satisfy the <paramref name="predicate"/></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="predicate"></param>
            <returns><see langword="true"/> if any of the elements satisfy the <paramref name="predicate"/> || Always <see langword="false"/> if the <paramref name="array"/> is <see langword="null"/> or empty</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyOf``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the <paramref name="list"/> contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if any of the elements are in both lists. || <see langword="false"/> if either list is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyOf``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>Checks if the <paramref name="list"/> contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if any of the elements are in both lists. || <see langword="false"/> if any of the inputs is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyOf``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},``0@)">
            <summary>Checks if the list contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <param name="firstMatch">The item in the <paramref name="list"/> that caused the method to return <see langword="true"/> || or <see langword="default"/> value of <typeparamref name="T"/></param>
            <returns><see langword="true"/> if any of the elements are in both lists. || <see langword="false"/> if either list is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAnyOf(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String@)">
            <summary>Checks if the <paramref name="list"/> contains any of the elements in the second list.</summary>
            <param name="list"></param>
            <param name="ofThese"></param>
            <param name="firstMatch">The item in the <paramref name="list"/> that caused the method to return <see langword="true"/> || or <see langword="null"/> if none found</param>
            <returns><see langword="true"/> if any of the elements are in both lists.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf(System.Int32,System.Collections.Generic.IList{System.Int32})">
            <summary>Check if <paramref name="value"/> is equal to any of the values in the given list</summary>
            <param name="value"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if the <paramref name="value"/> is any <paramref name="ofThese"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,System.Collections.Generic.IList{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if the <paramref name="value"/> is any <paramref name="ofThese"/> || Returns <see langword="false"/> if any input is <see langword="null"/> or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,``0@,``0@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,System.Collections.Generic.IList{``0})"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,``0[])">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,System.Collections.Generic.IList{``0})"></inheritdoc>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf_Internal``1(``0,System.Int32,``0[])">
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> or <paramref name="ofThese"/> is <see langword="null"/></exception><exception cref="T:System.IndexOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.IsAnyOf``1(``0,``0[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains``1(System.Collections.Generic.List{``0},``0@)">
            <inheritdoc cref="M:System.Collections.Generic.List`1.Contains(`0)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains``1(System.Collections.Generic.ISet{``0},``0@)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains``1(System.Collections.Generic.IReadOnlyList{``0},``0@)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains(System.Collections.Generic.IReadOnlyList{System.String},System.String@)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains``1(NQualityOfLife.Types.HashList{``0},``0@)">
            <inheritdoc cref="M:NQualityOfLife.Types.HashList`1.Contains(`0)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains``1(NQualityOfLife.Types.OrderedList{``0},``0@)">
            <inheritdoc cref="M:NQualityOfLife.Types.OrderedList`1.Contains(`0)"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains``1(``0[],``0@)">
            <inheritdoc cref="M:NQualityOfLife.Utils.ListExtensions.Contains``1(System.Collections.Generic.IEnumerable{``0},``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Contains``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <inheritdoc cref="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAllOf``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>Checks if the first <paramref name="list"/> contains all the provided items</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if <paramref name="list"/> contains all <paramref name="ofThese"/>
            <para><see langword="false"/> if <paramref name="list"/> or <paramref name="ofThese"/> is <see langword="null"/> or empty</para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAllOf``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the <paramref name="list"/> contains all the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns><see langword="true"/> if <paramref name="list"/> contains all <paramref name="ofThese"/>
            <para><see langword="false"/> if <paramref name="list"/> or <paramref name="ofThese"/> is <see langword="null"/> or empty</para></returns>
            <remarks><b>returns <see langword="false"/> if <paramref name="ofThese"/> is empty!</b></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAllOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the first list contains all the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.RoomExtensions">
            <summary>Room extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Neighbours(Verse.Room,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Get neighbouring rooms of a given room - Never null</summary>
            <param name="room">Get the neighbouring rooms of this room</param>
            <param name="forceCacheUpdate">Force update neighbour cache?</param>
            <param name="canPassHomeSeparators">do doors with an enabled home separator act like walls?</param>
            <param name="treatAirlocksAsDoors"></param>
            <param name="gameTicksNow"></param>
            <returns>List District of the given room's neighbouring rooms (not doorways) - Never null</returns><exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Cells(Verse.Region,System.Int32@,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RoomExtensions.Cells_Internal(Verse.Region,System.Int32@,Verse.Map,Verse.IntVec3)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Cells_Internal(Verse.Region,System.Int32@,Verse.Map,Verse.IntVec3)">
            <summary>Get the list of cells for the <paramref name="region"/> directly from the region grid</summary>
            <param name="region"></param>
            <param name="cellCount"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <returns>a <see langword="ref"/> to a read only <see cref="T:NQualityOfLife.Types.UnOrderedList`1"/> || Never <see langword="null"/></returns>
            <remarks><b>DO NOT USE <see cref="P:System.Collections.Generic.ICollection`1.Count"/></b> - Use the <see langword="out"/> <see cref="T:System.Int32"/> <paramref name="cellCount"/> instead to be safe</remarks>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.CellsSampled(Verse.Region,NQualityOfLife.Utils.RoomExtensions.CellSamplePattern)">
            <inheritdoc cref="M:NQualityOfLife.Utils.RoomExtensions.CellsSampled_Internal(Verse.Region,System.Int32@,NQualityOfLife.Utils.RoomExtensions.CellSamplePattern,Verse.Map,Verse.IntVec3@,Verse.IntVec3[],Verse.Region[])"/>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.CellsSampled_Internal(Verse.Region,System.Int32@,NQualityOfLife.Utils.RoomExtensions.CellSamplePattern,Verse.Map,Verse.IntVec3@,Verse.IntVec3[],Verse.Region[])">
            <summary></summary>
            <param name="region"></param>
            <param name="cellCount"></param>
            <param name="samplePattern"></param>
            <param name="map"></param>
            <param name="mapSize"></param>
            <param name="tempListInOut"></param>
            <param name="directGrid"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="region"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.WallsAndCells_Internal(Verse.Region,Verse.IntVec3@,System.Int32@,Verse.Map)">
            <summary></summary>
            <param name="region"></param>
            <param name="mapSize"></param>
            <param name="wallCellsCount"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks></remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetThingsOfType``1(Verse.Room)">
            <summary>Not <see langword="null"/></summary>
            <typeparam name="T"></typeparam>
            <param name="room"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetThingsOfType``1(Verse.Room,System.Int32@)">
            <summary>Not <see langword="null"/></summary>
            <typeparam name="T"></typeparam>
            <param name="room"></param><param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Debug(System.Collections.Generic.IList{Verse.IntVec3},UnityEngine.Color,UnityEngine.Color)">
            <summary>Draw the cells with a gradient</summary>
            <param name="cells"></param>
            <param name="startColor"></param>
            <param name="endColor"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHomeID(Verse.Room,System.Boolean)">
            <summary>Get the id of the home that a room belongs to</summary>
            <param name="room">Get the id of the home that this room belongs to</param>
            <param name="skipIsPartOfHomeCheck">Skip check if we know that the room is part of a home</param>
            <returns>The id of the home that the room belongs to, or <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHome(Verse.Room)">
            <summary>Get the home that a room belongs to</summary>
            <param name="room">Get the home that this room belongs to</param>
            <returns>The home if it was found or <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHomeOwner(Verse.Room)">
            <summary>Get the pawn who is the owner of the home that the room belongs to, returns <see langword="null"/> if failed</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.DoorWays(Verse.Room)">
            <summary>Get the doorway <seealso cref="T:Verse.Region">regions</seealso> of the given <paramref name="room"/></summary>
            <param name="room">The room whose door ways we want to get.</param>
            <returns>A list of <see cref="T:Verse.Region"/>s</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Doors(Verse.Room,Verse.Map)">
            <summary>Get the <seealso cref="T:RimWorld.Building_Door">doors</seealso> from all neighbouring districts of the given <paramref name="room"/> || If you don't need the '<see cref="T:Verse.Thing"/>' use '<see cref="M:NQualityOfLife.Utils.RoomExtensions.DoorWays(Verse.Room)"/>' instead</summary>
            <param name="room">The room whose door ways we want to get.</param>
            <param name="map">Will be taken from room.Map if <see langword="null"/>, provide it if possible.</param>
            <returns>A list of Things (doors)</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Networking.Web">
            <summary>Utilities for web stuff, such as web requests or opening of web pages in browser</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Networking.Web.myGitHubAccount">
            <summary>My GitHub username</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Networking.Web.NQoLGitHubRepo">
            <summary>The GitHub repository name for the NQoL mod</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Networking.Web.GitHubURL">
            <summary><seealso cref="F:NQualityOfLife.Utils.Networking.Web.GitHub"><see href="https://github.com"/></seealso> <see cref="T:NQualityOfLife.Types.URL"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Networking.Web.myModChangelogURL">
            <summary>The full <see cref="T:NQualityOfLife.Types.URL"/> to the changelog page of NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Networking.Web.myModSteamURL">
            <summary>The full <see cref="T:NQualityOfLife.Types.URL"/> to the steam workshop page of NQoL</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Networking.Web.NQoLGithubWikiHome">
            <summary><see href="https://github.com/Niilo007/RimWorld-NQoL/wiki"/></summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Networking.Web.ConnectedToTheInternet">
            <summary>Get if we have access to the internet</summary>
            <remarks>Seems to return <see langword="true"/> when the ethernet cable is un-plugged as '<see cref="P:UnityEngine.Application.internetReachability"/>' gives 'NetworkReachability.ReachableViaLocalAreaNetwork', idk why</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.ValidateFileId(System.String)">
            <summary>Make sure the id is a valid id and not something un-expected</summary>
            <param name="publishedFileID">The <paramref name="publishedFileID"/> of the steam workshop item</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenWorkshopItem_Changelog(System.String)">
            <summary>Open the changelog tab of the given workshop item in the web browser</summary>
            <param name="publishedFileID">The id of the workshop item we want to open the changelog page of</param>
            <returns><see langword="false"/> if we failed to open the page for any reason</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenWorkshopItem(System.String)">
            <summary>Open the workshop page of the given workshop item in the web browser</summary>
            <param name="publishedFileID">The id of the workshop item we want to open in the browser</param>
            <returns><see langword="false"/> if we failed to open the page for any reason</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenURL(NQualityOfLife.Types.URL@)">
            <summary>Open the given <see cref="T:NQualityOfLife.Types.URL"/> in the browser - Displays on screen and log message, and plays sound.</summary>
            <param name="url">The <see cref="T:NQualityOfLife.Types.URL"/> of the web page to open in the web browser</param>
            <exception cref="T:System.PlatformNotSupportedException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.GetLatestVersionStringFromSteam">
            <summary>Get the raw text of the changelog page of the steam workshop and parse out the latest version <see cref="T:System.String"/></summary>
            <returns>The version <see cref="T:System.String"/> from the changelog page on the workshop, <see cref="F:NQualityOfLife.IO.VersionInfo.Invalid"/> if failed to get the version <see cref="T:System.String"/> or it is not formatted correctly</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.TryFindVersionFromText(System.String)">
            <summary>Try to parse out the version string from the raw web page text</summary>
            <param name="webPageText"></param>
            <returns><see cref="F:NQualityOfLife.IO.VersionInfo.Invalid"/> on fail</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.GetTextFromWebPage(NQualityOfLife.Types.URL@,System.String@)">
            <summary>Get the raw text from the given <see cref="T:NQualityOfLife.Types.URL"/></summary>
            <param name="url"></param>
            <param name="error">Error <see cref="T:System.String"/> or <see langword="null"/> if no error</param>
            <returns>The raw text of the <see cref="T:NQualityOfLife.Types.URL"/> as a <see cref="T:System.String"/><para><see langword="null"/> if no internet connection or request failed</para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.TryReplaceWithMethodCall(HarmonyLib.CodeInstruction,System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="replacementMethod"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> or <paramref name="replacementMethod"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.ReplaceWithMethodCall(HarmonyLib.CodeInstruction,System.Reflection.MethodInfo)">
            <summary>Replace the given <paramref name="instruction"/> with a method call to the <paramref name="replacementMethod"/></summary>
            <param name="instruction"></param>
            <param name="replacementMethod"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> or <paramref name="replacementMethod"/> is <see langword="null"/></exception>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.CallMethod(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="method"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.LoadField(System.Reflection.FieldInfo)">
            <summary>Load a static or instance field</summary>
            <param name="field"></param>
            <returns>a <see langword="new"/> <see cref="T:HarmonyLib.CodeInstruction"/> that loads the given <paramref name="field"/> onto the stack</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="field"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.ThreadLockEnter">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.ThreadLockExit">
            <summary></summary>
            <returns></returns>
            <remarks>This should be inserted inside a <see langword="finally"/> block!</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.CallsMethod(HarmonyLib.CodeInstruction,System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="method"></param>
            <returns>True if the instruction calls the given method - if the method is null, will log an error</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> or <paramref name="method"/> is <see langword="null"/></exception>
            <remarks>Matches '<see cref="F:System.Reflection.Emit.OpCodes.Call"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.LoadsString(HarmonyLib.CodeInstruction,System.String)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="str"><see cref="T:System.String"/> literal stored in the assembly metadata</param>
            <returns><see langword="true"/> if the <paramref name="instruction"/> loads the given <see cref="T:System.String"/> literal onto the stack</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <remarks>Matches '<see cref="F:System.Reflection.Emit.OpCodes.Ldstr"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.CreatesObject(HarmonyLib.CodeInstruction,System.Type)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="type">The <see cref="T:System.Type"/> of the <see cref="T:System.Object"/> that the <paramref name="instruction"/> creates</param>
            <returns><see langword="true"/> if the <paramref name="instruction"/> creates a <see langword="new"/> <see cref="T:System.Object"/> of the given <see cref="T:System.Type"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> or <paramref name="type"/> is <see langword="null"/></exception>
            <remarks>Matches '<see cref="F:System.Reflection.Emit.OpCodes.Newobj"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.LoadsLocalVariable(HarmonyLib.CodeInstruction)">
            <summary></summary>
            <param name="instruction"></param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.TryGetLocalIndex(HarmonyLib.CodeInstruction)">
            <summary></summary>
            <param name="instruction"></param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.LoadsConstant(HarmonyLib.CodeInstruction,System.Int32)">
            <summary>Check if the <paramref name="instruction"/> loads the given constant <see cref="T:System.Int32"/> value onto the evaluation stack</summary>
            <param name="instruction"></param>
            <param name="intConst"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.LoadsConstant(HarmonyLib.CodeInstruction,System.Single)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="floatConst"></param>
            <returns><see langword="true"/> if the given <paramref name="instruction"/> loads the given constant <see cref="T:System.Single"/> value onto the stack</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> is <see langword="null"/></exception>
            <remarks>Matches '<see cref="F:System.Reflection.Emit.OpCodes.Ldc_R4"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.LoadsObjectFieldAddress(HarmonyLib.CodeInstruction,System.Reflection.FieldInfo)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="field"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> or <paramref name="field"/> is <see langword="null"/></exception>
            <remarks>Matches '<see cref="F:System.Reflection.Emit.OpCodes.Ldflda"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.LoadsObjectField(HarmonyLib.CodeInstruction,System.Reflection.FieldInfo)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="field"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> or <paramref name="field"/> is <see langword="null"/></exception>
            <remarks>Matches '<see cref="F:System.Reflection.Emit.OpCodes.Ldfld"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.SetsObjectField(HarmonyLib.CodeInstruction,System.Reflection.FieldInfo)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="field"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> or <paramref name="field"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <remarks>Matches '<see cref="F:System.Reflection.Emit.OpCodes.Stfld"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.LoadsLocalVariable(HarmonyLib.CodeInstruction,System.Int32,System.Type)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="index"></param>
            <param name="expectedType">The expected <see cref="T:System.Type"/> of the variable, will give error if the <see cref="T:System.Type"/> is not the one we expect</param>
            <returns><see langword="true"/> if the <paramref name="instruction"/> loads a local variable at the given <paramref name="index"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.CallsMethod_Virtual(HarmonyLib.CodeInstruction,System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="method"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="instruction"/> or <paramref name="method"/> is <see langword="null"/></exception>
            <remarks>Matches '<see cref="F:System.Reflection.Emit.OpCodes.Callvirt"/>'</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.XML.Patch.RemoveDef``1(``0)">
            <summary>Remove the given <see cref="T:Verse.Def"/> from the game</summary>
            <typeparam name="TDef">The type of the def</typeparam>
            <param name="def">The def to remove</param>
            <returns><see langword="true"/> if the <see cref="T:Verse.Def"/> was successfully removed from the <see cref="T:Verse.DefDatabase`1"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.XML.Patch.RemoveComp(Verse.ThingDef,System.Type,System.Boolean)">
            <summary>Remove all instances of the <paramref name="compClass"/> from the <paramref name="def"/></summary>
            <param name="def"></param>
            <param name="compClass"></param>
            <param name="warnIfAlreadyRemoved"></param>
            <returns><see langword="true"/> if the <paramref name="def"/> had a comp of the given <paramref name="compClass"/> and it / they were successfully removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.XML.Patch.AddComp``1(Verse.ThingDef,``0,System.Boolean)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="def"></param>
            <param name="compProperties"></param>
            <param name="warnIfAlreadyExists"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.XML.Patch.AddPlaceWorker(Verse.ThingDef,System.Type,System.Boolean)">
            <summary></summary>
            <param name="def"></param>
            <param name="placeWorker"></param>
            <param name="warnIfAlreadyExists"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Log">
            <summary>Utils for logging errors, warnings and other messages</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Log.Strings">
            <summary>Commonly used <see cref="T:NQualityOfLife.Utils.Log"/> strings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.Strings.DebugTag">
            <summary>The tag identifier for debug messages</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.Strings.ErrorTag">
            <summary>The tag identifier for error messages</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.Strings.WarningTag">
            <summary>The tag identifier for warning messages</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.Strings.QATag">
            <summary>Additional log tag for QA messages</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.Strings.NQoL_Tag">
            <summary>The identifier tag for all <see cref="N:NQualityOfLife"/> messages, errors and warnings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.Strings.Colored_NQoL_Tag">
            <summary><see cref="F:NQualityOfLife.Utils.Log.Strings.NQoL_Tag"/> with color added using <see cref="F:NQualityOfLife.Utils.Colors.NQoL_Color_Tag"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.totalErrors">
            <summary>the total amount of calls to <see cref="M:NQualityOfLife.Utils.Log.__ErrorFinal``2(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,``0,System.String,System.Int32)"/> / <see cref="M:NQualityOfLife.Utils.Log.ErrorOnceFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Int32,System.Boolean,System.Object)"/> since startup</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.totalWarnings">
            <summary>the total amount of calls to <see cref="M:NQualityOfLife.Utils.Log.WarningFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.String)"/> / <see cref="M:NQualityOfLife.Utils.Log.WarningOnceFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Int32,System.Boolean,Verse.LookTargets)"/> since startup</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Log.TotalErrors">
            <inheritdoc cref="F:NQualityOfLife.Utils.Log.totalErrors"/>
        </member>
        <member name="P:NQualityOfLife.Utils.Log.TotalWarnings">
            <inheritdoc cref="F:NQualityOfLife.Utils.Log.totalWarnings"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.FlagsAreSet(NQualityOfLife.Utils.Log.LogMode,NQualityOfLife.Utils.Log.LogMode)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.AnyFlagIsSet(NQualityOfLife.Utils.Log.LogMode,NQualityOfLife.Utils.Log.LogMode)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="T:NQualityOfLife.Utils.Log.NQoL_RW_Log_ThreadSafetyPatcher">
            <summary>Insert a thread lock to the debug log to prevent it erroring when messages are logged from background threads</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.NQoL_Remove_Color_Tags_From_Log_Patch_2_StackTraceWindow.lastOriginalTrace">
            <summary>The original un-modified version of '<see cref="F:NQualityOfLife.Utils.Log.NQoL_Remove_Color_Tags_From_Log_Patch_2_StackTraceWindow.lastModifiedTraceResult"/>'</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.NQoL_Remove_Color_Tags_From_Log_Patch_2_StackTraceWindow.lastModifiedTraceResult">
            <summary>Stack trace with color tags removed for clarity</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.NQoL_LogMessageLookTargets._roundRobinIndex">
            <summary>Used to iterate look targets when clicking on the same message again</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Log.NQoL_LogMessageLookTargets._lastMessageSelection">
            <summary>The log <see cref="T:Verse.LogMessage"/> that was clicked on last</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.NQoL_LogMessageLookTargets.Prefix(Verse.LogMessage,Verse.LogMessage)">
            <summary></summary>
            <param name="value">The message to select</param>
            <param name="___selectedMessage">The currently selected log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ExceptionInfo(System.Exception,System.Boolean)">
            <summary>Formats an <see cref="T:System.Exception"/> for display</summary>
            <param name="exception"></param>
            <param name="includeTrace">Include the stack trace of the <paramref name="exception"/> in the output <see cref="T:System.String"/></param>
            <returns>a <see cref="T:System.String"/> with information about the <paramref name="exception"/> and any inner exceptions there of</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.__GetLogTypeTagString(NQualityOfLife.Utils.Log.LogMode,System.String)">
            <summary></summary>
            <param name="logMode"></param>
            <param name="tag"></param>
            <returns>"- QA -" or "[E] - QA -" or "-" or "[E] -" etc</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageOnChange(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.MessageOnChange(System.String,System.String,System.Type,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object)"/>
            <summary></summary>
            <param name="message"></param>
            <param name="caller"></param>
            <param name="logMode"></param>
            <param name="lookTargets"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="caller"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageOnChange(System.String,System.String,System.Type,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object)">
            <summary>Log a message if the message has changed</summary><param name="message"></param>
            <param name="method"></param><param name="type"></param><param name="methodName"></param>
            <param name="logMode"></param>
            <param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.MessageFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageOnChange(System.String,System.Type,System.String)">
            <summary>Log a message if the message has changed</summary><param name="message"></param><param name="type"></param><param name="methodName"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageExternal(System.String,System.String)">
            <summary></summary>
            <param name="message"></param>
            <param name="tag"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Message(System.String,NQualityOfLife.Utils.Log.LogMode,System.Object)">
            <summary>Log a message with no method info</summary>
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.MessageFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Message(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.MessageFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageFinal(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.String)">
            <summary></summary>
            <param name="message"></param>
            <param name="method"></param>
            <param name="logMode"></param>
            <param name="lookTargets">Allowed <seealso cref="T:System.Type">types</seealso>: <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
            <param name="externalTag"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.WarningExternal(System.String,System.String)">
            <summary></summary>
            <param name="message"></param>
            <param name="tag"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,NQualityOfLife.Utils.Log.LogMode,System.String,System.Object)">
            <summary>Log a warning with the given <paramref name="logMode"/> - Logs method name by using the '(omit)' resolve mode</summary><param name="message"></param><param name="logMode"></param><param name="method"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param><remarks><paramref name="lookTargets"/> can be optionally provided</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.String)">
            <summary>Log a warning with the given <paramref name="logMode"/> and <paramref name="lookTargets"/> - Logs method name by using the '(omit)' resolve mode</summary><param name="message"></param><param name="logMode"></param><param name="method"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,System.String,System.Object)">
            <summary>Log a warning with the <paramref name="method"/> details and <paramref name="lookTargets"/></summary><param name="message"></param><param name="method"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,System.Object)">
            <summary>Log a warning to the log with a <paramref name="message"/> only</summary><param name="message">The message to print to the log</param>
            <param name="lookTargets"></param><remarks>No other details, such as the calling method will be included</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object)">
            <summary>Log a warning <paramref name="message"/> with the given <paramref name="method"/> info</summary><param name="message"></param><param name="method">The method info or mode</param><param name="logMode"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param><remarks><paramref name="lookTargets"/> can optionally be specified</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ErrorOnce(System.Exception,System.Object)">
            <summary>Log exception once with method resolve mode '(...)' and visible id</summary><param name="exception"></param><param name="lookTargets">The <see cref="T:Verse.LookTargets"/> to embed into the log message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ErrorExternal``1(``0,System.String)">
            <summary>Error message called from outside the NQoL dll</summary>
            <param name="exception"></param>
            <param name="tag"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ErrorExternal(System.String,System.String)">
            <summary>Error message called from outside the NQoL dll</summary>
            <param name="message"></param>
            <param name="tag"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null_Internal_AndReturn``1(System.String,System.String,``0,System.Object)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.Error_Null_AndReturn``1(System.String,System.String,``0,System.Object)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null_Internal(System.String,System.String,System.Object,System.String)">
            <summary>Logs a <see langword="null"/> error (<see cref="T:NQualityOfLife.Exceptions.InternalDataException"/>) and returns <see langword="false"/><para>The default message is: $"'{t}' is '{Common.Strings.nullSymbol}'!"</para></summary>
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.Object,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null_Internal(System.String,System.String,System.String,System.Object,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.Object,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null_AndReturn``1(System.String,System.String,System.String,``0,System.Object)">
            <summary>Logs a <see langword="null"/> error (<see cref="T:System.ArgumentNullException"/>) and returns the specified value</summary>
            <param name="nullThing"><see langword="nameof"/></param>
            <param name="nullThing2"><see langword="nameof"/></param><param name="returnValue">nameof(t)</param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param><param name="method"></param>
            <returns><typeparamref name="T"/> specified value or <see langword="default"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null_AndReturn``1(System.String,System.String,System.String,System.String,``0,System.Object)">
            <summary>Logs a <see langword="null"/> error (<see cref="T:System.ArgumentNullException"/>) and returns the specified value</summary>
            <param name="nullThing"><see langword="nameof"/></param>
            <param name="nullThing2"><see langword="nameof"/></param>
            <param name="nullThing3"><see langword="nameof"/></param><param name="returnValue">nameof(t)</param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param><param name="method"></param>
            <returns><typeparamref name="T"/> specified value or <see langword="default"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null_AndReturn``1(System.String,System.String,``0,System.Object)">
            <summary>Logs a <see langword="null"/> error (<see cref="T:System.ArgumentNullException"/>) and returns <see langword="default"/> or the specified <paramref name="returnValue"/></summary>
            <param name="nullThing">nameof</param><param name="returnValue">nameof(t)</param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param><param name="method"></param>
            <returns><typeparamref name="T"/> <see langword="default"/> value or the given <paramref name="returnValue"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.Object,System.String)">
            <summary>Logs a <see langword="null"/> error (<see cref="T:System.ArgumentNullException"/>) and returns <see langword="false"/><para>The default message is: $"'{<paramref name="t"/>}' is '{<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>}'!"</para></summary>
            <param name="t">nameof(t)</param><param name="method"></param>
            <param name="customMessage">Override the default message ($"'{<paramref name="t"/>}' is '{<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>}'!")</param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param><returns><see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null``1(System.String,System.String,System.Object,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.Object,System.String)"/>
            <remarks><see cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"/> has a default message of: $"'{<paramref name="t"/>}' is {<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>} or empty!"</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null``1(System.String,System.String,System.String,System.Object,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.Object,System.String)"/>
            <remarks><see cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"/> has a default message of: $"'{<paramref name="t1"/>}' or '{<paramref name="t2"/>}' is {<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>} or empty!"</remarks>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.Object,System.String)">
            <summary>Logs a <see langword="null"/> error (<see cref="T:System.ArgumentNullException"/>) and returns <see langword="false"/><para>The default message is: $"'{<paramref name="t1"/>}' or '{<paramref name="t2"/>}' is '{<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>}'!"</para></summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="method"></param>
            <param name="customMessage">Override the default message ($"'{<paramref name="t1"/>}' or '{<paramref name="t2"/>}' is '{<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>}'!")</param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param><returns><see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.String,System.Object,System.String)">
            <summary>Logs a <see langword="null"/> error (<see cref="T:System.ArgumentNullException"/>) and returns <see langword="false"/>
            <para>The default message is:</para>
            <para>$"'{<paramref name="t1"/>}', '{<paramref name="t2"/>}' or '{<paramref name="t3"/>}' is '{<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>}'!"</para></summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="t3"></param><param name="method"></param>
            <param name="customMessage">Override the default message ($"'{<paramref name="t1"/>}', '{<paramref name="t2"/>}' or '{<paramref name="t3"/>}' is '{<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>}'!")</param><param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param><returns><see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.String,System.String,System.Object,System.String)">
            <summary>Logs a <see langword="null"/> error (<see cref="T:System.ArgumentNullException"/>) and returns <see langword="false"/><para>The default message is: $"'{<paramref name="t1"/>}', '{<paramref name="t2"/>}', '{<paramref name="t3"/>}' or '{<paramref name="t4"/>}' is '{<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>}'!"</para></summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="t3"></param><param name="t4"></param><param name="method"></param>
            <param name="customMessage">Override the default message ($"'{<paramref name="t1"/>}', '{<paramref name="t2"/>}', '{<paramref name="t3"/>}' or '{<paramref name="t4"/>}' is '{<see cref="F:NQualityOfLife.Utils.Common.Strings.NullSymbol"/>}'!")</param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param><returns><see langword="false"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_NotImplemented(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.NotImplementedException)">
            <summary></summary>
            <param name="message"></param>
            <param name="method"></param>
            <param name="logMode"></param>
            <param name="ex"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput(System.String)">
            <summary><paramref name="method"/> - was called with an invalid parameter value!</summary>
            <param name="method"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput(System.String,System.String,System.Object)">
            <summary><paramref name="method"/> - $"'{<paramref name="parameter"/>}' has an invalid value for the method!"</summary>
            <param name="parameter"></param>
            <param name="method"></param><param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput``1(System.String,System.String,System.Object)">
            <summary><paramref name="method"/> - $"'{<paramref name="parameter"/>}' has an invalid value for the method!"</summary>
            <typeparam name="E"></typeparam>
            <param name="parameter"></param>
            <param name="method"></param>
            <returns></returns><param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput(System.String,System.String,System.String,System.Object)">
            <summary>$"'{<paramref name="parameter1"/>}' or '{<paramref name="parameter2"/>}' has an invalid value for the method!"</summary>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="method"></param>
            <param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput(System.String,System.String,System.String,System.String,System.Object)">
            <summary>$"'{<paramref name="parameter1"/>}', '{<paramref name="parameter2"/>}' or '{<paramref name="parameter3"/>}' has an invalid value for the method!"</summary>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="parameter3"></param>
            <param name="method"></param>
            <param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput_AndReturn``1(System.String,System.String,``0,System.Object)">
            <summary>Log an error and return the <see langword="default"/> value of the specified type</summary>
            <typeparam name="R"></typeparam>
            <param name="parameter"></param>
            <param name="method"></param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param>
            <param name="ret"></param>
            <returns><see langword="default"/> value of '<typeparamref name="R"/>' usually <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput_AndReturn``1(System.String,System.String,System.String,``0,System.Object)">
            <summary>Log an error and return the <see langword="default"/> value of the specified type</summary>
            <typeparam name="R"></typeparam>
            <param name="parameter"></param>
            <param name="parameter2"></param>
            <param name="method"></param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param>
            <param name="ret"></param>
            <returns><see langword="default"/> value of '<typeparamref name="R"/>' usually <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput_AndReturn``2(System.String,System.String,System.String,``0,System.String,System.Object)">
            <summary>Log an error and return the <see langword="default"/> value of the specified type</summary>
            <typeparam name="R"></typeparam>
            <typeparam name="E"></typeparam>
            <param name="parameter"></param>
            <param name="parameter2"></param>
            <param name="method"></param>
            <param name="lookTargets">Look targets to embed into the message<para>Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></para></param>
            <param name="ret"></param>
            <param name="message">Default is "'{<paramref name="parameter"/>}' or '{<paramref name="parameter2"/>}' has an invalid value for the method!"</param>
            <returns><see langword="default"/> value of '<typeparamref name="R"/>' usually <see langword="null"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput_WithReason``1(System.String,System.String,System.String,System.Object,``0)">
            <summary>$"'{<paramref name="parameter"/>}' {<paramref name="reason"/>}"</summary>
            <typeparam name="E"></typeparam>
            <param name="parameter"></param>
            <param name="method"></param>
            <param name="reason">'{<paramref name="parameter"/>}' "has an invalid value for the method!"</param>
            <param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
            <param name="e"></param>
            <returns><paramref name="e"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput_WithReason``1(System.String,System.String,System.String,System.String,System.Object,``0)">
            <summary>$"'{<paramref name="parameter1"/>}' or '{<paramref name="parameter2"/>}' {<paramref name="reason"/>}"</summary>
            <typeparam name="E"></typeparam>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="method"></param>
            <param name="reason">'{<paramref name="parameter1"/>}' or '{<paramref name="parameter2"/>}' "has an invalid value for the method!"</param>
            <param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
            <param name="e"></param>
            <returns><paramref name="e"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput_WithReason``1(System.String,System.String,System.String,System.String,System.String,System.Object,``0)">
            <summary>$"'{<paramref name="parameter1"/>}', '{<paramref name="parameter2"/>}' or '{<paramref name="parameter3"/>}' {<paramref name="reason"/>}"</summary>
            <typeparam name="E"></typeparam>
            <param name="parameter1"></param>
            <param name="parameter3"></param>
            <param name="parameter2"></param>
            <param name="method"></param>
            <param name="reason">'{<paramref name="parameter1"/>}', '{<paramref name="parameter2"/>}' or '{<paramref name="parameter3"/>}' "has an invalid value for the method!"</param>
            <param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
            <param name="e"></param>
            <returns><paramref name="e"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput_WithReason(System.String,System.String,System.String,System.String,System.Object)">
            <summary>$"'{<paramref name="parameter1"/>}' or '{<paramref name="parameter2"/>}' {<paramref name="reason"/>}"</summary>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="method"></param>
            <param name="reason">'{<paramref name="parameter1"/>}' or '{<paramref name="parameter2"/>}' "has an invalid value for the method!"</param>
            <param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error(System.String,NQualityOfLife.Utils.Log.LogMode,System.Object)">
            <summary>Log an error without including the method name or params</summary><param name="message"></param><param name="logMode"></param><param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.Int32)">
            <summary>Log error with the given method info</summary><param name="message"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
            <param name="sourceLineNumber">Leave as <see langword="default"/></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error``1(``0,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.Int32)">
            <summary>Log '<typeparamref name="E"/>' with method name and params</summary><param name="exception"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
            <param name="sourceLineNumber"></param><returns>The '<typeparamref name="E"/>' that was logged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error``1(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object)">
            <summary>Log an error with a given <see cref="T:System.Exception"/> <see cref="T:System.Type"/>: '<typeparamref name="E"/>'</summary>
            <typeparam name="E"></typeparam>
            <param name="message"></param>
            <param name="method"></param>
            <param name="logMode"></param>
            <param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error``1(System.String,``0,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,System.Int32)">
            <summary>Log '<typeparamref name="E"/>' with a message and method name and params</summary><param name="message"></param><param name="exception"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
            <param name="sourceLineNumber"></param><returns>The '<typeparamref name="E"/>' that was logged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.__ErrorFinal``2(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,System.Object,``0,System.String,System.Int32)">
            <summary></summary>
            <typeparam name="R"></typeparam>
            <typeparam name="E"></typeparam>
            <param name="message"></param>
            <param name="method"></param>
            <param name="logMode"></param>
            <param name="lookTargets">Allowed types: <see cref="T:RimWorld.Planet.WorldObject"/>, <see cref="T:Verse.Thing"/>, <see cref="T:Verse.LookTargets"/></param>
            <param name="ret"></param>
            <param name="externalTag"></param>
            <param name="lineNumber"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.FlagsAreSet(NQualityOfLife.Utils.Log.MethodResolveMode,NQualityOfLife.Utils.Log.MethodResolveMode)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.FlagsAreSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.AnyFlagIsSet(NQualityOfLife.Utils.Log.MethodResolveMode,NQualityOfLife.Utils.Log.MethodResolveMode)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Common.AnyFlagIsSetGeneric``1(``0,``0@)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ResolveMethodInfo(System.String,System.SByte,System.Boolean)">
            <summary>Input can be <see langword="null"/></summary>
            <param name="methodToResolve"></param>
            <param name="offsetStackFrames"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.RemoveColorTagsRegex(System.String)">
            <summary>Strips color tags</summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.FixColorTagParity(System.String,System.Byte,System.Boolean@,System.Boolean,System.Boolean)">
            <summary>Calling Utils.Log.Error can cause an infinite loop!</summary>
            <param name="text"></param>
            <param name="attempts"></param>
            <param name="error"></param>
            <param name="skipNullCheck"></param>
            <param name="skipHasColorTagsCheck"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ColorizeHashTagNumber(System.String)">
            <summary>Colorize the first found '#256' type <see cref="T:System.String"/></summary>
            <param name="inputString"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Settings">
            <summary>Global settings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Settings.DebugMode">
            <summary>global debug mode <see langword="bool"/></summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Settings.profile">
            <summary>The currently active setting profile, This will be constant after startup</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Flasher">
            <summary>Provides framerate independent on off values</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Pulser">
            <summary>Provides framerate independent <see cref="T:NQualityOfLife.Types.Ratio"/> wave values</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Resolve">
            <summary>Resolve invalid or <see langword="null"/> values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.MapIsNullAfterResolve``1(Verse.Map,Verse.Map@,``0,System.String,System.String)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="t">Use this thing to find map if available</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.IsNullAfterResolve(Verse.Map,Verse.Map@,System.String,System.String)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.MapIsNullAfterResolve(Verse.Map,Verse.Map@,System.String,System.String,System.SByte)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
            <param name="offsetFrames"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.NullMap``1(``0)">
            <summary>Try to find current map</summary>
            <returns>Map or null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.IdentifierInfo.FindContentSource(System.Type)">
            <summary></summary>
            <param name="type"></param>
            <returns>The packageId of the mod that the <paramref name="type"/> was found in || or <see langword="null"/> if it was not found</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Mouse_">
            <summary>values related to the mouse pointer</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Mouse_.PositionOnUIRatio">
            <summary>y1f is the top of the screen, x1f is the right side of the screen</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Mouse_.IsNearWidgetsOrLetters">
            <summary>true if yes, always false if game is unfocused</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Mouse_.IsNearWidgetsOrLettersUpdate">
            <summary>Is the mouse pointer near the widgets or letter stack?</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.IfPlayer.PlayerCanSeeNow(Verse.Thing,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Get.IfPlayer.CanSeeNow(Verse.Thing,Verse.Map)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.IfPlayer.CanSeeNow(Verse.Thing,Verse.Map)">
            <summary></summary>
            <param name="thing"></param>
            <param name="currentMap"></param>
            <returns><see langword="true"/> if the <paramref name="thing"/> is on the <see cref="T:Verse.Map"/> that the player is currently looking at, and is not fogged or otherwise hidden</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="thing"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.IfPlayer.PlayerCanSeeEver(Verse.Thing,Verse.Map)">
            <inheritdoc cref="M:NQualityOfLife.Utils.Get.IfPlayer.CanSeeEver(Verse.Thing,Verse.Map)"/>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.IfPlayer.CanSeeEver(Verse.Thing,Verse.Map)">
            <summary></summary>
            <param name="thing"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="thing"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Colony">
            <summary>values related to the colony</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Room_.Contains">
            <summary>Get room contents</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.ContainsFood(Verse.Room,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns><see langword="base"/>, <see langword="true"/> if contains food</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.ContainsFood(Verse.District,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns><see langword="base"/>, <see langword="true"/> if contains food</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.Food(Verse.District,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns><see langword="base"/>, <see langword="true"/> if contains food</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="room"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Room_.My">
            <summary>myRoom's x</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.My.Neighbours(Verse.District,System.Boolean,System.Boolean,System.Collections.Generic.HashSet{Verse.District},System.Boolean,System.Boolean,System.Int32,System.Byte,System.Boolean)">
            <summary>Get the neighbouring rooms of a room</summary>
            <param name="myRoom">The room whose neighbours we want to find</param>
            <param name="ignoreAirlocks">treat airlocks like a single door ISSUE: doesn't correctly return all rooms if this is enabled</param>
            <param name="ignoreRooms">Ignore these rooms</param>
            <param name="returnFirst">Return the first found neighbour instead of all of them</param>
            <param name="forceCacheUpdate">Force the method to recalculate, instead of using saved values</param>
            <param name="canPassHomeSeparators">Allow the search to return rooms behind home system home separator doors / do doors with an enabled home separator act like walls?</param>
            <param name="gameTicksNow"></param>
            <param name="maxRecursion"></param>
            <param name="debug"></param>
            <returns>List District of the given room's neighbouring rooms (not doorways) - Never null</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.My.FindEndOfDoorChain(Verse.District,Verse.District,System.Byte,System.Collections.Generic.HashSet{Verse.District})">
            <summary>Finds the room at the end of a chain of back to back doors</summary>
            <param name="startRoom">The room where firstDoor connects</param>
            <param name="firstDoor">The door in startRoom at the start of the door chain</param>
            <param name="maxIterations">Log error and give up after this many iterations of recursion</param>
            <param name="checkedDistricts"></param>
            <returns>The room at the end of the chain, that is not the starting room or null</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Best.MedicalCarePolicy">
            <summary>Methods for getting best medical care policy</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Best.MedicalCarePolicy.IsValidColonist(Verse.Pawn,System.Boolean)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forPrisoners"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Best.MedicalCarePolicy.ForThisPawn(Verse.Map,Verse.Pawn,System.Boolean)">
            <summary>Get the best medical care policy for the given <see cref="T:Verse.Pawn"/></summary>
            <returns>bool foundValidPolicy, MedicalCareCategory policy</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="pawnToAssign">The <see cref="T:Verse.Pawn"/> we want to get the policy for</param>
            <param name="forPrisoners"></param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Best.Area_">
            <summary>Get best Area for...</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Best.Area_.ForThisPawn(Verse.Map,Verse.Pawn,System.Boolean,System.Boolean)">
            <summary>Get the best area restriction for a given pawn</summary>
            <returns>Verse.Area of the best fit for the given pawn</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="pawnToAssign">The Pawn we want to get the Area for</param>
            <param name="slave">is the pawn known to be a slave?</param>
            <param name="skipValidation">Skip the checks for "playerSettings", "SupportsAllowedAreas" and "RespectsAllowedArea" because we already checked them</param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Relations">
            <summary>Get Pawn Relation info</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Relations.LoverPairsOnMap(Verse.Map,System.Boolean)">
            <summary>Get the count of lovers on the map</summary>
            <returns>count of lovers, and count of lovers assigned to double beds</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="mustBeAssignedToSameBed">Do we only count lovers if they are assigned to the same bed?</param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Skills">
            <summary>Get pawn skills</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Skills.AverageOf">
            <summary>Get average skills of </summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Skills.AverageOf.AssignedTo(Verse.Map,Verse.WorkTypeDef,RimWorld.SkillDef,Verse.Pawn)">
            <summary>Get the average skill of pawns assigned to work type</summary>
            <param name="map">The map to get the average from</param>
            <param name="workType">The work-type that the pawns need to be assigned to</param>
            <param name="skill">The skill to get</param>
            <param name="ignorePawn">Do not include this pawn</param>
            <returns>float of the average skill level</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns">
            <summary>Saved list of the top pawns who need treatment</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.priorityPawn">
            <summary>The first top priority pawn</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.secondPawn">
            <summary>The second priority pawn</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.thirdPawn">
            <summary>The third priority pawn</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.GetPriorityPawnHours">
            <summary></summary>
            <returns><see cref="F:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.ttdHoursInfinite"/> if there is no '<see cref="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.priorityPawn"/>' or the current priority pawn is no longer bleeding</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.GetSecondPawnHours">
            <summary></summary>
            <returns><see cref="F:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.ttdHoursInfinite"/> if there is no '<see cref="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.secondPawnHours"/>' or the current second pawn is no longer bleeding</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.GetThirdPawnHours">
            <summary></summary>
            <returns><see cref="F:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.ttdHoursInfinite"/> if there is no '<see cref="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.thirdPawnHours"/>' or the current third pawn is no longer bleeding</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.Item(System.Int32)">
            <summary></summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.LargestTTD">
            <summary>The largest (longest) Time Till Death of the current triage pawns</summary>
            <returns><see cref="F:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.ttdHoursInfinite"/> if there are no triage pawns</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.AddOrRemovePawnIfNeeded(Verse.Pawn,System.Single)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="ttd"></param>
            <returns>1 if the <paramref name="pawn"/> was added
            <para>0 if the <paramref name="pawn"/> was not added or removed</para>
            <para>-1 if the <paramref name="pawn"/> was removed</para></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.AddPawn(Verse.Pawn,System.Single)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="timeTillDeathForThisPawn"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> was added to any position in the triage, <see langword="false"/> if they were not added</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.RemovePawn(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="true"/> if the <paramref name="pawn"/> was removed from triage pawns, <see langword="false"/> if they were not removed/were not in the triage pawns in the first place</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.Clear">
            <summary>Create a <see langword="new"/> <see cref="T:NQualityOfLife.Utils.Get.Pawn_.Triage"/> instance</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Get.Pawn_.Triage.Item(RimWorld.Faction)">
            <summary></summary>
            <param name="forFaction"></param>
            <returns></returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.TriageUtils">
            <summary>Utilities for determining medical treatment priority</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.minBleedRatePerDayForTriage">
            <summary>if <code>bleedRatePerDay &lt;= minBleedRatePerDayForTriage</code> the <see cref="T:Verse.Pawn"/> is <b>not</b> eligible for triage</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.minBleedOutHoursForTriage">
            <summary>if <code>bleedOutHours &lt;= minBleedOutHoursForTriage</code> the <see cref="T:Verse.Pawn"/> is <b>not</b> eligible for triage</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.TimeTillDeath_String(Verse.Pawn,System.Single)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="ttdHours"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.FormatDeadlyHediffsForDisplay(System.Collections.Generic.List{System.ValueTuple{Verse.Hediff,System.Single,System.Single}},System.Single,System.Boolean)">
            <summary></summary>
            <param name="deadlyHediffs"></param>
            <param name="minSeverityForDisplay"></param>
            <param name="onlyReturnWorst"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="deadlyHediffs"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.DeadlyHediffs(Verse.Pawn)">
            <summary>Get all the hediffs that can cause the pawn to die</summary>
            <param name="pawn"></param>
            <returns><see langword="null"/> if no deadly hediffs found</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.TimeTillDeathForTriage(Verse.Pawn,RimWorld.Faction,System.Boolean)">
            <summary>Method for estimating time till death in hours for tendable hediffs like bleeding</summary>
            <param name="pawn">Estimate time till death for this pawn</param>
            <param name="hasHediffsNeedingTend"></param>
            <param name="saveTriageForFaction">Leave as <see langword="default"/> unless you know what you are doing</param>
            <returns><see langword="float"/> of time left in hours or <see cref="F:System.Single.MaxValue"/></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.TimeTillDeath(Verse.Pawn,System.Boolean,RimWorld.Faction)">
            <summary>Method for estimating time till death in hours</summary>
            <param name="pawn">Estimate time till death for this pawn</param>
            <param name="hasHediffsNeedingTendOrStarving">Skip check for hediffs if we already know</param>
            <param name="saveTriageForFaction">Leave as <see langword="default"/> unless you know what you are doing</param>
            <returns><see langword="float"/> of time left in hours or <see cref="F:NQualityOfLife.Utils.Get.Pawn_.TriageUtils.ttdHoursInfinite"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.WithBest">
            <summary>Utilities for getting the pawn with the best value of something</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.WithBest.Stat(Verse.Map,RimWorld.StatDef,Verse.WorkTypeDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Method for getting the pawn with the best stat</summary>
            <param name="map">The map to check for pawns, if null, will try to find map</param>
            <param name="greaterIsBetter"> larger values are better</param>
            <param name="stat"> the StatDef to check</param>
            <param name="mustBeCapable"> Return the best pawn that is capable?</param>
            <param name="mustBeAwake"> Get the best pawn from the pawns that are awake?</param>
            <param name="workType"> The pawn must be assigned to the relevant work-type to be considered, if set to null, will not be considered</param>
            <param name="mustNotBeOccupied"> Don't return pawns that are currently operating? </param>
            <param name="postProcess"> postProcess for GetStatValue()</param>
            <param name="forceGetFresh"></param>
            <returns>Pawn bestPawn and float statValue</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.TechLevel_">
            <summary>Utilities for getting tech-level related values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.Color(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="finished"></param>
            <param name="locked"></param>
            <returns>The color for the current state of this research</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.ColorHex(RimWorld.TechLevel,System.Boolean)">
            <summary>Gets the color associated with the provided tech level.</summary>
            <param name="techLevel"></param>
            <param name="noErrorOnInvalid"></param>
            <returns>UnityEngine.Color for the tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.OfFaction(RimWorld.Faction)">
            <summary>Method for getting the research level of a specified faction</summary>
            <param name="faction">The faction to check</param>
            <returns>the tech level of the faction</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.OfPlayer">
            <summary>Get the current player tech level</summary>
            <returns>the tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.ResearchStats(RimWorld.TechLevel,System.Boolean)">
            <summary>
            Retrieves statistics about completed research projects, including the number of completed projects,
            the total number of research projects, and the number of projects completed at a specific research level.
            </summary>
            <param name="checkLevelCompletion_Level">The research level to check for completed projects.</param>
            <param name="debug"></param>
            <returns>
            A tuple containing:
            - The highest level of research achieved.
            - The count of completed projects.
            - The total count of research projects.
            - The count of completed projects at the specified research level.
            - The total count of projects at the specified research level.
            - The count of completed projects at the next research level.
            - The total count of projects at the next research level.
            </returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_PrintSettings">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_PrintSettings.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_PreviewSound">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_PreviewSound.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Doc">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Doc.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Trade">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Trade.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_TryCreate_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_TryCreate_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_TryFillRooms_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_TryFillRooms_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_PrintHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_PrintHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_AnnexRooms_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_AnnexRooms_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_ValidateHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_ValidateHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_DeleteHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_DeleteHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.TechLevel_">
            <summary>Utilities for setting tech level values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.TechLevel_.OfPlayer(RimWorld.TechLevel,System.Boolean)">
            <summary>Sets the player factions tech level to the provided level</summary>
            <param name="newTechLevel">The research level to set</param>
            <param name="debug"></param>
            <returns><see langword="true"/> if level changed, <see langword="false"/> if level was not changed</returns>
        </member>
        <member name="T:NQualityOfLife.Exceptions.DimensionMismatchException">
            <summary>thrown when an attempt is made to compare or perform arithmetic operations on incompatible units</summary>
        </member>
        <member name="M:NQualityOfLife.Exceptions.DimensionMismatchException.#ctor(System.String)">
            <inheritdoc cref="T:NQualityOfLife.Exceptions.DimensionMismatchException"/>
            <summary></summary>
            <param name="message"></param>
        </member>
        <member name="M:NQualityOfLife.Exceptions.DimensionMismatchException.#ctor(System.String,System.Exception)">
            <inheritdoc cref="T:NQualityOfLife.Exceptions.DimensionMismatchException"/>
            <summary></summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:NQualityOfLife.Exceptions.InternalLogicException">
            <summary>Thrown when the result of an operation is not what is expected</summary>
        </member>
        <member name="T:NQualityOfLife.Exceptions.InternalDataException">
            <summary>Thrown when data stored in an <see cref="T:System.Object"/> is detected to be in an invalid, impossible or corrupted state</summary>
        </member>
        <member name="M:NQualityOfLife.Exceptions.InternalDataException.#ctor">
            <inheritdoc cref="T:NQualityOfLife.Exceptions.InternalDataException"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.InternalDataException.#ctor(System.String)">
            <inheritdoc cref="M:NQualityOfLife.Exceptions.InternalDataException.#ctor"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.InternalDataException.#ctor(System.String,System.Exception)">
            <inheritdoc cref="M:NQualityOfLife.Exceptions.InternalDataException.#ctor"/>
        </member>
        <member name="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException">
            <summary>Thrown when an argument is <see langword="null"/> or empty when it is expected to be non-<see langword="null"/> and to contain at least one item</summary>
            <inheritdoc cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException.#ctor">
            <inheritdoc cref="M:System.ArgumentNullException.#ctor"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException.#ctor(System.String)">
            <inheritdoc cref="M:System.ArgumentNullException.#ctor(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException.#ctor(System.String,System.String)">
            <inheritdoc cref="M:System.ArgumentNullException.#ctor(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException.#ctor(System.String,System.Exception)">
            <inheritdoc cref="M:System.ArgumentNullException.#ctor(System.String,System.Exception)"/>
        </member>
        <member name="T:NQualityOfLife.Exceptions.ArgumentEmptyException">
            <summary>Thrown when an argument is empty when it is expected to contain at least one item</summary>
            <inheritdoc cref="T:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.ArgumentEmptyException.#ctor(System.String)">
            <inheritdoc cref="M:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException.#ctor(System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.ArgumentEmptyException.#ctor(System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException.#ctor(System.String,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Exceptions.ArgumentEmptyException.#ctor(System.String,System.Exception)">
            <inheritdoc cref="M:NQualityOfLife.Exceptions.ArgumentNullOrEmptyException.#ctor(System.String,System.Exception)"/>
        </member>
        <member name="M:NQualityOfLife.QA.SelfScan.ScanTranslations(System.Diagnostics.Stopwatch@,System.Threading.CancellationToken@)">
            <summary>Scans the mod translation files for any issues</summary>
        </member>
        <member name="M:NQualityOfLife.QA.SelfScan.TestAllMyTypes(System.Reflection.Assembly,System.Boolean,System.Diagnostics.Stopwatch,NQualityOfLife.Utils.Threading.LongTaskHandler.LongTaskTracker{System.Diagnostics.Stopwatch})">
            <summary>Scans all the classes and methods of this mod to make sure everything is ready for a public release</summary>
            <param name="assembly"></param>
            <param name="getTodoList"></param>
            <param name="translationScanTime"></param>
            <param name="translationScanTask"></param>
        </member>
        <member name="M:NQualityOfLife.QA.SelfScan.TestMethodOrType(System.Reflection.MemberInfo,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Collections.Generic.List{System.String})">
            <summary></summary>
            <param name="methodOrType"></param>
            <param name="isMethod"></param>
            <param name="isConstructor"></param>
            <param name="isClass"></param>
            <param name="isField"></param>
            <param name="todoList"></param>
            <returns><see langword="true"/> if we should scan the inner types of the given '<paramref name="methodOrType"/>'</returns>
        </member>
        <member name="T:NQualityOfLife.Attributes.CustomAttribute">
            <summary>Base <see langword="class"/> for all <see cref="N:NQualityOfLife"/> <seealso cref="T:System.Attribute">attributes</seealso></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.WithDateAttribute">
            <summary>Abstract attribute that has <see cref="T:System.DateTime"/> data</summary>
            <remarks>Used in attributes like <see cref="T:NQualityOfLife.Attributes.AuthorsAttribute"/> or <see cref="T:NQualityOfLife.Attributes.ToDoAttribute"/>
            <para>The <see cref="T:NQualityOfLife.Attributes.ToDoAttribute"/> uses the <see cref="P:NQualityOfLife.Attributes.WithDateAttribute.Date"/> data to help keep track of tasks</para></remarks>
        </member>
        <member name="P:NQualityOfLife.Attributes.WithDateAttribute.Date">
            <summary>The <see cref="T:System.DateTime"/> data for <see langword="this"/> instance<para>Exact meaning depends on the overriding class</para></summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor">
            <summary>This constructor will create an <b>invalid</b> date</summary>
            <remarks>The <b>invalid</b> date is represented with <see cref="F:System.DateTime.MaxValue"/></remarks>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)">
            <summary>Date from <paramref name="day"/>, <paramref name="month"/>, <paramref name="year"/></summary>
            <param name="day">1~31</param>
            <param name="month">1~12</param>
            <param name="year">0~<seealso cref="F:System.UInt16.MaxValue">65535</seealso></param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,NQualityOfLife.Types.Month,System.Int32)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Int32,System.Byte,System.Byte)">
            <summary>Date from <paramref name="year"/>, <paramref name="month"/>, <paramref name="day"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.UInt16,System.Byte,System.Byte)">
            <summary>Date from <paramref name="year"/>, <paramref name="month"/>, <paramref name="day"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.UInt16,NQualityOfLife.Types.Month,System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.UInt16,System.Byte,System.Byte)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,NQualityOfLife.Types.Month,System.UInt16)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.UInt16,NQualityOfLife.Types.Month)">
            <summary>Date from <paramref name="day"/>, <paramref name="year"/>, <paramref name="month"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.UInt16,System.Byte,NQualityOfLife.Types.Month)">
            <summary>Date from <paramref name="year"/>, <paramref name="day"/>, <paramref name="month"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(NQualityOfLife.Types.Month,System.Byte,System.UInt16)">
            <summary>Date from <paramref name="month"/>, <paramref name="day"/>, <paramref name="year"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(NQualityOfLife.Types.Month,System.UInt16,System.Byte)">
            <summary>Date from <paramref name="month"/>, <paramref name="year"/>, <paramref name="day"/></summary>
            <inheritdoc cref="M:NQualityOfLife.Attributes.WithDateAttribute.#ctor(System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.WithDateAttribute.ValidateDate(System.DateTime@)">
            <summary></summary>
            <param name="today"></param>
            <returns><see langword="true"/> if the given <see cref="P:NQualityOfLife.Attributes.WithDateAttribute.Date"/> is valid for <see langword="this"/> <see cref="T:System.Attribute"/> <see cref="T:System.Type"/></returns>
        </member>
        <member name="F:NQualityOfLife.Attributes.CompatibilityAttribute.Promises.None">
            <summary>The member may change name or signiature, it may be moved or completely removed, or it's members may be modified, unless the member has a '<see cref="T:NQualityOfLife.Attributes.CompatibilityAttribute"/>' of it's own</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.CompatibilityAttribute.Promises.PreserveSigniature">
            <summary>The member signiature will not be changed till the given time, after it may or may not be changed</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.RecursiveAttribute">
            <summary>The method is <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#recursive">recursive</see> on itself directly, or through other methods</summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.RecursiveAttribute.#ctor">
            <summary>The method calls itself / Is <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#recursive">recursive</see> on itself</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.LazyAttribute">
            <summary>The method returns a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#lazy">lazy</see> <see cref="T:System.Collections.Generic.IEnumerable`1"/> and/or enumerates the inputs <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#lazy">lazily</see><para>The opposite of <see cref="T:NQualityOfLife.Attributes.EagerAttribute"/></para></summary>
            <remarks>All methods that have an input <see cref="T:System.Collections.Generic.IEnumerable`1"/> or return an <see cref="T:System.Collections.Generic.IEnumerable`1"/> should have <seealso cref="T:NQualityOfLife.Attributes.LazyAttribute">this attribute</seealso> or the <see cref="T:NQualityOfLife.Attributes.EagerAttribute"/> to clarify the behaviour</remarks>
        </member>
        <member name="T:NQualityOfLife.Attributes.EagerAttribute">
            <summary>The method <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#eager">eagerly</see> <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#iteration">iterates</see> any input <see cref="T:System.Collections.Generic.IEnumerable`1"/> or the output is not a <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#lazy">lazy</see> <see cref="T:System.Collections.Generic.IEnumerable`1"/><para>The opposite of <see cref="T:NQualityOfLife.Attributes.LazyAttribute"/></para></summary>
            <remarks>Should only be applied to <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#eager">eager</see> methods that have an input <see cref="T:System.Collections.Generic.IEnumerable`1"/> parameter or return a <see cref="T:System.Collections.Generic.IEnumerable`1"/> because methods that do not input or output a <see cref="T:System.Collections.Generic.IEnumerable`1"/> are known to be <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#eager">eager</see></remarks>
        </member>
        <member name="T:NQualityOfLife.Attributes.LicenseAttribute">
            <summary>Specifies that the decorated member is subject to a specific license, which may differ from the overall software license.</summary>
            <remarks>Members without a <see cref="T:NQualityOfLife.Attributes.LicenseAttribute"/> should be interpreted as <see href="https://en.wikipedia.org/wiki/All_rights_reserved">All rights reserved</see> unless a broader license applies to the entire software.
            <para>The <see cref="T:NQualityOfLife.Attributes.LicenseAttribute"/> can also be applied to an <see cref="T:System.Reflection.Assembly"/> by putting it into the AssemblyInfo.cs like this: <code>[assembly: License(LicenseAttribute.LicenseKind.AllRightsReserved)]</code></para></remarks>
        </member>
        <member name="M:NQualityOfLife.Attributes.LicenseAttribute.#ctor(NQualityOfLife.Attributes.LicenseAttribute.LicenseKind,System.String)">
            <summary>The member is subject to a specific license</summary>
            <param name="licenseType">The license type/template that applies.</param>
            <param name="licenseLocalPath">The relative path to the license document from the project root.</param>
            <exception cref="T:System.ArgumentException">Thrown when <paramref name="licenseType"/> is <see cref="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.Other"/> and <paramref name="licenseLocalPath"/> is <see langword="null"/> or empty.</exception>
            <inheritdoc cref="P:NQualityOfLife.Attributes.LicenseAttribute.LicenseType"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.LicenseAttribute.#ctor(NQualityOfLife.Attributes.LicenseAttribute.LicenseKind)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.LicenseAttribute.#ctor(NQualityOfLife.Attributes.LicenseAttribute.LicenseKind,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.LicenseAttribute.#ctor(System.String,NQualityOfLife.Attributes.LicenseAttribute.LicenseKind)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.LicenseAttribute.#ctor(NQualityOfLife.Attributes.LicenseAttribute.LicenseKind,System.String)"/>
        </member>
        <member name="P:NQualityOfLife.Attributes.LicenseAttribute.LicensePath">
            <summary>The relative file path to the license document, starting from the root of the project.<para>If <see cref="P:NQualityOfLife.Attributes.LicenseAttribute.LicensePath"/> is <see langword="null"/>, the specified <see cref="P:NQualityOfLife.Attributes.LicenseAttribute.LicenseType"/> applies.</para></summary>
            <inheritdoc cref="P:NQualityOfLife.Attributes.LicenseAttribute.LicenseType"/>
        </member>
        <member name="P:NQualityOfLife.Attributes.LicenseAttribute.LicenseType">
            <summary>The type of license that applies to the member.</summary>
            <remarks>
            If a license document is provided via <see cref="P:NQualityOfLife.Attributes.LicenseAttribute.LicensePath"/>, its contents take precedence over the specified <see cref="P:NQualityOfLife.Attributes.LicenseAttribute.LicenseType"/>.
            </remarks>
        </member>
        <member name="T:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind">
            <summary><see cref="T:System.Enum"/> describing common license templates.</summary>
            <inheritdoc cref="P:NQualityOfLife.Attributes.LicenseAttribute.LicenseType"/>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.Other">
            <summary>The license does not match a known template listed in <see cref="T:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind"/>.</summary>
            <remarks>A license document/file must be provided if the <see cref="T:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind"/> is set to <see cref="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.Other"/>!</remarks>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.AllRightsReserved">
            <summary><see href="https://en.wikipedia.org/wiki/All_rights_reserved">All Rights Reserved</see></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.MITLicense">
            <summary><see href="https://en.wikipedia.org/wiki/MIT_License">MIT License</see></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.ApacheLicense">
            <summary><see href="https://en.wikipedia.org/wiki/Apache_License">Apache License 2.0</see></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.GNUGeneralPublicLicense">
            <summary><see href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GNU GPL</see></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.Unlicense">
            <summary><see href="https://unlicense.org/">Unlicense</see></summary>
            <remarks>Public domain</remarks>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.CreativeCommonsAttribution">
            <summary><see href="https://creativecommons.org/licenses/by/4.0/"/>
            <para></para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.CreativeCommonsAttributionShareAlike">
            <summary><see href="https://creativecommons.org/licenses/by-sa/4.0/"/>
            <para></para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.CreativeCommonsAttributionNonCommercial">
            <summary><see href="https://creativecommons.org/licenses/by-nc/4.0/"/>
            <para></para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.CreativeCommonsAttributionNonCommercialShareAlike">
            <summary><see href="https://creativecommons.org/licenses/by-nc-sa/4.0/"/>
            <para></para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.CreativeCommonsAttributionNoDerivatives">
            <summary><see href="https://creativecommons.org/licenses/by-nd/4.0/"/>
            <para></para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.CreativeCommonsAttributionNonCommercialNoDerivatives">
            <summary><see href="https://creativecommons.org/licenses/by-nd/4.0/"/>
            <para></para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.LicenseAttribute.LicenseKind.CC0Universal">
            <summary><see href="https://creativecommons.org/publicdomain/zero/1.0/"/>
            <para></para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ExperimentalAttribute">
            <summary>Marks a method or class as experimental, Meaning it is still in development and could be unstable or un-optimized.</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ThreadSafeAttribute">
            <summary>The method can be safely used with async tasks and multithreading<para>The opposite of <see cref="T:NQualityOfLife.Attributes.ThreadUnsafeAttribute"/></para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ThreadUnsafeAttribute">
            <summary><para>The opposite of <see cref="T:NQualityOfLife.Attributes.ThreadSafeAttribute"/></para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.MustImplementAttribute">
            <summary>Specifies that a member that implements all the parent interfaces of the decorated <see langword="interface"/> must also implement the decorated <see langword="interface"/></summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.MustImplementAttribute.CheckAllSatisfied(System.Reflection.Assembly)">
            <summary></summary>
            <param name="assembly"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Attributes.MustImplementAttribute.Satisfied(System.Type[],System.Type,System.Type[])">
            <summary></summary>
            <param name="allTypes"></param>
            <param name="decoratedInterface"></param>
            <param name="decoratedInterfaceParents"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="allTypes"/>, <paramref name="decoratedInterface"/> or <paramref name="decoratedInterfaceParents"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.Attributes.MustImplementAttribute.Satisfied(System.Type,System.Type,System.Type[])">
            <summary></summary>
            <param name="type"></param>
            <param name="decoratedInterface"></param>
            <param name="decoratedInterfaceParents"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/>, <paramref name="decoratedInterface"/> or <paramref name="decoratedInterfaceParents"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Attributes.MustUseReturnAttribute">
            <summary>The return value must be used!</summary>
            <remarks>Marking methods that have the '<see cref="T:System.Diagnostics.Contracts.PureAttribute"/>' using this attribute is redundant and not required</remarks>
        </member>
        <member name="T:NQualityOfLife.Attributes.PureIshAttribute">
            <summary>The return value must be used, and the method doesn't have side effects - Error logging/throwing is allowed in case of internal errors, or the input is obviously invalid such as <see langword="null"/></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegal">
            <summary>The method may <see langword="throw"/> an error on an illegal argument</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegal">
            <summary>The method may log an error on an illegal argument</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.NullArgsMayBeIllegal">
            <summary>Passing a <see langword="null"/> to a non-nullable parameter may be illegal, and cause an error or <see cref="T:System.ArgumentNullException"/></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.RangeArgsMayBeIllegal">
            <summary>Passing out of range values may be illegal, and cause an error or <see cref="T:System.ArgumentOutOfRangeException"/></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.ArgsMayBeIllegal">
            <summary>Passing an argument may be invalid for some reason other than <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.NullArgsMayBeIllegal">nullability</see> or <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.RangeArgsMayBeIllegal">range</see></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalNull">
            <summary>The method may log on error if a <see langword="null"/> is passed to a non-nullable parameter
            <para>but the method will not <see langword="throw"/> and will give a <see langword="return"/> value</para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalRange">
            <summary>The method may log on error if a parameter is passed that is out of range of allowed values
            <para>but the method will not <see langword="throw"/> and will give a <see langword="return"/> value</para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayErrorOnIllegalArg">
            <summary>The method may log on error if a given argument is invalid for some reason that is not <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.NullArgsMayBeIllegal">nullability</see> or <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.RangeArgsMayBeIllegal">range</see>
            <para>but the method will not <see langword="throw"/> and will give a <see langword="return"/> value</para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalNull">
            <summary>The method may <see langword="throw"/> a <see cref="T:System.ArgumentNullException"/> if a <see langword="null"/> is passed to a non-nullable parameter</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalRange">
            <summary>The method may <see langword="throw"/> a <see cref="T:System.ArgumentOutOfRangeException"/> if a parameter is passed that is out of range of allowed values</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.MayThrowOnIllegalArg">
            <summary>The method may <see langword="throw"/> a <see cref="T:System.ArgumentException"/> of some form if a given argument is invalid for some reason that is not <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.NullArgsMayBeIllegal">nullability</see> or <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.RangeArgsMayBeIllegal">range</see></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.AssertPureCall">
            <summary>Used with '<see cref="T:NQualityOfLife.Attributes.InterfaceForAttribute"/>' to assert that the called <see cref="T:NQualityOfLife.Attributes.PureIshAttribute">PureIsh</see> method will act like a <see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see> method when called from the decorated <see cref="T:NQualityOfLife.Attributes.InterfaceForAttribute">interface method</see>
            <para>Or when a <see cref="T:NQualityOfLife.Attributes.PureIshAttribute">Pureish</see> method calls another <see cref="T:NQualityOfLife.Attributes.PureIshAttribute">Pureish</see> that has less strict <see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises"/> but is safe when called by the decorated method, in this case the <see cref="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.AssertPureCall">AssertPureCall</see> asserts on all called methods</para></summary>
            <remarks>This <see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises">Promise</see> is intended for analyzers to indicate that the exception cases are guarded</remarks>
        </member>
        <member name="F:NQualityOfLife.Attributes.PureIshAttribute.Promises.AssumingPureInterface">
            <summary>The method is <see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see> assuming that the passed <see langword="interface"/> parameter is implemented in a <see cref="T:System.Diagnostics.Contracts.PureAttribute">Pure</see> / expected way
            <para>Meaning the <see langword="interface"/> parameter follows common conventions</para>
            <para>For example a method that takes a '<see cref="T:System.Collections.Generic.IList`1"/>' or '<see cref="T:System.Collections.Generic.ICollection`1"/>' as an argument assumes that the '<see cref="P:System.Collections.Generic.ICollection`1.Count"/>' parameter call will not have side effects</para>
            <para>Additionally this <see cref="T:NQualityOfLife.Attributes.PureIshAttribute.Promises">promise</see> assures that the decorated method will not cause any <see cref="T:System.Exception">exceptions</see> listed in the documentation of the <see langword="interface"/></para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ImpureAttribute">
            <summary>The method has side effects or the return is not always the same for the same inputs
            <para>For example all <see cref="T:NQualityOfLife.Utils.Rand"/> methods are generally <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#impure">impure</see></para>
            <para>Methods with a <see langword="void"/> <see langword="return"/> type and no <see langword="ref"/> or <see langword="out"/> parameters are more often than not <see cref="T:NQualityOfLife.Attributes.ImpureAttribute">Impure</see></para>
            <para>The opposite of <see cref="T:System.Diagnostics.Contracts.PureAttribute"/></para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.UsesRNG">
            <summary>The method uses RNG in some way, such as <see cref="M:System.Random.Next"/></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.UsesTime">
            <summary>The output of the method depends on the current <see cref="P:System.DateTime.Now"/> or similar</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.NonDeterministic">
            <summary>The method may give different results for the same inputs, or the results may be given in a different order</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.Async">
            <summary>The method uses async tasks or background threads in a way that is not deterministic or not-pure</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.ReadsGlobalState">
            <summary>The output of the method depends on the global state of the '<see cref="T:System.AppDomain"/>', such as by reading <see langword="static"/> fields</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.WritesGlobalState">
            <summary>The method modifies global state of the '<see cref="T:System.AppDomain"/>' in some way, such as writing <see langword="static"/> fields</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.IOFileRead">
            <summary>The method will read from disk</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.IOFileWrite">
            <summary>The method will modify, create or delete files and or folders</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.Render">
            <summary>The method will cause something to be drawn on screen</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.Audio">
            <summary>The method may output audio from the device speakers</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.WebRead">
            <summary>The method uses web requests or similar to determine an output</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.LogMessage">
            <summary>The method may log warnings, messages or errors during normal operation
            <para>Errors caused by invalid or illegal parameter are not considered normal operation, see: <see cref="T:NQualityOfLife.Attributes.PureIshAttribute"/></para></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.CultureDependant">
            <summary>Output may depend on <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.OSAction">
            <summary>The method will start, stop or modify applications or other system state outside of the <see cref="T:System.AppDomain"/></summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.HardwareDependant">
            <summary>The method may return different results based on the hardware that the program is running on</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.OSDependant">
            <summary>The method may return different results based on the OS that the program is running on</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.InputDeviceRead">
            <summary>The method may read mouse, keyboard or other input devices, for example using '<see cref="M:System.Console.ReadKey"/>'</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.HardwareDeviceWrite">
            <summary>The method may write to, send commands to or in some other way affect the state of connected hardware devices</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ImpureAttribute.Impurity.SystemStateRead">
            <summary>The output of the method may depend on the state of the system outside of the <see cref="T:System.AppDomain"/></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.MutatesAttribute">
            <summary>The specified parameters are <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#mutation">mutated</see> by the method
            <para>If the given parameter names is <see langword="null"/> or empty, the <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#instance">instance</see> is <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#mutation">mutated</see></para></summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.MutatesAttribute.#ctor">
            <inheritdoc cref="M:NQualityOfLife.Attributes.MutatesAttribute.#ctor(System.String[])"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.MutatesAttribute.#ctor(System.Boolean)">
            <summary>The method mutates the instance</summary>
            <inheritdoc cref="M:NQualityOfLife.Attributes.MutatesAttribute.#ctor(System.String[])"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.MutatesAttribute.#ctor(System.String[])">
            <summary>The method mutates the specified parameter(s)</summary>
            <param name="parameterNames"></param>
            <remarks>If <paramref name="parameterNames"/> is <see langword="null"/> or empty, the <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#instance">instance</see> is <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#mutation">mutated</see></remarks>
        </member>
        <member name="M:NQualityOfLife.Attributes.MutatesAttribute.#ctor(System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.MutatesAttribute.#ctor(System.String[])"/>
        </member>
        <member name="T:NQualityOfLife.Attributes.MutatedAttribute">
            <summary>The specified parameter is <see href="https://github.com/Niilo007/RimWorld-NQoL/wiki/Coding-Standards-And-Practices#mutation">mutated</see> by the method, or read only if set to <see langword="false"/>, default is <see langword="true"/></summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.MutatedAttribute.#ctor(System.Boolean)">
            <summary>Specify if the given parameter is mutated or read only</summary>
            <param name="isMutated"></param>
        </member>
        <member name="T:NQualityOfLife.Attributes.SourceAttribute">
            <summary>Where something was sourced from and when</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.SourcesAttribute">
            <inheritdoc cref="T:NQualityOfLife.Attributes.SourceAttribute"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.SourcesAttribute.#ctor(System.Int32,System.Byte,System.Byte,System.String[],System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.SourceAttribute.#ctor(System.Int32,System.Byte,System.Byte)"/>
        </member>
        <member name="T:NQualityOfLife.Attributes.AuthorsAttribute">
            <summary>Information about when the member was modified and by whom</summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.Byte,System.Byte,System.UInt16,System.String)">
            <summary>This member was created/edited by the indicated <paramref name="author"/> on the given date</summary>
            <param name="author">The name of the person who created/edited this member</param>
            <param name="year">The year that the edit was made</param>
            <param name="month">The month of the <paramref name="year"/> that the edit was made</param>
            <param name="day">The day of the <paramref name="month"/> that the edit was made</param>
            <param name="comment">Optional comment with any additional information</param>
        </member>
        <member name="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.Double,System.Byte,System.UInt16,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.Byte,System.Byte,System.UInt16,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.Byte,System.Double,System.UInt16,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.Byte,System.Byte,System.UInt16,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.UInt16,System.Byte,System.Double,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.UInt16,NQualityOfLife.Types.Month,System.Byte,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.UInt16,System.Byte,System.Byte,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.UInt16,NQualityOfLife.Types.Month,System.Byte,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.UInt16,NQualityOfLife.Types.Month,System.Byte,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.Byte,System.Byte,System.UInt16,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.UInt16,System.Double,NQualityOfLife.Types.Month,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.Byte,System.Byte,System.UInt16,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.UInt16,System.Double,System.Byte,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.AuthorsAttribute.#ctor(System.String,System.Byte,System.Byte,System.UInt16,System.String)"/>
        </member>
        <member name="T:NQualityOfLife.Attributes.AliasAttribute">
            <summary>The method is identical to another method with a different name</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ImplicitOperatorAttribute">
            <summary><see langword="implicit"/> <see langword="operator"/>s should be marked with this attribute</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.InterfaceForAttribute">
            <summary>The method is used to make calling another method easier<para>For example it is the public member that then calls internal methods</para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ToDoAttribute">
            <summary>Attribute for keeping track of things that need to be done</summary>
        </member>
        <member name="F:NQualityOfLife.Attributes.ToDoAttribute.VersionDeadline">
            <summary>The QA system will give warnings and errors when the mod/game version matches this version</summary>
        </member>
        <member name="P:NQualityOfLife.Attributes.ToDoAttribute.VersionIsGameVersion">
            <summary>If this is <see langword="true"/> then the <see cref="F:NQualityOfLife.Attributes.ToDoAttribute.VersionDeadline"/> is the major game version, such as 1.5, 1.6 etc<para>If this is <see langword="false"/>, then it is the mod version, such as 2.2.3, 2.5.0 etc</para></summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.ToDoAttribute.#ctor(System.String,System.Boolean)">
            <summary><see cref="T:NQualityOfLife.Attributes.ToDoAttribute"/> with no version or date deadline</summary>
            <param name="toDo">What needs to be done?</param>
            <param name="critical">Is critical</param>
        </member>
        <member name="M:NQualityOfLife.Attributes.ToDoAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary><see cref="T:NQualityOfLife.Attributes.ToDoAttribute"/> with version deadline</summary>
            <param name="toDo">What needs to be done?</param>
            <param name="versionDeadline">This needs to be done when we reach this version</param>
            <param name="critical">Is critical</param>
        </member>
        <member name="M:NQualityOfLife.Attributes.ToDoAttribute.#ctor(System.String,System.Int16,System.Byte,System.Byte,System.Boolean)">
            <summary><see cref="T:NQualityOfLife.Attributes.ToDoAttribute"/> with date deadline</summary>
            <param name="toDo">What needs to be done?</param>
            <param name="critical">Is critical</param>
            <param name="deadLine_year">Deadline year</param><param name="deadLine_month">Deadline month</param><param name="deadLine_day">Deadline day</param>
        </member>
        <member name="M:NQualityOfLife.Attributes.ToDoAttribute.#ctor(System.String,System.Boolean,System.Int16,System.Byte,System.Byte)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.ToDoAttribute.#ctor(System.String,System.Int16,System.Byte,System.Byte,System.Boolean)"/>
        </member>
        <member name="T:NQualityOfLife.Attributes.MustRefactorAttribute">
            <summary>Used to mark code that will have to be updated on major game version changes</summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.MustRefactorAttribute.#ctor(System.String)">
            <summary>The code must be refactored on major game version change</summary>
            <param name="majorGameVersion">The next major game version, such as 1.5, 1.6, 1.7 etc</param>
        </member>
        <member name="T:NQualityOfLife.Attributes.TryPatchAttribute">
            <summary>Call: <see cref="M:NQualityOfLife.HarmonyPatches.ApplyHarmonyPatchesByAttributes(System.Reflection.Assembly,HarmonyLib.Harmony)"/> once to apply all patches marked with the <see cref="T:NQualityOfLife.Attributes.TryPatchAttribute"/></summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.TryPatchAttribute.#ctor">
            <inheritdoc cref="T:NQualityOfLife.Attributes.TryPatchAttribute"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.TryPatchAttribute.#ctor(System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.TryPatchAttribute.#ctor"/>
        </member>
        <member name="T:NQualityOfLife.Attributes.PatchIfEnabledAttribute">
            <summary>Used on harmony patch classes to conditionally apply the patches<para>Should only be applied to classes with a <see cref="T:HarmonyLib.HarmonyPatch"/> attribute</para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.TestedAttribute">
            <summary>The relevant feature was tested in game and confirmed to work (or not) as designed.</summary>
        </member>
        <member name="P:NQualityOfLife.Attributes.TestedAttribute.Works">
            <summary><see langword="true"/> if confirmed to work, else <see langword="false"/></summary>
        </member>
        <member name="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Int16,System.Byte,System.Byte,System.String[])">
            <summary>The decorated member has been confirmed to work by the given testers</summary>
            <param name="day"></param>
            <param name="month"></param>
            <param name="year"></param>
            <param name="testedBy">Testers who have confirmed that the decorated member works correctly</param>
        </member>
        <member name="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Byte,System.Byte,System.Int16,System.String[])">
             <inheritdoc cref="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Int16,System.Byte,System.Byte,System.String[])"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Boolean,System.String,System.Byte,System.Byte,System.Int16,System.String)">
            <summary></summary>
            <param name="confirmedToWork">Set to <see langword="false"/> if the member has been confirmed to <b>not</b> work</param>
            <param name="day"></param>
            <param name="month"></param>
            <param name="year"></param>
            <param name="testedBy"></param>
            <param name="optionalDetails"></param>
        </member>
        <member name="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Boolean,System.Byte,System.Byte,System.Int16,System.String,System.String)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Boolean,System.String,System.Byte,System.Byte,System.Int16,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Byte,System.Byte,System.Int16,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Boolean,System.String,System.Byte,System.Byte,System.Int16,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.String,System.Int16,System.Byte,System.Byte,System.String,System.Boolean)">
            <inheritdoc cref="M:NQualityOfLife.Attributes.TestedAttribute.#ctor(System.Boolean,System.String,System.Byte,System.Byte,System.Int16,System.String)"/>
        </member>
        <member name="T:NQualityOfLife.Attributes.HasQATesterAttribute">
            <summary>This method has a QA tester to ensure functionality and or performance</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.UsedInQATesterAttribute">
            <summary>The method is used to verify the results of a QA test<para>for this reason all methods with the <see cref="T:NQualityOfLife.Attributes.UsedInQATesterAttribute"/> should have a QA tester of their own</para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.UnusedAttribute">
            <summary>The member is not used for anything at the moment but might be in the future
            <para>Or it might be removed if no use is found</para></summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.RequiresModAttribute">
            <summary>Indicates that the method or class requires some other mod to be running in order to work</summary>
        </member>
        <member name="T:NQualityOfLife.Attributes.ExcludeFromAnalyzerXMLAttribute">
            <summary>The method or class should not be included in the Analyzer.xml file<para>This should be done if the class or method doesn't do any computations during run time or the method causes the analyzer to break</para></summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.toVar">
            <summary>The <see cref="F:NQualityOfLife.XML.PatchOperationPathed.xpath"/> is saved here after <see cref="F:NQualityOfLife.XML.PatchOperationPathed.applyVariables"/> is done / skipped</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.count">
            <summary>The variable where the patch specific count is stored. Usually the amount of nodes that matched the <see cref="F:NQualityOfLife.XML.PatchOperationPathed.xpath"/> (optional)</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.done">
            <summary>The patch to apply after this one succeedes. (optional)</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.error">
            <summary>The patch to apply if this one fails. (optional)</summary>
        </member>
        <member name="M:NQualityOfLife.XML.PatchOperationPathed.ApplyWorker(System.Xml.XmlDocument)">
            <summary>Apply variables (if <see cref="F:NQualityOfLife.XML.PatchOperationPathed.applyVariables"/> is enabled) to <see cref="F:NQualityOfLife.XML.PatchOperationPathed.xpath"/>
            <para>And then set <see cref="F:NQualityOfLife.XML.PatchOperationPathed.toVar"/> to the same <see cref="T:System.String"/> as the resulting <see cref="F:NQualityOfLife.XML.PatchOperationPathed.xpath"/></para></summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.XML.PatchOperationPathed.DoneOrError(System.Boolean,System.Xml.XmlDocument)">
            <summary>Apply the <see cref="F:NQualityOfLife.XML.PatchOperationPathed.error"/> or <see cref="F:NQualityOfLife.XML.PatchOperationPathed.done"/> path based on the <paramref name="result"/> if it exists</summary>
            <param name="result"></param>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.XML.Remove">
            <summary>Removes all matching nodes</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathedWithValue.value">
            <summary>The xml to add or replace etc</summary>
        </member>
        <member name="M:NQualityOfLife.XML.StringConcat.#ctor">
            *[JetBrains.Annotations.UsedImplicitly]*/ protected string? toVar;
            *[JetBrains.Annotations.UsedImplicitly]*/ protected bool applyVariables = true;
        </member>
        <member name="M:NQualityOfLife.AutoPlayer.SpawnBlueprint(Verse.IntVec3,Verse.ThingDef,Verse.Map,Verse.ThingDef,RimWorld.Faction,System.String)">
            <inheritdoc cref="M:NQualityOfLife.AutoPlayer.SpawnBlueprint(Verse.ThingDef,Verse.IntVec3,Verse.Map,Verse.ThingDef,RimWorld.Faction,System.String)"/>
        </member>
        <member name="M:NQualityOfLife.AutoPlayer.SpawnBlueprint(Verse.ThingDef,Verse.IntVec3,Verse.Map,Verse.ThingDef,RimWorld.Faction,System.String)">
            <summary></summary>
            <param name="thingDef"></param>
            <param name="atCell"></param>
            <param name="map"></param>
            <param name="stuff"></param>
            <param name="faction"></param>
            <param name="caller"></param>
            <returns></returns>
            <remarks><seealso cref="T:NQualityOfLife.Attributes.ThreadUnsafeAttribute">ThreadUnsafe</seealso></remarks>
        </member>
        <member name="M:NQualityOfLife.UI_.NQoL_Better_Recipe_Icons_Patch.AddIconIfNull_Postfix(Verse.ThingDef,Verse.RecipeDef)">
            <summary></summary>
            <param name="__result"></param>
            <param name="__instance"></param>
            <returns></returns>
            <remarks>When testing, and in QA build, press and hold control alt, then open the menu you are testing</remarks>
        </member>
        <member name="T:NQualityOfLife.UI_.NQoL_Better_Bed_Alert_Patch_1">
            <summary>Adds the 'x beds needed' info to the tooltip of the alert</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.Better_MedicalEmergency_Alert">
            <summary>Adds the time till death info for each sick pawn to the tooltip of the alert</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.Alert_Fatigue_Fix_MedicalEmergency">
            <summary>Remove pawns who are not actually an emergency</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.ArchitectButtonOrganizer.Action_Reset_Arch">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.ArchitectButtonOrganizer.Action_Reset_Arch.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.ArchitectButtonOrganizer.NQoL_MainTabWindow_Architect_Patch_1.UpdateCacheAndWriteSettings(System.Collections.Generic.List{RimWorld.ArchitectCategoryTab}@,RimWorld.QuickSearchWidget,RimWorld.MainTabWindow_Architect,NQualityOfLife.Settings.SettingProfile,System.Boolean)">
            <summary>Refresh the architect menu to use the new order of the tabs</summary>
            <param name="___desPanelsCached"></param>
            <param name="___quickSearchWidget"></param>
            <param name="__instance"></param>
            <param name="profile"></param>
            <param name="writeSettings"></param>
        </member>
        <member name="M:NQualityOfLife.UI_.ArchitectButtonOrganizer.NQoL_MainTabWindow_Architect_Patch_1.SwapPositions(System.Collections.Generic.List{RimWorld.ArchitectCategoryTab}@,RimWorld.QuickSearchWidget,RimWorld.MainTabWindow_Architect)">
            <summary>Swap the positions of the <see cref="F:NQualityOfLife.UI_.ArchitectButtonOrganizer.NQoL_MainTabWindow_Architect_Patch_1.swapStartDef"/> and <see cref="F:NQualityOfLife.UI_.ArchitectButtonOrganizer.NQoL_MainTabWindow_Architect_Patch_1.swapEndDef"/></summary>
            <param name="___desPanelsCached"></param>
            <param name="___quickSearchWidget"></param>
            <param name="__instance"></param>
        </member>
        <member name="T:NQualityOfLife.UI_.MainButtonOrganizer.Action_Reset_MainButtons">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.MainButtonOrganizer.Action_Reset_MainButtons.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.HyperLinks.BetterLinkIcons">
            <summary>Makes research projects have an icon, rather than the blank icon</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Drops">
            <summary>______Drops______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Caused_By">
            <summary>______Caused By______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Sources">
            <summary>______Sources______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_MadeAt">
            <summary>______Made At______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Creates">
            <summary>______Creates______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Complications">
            <summary>______Complications______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Affects_Part">
            <summary>______Affects Part______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Health_Conditions">
            <summary>______Health Conditions______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Health_Capacity">
            <summary>______Affects Capacity______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Health_Cured_By">
            <summary>______Cured By______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Health_Cures_Hediff">
            <summary>______Cures Affliction______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Affected_By">
            <summary>______Affected By______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Contains">
            <summary>______Contains______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Used_By">
            <summary>______Used By______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Requires">
            <summary>______Requires______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Unlocked_With">
            <summary>______Unlocked With______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_Unlocks">
            <summary>______Unlocks______</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.HyperLinks.LinkHelperDefOf.NQoL_HyperLinkSeparator_REDACTED">
            <summary>REDACTED</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.AddResearchLinks_Helper(Verse.Def,System.Collections.Generic.List{Verse.ResearchProjectDef})">
            <summary></summary>
            <param name="def"></param>
            <param name="researchPrerequisites"></param>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.CreateCapacityLinks(Verse.BodyPartDef)">
            <summary></summary>
            <param name="bodyPartDef"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.CreateLinkTo(Verse.Def,Verse.Def,System.Boolean)">
            <summary>Add a link from '<paramref name="addLinkInsideDef"/>' that points to '<paramref name="linkToThisDef"/>'</summary>
            <inheritdoc cref="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.CreateCrossLink(Verse.Def,Verse.Def,System.Boolean)"/>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.CreateCrossLink(Verse.Def,Verse.Def,System.Boolean)">
            <summary>Add a link from '<paramref name="fromThisDef"/>' that points to '<paramref name="linkToThisDef"/>'</summary>
            <param name="linkToThisDef"></param>
            <param name="fromThisDef"></param>
            <param name="allowDuplicates"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="linkToThisDef"/> or <paramref name="fromThisDef"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.AddSurgeryCureLink(Verse.HediffDef,Verse.RecipeDef)">
            <summary>Add a link from and to a <paramref name="recipeDef"/> that is used to cure/remove the given <paramref name="hediffCuredByRecipe"/></summary>
            <remarks>Also links to and from the <see cref="T:Verse.ThingDef"/> dropped by the <paramref name="recipeDef"/> (if any)</remarks>
            <param name="hediffCuredByRecipe"></param>
            <param name="recipeDef"></param>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.AddSurgeryAddLink(Verse.HediffDef,Verse.RecipeDef)">
            <summary>Links a <paramref name="recipeDef"/> to and from a <see cref="T:Verse.HediffDef"/> that is applied upon performing the recipe</summary>
            <remarks>Also links to and from any <see cref="F:Verse.RecipeDef.ingredients"/> used in the <paramref name="recipeDef"/> and or what is returned when reversing the <paramref name="recipeDef"/></remarks>
            <param name="hediffAddedByRecipe"></param>
            <param name="recipeDef"></param>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.AddRecipeLinks(Verse.RecipeDef)">
            <summary></summary>
            <param name="recipeDef"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="recipeDef"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.AddDeconstructLinksAndMore(Verse.ThingDef)">
            <summary></summary>
            <param name="thingDef"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="thingDef"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.AddComplicationLinks(Verse.HediffDef)">
            <summary>Adds links from the given <paramref name="hediffDef"/> to any complication hediffs that it may cause from its stages and hediff givers</summary>
            <remarks>The complications are also linked to the given <paramref name="hediffDef"/> as a cause</remarks>
            <param name="hediffDef"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="hediffDef"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.HyperLinks.HyperLinkCreator.CreateDrugLinks(Verse.ThingDef)">
            <summary>Creates links from a <paramref name="drug"/> to the possible side effect hediffs, and the chemical</summary> //and any associated addiction needs
            <remarks>The reverse links are also created pointing back at the <paramref name="drug"/></remarks>
            <param name="drug">Must have <see cref="F:Verse.ThingDef.ingestible"/> <see cref="F:RimWorld.IngestibleProperties.outcomeDoers"/></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"><paramref name="drug"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.FloatMenus.NQoL_Context_Menu_Patch_1.AddOrderPawnToSleepFloatMenuOption(System.Collections.Generic.List{Verse.FloatMenuOption},Verse.Pawn,Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="menuOptions"></param>
            <param name="selectedPawn"></param>
            <param name="clickCell"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.FloatMenus.NQoL_Context_Menu_Patch_1.AddTradeWithBestFloatMenuOption(System.Collections.Generic.List{Verse.FloatMenuOption},Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="menuOptions"></param>
            <param name="clickCell"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.UpdateMenuGreySetting.ApplyAction">
            <summary>This runs when the settings window is closed</summary>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.UI_.CompProperties_ExtraGizmos">
            <summary>Xml properties for extra gizmos</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.CompProperties_ExtraGizmos.#ctor">
            <summary>The gizmo class these properties belong to</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.CompExtraGizmos">
            <summary>Extra gizmos class</summary>
        </member>
        <member name="F:NQualityOfLife.UI_.CompExtraGizmos.__pawnGizmosSharedList">
            <summary><see cref="T:System.Collections.Generic.List`1"/> returned by <see cref="M:NQualityOfLife.UI_.CompExtraGizmos.GetNQoLPawnGizmos(Verse.Pawn)"/></summary>
        </member>
        <member name="M:NQualityOfLife.UI_.CompExtraGizmos.GetNQoLPawnGizmos(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see cref="F:NQualityOfLife.UI_.CompExtraGizmos.__pawnGizmosSharedList"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="P:NQualityOfLife.UI_.CompExtraGizmos.Props">
            <summary>Use the xml defined properties</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.CompExtraGizmos.CompGetGizmosExtra">
            <summary>IEnumerable containing all the extra gizmos</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar_Reverse.DesignateThing(Verse.Thing)">
            <summary></summary>
            <param name="t"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.AllThingsAre(System.Collections.Generic.List{System.Object})">
            <summary></summary>
            <param name="list"></param>
            <returns>The <see cref="T:Verse.ThingDef"/> that all the objects in the <paramref name="list"/> are || or <see langword="null"/> if not all the objects are the same <see cref="T:Verse.ThingDef"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.IsSimilar(Verse.Thing,Verse.Thing,Verse.ThingDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="thing"></param>
            <param name="selection"></param>
            <param name="orDef"></param>
            <param name="allMinifiedThings"></param>
            <param name="mustBeSameStuff"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.DesignateMultiCell(System.Collections.Generic.IEnumerable{Verse.IntVec3})">
            <summary></summary>
            <param name="cells"></param><exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.SelectAllSimilarThingsOnCell(Verse.IntVec3@,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="map"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException"></exception><exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.GetAllSimilarThingsOnCell(Verse.IntVec3@,Verse.Map,System.Int32@)">
            <summary>Never null</summary>
            <param name="cell"></param><param name="map"></param><param name="count"></param>
            <returns></returns><exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.DesignateThing(Verse.Thing)">
            <summary></summary>
            <param name="t"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.GizmoJumpToJobTarget(Verse.Pawn)">
            <summary></summary>
            <param name="workerPawn"></param>
            <returns>a <see langword="new"/> <see cref="T:Verse.Command_Action"/> that shows information about the current job target of the <paramref name="workerPawn"/> || <see langword="null"/> if there is no job info available</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="workerPawn"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.GizmoJumpToThing(Verse.Thing,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="thing">Will give <paramref name="failMessage"/> on click if <see langword="null"/></param>
            <param name="label"></param>
            <param name="description"></param>
            <param name="iconPath"></param>
            <param name="failMessage"></param>
            <param name="tryUseActualThingIcon"></param>
            <param name="labelIsPreTranslated"></param>
            <param name="descIsPreTranslated"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.TradeWithBestNegotiator(Verse.Map)">
            <summary>Gizmo to select the best available trader on the map</summary>
            <param name="map"></param>
            <returns>The gizmo</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.SurgeryWithBestSurgeon(Verse.Map)">
            <summary>Gizmo to select the best available surgeon on the map</summary>
            <param name="map"></param>
            <returns>The gizmo</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.GetIconFor(Verse.Thing,Verse.Thing,System.Single@,System.Single@,UnityEngine.Vector2@,UnityEngine.Color@)">
            <summary></summary>
            <param name="thingToSelect"></param>
            <param name="iconThing"></param>
            <param name="scale"></param>
            <param name="angle"></param>
            <param name="iconProportions"></param>
            <param name="color"></param>
            <returns>A <see cref="T:UnityEngine.Texture"/> icon for the <see cref="T:Verse.Thing"/> or <see cref="F:Verse.BaseContent.BadTex"/> if none found</returns>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.GizmoJumpToPawn(Verse.Pawn,System.String,System.String)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="description"></param>
            <param name="iconPath"></param>
            <returns>A <see langword="new"/> <see cref="T:Verse.Command_Action"/> that when clicked will select and jump to <paramref name="pawn"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="pawn"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.MassAndMinificationAdvanced.Minification_CompPowerPlantSteam_ErrorFix_Patch">
            <summary>Due to changes in 1.6, the generator causes errors when un installed, this patch is there to fix those issues</summary>
        </member>
        <member name="T:NQualityOfLife.MassAndMinificationAdvanced.Minification_CompPowerPlantWater_ErrorFix_Patch">
            <summary>Due to changes in 1.6, the generator causes errors when un installed, this patch is there to fix those issues</summary>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.NQoL_Minification_ErrorFix_Patch.Prefix(System.SByte)">
            <summary>Stops doors from ticking if un installed, this fixes some errors</summary>
            <param name="___mapIndexOrState"></param>
            <returns>False if should not tick</returns>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.MassPatcher.AddCategory(Verse.ThingDef,Verse.ThingCategoryDef,System.Boolean)">
            <summary>Add the <paramref name="thingDef"/> to a <see cref="T:Verse.ThingCategoryDef"/></summary>
            <param name="thingDef"></param>
            <param name="categoryDef"><see cref="F:NQualityOfLife.MassAndMinificationAdvanced.ThingCategoryDefOf.BuildingsMisc"/> by <see langword="default"/></param>
            <param name="resolveNow">When bulk patching defs, setting this to <see langword="false"/> will reduce redundant work, just remember to resolve the references after! (<see cref="M:Verse.ThingCategoryDef.ResolveReferences"/> and <see cref="M:Verse.ThingDef.ResolveReferences"/>)</param>
            <returns><see langword="true"/> if was successfully added, <see langword="false"/> if was already in a category or failed to add to one</returns>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.MassPatcher.MakeMinifiable(Verse.ThingDef,Verse.ThingCategoryDef,System.Boolean,System.Boolean)">
            <summary>Make the <paramref name="thingDef"/> be able to be minified (able to be un-installed/re-installed and stored in a stockpile)</summary>
            <param name="thingDef"></param>
            <param name="thingCategoryDef"><see cref="F:NQualityOfLife.MassAndMinificationAdvanced.ThingCategoryDefOf.BuildingsMisc"/> by <see langword="default"/></param>
            <param name="resolveCategoryNow">When bulk patching defs, setting this to <see langword="false"/> will reduce redundant work, just remember to resolve the references after! (<see cref="M:Verse.ThingCategoryDef.ResolveReferences"/>)</param>
            <param name="warnOnAlreadyHad"></param>
            <returns><see langword="false"/> if failed to make the <paramref name="thingDef"/> minifiable for any reason</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="thingDef"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.MassPatcher.AddMass(Verse.ThingDef,System.Boolean)">
            <summary>Dynamically add a proper mass value to the def - Will error if the def already has a defined mass!</summary>
            <param name="thingDef">The def that needs a mass value</param>
            <param name="debug"></param>
            <returns><see langword="true"/> if successful</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="thingDef"/> or <see cref="F:Verse.BuildableDef.statBases"/> is <see langword="null"/></exception>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.MassPatcher.Validate(Verse.ThingDef,System.Boolean,System.Boolean)">
            <summary>Checks if the <see cref="T:Verse.ThingDef"/> is valid</summary>
            <param name="thingDef"></param>
            <param name="skipMassValidation"></param>
            <param name="checkConfigErrors">Check the <see cref="M:Verse.ThingDef.ConfigErrors"/>, <paramref name="skipMassValidation"/> needs to also be <see langword="false"/></param>
            <returns><see langword="false"/> if the def has config errors etc</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="thingDef"/> is <see langword="null"/></exception>
        </member>
        <member name="T:NQualityOfLife.Plants.Plant_NoRest">
            <summary>Plant sub class for disabling rest period</summary>
        </member>
        <member name="P:NQualityOfLife.Plants.Plant_NoRest.Resting">
            <summary>Resting = always <see langword="false"/></summary>
        </member>
        <member name="T:NQualityOfLife.Plants.Plant_NoRest.NoRestPatch">
            <summary>Harmony patch to also make this work for custom plant classes in theory</summary>
        </member>
        <member name="F:NQualityOfLife.Infestation.Settings.foodAttraction">
            <summary>Is infestation food attraction enabled?</summary>
        </member>
        <member name="F:NQualityOfLife.Infestation.Settings.maxInsectLightLevel">
            <summary>float 0f - 1f</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Spot">
            <summary>The parent of all NQoL spots</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Trader_Spot">
            <summary>Spot that designates trader chillSpot</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Drop_Spot">
            <summary>Spot that designates drop pod delivery location</summary>
        </member>
        <member name="T:NQualityOfLife.AutoAssign.NQoLAction_AutoAssign_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.NQoLAction_AutoAssign_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.AutoAssign.Settings">
            <summary>Local Settings</summary>
        </member>
        <member name="F:NQualityOfLife.AutoAssign.Settings.debugMode">
            <summary>local debug mode bool</summary>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.TimeTableSetter.GetMostPopularActivityForHourForMap(Verse.Map,System.SByte,System.Boolean,RimWorld.TraitDef)">
            <summary></summary>
            <param name="map"></param>
            <param name="hour"></param>
            <param name="forSlaves"></param>
            <param name="forPawnsWithTrait"></param>
            <returns>The most popular activity for the given <paramref name="hour"/> on the given <paramref name="map"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.TimeTableSetter.AutoSetTimeTable(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <returns><see langword="true"/> if the timetable was successfully set, else <see langword="false"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.TimeTableSetter.AutoSetNightOwlSleep(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns><see langword="true"/> if <paramref name="pawn"/> timetable was changed, else <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.GetRelevantMapPawns(Verse.Map,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="map"></param>
            <param name="forSlaves"></param>
            <param name="forPrisoners"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.GetBestDrugPolicyForPawn(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.GetBestFoodPolicyForPawn(Verse.Pawn,System.Boolean,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="forPrisoners"></param>
            <param name="map"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartOutfitSetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartDrugPolicySetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartReadingPolicySetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary>Set the pawn reading policy to the most popular reading policy on the map</summary>
            <param name="pawn"></param>
            <param name="forSlaves">un-used</param>
            <param name="map"></param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartFoodPolicySetter(Verse.Pawn,System.Boolean,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="forPrisoners"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.ThreatResponseSetter.SmartThreatResponseSetter(Verse.Pawn)">
            <summary>Set HostilityResponseMode to attack if capable of violence</summary>
            <param name="pawn">Set for this pawn</param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.MedicalCareSetter.SmartMedicalCareSetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary>Set the default medical care policy based on what other pawns are set to</summary>
            <param name="pawn"></param>
            <param name="forPrisoners"></param>
            <param name="map"></param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.WorkSetter.PawnIsAboveAverageAtWorkRelatedSkill(Verse.Pawn,Verse.WorkTypeDef,RimWorld.SkillDef,System.Boolean,Verse.Map)">
            <summary>Is the given Pawn above average in the work related skill?</summary>
            <param name="pawn">This pawn</param>
            <param name="work">The work</param>
            <param name="skill">The skill relevant to the work</param>
            <param name="gameStart"></param>
            <param name="map"></param>
            <returns>True if pawn has above average skill compared to other pawns assigned to the WorkType on the map</returns>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.WorkSetter.EnableWorkIfAboveAverageSkill(Verse.Pawn,Verse.WorkTypeDef,RimWorld.SkillDef,System.Boolean,Verse.Map)">
            <summary>Set the work type to active and set priority if the <paramref name="pawn"/> is above average in <paramref name="skill"/> at the work type compared to the other pawns on the <paramref name="map"/>.</summary>
            <param name="pawn"></param>
            <param name="work"></param>
            <param name="skill"></param>
            <param name="gameStart"></param>
            <param name="map"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.WorkSetter.SmartPriorityLevelSetter(Verse.Pawn,Verse.WorkTypeDef,RimWorld.SkillDef,System.Boolean)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="work"></param>
            <param name="skill"></param>
            <param name="fallback"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo">
            <summary>Place worker for preventing placing adjacent to something</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.preventPlacingNextToType">
            <summary>Prevent placing next to thing of this type</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.allowTouchingCorners">
            <summary>Are corners allowed to touch?</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.checkForBlueprintsAndFrames">
            <summary>Check for unfinished versions of the thing</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.errorMessageString">
            <summary>The message to display if placement is not allowed</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.warningOnly">
            <summary>Only do a warning message, instead of preventing placement - Used with other comps and stuff</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for preventing placing adjacent to something</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed">
            <summary>Place worker for preventing bed cramming</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed.#ctor">
            <summary>Place worker for preventing bed cramming</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed_Warning">
            <summary>Place worker for warning about bed cramming debuffs</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed_Warning.#ctor">
            <summary>Place worker for warning about bed cramming debuffs</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_Hang_From_Roof">
            <summary>Place worker for hanging things from roofs</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_Hang_From_Roof.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for hanging things from roofs</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall">
            <summary>Place worker for placing things on walls</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall.mustFaceEmptyTile">
            <summary>There has to be an empty tile in front</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for placing things on walls</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach">
            <summary>Place worker for placing things on walls, facing an empty tile</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach.#ctor">
            <summary>Place worker for placing things on walls, facing an empty tile</summary>
        </member>
        <member name="T:NQualityOfLife.HarmonyPatches">
            <summary>Apply harmony patches based on settings</summary>
        </member>
        <member name="F:NQualityOfLife.HarmonyPatches.buildInfo">
            <summary>This string contains the major game version that the dll was built for</summary>
        </member>
        <member name="M:NQualityOfLife.HarmonyPatches.TryToSafelyApplyHarmonyPatch``1(HarmonyLib.Harmony)">
            <inheritdoc cref="M:NQualityOfLife.HarmonyPatches.TryToSafelyApplyHarmonyPatch``1(HarmonyLib.Harmony,HarmonyLib.HarmonyException@)"/>
        </member>
        <member name="M:NQualityOfLife.HarmonyPatches.TryToSafelyApplyHarmonyPatch``1(HarmonyLib.Harmony,HarmonyLib.HarmonyException@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="harmony"></param>
            <param name="exception"></param>
            <returns><see langword="true"/> if the patch was successfully applied, <see langword="false"/> if there was an <paramref name="exception"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="harmony"/> is <see langword="null"/></exception>
            <exception cref="T:HarmonyLib.HarmonyException"></exception>
            <remarks>The patch class '<typeparamref name="T"/>' must be a child class of <see cref="T:HarmonyLib.HarmonyPatch"/> for this method</remarks>
        </member>
    </members>
</doc>
