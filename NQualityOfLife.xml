<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NQualityOfLife</name>
    </assembly>
    <members>
        <member name="M:NQualityOfLife.AI.Toil_.UnDraftIfDrafted(Verse.Pawn)">
            <summary>null checks included</summary>
            <param name="pawn"></param>
            <returns>Toil with the un-draft action</returns>
        </member>
        <member name="M:NQualityOfLife.AI.Find.DefensivePositions(Verse.Pawn,System.Int32@,RimWorld.Faction,Verse.Map,Verse.Region,System.Single,System.Byte,System.Boolean)">
            <summary></summary>
            <param name="inRegion"></param>
            <param name="faction"></param>
            <param name="positionCount"></param>
            <param name="map"></param>
            <param name="pawn"></param>
            <param name="minimumCover"></param>
            <param name="maxPositionsToGet"></param>
            <param name="debug"></param>
            <returns>Never null</returns>
        </member>
        <member name="M:NQualityOfLife.AI.Find.DefensivePositions(Verse.Region,RimWorld.Faction,System.Int32@,Verse.Map,Verse.Pawn,System.Single,System.Byte,System.Boolean)">
            <summary></summary>
            <param name="inRegion"></param>
            <param name="faction"></param>
            <param name="positionCount"></param>
            <param name="map"></param>
            <param name="pawn"></param>
            <param name="minimumCover"></param>
            <param name="maxPositionsToGet"></param>
            <param name="debug"></param>
            <returns>Never null</returns>
        </member>
        <member name="F:NQualityOfLife.Weapons.SuppressionSystem.SuppressionHediff.maxPinTimePerBuller">
            <summary>How many ticks can one bullet add to the timer?</summary>
        </member>
        <member name="F:NQualityOfLife.Weapons.SuppressionSystem.SuppressionHediff.minPinTimePerBuller">
            <summary>How many ticks should be the minimum amount to add?</summary>
        </member>
        <member name="M:NQualityOfLife.Weapons.SuppressionSystem.Utils_Suppression.CanSuppress(Verse.Pawn)">
            <summary>Can the given pawn be affected by supression?</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Solitary.LordJob_Dwelling.#ctor">
            <summary>Empty constructor is needed to prevent errors</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Solitary.Dwelling.SpawnDwellingFlooring(Verse.IntVec3,Verse.Map,Verse.ThingDef)">
            <summary>Spawns decorative stuff on the cell</summary>
            <param name="cell">Where to spawn?</param><param name="map">What map?</param><param name="flooringDef">What to spawn?</param>
        </member>
        <member name="M:NQualityOfLife.Animal.Solitary.Dwelling.DigDwelling(Verse.Pawn,Verse.Map,Verse.Region,System.Boolean)">
            <summary>Tries to queue a digging job for the given dweller animal</summary>
            <param name="pawn"></param><param name="map"></param>
            <param name="existingDwellingToExpand">Expand this existing dwelling, try to dig new if this is null</param>
            <param name="debug"></param>
            <returns>True if was able to queue the digging job</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Solitary.Dwelling.NewDwelling(Verse.Pawn,Verse.Map,System.Nullable{System.Int32},Verse.AI.Group.Lord,System.Boolean)">
            <summary>Create a new dwelling lord for the given pawn</summary>
            <param name="pawn"></param><param name="map"></param><param name="maxDwellers"></param>
            <param name="oldLord"></param><param name="isMother"></param>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.DutyDefOf">
            <summary>XML defs</summary>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DutyDefOf.NQoL_Dwell">
            <summary>XML def for dweller animals</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.IsWarm(NQualityOfLife.Animal.Dweller.DwellingType)">
            <summary></summary>
            <param name="dwellingType"></param>
            <returns>True if the dwelling type provides protection from extreme temperatures</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.ValidDwellingsForPawn(NQualityOfLife.UnOrderedList{System.ValueTuple{Verse.IntVec3,NQualityOfLife.Animal.Dweller.DwellingType}},Verse.Pawn,Verse.Map,NQualityOfLife.Animal.Dweller.DwellingType)">
            <summary>Filters out invalid dwellings for the given pawn</summary>
            <param name="dwellings">The un-validated dwellings</param><param name="pawn"></param><param name="map"></param>
            <param name="ofType"></param>
            <returns>A new list with invalid dwellings removed</returns>
        </member>
        <member name="F:NQualityOfLife.Animal.Dweller.DwellingFinder.DwellingCache">
            <summary>Cached dwellings for each map</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.DwellingFinder.GoodDwellingSpots(Verse.Map,Verse.Pawn,Verse.AI.Group.Lord,System.Boolean,System.Boolean)">
            <summary>Not null</summary>
            <param name="map"></param><param name="pawn">Get the valid dwellings for this pawn</param><param name="pawnLord"></param><param name="debug"></param>
            <param name="isAsyncOperation"></param>
            <returns>A list of valid dwellings for the pawn, if pawn is not given, will return all valid dwellings of all types. - not null</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Jobs.TryMakeHaulingCorpseToDwellingJob(Verse.Pawn,Verse.IntVec3,Verse.Map,Verse.ThingDef)">
            <summary>Tries to get a fresh corpse to haul, and if found returns the hauling job, Does not reserve or start the job, only creates it.</summary>
            <param name="pawn"></param>
            <param name="cellInDwelling">Where the corpse should be hauled, and where to spawn dwelling deco</param>
            <param name="myMap"></param>
            <param name="dwellingDecoToSpawn"></param>
            <returns>null if no jobs available, else the job</returns>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.Jobs.TryMakeCleanDwellingJob(Verse.Pawn,Verse.Map,Verse.AI.Group.Lord)">
            <summary>Returns null or the job ready to be started, Does not reserve or start the job, only creates it.</summary>
            <param name="pawn"></param>
            <param name="map"></param>
            <param name="myLord"></param>
            <returns>null if no job, or the job</returns>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.JobGiver_HaulCorpseToDwelling">
            <summary>Haul fresh corpses to dwelling</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_HaulCorpseToDwelling.TryGiveJob(Verse.Pawn)">
            <summary>Try to give haul job</summary>
            <param name="pawn">The pawn who will do the job</param>
        </member>
        <member name="T:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling">
            <summary>Remove rotting corpses from dwelling to prevent lung rot</summary>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling.TryIssueJobPackage(Verse.Pawn,Verse.AI.JobIssueParams)">
            <summary>Try to give haul job</summary>
            <param name="pawn">The pawn who will do the job</param>
            <param name="jobParams">jobParams</param>
        </member>
        <member name="M:NQualityOfLife.Animal.Dweller.JobGiver_CleanDwelling.TryGiveJob(Verse.Pawn)">
            <summary>Try to give haul job</summary>
            <param name="pawn">The pawn who will do the job</param>
        </member>
        <member name="P:NQualityOfLife.Animal.LordJob_Animal.Map">
            <summary>Get the map of the lord (lordManager) - Can be null if the lord / lordManager has not yet initialized</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_">
            <summary>Utils for creating setting menus</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.EndScrollLister(NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions)">
            <summary>Ideally should be called inside a 'finally' block to prevent cascading errors</summary>
            <param name="scrollList"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.EndScrollLister(NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions,System.Single@)">
            <summary>Ideally should be called inside a 'finally' block to prevent cascading errors</summary>
            <param name="scrollList"></param>
            <param name="finalLength"></param>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions">
            <summary>Extension to 'Listing_Standard' for creating setting menus</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabelTranslated">Inner setting label</param><param name="innerSetting">Inner setting bool</param>
            <param name="topSettingTipTranslated">Main setting tooltip</param>
            <param name="innerSettingTipTranslated">Inner setting tip</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting 1 label</param><param name="innerSetting1">Inner setting 1 bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTipTranslated">Top setting tooltip</param>
            <param name="innerSettingTip1Translated">Inner setting 1 tip</param>
            <param name="innerSettingTip2Translated">Inner setting 2 tip</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 3 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param><param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param><param name="innerSettingTip3Translated">Tooltip for setting 3</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param><param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param><param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param>
            <param name="innerSettingTip3Translated">Tooltip for setting 3</param><param name="innerSettingTip4Translated">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.Boolean,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting in a horizontal row</summary>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="horizontal">Must be true, if false you should call a different method will redirect if called with false</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerTip1Translated">Tooltip for the first inner setting</param><param name="innerTip2Translated">Tooltip for setting 2</param>
            <param name="innerTip3Translated">Tooltip for setting 3</param><param name="innerTip4Translated">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NestedSettingsSection(System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="topSettingLabelTranslated">Main setting label</param>
            <param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5Translated">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6Translated">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param>
            <param name="innerSettingTip3Translated">Tooltip for setting 3</param><param name="innerSettingTip4Translated">Tooltip for setting 4</param>
            <param name="innerSettingTip5Translated">Tooltip for setting 5</param><param name="innerSettingTip6Translated">Tooltip for setting 6</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Int32@,System.Int32,System.Int32,System.String,System.Func{System.Int32,System.String})">
            <summary>Draw a slider with label and visible value</summary>
            <param name="labelTranslated">The label that is displayed above the slider</param>
            <param name="setting">The float we are adjusting, will be drawn on top of the slider</param>
            <param name="min">Minimum allowed input value</param><param name="max">Maximum allowed input value</param>
            <param name="customTooltip">Tooltip, if null: use default</param>
            <param name="specialNumberFormatter">Optinally convert the selected int to something else for display purposes.</param>
            <returns>value of setting</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.NewSlider(System.String,System.Single@,System.Single,System.Single,System.String)">
            <summary>Draw a slider with label and visible value</summary>
            <param name="labelTranslated">The label that is displayed above the slider</param>
            <param name="setting">The float we are adjusting, will be drawn on top of the slider</param>
            <param name="min">Minimum allowed input value</param><param name="max">Maximum allowed input value</param>
            <param name="customTooltip">Tooltip, if null: use default</param>
             <returns>setting</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawColumns(UnityEngine.Color,UnityEngine.Color,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,System.Int32,System.Single,System.Boolean)">
            <summary>Draw 4 columns with specified height</summary>
            <param name="outlineColor">Outline color</param><param name="fillColor">Column fill color</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Border thickness</param>
            <param name="height">Height of the columns</param>
            <param name="progressScroll">Set to false to disable adding of gap. (Useful for some cases) Normally should leave to true</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawHorizontalCheckButtons(System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32)">
            <summary>Draw 4 check box buttons in a horizontal row with grey border and no fill color</summary>
            <param name="setting1">Left most button setting</param><param name="setting2">Left middle button setting</param>
            <param name="setting3">Right middle button setting</param><param name="setting4">Right most button setting</param>
            <param name="label1">Left most button label</param><param name="label2">Left middle button label</param>
            <param name="label3">Right middle button label</param><param name="label4">Right most button label</param>
            <param name="borderThickness">Button border thickness pixels</param>
            <param name="tooltip1"></param><param name="tooltip2"></param>
            <param name="tooltip3"></param><param name="tooltip4"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.DrawHorizontalCheckButtons(UnityEngine.Color,UnityEngine.Color,System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32)">
            <summary>Draw 4 check box buttons in a horizontal row</summary>
            <param name="outlineColor">Button border color</param><param name="fillColor">Button box fill color</param>
            <param name="setting1">Left most button setting</param><param name="setting2">Left middle button setting</param>
            <param name="setting3">Right middle button setting</param><param name="setting4">Right most button setting</param>
            <param name="label1">Left most button label</param><param name="label2">Left middle button label</param>
            <param name="label3">Right middle button label</param><param name="label4">Right most button label</param>
            <param name="borderThickness">Button border thickness pixels</param>
            <param name="tooltip1"></param><param name="tooltip2"></param>
            <param name="tooltip3"></param><param name="tooltip4"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelLargeCentered(System.String,System.Boolean)">
            <summary>Draw a large label centered with the given (translated) text.</summary>
            <param name="labelTranslated">The translated text to draw.</param>
            <param name="debug">Draw debug rects</param>
            <returns>The rect that contains the text.</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Listing_Standard_Extensions.LabelCentered(System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="labelTranslated"></param><param name="tooltip"></param><param name="debug"></param>
            <returns>The rect that contains the text.</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKeys``2(System.Collections.Generic.IDictionary{``0,``1},NQualityOfLife.Settings.SettingProfile)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="keyValuePairs">The dict of defs etc to convert to settings data strings</param>
            <param name="profile"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKeys``1(System.Collections.Generic.IList{``0},NQualityOfLife.Settings.SettingProfile)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="K">The type, such as Verse.Def</typeparam>
            <param name="keys">The list of defs etc to convert to settings data strings</param>
            <param name="profile"></param>
            <returns>A List of 'Profile.Data_Key' strings</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKeys``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0})">
            <summary>Extracts the actual values and keys from a list of setting keys. (Input list format: 'Profile.DataName_Key')</summary>
            <typeparam name="T"></typeparam>
            <param name="keyValuePairs"></param>
            <returns>A dictionary of the keys and values, with Profile. and _Key removed from the keys</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKeys(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey})">
            <summary>Extracts the data from a list of 'Profile.Data_Key' strings</summary>
            <param name="keys">List of setting keys starting with 'profile.' and ending with '_Key'</param>
            <returns>The defNames of the defs, or equivalent</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKey(NQualityOfLife.Settings.SettingKey,NQualityOfLife.Settings.SettingProfile)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <param name="key"></param>
            <param name="profile"></param>
            <returns>A 'Profile.t_Key' string</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToKey``1(``0,NQualityOfLife.Settings.SettingProfile)">
            <summary>Creates a setting data key for the given class, such as Def</summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="profile"></param>
            <returns>A 'Profile.t_Key' string</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForCurrentProfile(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey})">
            <summary>Filters out the keys to get only the keys for the current profile</summary>
            <param name="keys">the input setting data keys</param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForProfile(System.Collections.Generic.IList{NQualityOfLife.Settings.ProfileSettingKey},NQualityOfLife.Settings.SettingProfile)">
            <summary>Filters out the keys to get only the keys for the current profile</summary>
            <param name="keys">the input setting data keys</param>
            <param name="profile"></param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractKey(NQualityOfLife.Settings.ProfileSettingKey)">
            <summary>Extracts the data from a 'Profile.Data_Key' string</summary>
            <param name="k">A setting key starting with 'profile.' and ending with '_Key'</param>
            <returns>The defName of the def, or equivalent</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForCurrentProfile``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0})">
            <summary>Filters out the keys to get only the keys for the current profile (input strings foramt expected: 'Profile.DataName_Key')</summary>
            <typeparam name="T"></typeparam>
            <param name="keysForAllProfiles"></param>
            <returns>All the raw keys for the current profile in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ForProfile``1(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.ProfileSettingKey,``0},NQualityOfLife.Settings.SettingProfile)">
            <summary>Filters out the keys to get only the keys for the provided profile</summary>
            <typeparam name="T"></typeparam>
            <param name="keysForAllProfiles"></param>
            <param name="profile"></param>
            <returns>All the raw keys for 'profile' in the: 'Profile.Thing_Key' format</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDefs``2(System.Collections.Generic.IDictionary{NQualityOfLife.Settings.SettingKey,``1})">
            <summary>Expected input is a list of defNames</summary>
            <typeparam name="D"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDefs``1(System.Collections.Generic.IList{NQualityOfLife.Settings.SettingKey})">
            <summary>Extract the Defs from a list of 'defName's</summary>
            <typeparam name="D">Def type</typeparam>
            <param name="defNames">The list of defNames</param>
            <returns>A list of Defs of type D</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ExtractDef``1(NQualityOfLife.Settings.SettingKey)">
            <summary>Extract the Def from a 'defName'</summary>
            <typeparam name="D">Def type</typeparam>
            <param name="defName">The defName</param>
            <returns>The def</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_Int(NQualityOfLife.Settings.SettingKey,System.Nullable{System.Int32},System.Int32,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved int value</summary>
            <param name="settingKey">The unique key of the setting data - Should not have the profile prefix!</param>
            <param name="directInt">The int field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved int value or fallback if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_Float(NQualityOfLife.Settings.SettingKey,System.Nullable{System.Single},System.Single,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved float value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="directFloat">The float field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved float value or fallback if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.SetSettingValue_Float(NQualityOfLife.Settings.SettingKey,System.Single,System.Nullable{NQualityOfLife.Settings.SettingProfile})">
            <summary>Sets the saved float value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="newValue">Set this value as the new value</param>
            <param name="profile"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingValue_String(NQualityOfLife.Settings.SettingKey,System.String,System.String,System.Nullable{NQualityOfLife.Settings.SettingProfile},NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved string value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="directString">The string field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys"></param>
            <returns>The saved string value or fallback if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.GetSettingEnabled(NQualityOfLife.Settings.SettingKey,System.Nullable{System.Boolean},System.Nullable{NQualityOfLife.Settings.SettingProfile},System.Boolean,NQualityOfLife.Settings.SettingKey[])">
            <summary>Gets the saved bool value</summary>
            <param name="settingKey">The unique key of the setting data</param>
            <param name="directBool">The bool field</param>
            <param name="fallback">Return this value if the setting data is not found</param>
            <param name="profile"></param>
            <param name="migrateFromLegacyKeys">Copy the setting from a legacy key if found.</param>
            <returns>The saved bool value or fallback if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.LabelLarge(UnityEngine.Rect,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Draw text in a large font and center it inside a Rect</summary>
            <param name="rect">Text inside this Rect</param>
            <param name="labelTranslated">label text</param>
            <param name="centerX"></param>
            <param name="centerY"></param>
            <param name="debug">Draw debug info</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.TextArea(UnityEngine.Rect,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="rect"></param>
            <param name="text">The current text in the area</param>
            <param name="tooltip"></param>
            <param name="readOnly"></param>
            <returns>The text in the text area after user input</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button(UnityEngine.Rect,System.String,System.String,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="rect">The rectangle that the button occupies</param>
            <param name="labelKey">Label translation key</param>
            <param name="tooltipKey">Tooltip translation key, no tooltip if null</param>
            <param name="maxHeight">Limit how tall the button can be at maximum</param>
            <param name="minHeight">The minimum height that the button can be.</param>
            <param name="labelIsPreTranslated">Is the label already translated, or do we translate it here?</param>
            <param name="tooltipIsPreTranslated">Is the tooltip already translated, or do we translate it here?</param>
            <returns>True when the button is pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button_Confirmation(UnityEngine.Rect,System.String,System.String,System.String,System.Action,System.String,Verse.WindowStack)">
            <summary>Draws a button that when pressed; opens a popup window to confirm or cancel the action.</summary>
            <param name="rect">Draw button inside this rect</param>
            <param name="labelKey"></param>
            <param name="tooltipKey"></param>
            <param name="confirmationLabelKey"></param>
            <param name="actionOnConfirm">Action on pressing confirm on the pop-up</param>
            <param name="confirmationExtraLabel_Translated"></param>
            <param name="windowStack">Optional</param>
            <returns>True when this button is pressed (not the confirmation popup button)</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Button_Confirmation_HyperLink(UnityEngine.Rect,System.String,System.String,System.String,NQualityOfLife.URL,Verse.WindowStack)">
            <summary>Draws a button that opens a pop up confirmation window with the given link</summary>
            <param name="rect">The rect where the button is drawn</param>
            <param name="labelKey"></param>
            <param name="tooltipKey"></param>
            <param name="confirmationLabelKey"></param>
            <param name="hyperLink"></param>
            <param name="windowStack"></param>
            <returns>True when clicking the button</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.Hyperlink(UnityEngine.Rect,NQualityOfLife.URL,System.Boolean,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="rect"></param>
            <param name="link"></param>
            <param name="copyToClipboardOnClick"></param>
            <param name="customToolTipKey"></param>
            <param name="centered"></param>
            <param name="debug"></param>
            <returns>The rect containing the hyperlink text</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabs(UnityEngine.Rect,System.Int32@,System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.Single)">
            <summary>Draw 4 tab buttons at the top of the given Rect</summary>
            <param name="parentRect">Draw at the top of this</param>
            <param name="currentSelectedTabId">The currently active tab (1-6)</param>
            <param name="outlinePixels">Tab button outline thickness</param>
            <param name="heightPixels">Height of the tab buttons</param>
            <param name="tip1Key">Tooltip translation key for the button, null means no tip</param><param name="tip2Key">Tooltip translation key for the button, null means no tip</param>
            <param name="tip3Key">Tooltip translation key for the button, null means no tip</param><param name="tip4Key">Tooltip translation key for the button, null means no tip</param>
            <param name="label1">Label of the left most tab</param><param name="label2">Label of the 2. tab from the left</param>
            <param name="label3">Label of the 3. tab from the left</param><param name="label4">Label of the right most tab</param>
            <param name="selectSound">Play this sound when selecting a new tab</param>
            <param name="rejectSound">Play this sound if selecting already open tab</param>
            <param name="hoverSound">Play this sound on mouse hover</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabs(UnityEngine.Rect,System.Int32@,System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.Single)">
            <summary>Draw 6 tab buttons at the top of the given Rect</summary>
            <param name="parentRect">Draw at the top of this</param>
            <param name="currentSelectedTabId">The currently active tab (1-6)</param>
            <param name="outlinePixels">Tab button outline thickness</param>
            <param name="label1">Label of the left most tab</param><param name="label2">Label of the 2. tab from the left</param>
            <param name="label3">Label of the 3. tab from the left</param><param name="label4">Label of the 4. tab from the left</param>
            <param name="label5">Label of the 5. tab from the left</param><param name="label6">Label of the right most tab</param>
            <param name="tip1Key">Tooltip translation key for the button, null means no tip</param><param name="tip2Key">Tooltip translation key for the button, null means no tip</param>
            <param name="tip3Key">Tooltip translation key for the button, null means no tip</param><param name="tip4Key">Tooltip translation key for the button, null means no tip</param>
            <param name="tip5Key">Tooltip translation key for the button, null means no tip</param><param name="tip6Key">Tooltip translation key for the button, null means no tip</param>
            <param name="selectSound">Play this sound when selecting a new tab</param>
            <param name="rejectSound">Play this sound if selecting already open tab</param>
            <param name="hoverSound">Play this sound on mouse hover</param>
            <param name="buttonHeightPixels"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawTabButton(UnityEngine.Rect,System.Int32,System.String,System.Int32@,Verse.SoundDef,Verse.SoundDef,Verse.SoundDef,System.String,System.Boolean)">
            <summary></summary>
            <param name="tabButtonRect"></param>
            <param name="thisTabId"></param>
            <param name="label"></param>
            <param name="currentSelectedTabId"></param>
            <param name="selectSound"></param>
            <param name="rejectSound"></param>
            <param name="hoverSound"></param>
            <param name="tooltipKey"></param>
            <param name="debug"></param>
            <returns>The LabelLarge Rect inside the button</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,System.Int32,System.Single)">
            <summary>Draw 2 vertical column Rects inside a Rect with grey border and no fill color</summary>
            <param name="rect"></param>
            <param name="L">Left column</param><param name="R">Right column</param>
            <param name="outlinePixels">Column border thickness pixels</param>
            <param name="middleGap">Move the columns away from each other by this amount.</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Color,UnityEngine.Color,UnityEngine.Rect@,UnityEngine.Rect@,System.Int32,System.Single)">
            <summary>Draw 2 vertical column Rects inside a Rect</summary>
            <param name="rect"></param>
            <param name="outlineColor">Column border color</param><param name="fillColor">Column fill color</param>
            <param name="L">Left column</param><param name="R">Right column</param>
            <param name="outlinePixels">Column border thickness pixels</param>
            <param name="middleGap">Move the columns away from each other by this amount.</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,System.Single,System.Int32)">
            <summary>Draw 3 vertical column Rects inside a Rect with grey borders and no fill color</summary>
            <param name="rect"></param>
            <param name="L">Left column</param><param name="R">Right column</param><param name="M">Middle column</param>
            <param name="ColumnWidthPercent">How wide the columns should be (0f-1f) 1f = 1/3 of parent rect</param>
            <param name="outlinePixels">Column border thickness pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Color,UnityEngine.Color,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,System.Single,System.Int32)">
            <summary>Draw 3 vertical column Rects inside a Rect</summary>
            <param name="rect"></param>
            <param name="outlineColor"></param><param name="fillColor"></param>
            <param name="L">Left column</param><param name="R">Right column</param><param name="M">Middle column</param>
            <param name="ColumnWidthPercent">How wide the columns should be (0f-1f) 1f = 1/3 of parent rect</param>
            <param name="outlinePixels">Column border thickness pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,System.Int32)">
            <summary>Draw 4 new vertical column Rects inside a Rect with default colors</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Color,UnityEngine.Color,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,System.Int32)">
            <summary>Draw 4 new vertical column Rects inside a Rect</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="outlineColor">Column border color</param>
            <param name="fillColor">Column fill color</param>
            <param name="LL">Left most column</param><param name="L">Left column</param>
            <param name="R">Right column</param><param name="RR">Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,System.Int32)">
            <summary>Draw 6 new vertical column Rects inside a Rect with default border and fill colors</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="A">1. from the left, Left most column</param><param name="B">2. from the left</param>
            <param name="C">3. from the left</param><param name="D">4. from the left</param>
            <param name="E">5. from the left</param><param name="F">6. from the left, Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawColumns(UnityEngine.Rect,UnityEngine.Color,UnityEngine.Color,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,System.Int32)">
            <summary>Draw 6 new vertical column Rects inside a Rect</summary>
            <param name="rect">Make columns inside this rect</param>
            <param name="outlineColor">Column border color</param><param name="fillColor">Column fill color</param>
            <param name="A">1. from the left, Left most column</param><param name="B">2. from the left</param>
            <param name="C">3. from the left</param><param name="D">4. from the left</param>
            <param name="E">5. from the left</param><param name="F">6. from the left, Right most column</param>
            <param name="outlinePixels">Column border thickness in pixels</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.DrawNewBorderInsideRectWithPads(UnityEngine.Rect,UnityEngine.Rect@,System.Int32,System.Single,System.Single)">
            <summary>Draw with default colors</summary>
            <param name="outerRect"></param>
            <param name="newRect"></param>
            <param name="borderThickness"></param>
            <param name="outerPadding"></param>
            <param name="innerPadding"></param>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow">
            <summary>Base pop up window - Pop up windows are draggable, resizable windows that are drawn on top of other UI elements</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.HeaderTextTranslated">
            <summary>The translated header text to draw at the top of the window</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.TextTranslated">
            <summary>Optional text to draw under the header</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Header">
            <summary>The top part of the window - Intended for a header text</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.TextArea">
            <summary>The middle section of the window - Intended for text input fields or other controls or displays</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Bottom">
            <summary>The bottom part of the window - Intended for controls such as confirm or cancel buttons</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.HeaderPixels">
            <summary>The size (height) of the header</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.BottomPixels">
            <summary>The size (height) of the bottom rect</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.Debug">
            <summary>Debug the ui elements</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow.DefaultInitialSize">
            <summary>'DefaultInitialSize' / (500f, 250f)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.#ctor(System.String,System.String,System.Single,System.Single)">
            <summary>The base pop up window with a header and text</summary>
            <param name="headerTextTranslated"></param><param name="textTranslated">Text drawn under the header</param><param name="headerPixels"></param><param name="bottomPixels"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.#ctor(System.String,System.Single,System.Single)">
            <summary>The base pop up window with only a header</summary>
            <param name="headerTextTranslated"></param><param name="headerPixels"></param><param name="bottomPixels"></param>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow.InitialSize">
            <summary>The initial size of the popup window (x, y) - Default is 'DefaultInitialSize' / (500f, 250f)</summary>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow.InitialPosition">
            <summary>The initial position of the window when it is created - Middle of the screen by default</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.DoWindowContents(UnityEngine.Rect)">
            <summary>Should be called in the overrides, Draws the contents of the pop up window, such as text and or buttons.</summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.WindowUpdate">
            <summary>By default only maintains the sound sustainer if any</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.ExtraOnGUI">
            <summary>Does not do anything by default</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.WindowOnGUI">
            <summary>Called before DoWindowContents</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.LateWindowOnGUI(UnityEngine.Rect)">
            <summary>Is called after WindowOnGUI and DoWindowContents</summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreOpen">
            <summary>Sets initial size and position and does some other stuff</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostOpen">
            <summary>Plays the appear sound and starts the sound sustainer if any</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PreClose">
            <summary>Does not do anything by default</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.PostClose">
            <summary>Does not do anything by default</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.OnAcceptKeyPressed">
            <summary>Accept key press (Enter)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.OnCancelKeyPressed">
            <summary>Cancel key press (Esc)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow.SetInitialSizeAndPosition">
            <summary>Sets the size and position, and makes sure the window is on screen.</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_IdeoRoleSettings.OnAcceptPressed">
            <summary>Saves the settings</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation">
            <summary>A pop up window with confirm and cancel buttons</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmAction">
            <summary>Action to invoke when pressing confirm - Can be null - Should be invoked last if multiple actions!</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelAction">
            <summary>Action to invoke when pressing cancel - Can be null - Should be invoked last if multiple actions!</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.AllowConfirmWithEnter">
            <summary>Set this to false to allow for a better text input experience.</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmTooltipKey">
            <summary>Confirm button hover tooltip translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelTooltipKey">
            <summary>Cancel button hover tooltip translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.ConfirmKey">
            <summary>Confirm button label translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.CancelKey">
            <summary>Cancel button label translation key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.DrawButtons">
            <summary>Draw the default buttons that invoke the default actions?</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.#ctor(System.String,System.Single,System.Single)">
            <summary>Will not draw the base confirm / cancel buttons</summary>
            <param name="headerTextKey"></param><param name="headerPixels"></param><param name="bottomPixels"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.#ctor(System.String,System.Boolean,System.Single,System.Single)">
            <summary>Draw the base confirm / cancel buttons</summary>
            <param name="headerTextKey"></param><param name="closeOnConfirm">Close the window instance when pressing confirm</param><param name="headerPixels"></param><param name="bottomPixels"></param>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.InitialSize">
            <summary>The initial size of the confirmation popup window (x, y) - Default is (600f, 250f)</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.DoWindowContents(UnityEngine.Rect)">
            <summary>If 'DrawButtons' is true, draws the default cancel and confirm buttons, else draws the default popup window.</summary>
            <param name="inRect"></param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnAcceptKeyPressed">
            <summary>Must be called last inside the OnAcceptPressed() method! - Calls the confirm actions (ConfirmAction) when pressing accept / enter</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnAcceptPressed">
            <summary>Calls the confirm actions (ConfirmAction) when pressing accept / enter</summary>
            <returns>True if we should accept the input, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Confirmation.OnCancelKeyPressed">
            <summary>Calls the cancel actions (CancelAction) when pressing cancel / esc</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_ColorSelector.OnAcceptPressed">
            <summary>Invokes the confirm action and color confirm action</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.GetData(System.Collections.Generic.List{NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.GraphData},System.Int32,NQualityOfLife.Settings.Utils_.PopUpWindow_Graph.State@)">
            <summary></summary>
            <param name="data">The graphs to get the data for</param>
            <param name="forTick"></param>
            <param name="state"></param>
            <returns>True if the data was succesfully collected</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ScrollControls(UnityEngine.Rect,NQualityOfLife.Settings.Utils_.PopUpWindow,NQualityOfLife.Factor@,NQualityOfLife.Factor@,System.Single@,System.Single@)">
            <summary></summary>
            <param name="displayRect"></param>
            <param name="popUpWindow"></param>
            <param name="xScaler"></param>
            <param name="yScaler"></param>
            <param name="xDisplayOffset"></param>
            <param name="yDisplayOffset"></param>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput">
            <summary>Use helper method -> 'NewPopUpWindow_TextInput'</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.NewPopUpWindow_TextInput(System.String,System.String,System.Action{System.String},System.Boolean,Verse.WindowStack)">
            <summary>Example usage: 'NewPopUpWindow_TextInput("NQoL_Animal_Color", TechLevel_.Animal_ColorHex, newText => TechLevel_.Animal_ColorHex = newText))'</summary>
            <param name="headerTextKey">Example usage: '"NQoL_Animal_Color"'</param>
            <param name="initialValue">Example usage: 'TechLevel_.Animal_ColorHex'</param>
            <param name="confirmAction">Example usage: 'newText => TechLevel_.Animal_ColorHex = newText'</param>
            <param name="closeOnConfirm">Close the window on confirm/accept (true) or keep it open (false).</param>
            <param name="windowStack">Optional, will find if null</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.NewPopUpWindow_TextInput(System.String,System.String,System.String,System.Action{System.String},System.Action,System.Boolean,Verse.WindowStack)">
            <summary>Example usage: 'NewPopUpWindow_TextInput("NQoL_Animal_Color", TechLevel_.Animal_ColorHex, newText => TechLevel_.Animal_ColorHex = newText))'</summary>
            <param name="headerTextKey">Example usage: '"NQoL_Animal_Color"'</param>
            <param name="topTextKey"></param>
            <param name="initialValue">Example usage: 'TechLevel_.Animal_ColorHex'</param>
            <param name="confirmAction">Example usage: 'newText => TechLevel_.Animal_ColorHex = newText'</param>
            <param name="confirmAction_2">Example usage: '() => NQualityOfLife_Mod.NQualityOfLife_Settings.Write()'</param>
            <param name="closeOnAccept">Close the window on accept (true) or keep it open (false).</param>
            <param name="windowStack">Optional, will find if null</param>
        </member>
        <member name="P:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextEntry">
            <summary>User inputted text</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextConfirmAction">
            <summary>Action to invoke on confirm using the inputted text as a parameter</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.Utils_.PopUpWindow_TextInput.TextCancelAction">
            <summary>Action to invoke on cancel using the inputted text as a parameter</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.IsFocus_ForKeyboardInput(UnityEngine.Rect)">
            <summary>Is this rect the current focus for keyboard inputs?</summary>
            <param name="inputRect">The rect for the input widget</param>
            <returns>True if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.MouseHover(UnityEngine.Rect,System.Boolean)">
            <summary></summary>
            <param name="rect"></param>
            <param name="debug">Enable debug draw.</param>
            <returns>True if mouse is over the Rect</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PositionForBottomRightCorner(Verse.Window)">
            <summary>Gets the position for the window that position it in the bottom right corner of the screen with some margin</summary>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PositionForTopLeftCorner(Verse.Window)">
            <summary>Gets the position for the window that position it in the top left corner of the screen with some margin</summary>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.ToFullScreen(Verse.Window,System.Single)">
            <summary>Set the window to full screen</summary>
            <param name="window"></param>
            <param name="border">How much gap to leave between the screen edges and the window</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.AddPadding(UnityEngine.Rect,System.Single)">
            <summary></summary>
            <param name="rect">Input rect</param>
            <param name="padding">How much gap to add between the outer rect and the new rect</param>
            <returns>A new Rect that is inside the input rect</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.TooltipAndHighlight(UnityEngine.Rect,UnityEngine.Rect,System.String,System.Boolean)">
            <summary>Highlight both rects when hovering over Rect_A, and draw tooltips when hovering over Rect_A</summary>
            <param name="rect_A">Tooltip and highlight on hover</param><param name="rect_B">Highlight when hovering over rect_A</param>
            <param name="tooltip">Tooltip on hovering over rect_A</param><param name="tipIsTranslationKey">Is the tip already translated, or a translation key?</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(UnityEngine.Rect@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabelTranslated">Inner setting label</param><param name="innerSetting">Inner setting bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTipTranslated">Tooltip for the first inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Internal_Final(UnityEngine.Rect@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String)">
            <summary>Create a nested setting box with 1 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabelTranslated">Inner setting label</param><param name="innerSetting">Inner setting bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTipTranslated">Tooltip for the first inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(UnityEngine.Rect,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(UnityEngine.Rect@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 2 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting 1 label</param><param name="innerSetting1">Inner setting 1 bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param>
            <param name="innerSettingTip2">Tooltip for the second inner setting</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(UnityEngine.Rect@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 3 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param><param name="innerSettingTip3">Tooltip for setting 3</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(UnityEngine.Rect@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 3 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param><param name="innerSettingTip3Translated">Tooltip for setting 3</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(UnityEngine.Rect,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(UnityEngine.Rect@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 4 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection(UnityEngine.Rect@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabel">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTip">Tooltip for the top setting</param>
            <param name="innerSettingTip1">Tooltip for the first inner setting</param><param name="innerSettingTip2">Tooltip for setting 2</param>
            <param name="innerSettingTip3">Tooltip for setting 3</param><param name="innerSettingTip4">Tooltip for setting 4</param>
            <param name="innerSettingTip5">Tooltip for setting 5</param><param name="innerSettingTip6">Tooltip for setting 6</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.NewNestedSettingsSection_Final(UnityEngine.Rect@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.Boolean@,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a nested setting box with 6 inner setting</summary>
            <param name="container">The parent rectangle</param>
            <param name="topSettingLabelTranslated">Main setting label</param><param name="topSetting">The main setting that must be enabled to show the inner settings</param>
            <param name="innerSettingLabel1Translated">Inner setting label</param><param name="innerSetting1">Inner setting bool</param>
            <param name="innerSettingLabel2Translated">Inner setting 2 label</param><param name="innerSetting2">Inner setting 2 bool</param>
            <param name="innerSettingLabel3Translated">Inner setting 3 label</param><param name="innerSetting3">Inner setting 3 bool</param>
            <param name="innerSettingLabel4Translated">Inner setting 4 label</param><param name="innerSetting4">Inner setting 4 bool</param>
            <param name="innerSettingLabel5Translated">Inner setting 5 label</param><param name="innerSetting5">Inner setting 6 bool</param>
            <param name="innerSettingLabel6Translated">Inner setting 6 label</param><param name="innerSetting6">Inner setting 6 bool</param>
            <param name="topSettingTipTranslated">Tooltip for the top setting</param>
            <param name="innerSettingTip1Translated">Tooltip for the first inner setting</param><param name="innerSettingTip2Translated">Tooltip for setting 2</param>
            <param name="innerSettingTip3Translated">Tooltip for setting 3</param><param name="innerSettingTip4Translated">Tooltip for setting 4</param>
            <param name="innerSettingTip5Translated">Tooltip for setting 5</param><param name="innerSettingTip6Translated">Tooltip for setting 6</param>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.PreOpen">
            <summary>Set 'exampleStartingLevel' to the current player tech level</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.PostClose">
            <summary>Re-calculate and set the player tech level if player is in game, and write setting data to file.</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.Pop">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.Utils_.PopUpWindow_TechProgressionInfo.Pop.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.ProfileSettingKey">
            <summary>A setting key made from a 'SettingProfile' and a 'SettingKey'</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.ProfileSettingKey.ToString">
            <summary></summary>
            <returns>"Profile.Data_Key"</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.ToString">
            <summary></summary>
            <returns>"Profile"</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(NQualityOfLife.Settings.SettingProfile,NQualityOfLife.Settings.SettingProfile)">
            <summary>Compare the internal profile strings</summary><param name="a"></param><param name="b"></param><returns>True if the profile strings match / The 2 profiles are the same profile || True if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(NQualityOfLife.Settings.SettingProfile,NQualityOfLife.Settings.SettingProfile)">
            <summary>Compare the internal profile strings</summary><param name="a"></param><param name="b"></param><returns>False if the profile strings match / The 2 profiles are the same profile || False if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(System.String,NQualityOfLife.Settings.SettingProfile)">
            <summary>Compare the given string to the internal string of the given profile</summary><param name="a"></param><param name="b"></param><returns>True if the string matches the given profile, false if they don't match || True if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(System.String,NQualityOfLife.Settings.SettingProfile)">
            <summary>Compare the given string to the internal string of the given profile</summary><param name="a"></param><param name="b"></param><returns>False if the string matches the given profile, true if they don't match || False if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Equality(NQualityOfLife.Settings.SettingProfile,System.String)">
            <summary>Compare the internal profile string to the given string</summary><param name="a"></param><param name="b"></param><returns>True if the profile strings matches the given string / The 2 profiles are the same profile || True if the profiles are the same</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.SettingProfile.op_Inequality(NQualityOfLife.Settings.SettingProfile,System.String)">
            <summary>Compare the internal profile string to the given string</summary><param name="a"></param><param name="b"></param><returns>False if the profile strings matches the given string / The 2 profiles are the same profile || False if the profiles are the same</returns>
        </member>
        <member name="T:NQualityOfLife.Settings.NQualityOfLife_Mod">
            <summary>My mod class</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Mod.Instance">
            <summary>The instance of my 'Mod'</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.#ctor(Verse.ModContentPack)">
            <summary>My mod content pack</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.DoSettingsWindowContents(UnityEngine.Rect)">
            <summary>My mod settings menu contents</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Mod.SettingsCategory">
            <summary>My mod settings label - Displayed in the mod settings list</summary>
        </member>
        <member name="T:NQualityOfLife.Settings.NQualityOfLife_Settings">
            <summary>My mod settings class</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.rocketCacheHasBeenPurged">
            <summary>True when the rocketman cache has been purged during this session and thus doesn't need to be again.</summary>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.Write(System.Boolean)">
            <summary>Write the settings to file</summary>
            <param name="dontPurgeRocketCache">Set to true if purging the cache is not needed</param>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.TryPurgeRocketCache">
            <summary>Try purge the rocketman cache if rocketman loaded</summary>
            <returns>false on error</returns>
        </member>
        <member name="M:NQualityOfLife.Settings.NQualityOfLife_Settings.PurgeRocketCache">
            <summary>Sets 'Gagarin.Context.IsUsingCache' to false when writing mod settings, to allow conditional xml patches to apply.</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Infestation_Light_Max_For_Insects_100">
            <summary>int 0 - 100</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Infestation_Temperature_Range_Min">
            <summary>-20 - 60</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Infestation_Temperature_Range_Max">
            <summary>-20 - 60</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Research_TechLevel_Progression_Slider">
            <summary>Must be 0f - 1f</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.NiilosQoL_Settings_Research_TechLevel_Progression_Skip_Slider">
            <summary>Must be 0f - 1f</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.architectPosData">
            <summary>Key: $"{Utils.Settings.profile}.{item.defName}_Key"</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.architectColData">
            <summary>Key: $"{Utils.Settings.profile}.{item.defName}_Key"</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.mainButtonPosData">
            <summary>Keys: SettingProfileKey</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.mainButtonSizeData">
            <summary>Keys: SettingProfileKey</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalLetterFilterDefFilterData">
            <summary>Keys are formatted as Profile.defName_Key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalMessageFilterDefFilterData">
            <summary>Keys are formatted as Profile.defName_Key</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalLetterFilterTextProfiles">
            <summary>Keys are the profiles, value is the text data</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.GlobalMessageFilterTextProfiles">
            <summary>Keys are the profiles, value is the text data</summary>
        </member>
        <member name="F:NQualityOfLife.Settings.NQualityOfLife_Settings.diseaseEventFilterData">
            <summary>Data keys saved in the Profile.Key_Key format</summary>
        </member>
        <member name="T:NQualityOfLife.ITreeNode`3">
            <summary></summary>
            <typeparam name="IN">The type of the node that implements this interface</typeparam>
            <typeparam name="D">The type of the data that this node contains</typeparam>
            <typeparam name="IT">The type of the tree that contains this node</typeparam>
        </member>
        <member name="P:NQualityOfLife.ITreeNode`3.Parent">
            <summary>The parent of this node - If null, the node is the root of the tree</summary>
        </member>
        <member name="P:NQualityOfLife.ITreeNode`3.Tree">
            <summary>Get the tree that contains this node</summary>
        </member>
        <member name="P:NQualityOfLife.ITreeNode`3.Depth">
            <summary>The depth of the node in the tree, where 0 is the root node</summary>
        </member>
        <member name="P:NQualityOfLife.ITreeNode`3.Data">
            <summary>Get or set the data that this node contains</summary>
        </member>
        <member name="M:NQualityOfLife.ITreeNode`3.DataFormatted``1(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.ITreeNode`3.DataFormatted(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary></summary>
            <param name="displayMode"></param>
            <returns></returns>
        </member>
        <member name="P:NQualityOfLife.ITreeNode`3.Root">
            <summary>The root node of the tree, The root node does not have a parent || Calling this on the root node will return null</summary>
        </member>
        <member name="P:NQualityOfLife.ITreeNode`3.SubRoot">
            <summary>The root node of this sub tree || or Root if this is not a sub tree || Calling this on the root node will return null</summary>
        </member>
        <member name="P:NQualityOfLife.ITreeNode`3.Path">
            <summary>The string representation of the branch ending with this node</summary>
        </member>
        <member name="T:NQualityOfLife.ITree`3">
            <summary></summary>
            <typeparam name="IN">The type of the node that this tree is made from</typeparam>
            <typeparam name="IT">The type of the tree that implements this interface</typeparam>
            <typeparam name="D">The type of the data that this tree can contain</typeparam>
        </member>
        <member name="P:NQualityOfLife.ITree`3.Root">
            <summary>The root node of the tree, The root node does not have a parent</summary>
        </member>
        <member name="P:NQualityOfLife.ITree`3.LocalRoot">
            <summary>The node where this tree starts inside a parent tree || or Root if this tree is not a sub tree</summary>
        </member>
        <member name="P:NQualityOfLife.ITree`3.Count">
            <summary>The total nodes in the tree</summary>
        </member>
        <member name="P:NQualityOfLife.ITree`3.Depth">
            <summary>The max depth of the tree, where 0 is only the root node</summary>
        </member>
        <member name="P:NQualityOfLife.ITree`3.AllNodes">
            <summary>Get all the nodes that are a part of the tree</summary>
        </member>
        <member name="P:NQualityOfLife.ITree`3.ParentTree">
            <summary>The parent tree of a sub tree || or null if this is not a sub tree</summary>
        </member>
        <member name="F:NQualityOfLife.Tree`1.root">
            <summary>The node that is the root of this tree</summary>
        </member>
        <member name="F:NQualityOfLife.Tree`1.Node._containedData">
            <summary>The data that is linked / represented by this node</summary>
        </member>
        <member name="F:NQualityOfLife.Tree`1.Node._parent">
            <summary>The direct parent node of this node, or null if this node is the root of a tree</summary>
        </member>
        <member name="F:NQualityOfLife.Tree`1.Node._children">
            <summary>The direct child nodes of this node</summary>
        </member>
        <member name="P:NQualityOfLife.Tree`1.Node.Item(System.Int32)">
            <summary>Get a direct child of this node by index</summary>
            <param name="index"></param><returns>One of the direct child nodes</returns>
        </member>
        <member name="P:NQualityOfLife.Tree`1.Node.Count">
            <summary>Get how many direct child nodes this node has</summary>
        </member>
        <member name="P:NQualityOfLife.Tree`1.Node.Children">
            <summary>Get the direct child nodes of this node</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.R">
            <summary>Set or get the Red 'RGBA' component</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.G">
            <summary>Set or get the Green 'RGBA' component</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.B">
            <summary>Set or get the Blue 'RGBA' component</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.A">
            <summary>Set or get the A (Transparency) 'RGBA' component - || 255 is max opacity, 0 is fully transparent</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.HexCode">
            <summary>Get or set the hex color code (#AA4435FF)</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.AsRGBA">
            <summary>Get or set the color as 'RGBA'</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.AsRGB">
            <summary>Get or set the color as 'RGB'</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.UnityColor">
            <summary>Get or set the color as 'UnityEngine.Color'</summary>
        </member>
        <member name="P:NQualityOfLife.IColor.ToColorTag">
            <summary>Get the &lt;color&gt; tag</summary>
        </member>
        <member name="T:NQualityOfLife.Hex">
            <summary>Represents a hex color code such as #FF2277FF</summary>
        </member>
        <member name="P:NQualityOfLife.Hex.AsRGBA">
            <summary>Convert a hex color code such as #FF15ABFF into its RGBA components. If the hex code doesn't have an Alpha component like in '#FF15AB', it will be returned as 255. - The input hex code can start with or without '#'</summary>
            <returns>If input is null or empty => (0, 0, 0, 255)</returns>
        </member>
        <member name="P:NQualityOfLife.Hex.AsRGB">
            <summary>Convert a hex color code such as #FF15AB into its RGB components. If the hex code has an Alpha component like in '#FF00AAF6', it will be ignored</summary>
            <returns> If input is null or empty => (0, 0, 0)</returns>
        </member>
        <member name="M:NQualityOfLife.IAngle`1.Abs">
            <summary>Get the Absolute value</summary>
            <returns>The absolute value (non negative) of the angle</returns>
        </member>
        <member name="P:NQualityOfLife.ILine2D.Middle">
            <summary>The mid point between A and B</summary>
        </member>
        <member name="P:NQualityOfLife.ILine2D.Length">
            <summary>The Length between A and B</summary>
        </member>
        <member name="P:NQualityOfLife.ILine3D.Middle">
            <summary>The mid point between A and B</summary>
        </member>
        <member name="P:NQualityOfLife.ILine3D.Length">
            <summary>The Length between A and B</summary>
        </member>
        <member name="P:NQualityOfLife.IGeometry2D.Middle">
            <summary>The point in the middle of the shape.</summary>
        </member>
        <member name="P:NQualityOfLife.IPolygon.Area">
            <summary>The area of the 2D shape</summary>
        </member>
        <member name="P:NQualityOfLife.IGeometry3D.Area">
            <summary>The area of the 3D shape</summary>
        </member>
        <member name="P:NQualityOfLife.IGeometry3D.Volume">
            <summary>The volume of the 3D shape</summary>
        </member>
        <member name="P:NQualityOfLife.IGeometry3D.Position">
            <summary>The point in the middle of the 3D shape. or the position of the point.</summary>
        </member>
        <member name="P:NQualityOfLife.IGeometry3D.Middle">
            <summary>The point in the middle of the 3D shape. or the position of the point.</summary>
        </member>
        <member name="T:NQualityOfLife.Factor">
            <summary>A positive float value</summary>
        </member>
        <member name="M:NQualityOfLife.Factor.LargerOf(NQualityOfLife.Factor)">
            <summary>Returns the larger value</summary><param name="otherValue"></param><returns>The larger of the 2 values</returns>
        </member>
        <member name="T:NQualityOfLife.Percentage">
            <summary>Represents a float value as a percentage, a float of '1' is 100% when casting</summary>
        </member>
        <member name="F:NQualityOfLife.Percentage.PercentageValue">
            <summary>0%~100% || 0%~100% to float -> 0f~1f</summary>
        </member>
        <member name="M:NQualityOfLife.Percentage.#ctor(System.Single,System.Single)">
            <summary>Creates a Percentage - of/max</summary>
            <param name="of"></param>
            <param name="max">Max value</param>
        </member>
        <member name="M:NQualityOfLife.Percentage.op_Explicit(NQualityOfLife.Percentage)~NQualityOfLife.Ratio">
            <summary>Converts a Percentage with a value between: 0f~100f to a ratio: 0f~1f</summary>
            <param name="percentage"></param>
        </member>
        <member name="M:NQualityOfLife.Percentage.RoundToInt">
            <summary></summary>
            <returns>The percentage as an int (0~100)</returns>
        </member>
        <member name="T:NQualityOfLife.Ratio">
            <summary>A float value between 0 and 1</summary>
        </member>
        <member name="M:NQualityOfLife.Ratio.#ctor(System.Byte)">
            <summary>Set the internal value directly 0~255</summary>
            <param name="value">0~255 - 0~1</param>
        </member>
        <member name="M:NQualityOfLife.Comps.BuildingComp.Notify_Killed(Verse.Map,System.Nullable{Verse.DamageInfo})">
            <summary>N/A</summary><param name="prevMap">N/A</param><param name="dInfo">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.BuildingComp.Notify_AddBedThoughts(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_LordDestroyed">
            <summary>Called when the lord of this pawn is destroyed</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Arrested(System.Boolean)">
            <summary>Called when this pawn is getting arrested</summary>
            <param name="succeeded">true if was successfully arrested</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Released">
            <summary>Called when the pawn is released from prison / slavery etc</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Downed">
            <summary>Called when this pawn is downed</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Equipped(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_UsedWeapon(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_WearerDied">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.PawnComp.Notify_Unequipped(Verse.Pawn)">
            <summary>N/A</summary><param name="pawn">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_Unequipped(Verse.Pawn)">
            <summary>Is called when the weapon or apparel is unequipped</summary>
            <param name="pawn">The pawn who unequipped this thing</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_KilledPawn(Verse.Pawn)">
            <summary>Called on all equipment when a pawn kills another pawn</summary>
            <param name="pawn">The pawn that was killed</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_Arrested(System.Boolean)">
            <summary>N/A</summary><param name="succeeded">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ItemComp.Notify_WearerDied">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_WearerDied">
            <summary>Called when the pawn wearing this apparel has died</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.CompAllowVerbCast(Verse.Verb)">
            <summary>Can the verb be casted while wearing this?</summary>
            <param name="verb"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.PostIngested(Verse.Pawn)">
            <summary>N/A</summary><param name="ingester">>N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.PrePostIngested(Verse.Pawn)">
            <summary>N/A</summary><param name="ingester">>N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_UsedVerb(Verse.Pawn,Verse.Verb)">
            <summary>N/A</summary><param name="pawn">N/A</param><param name="verb">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Released">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Downed">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.Notify_Arrested(System.Boolean)">
            <summary>N/A</summary><param name="succeeded">N/A</param>
        </member>
        <member name="M:NQualityOfLife.Comps.ApparelComp.GetAdditionalHarvestYield">
            <summary>N/A</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoLAction_DiseaseEventFilter_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.SpecialThingFilterWorker_Infectious">
            <summary>Used to filter infected animals in pens</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.SpecialThingFilterWorker_Non_Infectious">
            <summary>Used to filter non infected animals in pens</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.CompQuarantineBed">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediff_.PreCachedMedicalMasks.preCachedApparelThatHelpsGermResistance">
            <summary>This is used for the disease spread message, it does not contain all germ resistant apparel. Helmets are excluded for example.</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediff_.PreCachedMedicalMasks.preCachedMedicalMasks">
            <summary>Contains specifically medical apparel, such as the surgical mask from vanilla expanded. This list is used for extra buffs in calculations.</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.Hediff_.GermMaker.difficultyRatio">
            <summary>Affects base infection chance</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.PawnCanSpreadAnyDiseaseNow(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>True if pawn can spread disease, false if cant</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.PawnCanSpreadDisease(Verse.Pawn,Verse.Hediff)">
            <summary>Checks if the given pawn can spread germs from the specified disease instance.</summary>
            <param name="pawn"></param>
            <param name="myDisease">The infectious disease the pawn has</param>
            <returns>True if pawn can spread the disease, false if cant</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.TryGetInfectiousDisease(Verse.Pawn,Verse.ThingDef@)">
            <summary>Gets the first found infectious disease if it exists</summary>
            <param name="pawn">Pawn to check</param>
            <param name="filthDef">The ThingDef Filth that is the germs dropped by the disease, null if no disease found</param>
            <returns>The first Hediff or null if no disease found.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.IsInfectiousDisease(Verse.HediffDef,Verse.ThingDef@)">
            <summary>Is the given hediff an infectious disease for the purposes of the disease spread system, or other integrated systems.</summary>
            <param name="hediffDef">Is this hediff an infectious disease?</param>
            <param name="filthDef">The Filth (ThingDef) that corresponds to this disease.</param>
            <returns>True if hediff is an infectious disease. else false.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.IsCarryingGerms(Verse.Pawn,Verse.HediffDef@,RimWorld.Filth@)">
            <summary>Returns true if the given pawn is carrying (has Filth attached to them) that corresponds to an infectious disease.</summary>
            <param name="pawn">Check this pawn for germs.</param>
            <param name="disease">The disease of the germs that are found, or null if no germs are found.</param>
            <param name="germFilth"></param>
            <returns>Returns true if the given pawn is carrying germs</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.ShouldInfectPawnWith(Verse.Pawn,Verse.HediffDef,NQualityOfLife.Ratio@,NQualityOfLife.Percentage@,NQualityOfLife.Factor@,NQualityOfLife.Factor@,System.Collections.Generic.List{RimWorld.Trait}@,System.Single)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="disease"></param>
            <param name="generalResistance"></param>
            <param name="immunityToThis"></param>
            <param name="negativeModifiers"></param>
            <param name="affectingTraits">A list of traits that contributed to the final chance, or empty list if there were none.</param>
            <param name="baseInfectionChance"></param>
            <param name="positiveModifiers"></param>
            <returns>True if tha pawn should be infected with the specified disease.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.InfectionResistCoinFlipWithModifiers(Verse.Pawn,System.Single,NQualityOfLife.Factor@,NQualityOfLife.Factor@,System.Collections.Generic.List{RimWorld.Trait}@)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="baseChance">Base chance that is then modified by traits etc.</param>
            <param name="positiveModifiers"></param>
            <param name="negativeModifiers"></param>
            <param name="affectingTraits">A list of traits that contributed to the calculation. or empty list if none.</param>
            <returns>True if the pawn resisted the infection attempt, else false.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.GetNegativeModifiers(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>a positive float of the negative modifiers for germ resistance for the given pawn.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.GetPositiveModifiers(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>a positive float of the modifiers for germ resistance for the given pawn.</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.GetClothingGermResistance(Verse.ThingDef,Verse.BodyDef,System.Boolean)">
            <summary></summary>
            <param name="apparel"></param>
            <param name="raceBody"></param>
            <param name="useToxResistStat"></param>
            <returns>float value in the 0.0f - 1.0f range</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Hediff_.DiseaseSpreadUtils.ImmunityToDisease(Verse.Pawn,Verse.HediffDef)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="disease"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.HasChildParts(Verse.BodyPartRecord)">
            <summary></summary>
            <param name="part"></param>
            <returns>True if the given part has child parts</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.GetDirectChildParts(Verse.BodyPartRecord)">
            <summary>Gets the child parts directly attached to this part</summary>
            <param name="part">Get the child parts directly attached to this part</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.SeverityPerDay(Verse.Hediff)">
            <summary>Gets the base severity per day for the hediff</summary>
            <param name="hediff"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.Hediffs(Verse.BodyPartRecord,Verse.Pawn)">
            <summary>Gets all the hediffs affecting the given part on the given pawn</summary>
            <param name="part"></param>
            <param name="pawn"></param>
            <returns>All the hediffs on the given body part of the pawn</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Utils_Medical.Hediffs(Verse.BodyPartRecord,Verse.Pawn,System.Int32@)">
            <summary></summary>
            <param name="part"></param>
            <param name="pawn"></param>
            <param name="count"></param>
            <returns>Not null</returns>
        </member>
        <member name="F:NQualityOfLife.Medical.Surgery.SurgerySuccessInfo_Patch_1.report_Quality">
            <summary>The details for the surgery fail letter</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.Surgery.Utils_Surgery.CanEverFail(RimWorld.Recipe_Surgery)">
            <summary>Can this surgery ever fail?</summary>
            <param name="surgery">The surgery to perform</param>
            <returns>true if can fail, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.Surgery.Utils_Surgery.CanEverFail(NQualityOfLife.Medical.Surgery.RecipeDef)">
            <summary>Can this type of surgery / recipeDef ever fail?</summary>
             <param name="surgery">The surgery recipe</param>
             <returns>true if can fail, else false</returns>
        </member>
        <member name="T:NQualityOfLife.Medical.LocalSettings">
            <summary>Settings on start up</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.LocalSettings.debugMode">
            <summary>debug mode bool</summary>
        </member>
        <member name="T:NQualityOfLife.Medical.CPR_Utils">
            <summary>CPR related helper functions</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.SomeoneBetterAtCPRIsFree(Verse.Pawn,Verse.Pawn,Verse.Pawn@,System.Boolean@,System.Nullable{System.Single},System.Boolean)">
            <summary></summary>
            <param name="patient"></param>
            <param name="me"></param>
            <param name="betterPawn">The pawn who is better and available to take over</param>
            <param name="otherPawnOnTheWayOrHere">Is the other pawn heading to help?</param>
            <param name="myCPRPower">float of my CPR power, if left to null it will be re calculated</param>
            <param name="orderBetterPawnToHelp">Should we order a better pawn to come help if able?</param>
            <returns>True if someone is better and able to help</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetCPRStrengthOfPawn(Verse.Pawn)">
            <summary>Get the CPR strength of a pawn</summary>
            <param name="doctor">Get the CPR strength of this pawn</param>
            <returns>float CPRStrength, and float techniqueMultiplier</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetDeathRattleHediffsToTreat(Verse.Pawn)">
            <summary></summary>
            <param name="patient"></param>
            <returns>Not null</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.HasAnyApplicableHediff(Verse.Pawn)">
            <summary>Does the pawn have any hediffs that can be treated with CPR?</summary>
            <param name="patient">The pawn who's hediffs to check</param>
            <returns>true if has any applicable hediff</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.CPR_Utils.GetHediffsToTreat(Verse.Pawn)">
            <summary></summary>
            <param name="patient">Pawn to check</param>
            <returns>IEnumerable of all the hediffs that CPR will treat - Not null</returns>
        </member>
        <member name="T:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other">
            <summary>Perform CPR on an other pawn</summary>
        </member>
        <member name="P:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.PotentialWorkThingRequest">
            <summary>Pawns only</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.PotentialWorkThingsGlobal(Verse.Pawn)">
            <summary>Only pawns with any hediff</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.GoodLayingStatusForTend(Verse.Pawn)">
            <summary>Determine if GoodLayingStatusForTend</summary>
            <param name="patient">Check if this pawn is in a good position to be tended</param>
            <returns>bool, true if good status</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.HasJobOnThing(Verse.Pawn,Verse.Thing,System.Boolean)">
            <summary>Determine if pawn has a CPR job on an other pawn</summary>
            <param name="pawn">The doctor who is looking for a CPR job</param>
            <param name="t">The pawn to check for a job</param>
            <param name="forced"></param>
            <returns>bool, true if there is a CPR job that needs to be done</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.JobOnThing(Verse.Pawn,Verse.Thing,System.Boolean)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="t">The pawn to check for a job</param>
            <param name="forced">false</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Medical.NQoL_WorkGiver_CPR_Other.IsAnyColonistPerformingCPROn(Verse.Pawn,Verse.Map)">
            <summary>Determine if any colonist is performing CPR on the target pawn</summary>
            <param name="patient">check if anyone is performing CPR on this pawn</param>
            <param name="map"></param>
            <returns>bool, true if someone is doing CPR</returns>
        </member>
        <member name="T:NQualityOfLife.Medical.JobDriver_Perform_CPR">
            <summary>CPR job driver</summary>
        </member>
        <member name="P:NQualityOfLife.Medical.JobDriver_Perform_CPR.Patient">
            <summary>The patient is the pawn who needs CPR</summary>
        </member>
        <member name="F:NQualityOfLife.Medical.JobDriver_Perform_CPR.PawnOnTheWay">
            <summary>The pawn who is on the way to help</summary>
        </member>
        <member name="M:NQualityOfLife.Medical.JobDriver_Perform_CPR.TryMakePreToilReservations(System.Boolean)">
            <summary>Determine if possible to do CPR job</summary>
            <param name="errorOnFailed">output error on failed reservations</param>
            <returns>bool true if success</returns>
        </member>
        <member name="M:NQualityOfLife.Medical.JobDriver_Perform_CPR.MakeNewToils">
            <summary>Create the sequence of jobs for CPR</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.CompHomeSeparator">
            <summary>ThingComp for doors that can be used to toggle home separation</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility">
            <summary>Pawn homes</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility.HomeData">
            <summary>Contains all the family homes</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.HomeUtility.HomeData.homes">
            <summary>List of all active homes</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.HomeUtility.HomeRoom">
            <summary>Contains data for HomeRooms</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.DeleteAllHomes(Verse.Map)">
            <summary>Delete all homes on the given map, or all homes on all maps</summary>
            <param name="map">The Map to limit the deletion to, if null: delete all</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.PrintHomes(Verse.Map)">
            <summary>Print all the homes of a given map to debug log, or all homes if map is not given</summary>
            <param name="map">Only print homes on this Map, if null: print all homes</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.GetPotentialNewHomeOwners(Verse.Map)">
            <summary>Get all pawns on a given map, who can be home owners that are not already owners</summary>
            <returns>A List of all pawns who can create a home</returns>
            <param name="map">The Map to use as a reference, will try to resolve if null, but should be given if possible</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToFillAllRooms(Verse.Map)">
            <summary>Attempt to fill all homes on the given map, or all homes on all maps</summary>
            <param name="map">Only this map, if null: on all maps</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToFillRooms(NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Attempt to add relatives of home owner to given home</summary>
            <param name="home">Try fill the rooms of this home</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.HomeID(Verse.Pawn)">
            <summary>Get the home id of the home this pawn is an occupant of</summary>
            <param name="pawn">Get the home id of this pawn</param>
            <returns>int?, null if not part of any home</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CanBeAHomeOwner(Verse.Pawn,System.Boolean,System.Boolean)">
            <summary>Is this pawn a valid pawn to be a home owner, same result even if already home owner</summary>
            <param name="pawn">Is this pawn a valid pawn to be a home owner</param>
            <param name="ignoreRelatives">Ignore the relative requirement</param>
            <param name="loversCountAsRelatives">Lovers count as relatives for the relative check</param>
            <returns>true if can be home owner</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToCreateAllHomes(Verse.Map,System.Boolean)">
            <summary>Try to create all valid homes on the given map, or on all maps</summary>
            <param name="map">Specific map to apply the method to, can be null</param>
            <param name="annexRooms">Should we attempt to annex all valid rooms after creation?</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TryToCreateHome(Verse.Map,System.Boolean,Verse.Room,System.Boolean,System.Boolean)">
            <summary>Try to create a home on the given map origination from a specific room, or any valid room</summary>
            <param name="map">The target map, cannot be null!</param>
            <param name="annexRooms">should we attempt to annex all valid rooms to the home?</param>
            <param name="specificRoom">Create the home starting from this specific room, if null, create in a valid room</param>
            <param name="forceCacheUpdate">Force cache updates?</param>
            <param name="ignoreRelatives"></param>
            <returns>bool true if succeeded in creating a home</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.TransferHouseOwnershipFrom(Verse.Pawn,Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="newOwner"></param>
            <param name="home"></param>
            <returns>true if ownership was successfully transferred</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CouldBeAPublicHub(Verse.Room,Verse.Map)">
            <summary>Is the given room likely to be a public hallway that connects to multiple homes or public areas</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsDeadEndRoom(Verse.Room)">
            <summary>true if the given room only connects to one other room, door count doesn't matter, as long as they connect to the same room</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.WouldMergeHomes(Verse.Room,Verse.Map)">
            <summary>Would adding this room to a home make two homes touch? (separated only by 1 door)</summary>
            <param name="room"></param>
            <param name="map"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsValidRoomForAHome(Verse.Room,Verse.Map,System.Boolean,System.Boolean,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary></summary>
            <param name="room"></param>
            <param name="map"></param>
            <param name="mustBeBedroom"></param>
            <param name="simplifiedCheck"></param>
            <param name="isDoorway"></param>
            <param name="isPrison"></param>
            <param name="isProperRoom"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.ValidateAllHomes(Verse.Map)">
            <summary>Validate the data on all the homes on a map, or all homes on all maps. Attempts to fix any issues.</summary>
            <param name="map">The Map where we want to validate, if null: validate all</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.ValidateAllRoomsOfHome(NQualityOfLife.HomeSystem.HomeUtility.Home,Verse.Map)">
            <summary>Validate the data on all the rooms of a given home. Attempts to fix any issues.</summary>
            <param name="home">Validate this home</param>
            <param name="map">The Map where the home is located, should be given if possible.</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.AttemptToAnnexAllRooms(Verse.Map)">
            <summary>Attempt to annex all valid rooms to all homes</summary>
            <param name="map">The Map to affect, or all maps if null</param>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.AttemptToAnnexRoomsToHome(NQualityOfLife.HomeSystem.HomeUtility.Home,Verse.Map,System.Boolean)">
            <summary>Attempt to annex all valid rooms to a home</summary>
            <param name="home">try to add all valid rooms to this home</param>
            <param name="map"></param>
            <param name="forceCacheUpdate">force update caches?</param>
            <returns>bool of success</returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.CreateNewRoomData(Verse.Room,System.Boolean)">
            <summary></summary>
            <param name="room"></param>
            <param name="isBedroom"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsPartOfAnyHome(Verse.District)">
            <summary>Is the given room already a part of a home?</summary>
        </member>
        <member name="M:NQualityOfLife.HomeSystem.HomeUtility.IsPartOfAnyHome(Verse.Room,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is the given room already a part of a home?</summary>
        </member>
        <member name="T:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf">
            <summary>ThoughtDefs related to family homes</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf.NQoL_SleptInAFamilyHome">
            <summary>The thought given to pawns upon sleeping in their own home</summary>
        </member>
        <member name="F:NQualityOfLife.HomeSystem.Thoughts.ThoughtDefOf.NQoL_JoyActivityInImpressiveLivingRoom">
            <summary>The thought given to pawns after playing in their own living room</summary>
        </member>
        <member name="M:NQualityOfLife.Progression.NQoL_Research_Queue_Patch_1.GetNextFromQueue(System.Collections.Generic.List{Verse.ResearchProjectDef},System.Boolean)">
            <summary></summary>
            <param name="researchQueue"></param>
            <param name="debugWarningOnFail"></param>
            <returns>Null if nothing to start, or the project to try start from queue</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.NQoL_Research_Queue_Patch_1.TryToStartNextAvailableResearchFromQueue(System.Collections.Generic.List{Verse.ResearchProjectDef},System.Boolean)">
            <summary></summary>
            <param name="researchQueue"></param>
            <param name="errorOnFail"></param>
            <returns>True if research was started, false if not</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.DoProgression(NQualityOfLife.Ratio,NQualityOfLife.Ratio,System.Boolean,RimWorld.TechLevel@,RimWorld.TechLevel@,System.Boolean)">
            <summary>Calls all the methods needed to progress the tech level</summary>
            <param name="ratioNeeded">The ratio of completed research projects of a level needed to consider that level completed</param>
            <param name="ratioNeededForSkip">The ratio of tech needed to be completed in a tech level 2 tiers ahead to level up</param>
            <param name="allowRegression"></param>
            <param name="oldLevel"></param>
            <param name="newLevel"></param>
            <param name="suppressMessage">Suppress in game notification message about level progress</param>
            <returns>false if there was an issue</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.GetDesiredTechLevel(NQualityOfLife.Ratio,NQualityOfLife.Ratio,System.Boolean)">
            <summary>Calculate the tech level that the colony should have based on the given parameters</summary>
            <param name="ratioNeeded">The ratio of completed research projects of a level needed to consider that level completed</param>
            <param name="ratioNeededForSkip">The ratio of tech needed to be completed in a tech level 2 tiers ahead to level up</param>
            <param name="debug"></param>
            <returns>Desired tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Progression.Evaluate_Progression.SetDesiredTechLevel(RimWorld.TechLevel,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set the colony tech level to the given Int</summary>
            <param name="newTechLevel">The Int of the new tech level</param>
            <param name="allowRegression"></param>
            <param name="suppressMessage">Suppress in game message notification</param>
            <param name="debug"></param>
            <returns>true if level changed, false if level was not changed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.ToString">
            <summary>Convert the IString to string</summary>
            <returns>string</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.IString.Dot(System.String)">
            <summary>Concats 2 strings with a dot between them</summary>
            <param name="afterDot">Text after the dot</param>
            <returns>{text}.{afterDot}</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.IString`1.Dot(`0)">
            <summary>Concats 2 strings with a dot between them</summary>
            <param name="afterDot">Text after the dot</param>
            <returns>{text}.{afterDot}</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FormatAsString_XML_List(System.String,NQualityOfLife.Utils.Common.FormatMode)">
            <summary>Accepts a string that contains XML '&lt;li&gt;value&lt;/li&gt;' elements.</summary>
            <param name="xmlList">a string made from '&lt;li&gt;value&lt;/li&gt;' elements.</param>
            <param name="formatMode">The format we want to convert the list to</param>
            <returns>The list re-formatted using the selected format mode</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.XMLToList(System.String,System.Boolean)">
            <summary>Accepts a string that contains XML '&lt;li&gt;value&lt;/li&gt;' elements.</summary>
            <param name="xmlList"></param>
            <param name="keepTags">Include the '&lt;li&gt;&lt;/li&gt;' tags around the values in the output list</param>
            <returns>The values of the xml list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IndexOf(System.String,System.Char,System.Int32@)">
            <summary>Get the zero based index of the first occurance of the given character || or -1 if none found.</summary><param name="str"></param><param name="character"></param><param name="stringLength">The Length of the string</param><returns>The zero based index || or -1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char)">
            <summary>Get the zero based index of the first occurance of the given character || or -1 if none found.</summary><param name="text"></param><param name="character"></param><returns>The zero based index || or -1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.Char,System.Int32@)">
            <summary>Get the zero based index of the first occurance of the given character || or -1 if none found.</summary><param name="text"></param><param name="character"></param><param name="stringLength">The Length of the string</param><returns>The zero based index || or -1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.Char,System.Int32@)">
            <summary>Get the zero based index of the last occurance of the given character || or -1 if none found.</summary><param name="text"></param><param name="character"></param><param name="stringLength">The Length of the string</param><returns>The zero based index || or -1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <summary>Get the zero based index of the first occurance of the given subString || or -1 if none found.</summary><param name="str"></param><param name="subString"></param><param name="stringLength"></param><param name="comparisonType"></param><returns>The zero based index || or -1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.StringComparison)">
            <summary>Get the zero based index of the first occurance of the given subString || or -1 if none found.</summary><param name="str"></param><param name="subString"></param><param name="comparisonType"></param><returns>The zero based index || or -1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstIndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <summary>Get the zero based index of the first occurance of the given subString || or -1 if none found.</summary><param name="str"></param><param name="subString"></param><param name="stringLength"></param><param name="comparisonType"></param><returns>The zero based index || or -1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastIndexOf(System.String,System.String,System.Int32@,System.StringComparison)">
            <summary>Get the zero based index of the last occurance of the given subString || or -1 if none found.</summary><param name="str"></param><param name="subString"></param><param name="stringLength"></param><param name="comparisonType"></param><returns>The zero based index || or -1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Char)">
            <summary>Count matching a characters</summary>
            <param name="str"></param>
            <param name="character"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Char,System.Char)">
            <summary>Count matching a characters</summary>
            <param name="str"></param>
            <param name="character"></param>
            <param name="or"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Count(System.String,System.Predicate{System.Char})">
            <summary>Count characters matching a condition</summary>
            <param name="str"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Dot(System.String,System.String)">
            <summary>Concats 2 strings with a dot between them</summary>
            <param name="text">Text before the dot</param>
            <param name="dotText">Text after the dot</param>
            <returns>{text}.{dotText}</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String)">
            <summary>Concat a string to the end of this string</summary>
            <param name="text"></param><param name="other"></param>
            <returns>A new string composed of the input strings</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String)">
            <summary>Concat a string to the end of this string</summary>
            <param name="text"></param><param name="other1"></param>
            <param name="other2"></param>
            <returns>A new string composed of the input strings</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String)">
            <summary>Concat a string to the end of this string</summary>
            <param name="text"></param><param name="other1"></param>
            <param name="other2"></param>
            <param name="other3"></param>
            <returns>A new string composed of the input strings</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat a string to the end of this string</summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param>
            <returns>A new string composed of the input strings</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat a string to the end of this string</summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param><param name="other5"></param>
            <returns>A new string composed of the input strings</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Concat(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Concat a string to the end of this string</summary>
            <param name="text"></param><param name="other1"></param><param name="other2"></param><param name="other3"></param><param name="other4"></param><param name="other5"></param><param name="other6"></param>
            <returns>A new string composed of the input strings</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SplitBy(System.String,System.Int32,System.Int32)">
            <summary>Splits the string into chunks of a specified length</summary>
            <param name="text"></param>
            <param name="chunkLength"></param>
            <param name="textLength">text.Length</param>
            <returns>A list of strings with a length of 'chunkLength'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.NullOrEmpty(System.String,System.Boolean)">
            <summary></summary>
            <param name="s">string</param>
            <param name="treatSymbolsAsValue">Treat the null or empty symbols as if they were the values they represent</param>
            <returns>True if the string is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Boolean)">
            <summary></summary>
            <param name="s">string</param>
            <param name="treatSymbolsAsValue">Treat the null or empty symbols as if they were the values they represent</param>
            <returns>True if the string is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(NQualityOfLife.Utils.IString,System.Boolean)">
            <summary></summary>
            <param name="s">string</param>
            <param name="treatSymbolsAsValue">Treat the null or empty symbols as if they were the values they represent</param>
            <returns>True if the string is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(NQualityOfLife.Utils.IString,System.Int32@,System.Boolean)">
            <summary></summary>
            <param name="s">string</param>
            <param name="length"></param>
            <param name="treatSymbolsAsValue">Treat the null or empty symbols as if they were the values they represent</param>
            <returns>True if the string is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsEmptySymbol(System.String)">
            <summary>Is the given string the value of the empty symbol</summary>
            <param name="s"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullSymbol(System.String)">
            <summary>Is the given string the value of the null symbol</summary>
            <param name="s"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsNullOrEmpty(System.String,System.Int32@,System.Boolean)">
            <summary></summary>
            <param name="s"></param>
            <param name="length">Will be -1 if string is null, else the Length of the string</param>
            <param name="treatSymbolsAsValue">Treat the null or empty symbols as if they were the values they represent</param>
            <returns>True if string is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceLast(System.String,System.Char,System.Char)">
            <summary>Iterates the input string in reverse and replaces the first found oldChar with newChar and returns the modified string</summary>
            <param name="text">Input string</param>
            <param name="oldChar">Replace last instance of this char</param>
            <param name="newChar">Replace oldChar with this</param>
            <returns>The input string with the last occurrence of oldChar replaced with newChar</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveFirst(System.String)">
            <summary>Removes the first character from the input string</summary>
            <param name="text"></param>
            <returns>The input string with the first letter/char removed.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLast(System.String)">
            <summary>Removes the last character from the input string</summary>
            <param name="text"></param>
            <returns>The input string with the last letter/char removed.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char,System.Int32@)">
            <summary>Checks if the input string contains the specific character - input string must not be null!</summary>
            <param name="text">Check this string for the char</param><param name="character">The char to look for</param>
            <param name="index">The index of the first found char || or -1 if it was not found</param>
            <returns>True if the input string contains the character</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char,System.Int32@,System.Int32@)">
            <summary>Checks if the input string contains the specific character - input string must not be null!</summary>
            <param name="text">Check this string for the char</param><param name="character">The char to look for</param>
            <param name="index">The index of the first found char || or -1 if it was not found</param>
            <param name="textLength">-1 on error</param>
            <returns>True if the input string contains the character</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char)">
            <summary>Checks if the input string contains the specific character - input string must not be null!</summary>
            <param name="text">Check this string for the char</param><param name="character">The char to look for</param>
            <returns>True if the input string contains the character</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.Char,System.Int32)">
            <summary>Checks if the input string contains the specific character - input string must not be null!</summary>
            <param name="text">Check this string for the char</param>
            <param name="textLength">text.Length</param><param name="character">The char to look for</param>
            <returns>True if the input string contains the character</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAny(System.String,System.Char[])">
            <summary>Checks if the input string contains ony of the specific characters - input string must not be null!</summary>
            <param name="text"></param>
            <param name="characters"></param>
            <returns>True if the input string contains any of the characters</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.TrimAll(System.Collections.Generic.IList{System.String},System.Boolean)">
            <summary>Create a copy of the input strings with leading and trailing whitespace removed</summary>
            <param name="strings"></param>
            <param name="removeEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsAny(System.Char,System.Char[])">
            <summary>Checks if the provided character is the same as any of the characters in the array</summary>
            <param name="character"></param><param name="ofTheseCharacters"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsAny(System.Char,System.Char[],System.Int32)">
            <summary>Checks if the provided character is the same as any of the characters in the array</summary>
            <param name="character"></param><param name="ofTheseCharacters"></param>
            <param name="arraySize">The known amount of characters in the array</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.IsAny(System.Char,System.Int32,System.Char[])">
            <summary>Checks if the provided character is the same as any of the characters in the array</summary>
            <param name="character"></param><param name="ofTheseCharacters"></param>
            <param name="arraySize">The known amount of characters in the array</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAny(System.String,System.String[])">
            <summary>Checks if the provided string contains or matches any of the strings in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <returns>True if the input matches or contains any of the provided strings. If input text or string array are null or empty; returns false.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAny(System.String,System.Collections.Generic.IList{System.String},System.String@)">
            <summary>Checks if the provided string contains or matches any of the strings in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <param name="firstMatch"></param>
            <returns>True if the input matches or contains any of the provided strings. If input text or string array are null or empty; returns false.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAny(System.String,System.String@,System.String[])">
            <summary>Checks if the provided string contains or matches any of the strings in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <param name="firstMatch"></param>
            <returns>True if the input matches or contains any of the provided strings. If input text or string array are null or empty; returns false.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Contains(System.String,System.String,System.Int32)">
            <summary>Checks if the string contains the given substring</summary>
            <param name="text"></param>
            <param name="substring"></param>
            <param name="textLength"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAll(System.String,System.String[])">
            <summary>Checks if the provided string contains or matches all of the strings in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <returns>True if the input matches or contains all of the provided strings. || If input text or string array are null or empty; returns false.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ContainsAll(System.String,System.Char[])">
            <summary>Checks if the provided string contains or matches all of the chars in the array.</summary>
            <param name="text"></param>
            <param name="ofThese"></param>
            <returns>True if the input string contains or matches all of the provided chars. || If input text or char array are null or empty; returns false.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.EndsWith_Fast(System.String,System.String)">
            <summary>Checks if the provided string ends with the given substring</summary>
            <param name="text"></param><param name="with"></param>
            <returns>False if any input is null, True if 'text' ends with 'with'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String)">
            <summary></summary>
            <param name="text"></param>
            <param name="with"></param>
            <returns>false if any input is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.StartsWith_Fast(System.String,System.String,System.String)">
            <summary></summary>
            <param name="text"></param>
            <param name="with"></param>
            <param name="or"></param>
            <returns>always false if the input string is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbol(System.String)">
            <summary>Returns the last char of a string, or '\0' if invalid string</summary>
            <param name="text">text to check</param>
            <returns>The last char of the provided string or empty char ('\0') if text is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char)">
            <summary>Checks if the last symbol (char) of a string is the provided char</summary>
            <param name="text">text to check</param>
            <param name="lastSymbol">char that we are comparing</param>
            <returns>True if the string ends with the provided char</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char,System.Char)">
            <summary>Checks if the last symbol (char) of a string is the provided char</summary>
            <param name="text">text to check</param>
            <param name="lastSymbol">char that we are comparing</param>
            <param name="or"></param>
            <returns>True if the string ends with the provided char</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.LastSymbolIs(System.String,System.Char,System.Char,System.Char)">
            <summary>Checks if the last symbol (char) of a string is the provided char</summary>
            <param name="text">text to check</param>
            <param name="lastSymbol">char that we are comparing</param>
            <param name="or"></param>
            <param name="orThis"></param>
            <returns>True if the string ends with the provided char</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbol(System.String)">
            <summary>Returns the first char of a string, or '\0' if invalid string</summary>
            <param name="text">text to check</param>
            <returns>The first char of the provided string or empty char ('\0') if text is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char)">
            <summary>Checks if the first symbol (char) of a string is the provided char - a null or empty string will return false</summary>
            <param name="text">text to check - a null or empty string will return false</param>
            <param name="firstSymbol">char that we are comparing</param>
            <returns>True if the string starts with the provided char - a null or empty string will return false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char,System.Char)">
            <summary>Checks if the first symbol (char) of a string is the provided char - a null or empty string will return false</summary>
            <param name="text">text to check - a null or empty string will return false</param>
            <param name="firstSymbol">char that we are comparing</param>
            <param name="or"></param>
            <returns>True if the string starts with the provided char - a null or empty string will return false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.FirstSymbolIs(System.String,System.Char,System.Char,System.Char)">
            <summary>Checks if the first symbol (char) of a string is the provided char - a null or empty string will return false</summary>
            <param name="text">text to check - a null or empty string will return false</param>
            <param name="firstSymbol">char that we are comparing</param>
            <param name="or"></param>
            <param name="orThis"></param>
            <returns>True if the string starts with the provided char - a null or empty string will return false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterLastOrFallback(System.String,System.Char,System.String)">
            <summary>Gets the substring after the last instance of the specified character.</summary>
            <param name="text"></param>
            <param name="afterThisChar"></param>
            <param name="fallback"></param>
            <returns>The substring after the last instance of the specified char or 'fallback' if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfterLast(System.String,System.Char)">
            <summary>Gets the substring after the last instance of the specified character.</summary>
            <param name="text"></param>
            <param name="afterThisChar">Get the substring after the first instance of this char</param>
            <returns>The substring after the last instance of the specified char || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfter(System.String,System.Char)">
            <summary>Gets the substring after the first instance of the specified character.</summary>
            <param name="text"></param>
            <param name="afterThisChar"></param>
            <returns>The substring after the specified char || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringAfter(System.String,System.Int32,System.Int32)">
            <summary>Get the substring after the given index</summary>
            <param name="text"></param><param name="index"></param>
            <param name="textLength"></param>
            <returns>The part of the input string after the given index || or string.Empty (with error) if out of bounds</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Char[])">
            <summary>Get all the characters of the substring from start to end until the condition no longer mathes or it reaches the end of the input string</summary>
            <param name="text"></param>
            <param name="matchChars"></param>
            <returns>The substring before the predicate returned false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringWhile(System.String,System.Predicate{System.Char})">
            <summary>Get all the characters of the substring from start to end until the condition no longer mathes or it reaches the end of the input string</summary>
            <param name="text"></param>
            <param name="predicate"></param>
            <returns>The substring before the predicate returned false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBefore(System.String,System.Char)">
            <summary>Gets the substring before the first instance of the specified character.</summary>
            <param name="text"></param>
            <param name="beforeThisChar"></param>
            <returns>The substring before the first found instance of the specified char || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeOrFallback(System.String,System.Char,System.String)">
            <summary>Gets the substring before the first instance of the specified character.</summary>
            <param name="text"></param>
            <param name="beforeThisChar"></param>
            <param name="fallback"></param>
            <returns>The substring before the first found instance of the specified char or 'fallback' if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBeforeOrFallback(System.String,System.String,System.String)">
            <summary>Get the substring before the first instance of the given sub string - Excluding the substring</summary>
            <param name="text"></param><param name="subString">Get the text before the first instance of this</param>
            <param name="fallback">Return this string instead if no match found</param>
            <returns>The substring before the given substring - 'fallback' if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBefore(System.String,System.String)">
            <summary>Get the substring before the first instance of the given sub string - Excluding the substring</summary>
            <param name="text"></param><param name="subString">Get the text before the first instance of this</param>
            <returns>The substring before the given substring - 'string.Empty' if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringBefore(System.String,System.Int32)">
            <summary>Get the part of the input string before a specific index</summary>
            <param name="text"></param><param name="index">Get all the text before this index</param>
            <returns>The part of the given string before the given index - Excluding the char at the index - May throw an 'ArgumentOutOfRangeException'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Inclusive(System.String,System.String,System.String,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified start and end strings - Including the start and end strings</summary>
            <param name="text">Input text</param>
            <param name="start">Start string of the substring</param>
            <param name="end">End string of the substring</param>
            <param name="settings"></param>
            <returns>The substring starting with "start" and ending with "end" || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.String,System.String,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified start and end strings - Excluding the start and end strings</summary>
            <param name="text">Input text</param>
            <param name="start">The string before the target substring</param>
            <param name="end">The string after the target substring</param>
            <param name="settings"></param>
            <returns>The substring between "start" and "end" || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.String,System.Char,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified start string and end char - Excluding the start string and end char</summary>
            <param name="text">Input text</param>
            <param name="start">The string before the target substring</param>
            <param name="end">The char after the target substring</param>
            <param name="settings"></param>
            <returns>The substring after the "start" string and before the 'end' char || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.Int32,System.Char)">
            <summary>Gets the first substring that is inside the specified [ startIndex ] and [ 'end' char ] - Excluding the end char and the character at the start index</summary>
            <param name="text">Input text</param>
            <param name="startIndex">The index right before the target substring</param>
            <param name="end">The char right after the target substring</param>
            <returns>The substring starting after "startIndex" and ending before [ 'end' char ] || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.Int32,System.String,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified start and end strings - Excluding the start and end strings</summary>
            <param name="text">Input text</param>
            <param name="startIndex">Start index of the substring</param>
            <param name="end">End string of the substring</param>
            <param name="settings"></param>
            <returns>The substring starting at 'startIndex' and ending with "end" || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.String,System.Int32,System.StringComparison)">
            <summary>Gets the first substring that is inside the specified start string and end Index - Excluding the start string and end Index</summary>
            <param name="text">Input text</param>
            <param name="start">The string before the target substring</param>
            <param name="endIndex">The index after the target substring</param>
            <param name="settings"></param>
            <returns>The substring between "start" and 'endIndex' || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Inclusive(System.String,System.Char,System.Char)">
            <summary>Gets the first found substring that starts and ends with the specified characters - Including the characters</summary>
            <param name="text">Input text</param>
            <param name="start">Start char of the substring</param>
            <param name="end">End char of the substring</param>
            <returns>The first found substring starting with 'start' and ending with 'end' || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.SubstringInsideOf_Exclusive(System.String,System.Char,System.Char)">
            <summary>Gets the first found substring that is inside the specified characters - Excluding the characters</summary>
            <param name="text">Input text</param>
            <param name="start">The char before the start of the substring</param>
            <param name="end">The char after the end of the substring</param>
            <returns>The substring between the start and end chars || or 'string.Empty' if not found || - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_FirstSubstringInsideOf_Exclusive(System.String,System.Char,System.Char,System.String)">
            <summary>Replaces the substring that is inside the specified characters - Excluding the characters - If no math found, return the input string un-changed</summary>
            <param name="text">Input text</param>
            <param name="startChar">The char before the start of the substring</param>
            <param name="endChar">The char after the end of the substring</param>
            <param name="replacement">Replace the substring with this</param>
            <returns>The original string with the substring between the start and end chars replaced || or the original text un-changed if the substring is not found || - Null symbol if any input is null (will error)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceCaseInsensitive(System.String,System.String,System.String)">
            <summary>Replaces all occurrences of the specified string (Case insensitive) with a new string.</summary>
            <param name="originalText"></param>
            <param name="stringsToReplace"></param>
            <param name="replacement"></param>
            <returns>The input string with all the substrings replaced</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirstSymbol(System.String,System.Char)">
            <summary>Replace the first char of the given string with a new character</summary>
            <param name="text"></param><param name="newSymbol"></param><returns>The input string with the first char swapped</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace_FirstSubstringInsideOf_Inclusive(System.String,System.Char,System.Char,System.String)">
            <summary>Replaces the first found substring that is inside the specified characters - Including the characters</summary>
            <param name="text">Input text</param>
            <param name="start">The first char of the substring to replace</param>
            <param name="end">The last char of the substring to replace</param>
            <param name="replacement">Replace the substring with this</param>
            <returns>The original string with the first found substring replaced || or the original text un-changed if the substring is not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace(System.String,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>Replaces a part of the string from start index to end index with a new value - (to = (from + with.Length - 1))</summary>
            <param name="text">Original string</param>
            <param name="fromIndex">Replace starting from index</param>
            <param name="toIndex">to index - (from + with.Length - 1)</param>
            <param name="with">New value to be placed starting and ending at the specified indexes</param>
            <param name="textLength"></param>
            <returns>The original string with the specified part replaced || - never null (returns null symbol if input text is null (with error logged))</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace(System.String,System.Int32,System.String)">
            <summary>Replace the character at the specified index with the given substring</summary>
            <param name="text">Text to modify - Cannot be null!</param><param name="at">The index of the character to replace with a string</param><param name="with">The string to place at the given index</param>
            <returns>The input string modified with the character at the given index replaced with the given string</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.Replace(System.String,System.Int32,System.Char)">
            <summary>Replace the character at the specified index with the given character</summary>
            <param name="text">Text to modify - Cannot be null!</param><param name="at">The index of the character to replace</param><param name="with">The new character to put at the index</param>
            <returns>The input string modified with the character at the given index swapped</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveFirst(System.String,System.String)">
            <summary>Removes the first instance of the given sub string</summary>
            <param name="text"></param><param name="subString">The sub string to remove</param>
            <returns>The input string with the first occurance of the sub string removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceFirst(System.String,System.String,System.String)">
            <summary>Replaces the first found instance of 'subString' with 'with'</summary>
            <param name="text">The original text to modify</param>
            <param name="subString">Replace the first instance of this with 'with'</param>
            <param name="with">Replace 'subString' with this</param>
            <returns>The original string with the first matching substring replaced || or the original string un-changed if none found.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.RemoveLast(System.String,System.String)">
            <summary>Removes the last instance of the given sub string</summary>
            <param name="text"></param><param name="subString">The sub string to remove</param>
            <returns>The input string with the last occurance of the sub string removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.StringExtensions.ReplaceLast(System.String,System.String,System.String)">
            <summary>Replace the specified substring that is closest to the end of the string with a new value</summary>
            <param name="text"></param>
            <param name="subString"></param>
            <param name="with"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Reflection_">
            <summary>Class containing all sorts of utilities and methods for purposes of reflection and dynamic method invocation</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ClearCache">
            <summary>Clear the cache of methods and fields</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_FromString(System.String,System.String,System.Object@,System.Boolean)">
            <summary>Invoke a method or property getter using an input string</summary>
            <param name="invoke">The method or propery getter and its parameters - The return value (if any) is passed as the first param to the 'postInvoke' method (if given)</param>
            <param name="postInvoke">Invoke a secondary method or property getter using the result from the first invoke as the first param</param>
            <param name="firstInvokeResult">The value returned by the method specifeid in 'invoke'</param>
            <param name="allowNonPublic"></param>
            <returns>The value returned by the invoked method or propery, if 'postInvoke' is given the value of it will be returned instead of 'invoke'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_StringForInvoke(System.String)">
            <summary>Check if the string is illegal</summary>
            <param name="myString"></param>
            <returns>true if ok, false if not allowed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ResolveParameters_FromStrings(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Type}@)">
            <summary>Convert a list of strings into the objects / values that they represent</summary>
            <param name="parameters">The parameter inputs strings</param>
            <param name="parsedAs">The types that the input parameters were parsed as</param>
            <returns>The actual values that the input strings represented</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.ResolveParameter_FromString(System.String,System.Type@)">
            <summary>Convert a string into the real value it represents. for example and input parameter of 'A' will be parsed as a char 'A'. input of "ABC" will be parsed as a string etc.</summary>
            <param name="parameter">The string representation of a value. "" for strings, '' for chars, f for floats etc..</param>
            <param name="parsedAs">The type that the input was parsed as.</param>
            <returns>The real value that the input string represents</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.GetTypes(System.Object[])">
            <summary>Get the types of the given objects</summary>
            <param name="parameters"></param>
            <returns>An array of the types in order</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.GetMethod(System.String,System.Object[]@,System.Object@,System.Object,System.Object[])">
            <summary>Try get the MethodInfo for the method or property getter matching the given params</summary>
            <param name="nameSpaceDotTypeColonMethod"></param>
            <param name="parametersOut"></param>
            <param name="instanceOut"></param>
            <param name="instance"></param>
            <param name="parameters"></param>
            <returns>The found MethodInfo of the specified method or property or null if not found.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Method_WithType(System.String,System.String,System.String,System.Boolean,System.Object[])">
            <summary>Inoke a method or propery getter of the given type with the given params</summary>
            <param name="type"></param>
            <param name="method"></param>
            <param name="defaultNameSpace"></param>
            <param name="allowNonPublic"></param>
            <param name="parameters"></param>
            <returns>The result of the invoked method or property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Method(System.String,System.Object[],System.Boolean)">
            <summary>Invokes a method or propery getter</summary>
            <param name="nameSpaceDotTypeColonMethod"></param>
            <param name="parameters"></param>
            <param name="allowNonPublic"></param>
            <returns>The return of the invoked method or property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.TryResolveTargetType(System.String,System.String@,System.String)">
            <summary>Resolve the type / namespace of the given type</summary>
            <param name="targetType"></param>
            <param name="nameSpaceDotType"></param>
            <param name="defaultNameSpace"></param>
            <returns>True if the target type was valid and succesfully resolved</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_Final_String(System.String)">
            <summary>Checks for illegal characters or blacklisted namespaces etc</summary>
            <param name="typeColonMethod"></param>
            <returns>false if the provided method or type is not allowed.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Validate_Method(System.Reflection.MethodInfo,System.Boolean)">
            <summary>Make sure the specified method is allowed</summary>
            <param name="method"></param>
            <param name="allowNonPublic"></param>
            <returns>false if the method is not allowed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_PropertyGet_Static(System.String,System.String,System.String,System.Boolean)">
            <summary>Invoke a static propert getter</summary>
            <param name="type">The class containing the static property getter</param>
            <param name="propertyGet">The name of the property getter</param>
            <param name="defaultNameSpace"></param>
            <param name="allowNonPublic"></param>
            <returns>The value returned by the static property getter</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_GetFieldValue(System.String,System.Object,System.String)">
            <summary>Get the value stored in the specified field of the instance (or static field if instance is null)</summary>
            <param name="fieldName"></param>
            <param name="instance">Get the non static field from this instance, or static field if instance is null</param>
            <param name="nameSpaceDotType"></param>
            <returns>The value stored in the field</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_GetFieldValue(System.Type,System.String,System.Object,System.String)">
            <summary>Get the value of the given field from the given instance (or static field if instance is null)</summary>
            <param name="type"></param>
            <param name="fieldName">The name of the field</param>
            <param name="instance">Instance class to get the field value of, or null if the field is static</param>
            <param name="nameSpaceDotType">NameSpace.Type</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_PropertyGet(System.String,System.Object,System.Boolean)">
            <summary>Invoke a property get of the given instance (or a static property if instance is not given)</summary>
            <param name="typeColonPropertyGet">NameSpace.Type:PropertyGet - If NameSpace not given, will use default</param>
            <param name="instance">Invoke a non static property of this instance, set to null if the property is static</param>
            <param name="allowNonPublic">Are non-public property invokes allowed?</param>
            <returns>The returned value of the invoked property getter</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke_Static(System.Reflection.MethodInfo,System.Object[],System.Boolean)">
            <summary>Invoke a static method or property getter</summary>
            <param name="method">The static method to invoke</param>
            <param name="parameters">The parameters to pass into the method, should be set to null if the method doesnt have any parameters or it is a property getter</param>
            <param name="allowNonPublic">Allow non-public members to be invoked</param>
            <returns>The value returned by the target method or property</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.Invoker.Invoke(System.Object,System.Reflection.MethodInfo,System.Object[],System.Boolean)">
            <summary>Invoke the given static or instanced method or param getter of the given instance with the given parameters - instance should be null if the method or property is static</summary>
            <param name="instance">Instance of the non static class that contains the non static method or property, set to null if the method or propery is static</param>
            <param name="method">The name of the method or property getter</param>
            <param name="parameters">The parameters to invoke the method with, or null if no params or the method is a property getter - Should be null if no params</param>
            <param name="allowNonPublic">Is invoking non public members allowed?</param>
            <returns>The invoke result / The value returned by the target method or property getter - void methods will return null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsRecursive(System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="method"></param>
            <returns>True if the given method is recursive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPatchClass(System.Type)">
            <summary>Is the given class a harmony path?</summary><param name="type"></param><returns>True if the class is a harmony patch</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPrefix(System.Reflection.MethodInfo)">
            <summary>Check if the given method is a harmony Prefix method inside a harmony patch class</summary>
            <param name="method"></param><returns>True if isa harmony Prefix method</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.IsHarmonyPostfix(System.Reflection.MethodInfo)">
            <summary>Check if the given method is a harmony Prefix method inside a harmony patch class</summary>
            <param name="method"></param><returns>True if isa harmony Postfix method</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetTypes_Safe(System.Reflection.Assembly)">
            <summary>Get Types from an Assembly, ReflectionTypeLoadExceptions are handled silently</summary>
            <param name="assembly">the input assembly</param>
            <returns>Array 'Type[]' of all the successfully loaded Types</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetTypes(System.Reflection.Assembly,System.Boolean)">
            <summary>Get Types from an Assembly, ReflectionTypeLoadExceptions are handled silently</summary>
            <param name="assembly">the input assembly</param>
            <param name="alwaysPrintExceptions">Always print ReflectionTypeLoadExceptions to log as warnings, even if debug mode is off</param>
            <returns>Array 'Type[]' of all the successfully loaded Types</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary></summary>
            <typeparam name="A"></typeparam>
            <param name="memberInfo"></param>
            <returns>True if the member has the attribute</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetAttributes_Safe(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
            <summary>Get attributes safely, if an exception occurs, return a partial list / empty list - Never null</summary>
            <param name="memberInfo">Type, method, field, etc. Whose attributes we want.</param>
            <param name="alwaysPrintExceptions">Always print type load exceptions as warnings. (Normally handled silently)</param>
            <param name="inherit"></param>
            <returns>List&lt;Attribute&gt; - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetMethod_Safe(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>Try to get the method inside the given type</summary>
            <param name="declaringType"></param>
            <param name="methodName"></param>
            <param name="bindingFlags"></param>
            <returns>MethodInfo of the given method, or null if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetFieldValue(System.Object,System.String,System.Reflection.BindingFlags)">
            <summary>Get the non-static field value from the provided instance</summary>
            <param name="instance"></param>
            <param name="fieldName"></param>
            <param name="bindingFlags"></param>
            <returns>The value stored in the non-static field of the given instance</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Reflection_.GetFieldValue(System.Type,System.String,System.Reflection.BindingFlags,System.String)">
            <summary>Get the field value of a static field</summary>
            <param name="declaringType">One of: 'declaringType' or 'nameSpaceDotType' must be provided</param>
            <param name="fieldName"></param>
            <param name="bindingFlags"></param>
            <param name="nameSpaceDotType">One of: 'declaringType' or 'nameSpaceDotType' must be provided</param>
            <returns>The value of the specified static field</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Colors.GoodColor">
            <summary>Will give the 'good' color, will differ based on settings. Intended for color blind support etc...</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Colors.BadColor">
            <summary>Will give the 'bad' color, will differ based on settings. Intended for color blind support etc...</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.SetTransparency(UnityEngine.Color,NQualityOfLife.Ratio)">
            <summary>1 is fully transparent (see trough) 0 is fully opaque</summary>
            <param name="color"></param>
            <param name="ratio">1 is fully transparent, 0 is opague</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToColor(System.String)">
            <summary>Converts a hex code such as '#FF1144FF' into a UnityEngine.Color</summary><param name="colorHexCode"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToByte(System.String)">
            <summary>Input must be a string with a length of 2, such as 'F2' or '5F'</summary>
            <param name="hexCode">Must be 'FF', '0A', 'A2', '01', '00' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexToByte(System.ValueTuple{System.Char,System.Char})">
            <summary>Converts the given 2 letter hex code to its byte value</summary>
            <param name="hex">Must be 'FF', 'F0', '1A', '51', 'AB' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexToByte(System.Char,System.Char)">
            <summary>Converts the given 2 letter hex code to its byte value</summary>
            <param name="bigger">Must be 'F', '0', 'A', '1', 'B' etc</param>
            <param name="smaller">Must be 'F', '0', 'A', '1', 'B' etc</param>
            <returns>byte of 0 - 255, for example 'FF' -> '255'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToColor(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte})">
            <summary>Converts RGBA values to a UnityEngine.Color</summary><param name="color"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBToColor(System.ValueTuple{System.Byte,System.Byte,System.Byte})">
            <summary>Converts RGB values to a UnityEngine.Color</summary><param name="color"></param><returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexLetterToByte(System.Char,System.Byte)">
            <summary></summary>
            <param name="hexLetter">A single hex letter, from 0 -> 9 -> A -> F</param>
            <param name="pos">Must be 0 or 1</param>
            <returns>The value of the letter for the given position, for example 'F' pos '0' -> '15' and 'F' pos '1' -> '240'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ByteToHexS(System.Byte)">
            <summary>Returns the corresponding hex symbol for the given byte, Accepts inputs in the '0 - 15' range!</summary>
            <param name="b">byte in the '0 - 15' range</param>
            <returns>'0 -> 0', '15 -> F'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ByteToHexCode(System.Byte)">
            <summary>Converts a byte value into its corresponding hex code. Such as: '255 -> FF'</summary>
            <param name="b">byte to convert '255 -> FF'</param>
            <returns>a hex code such as 'FF' 'AB' 'F4' etc</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ByteToHex(System.Byte)">
            <summary>Converts a byte value into its corresponding hex code. Such as: '255 -> FF'</summary>
            <param name="b">byte to convert '255 -> FF'</param>
            <returns>a hex code such as 'FF' 'AB' 'F4' etc</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToRGB(System.String)">
            <summary>Convert a hex color code such as #FF15AB into its RGB components. If the hex code has an Alpha component like in '#FF00AAF6', it will be ignored</summary>
            <param name="hexCode">Valid inputs: '001122', '#112233', '#ff0000f9', 'FF12F0FF'</param>
            <returns> If input is null or empty => (0, 0, 0)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.HexCodeToRGBA(System.String)">
            <summary>Convert a hex color code such as #FF15ABFF into its RGBA components. If the hex code doesn't have an Alpha component like in '#FF15AB', it will be returned as 255. - The input hex code can start with or without '#'</summary>
            <param name="hexCode">Valid inputs: '001122', '#112233', '#ff0000f9', 'FF12F0FF'</param>
            <returns>If input is null or empty => (0, 0, 0, 255)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorToHex(UnityEngine.Color)">
            <summary>Converts an UnityEngine.Color into a hex code such as '#FF1144FF'</summary><param name="color"></param><returns>A hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Single,System.Single,System.Single,System.Single)">
            <summary>Converts the given floats to a hex color code. If the input values are above 1f max value will be 255f else max will be 1f</summary>
            <param name="R">Red</param>
            <param name="G">Green</param>
            <param name="B">Blue</param>
            <param name="A">Alpha - Transparency</param>
            <returns>a hex code such as '#FF3300FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHex(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte})">
            <summary></summary><param name="color"></param><returns>a hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte})">
            <summary></summary><param name="color"></param><returns>a hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHex(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Converts the given RGBA values into a hex color code, such as: '#FF5BA6FF'</summary>
            <param name="R"></param>
            <param name="G"></param>
            <param name="B"></param>
            <param name="A">Alpha (Transparency)</param>
            <returns>a hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.RGBAToHexCode(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Converts the given RGBA values into a hex color code, such as: '#FF5BA6FF'</summary>
            <param name="R"></param>
            <param name="G"></param>
            <param name="B"></param>
            <param name="A">Alpha (Transparency)</param>
            <returns>a hex code such as '#FF1144FF'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Darken(NQualityOfLife.Hex,NQualityOfLife.Ratio)">
            <summary>Darkens a hex color code</summary>
            <param name="color"></param>
            <param name="amount"></param>
            <returns>Hex color code such as: '#FF9977FA'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.MutateColor(NQualityOfLife.Hex,NQualityOfLife.Utils.Colors.MutatorMode)">
            <summary></summary>
            <param name="inputColor"></param>
            <param name="mutatorMode"></param>
            <returns>A hex color code.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorIsTooDark(NQualityOfLife.Hex)">
            <summary>Returns true if the input hex color is too dark</summary>
            <param name="hex">a hex color like: '#F4A5FF'</param>
            <returns>true if the input hex color is too dark</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.ColorIsTooBland(NQualityOfLife.Hex)">
            <summary></summary>
            <param name="hex">The input color code. for example: '#FF17A7'</param>
            <returns>True if the given hex color is too 'bland'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.Brighten(NQualityOfLife.HexByte)">
            <summary>Brightens the given color channel</summary>
            <param name="b"></param>
            <returns>0 - 255</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.BrightenIfDark(NQualityOfLife.Hex)">
            <summary>Brightens a hex color code if the color is too dark</summary>
            <param name="color"></param>
            <returns>Hex color code such as: '#FF9977'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Colors.GenerateDeterministicUniqueColor(System.Int32)">
            <summary>Returns a hex code based on the input hash</summary>
            <param name="hash">the seed for the generated color</param>
            <returns>a hex color code such as: '#AF44FF' || or "#000000FF" if failed to generate the color from the hash</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Mods">
            <summary>Data about loaded mods for compatibility and integration</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods._MyMetaData">
            <summary>The instance of my 'ModMetaData'</summary>
        </member>
        <member name="P:NQualityOfLife.Utils.Mods.MyMetaData">
            <summary>Get the 'ModMetaData' for the NQoL mod</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutLoadOrder(Verse.ModMetaData,System.String,System.Int32)">
            <summary>Check and warn the user if any mod violates the load order rules</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="loadIndex"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.CheckRules(Verse.ModMetaData,System.String,System.ValueTuple{NQualityOfLife.Utils.Mods.LoadOrderRules,System.String,NQualityOfLife.Utils.Mods.IssueSeverity,System.String},System.Int32)">
            <summary>Check and warn the user if any mod violates the load order rules</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
            <param name="ruleIn"></param>
            <param name="modLoadIndex"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutCompatibleVersion(Verse.ModMetaData,System.String)">
            <summary>Check the mod version of a mod to the known working version (for compatibility reasons)</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.TestVersionAndWarn(Verse.Mod,System.String,System.String)">
            <summary>Check the mod version of a mod to the known working version (for compatibility reasons)</summary>
            <param name="mod"></param>
            <param name="testedModVersion"></param>
            <param name="backupTestedModVersion"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(Verse.ModMetaData,System.String)">
            <summary>Check the mod for any suspicious or harmful things such as error supression</summary>
            <param name="modMetaData">Check this mod for sus stuff</param>
            <param name="modPackageId">Fallback identifier for finding the mod</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.GetHandleFromPackageID(System.String,System.Boolean)">
            <summary>Get the Mod associated with the given packageid</summary>
            <param name="packageID"></param>
            <param name="errorOnFail"></param>
            <returns>Mod</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(System.IO.DirectoryInfo,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan the assemblies of the given mod / root folder for potentially un-wanted stuff.</summary>
            <param name="modRootFolder"></param>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan the nested types of the given type for unwanted stuff</summary>
            <param name="type">Type whose nested classes to scan</param>
            <param name="assembly">The assembly that the type is from</param>
            <param name="fromMod">The mod where the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan all the types of the given assembly for potentially unwanted harmony patches etc...</summary>
            <param name="assembly">Assembly to scan</param>
            <param name="fromMod">The mod that the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusTypes(System.Type[],System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan the given types and their nested types for un-wanted stuff</summary>
            <param name="types">The types to check</param>
            <param name="assembly">The parent assembly of the given types</param>
            <param name="fromMod">The parent mod of the types / assembly</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusType(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Checks if the given type (class) or any of its nested classes are an error supression harmony patch, or other potentially un-wanted thing.</summary>
            <param name="type">The type to check (and its nested classes)</param>
            <param name="assembly">The assembly that contanis the type</param>
            <param name="fromMod">The mod that the assembly and type are from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusType_ErrorSuppression(System.Type,System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Print a waring if the given type is an error suppressing harmony patch.</summary>
            <param name="type">The type to test</param>
            <param name="assembly"></param>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMethods_AnyDestructivePrefix(System.Type,System.Reflection.MethodInfo@,System.String@)">
            <summary>Checks if any of the method in the given type are destructive prefixes.</summary>
            <param name="type">The type whose methods we want to check.</param>
            <param name="susMethod">The detected sus method or null if none found.</param>
            <param name="reason">The reason why the detected method is 'sus'.</param>
            <returns>true if any of the methods in the specified type are destructive prefixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMethods_AnyDestructivePrefix(System.Reflection.MethodInfo[],System.Reflection.MethodInfo@,System.String@)">
            <summary>Checks if any of the method in the given array are destructive prefixes.</summary>
            <param name="methods">The array of methods to check.</param>
            <param name="susMethod">The detected sus method or null if none found.</param>
            <param name="reason">The reason why the detected method is 'sus'.</param>
            <returns>true if any of the given methods is a destructive prefix</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssembly(System.Reflection.Assembly,Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scan all the types in the given assembly for error supression etc...</summary>
            <param name="assembly">Assembly to scan</param>
            <param name="fromMod">The mod that the assembly is from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssemblies(Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scans the asseblies of the given mod for error supression or other things that are potentially concerning.</summary>
            <param name="fromMod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusAssemblies(System.Reflection.Assembly[],Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scans the given assemblies for error supression or other things that are potentially concerning.</summary>
            <param name="assemblies">Assemblies to scan</param>
            <param name="fromMod">The mod that the assemblies are from</param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutSusMod(Verse.Mod,Verse.ModMetaData,System.String)">
            <summary>Scans the asseblies of the given mod for error supression or other things that are potentially concerning.</summary>
            <param name="mod"></param>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutOutdated(Verse.Mod,System.String)">
            <summary>Warn the user if the given mod is not updated for the current game version</summary>
            <param name="mod"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.WarnAboutOutdated(Verse.ModMetaData,System.String)">
            <summary>Warn the user if the given mod is not updated for the current game version</summary>
            <param name="modMetaData"></param>
            <param name="modPackageId"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.ModMetaData)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.Mod)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Mods.PackageId_BlindToLocal_LowerCase(Verse.ModContentPack)">
            <summary>Get the PackageId in lover case with all postfixes (such as '_steam') removed</summary>
            <param name="mod"></param><returns>The PackageId in lower case with no postfixes</returns>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.BiotechActive">
            <summary>Is the Biotech DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.IdeologyActive">
            <summary>Is the Ideology DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.RoyaltyActive">
            <summary>Is the Royalty DLC active?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Mods.AnomalyActive">
            <summary>Is the Anomaly DLC active?</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.IncidentUtils.Artillery.ArtilleryStrike(Verse.Map,System.Int32,RimWorld.Direction8Way,NQualityOfLife.UnOrderedList{Verse.ThingDef})">
            <summary></summary>
            <param name="map"></param>
            <param name="shells">How many shells to launch</param>
            <param name="fromDirection">The direction where the shells will fly from</param>
            <param name="allowedProjectiles">The list of allowed shells || if null select a random shell from all available shells</param>
        </member>
        <member name="M:NQualityOfLife.Utils.IncidentUtils.Artillery.NuclearStrike(System.Int32,RimWorld.Planet.GlobalTargetInfo,System.Single)">
            <summary>Launch a rimatomics ICBM at the specified target</summary>
            <param name="launchTile"></param>
            <param name="target"></param>
            <param name="warheadYield"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Atan(System.Single)">
            <summary>Get the angle in radians whose tangent is the given 'tangent'</summary>
            <param name="tangent"></param>
            <returns>Angle in radians whose tangent is the given 'tangent'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Atan(System.Double)">
            <summary>Get the angle in radians whose tangent is the given 'tangent'</summary>
            <param name="tangent"></param>
            <returns>Angle in radians whose tangent is the given 'tangent'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>Get the expected value of Y at the given X</summary>
            <param name="from_X">X before target_X</param><param name="from_Y">Y value at from_X</param><param name="to_X">X after target_X</param><param name="to_Y">Y value at to_X</param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at target_X</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
            <summary>Get the expected value of Y at the given X</summary>
            <param name="from">The point before target_X</param><param name="to">The point after target_X</param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at target_X</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Interpolate(NQualityOfLife.Point2D,NQualityOfLife.Point2D,System.Single)">
            <summary>Get the expected value of Y at the given X</summary>
            <param name="from">The point before target_X</param><param name="to">The point after target_X</param><param name="target_X">The target X whose Y value we want to get</param>
            <returns>The expected value of Y at target_X</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Single,Verse.FloatRange)">
            <summary></summary>
            <param name="num"></param><param name="range"></param>
            <returns> True if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Single,System.ValueTuple{System.Single,System.Single})">
            <summary></summary>
            <param name="num"></param><param name="range"></param>
            <returns> True if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Contains(System.ValueTuple{System.Single,System.Single},System.Single)">
            <summary></summary>
            <param name="range"></param><param name="num"></param>
            <returns>True if the given number is inside the min and max rang, inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Includes(System.ValueTuple{System.Single,System.Single},System.Single)">
            <summary></summary>
            <param name="range"></param><param name="num"></param>
            <returns>True if the given number is inside the min and max rang, inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Contains_Inclusive(Verse.IntRange,System.Int32)">
            <summary></summary>
            <param name="range"></param>
            <param name="number"></param>
            <returns>True if the given number is within the range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Int32,Verse.IntRange)">
            <summary></summary>
            <param name="num"></param>
            <param name="range"></param>
            <returns> True if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeExclusive(System.Int32,Verse.IntRange)">
            <summary></summary>
            <param name="num"></param>
            <param name="range"></param>
            <returns>True if the given number is within the given range - Exclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeInclusive(System.Int32,System.Int32,System.Int32)">
            <summary></summary>
            <param name="num"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns> True if the given number is within the given range - Inclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.InRangeExclusive(System.Int32,System.Int32,System.Int32)">
            <summary></summary>
            <param name="num"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns>True if the given number is within the given range - Exclusive</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.RoundToInt(System.Single)">
            <summary>Round to the closest int</summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.RoundToInt(System.Double)">
            <summary>Round to the closest int</summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Int32,System.Int32)">
            <summary>Returns the larger value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Int32,System.Int32)">
            <summary>Returns the smaller value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Single,System.Single)">
            <summary>Returns the larger value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.LargerOf(System.Byte,System.Byte)">
            <summary>Returns the larger value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Max(System.Single,System.Single)">
            <summary>Returns the larger value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Max(System.Int32,System.Int32)">
            <summary>Returns the larger value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Byte,System.Byte)">
            <summary>Returns the smaller value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.SmallerOf(System.Single,System.Single)">
            <summary>Returns the smaller value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Min(System.Single,System.Single)">
            <summary>Returns the smaller value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Min(System.Int32,System.Int32)">
            <summary>Returns the smaller value</summary>
            <param name="value"></param><param name="otherValue"></param>
            <returns>The smaller of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Byte,System.Byte,System.Byte)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Int32,System.Byte,System.Byte)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Clamp(System.Single,System.Single,System.Single)">
            <summary>Clamp inclusive</summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.ClampRatio(System.Single)">
            <summary>Clamps the number to 0f-1f inclusive</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Int32)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) value</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Single)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) value</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.Abs(System.Double)">
            <summary>Get the absolute value</summary><param name="number"></param>
            <returns>The absolute (non negative) value</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.CountHexTiles(System.Int32)">
            <summary></summary>
            <param name="distance"></param>
            <returns>The count of hex tiles in the given radius/distance from the center hex tile</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Math.CountHexTilesDonut(System.Int32)">
            <summary></summary>
            <param name="distance"></param>
            <returns>The count of hex tiles in a donut pattern for the given distance from the center</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1">
            <summary></summary>
            <typeparam name="E"></typeparam>
            <returns>A random value of the provided enum</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(``0[])">
            <summary>Select a random element from the set - a null or empty set may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item from the set</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.IList{``0})">
            <summary>Select a random element from the list - a null or empty set may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item from the list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.List{``0})">
            <summary>Select a random element from the list - a null or empty set may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item from the list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Select a random element from the list - An empty or null set may error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <returns>A random item from the list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="set"></param>
            <param name="predicate"></param>
            <returns>default if no element is found that satisfies the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="predicate"></param>
            <returns>default if none of the elements in the set satisfy the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Selects a random item from the list, or returns fallback if the list is null or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this set if it is not null or empty, else return the fallback</param>
            <param name="fallback">Return this if the list is null or empty</param>
            <returns>A random item from the list or fallback if list is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.List{``0},``0)">
            <summary>Selects a random item from the list, or returns fallback if the list is null or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this set if it is not null or empty, else return the fallback</param>
            <param name="fallback">Return this if the list is null or empty</param>
            <returns>A random item from the list or fallback if list is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomOrFallback``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Selects a random item from the list, or returns fallback if the list is null or empty</summary>
            <typeparam name="T"></typeparam>
            <param name="set">Select a random element from this set if it is not null or empty, else return the fallback</param>
            <param name="fallback">Return this if the list is null or empty</param>
            <returns>A random item from the list or fallback if list is null or empty</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSetWhere``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="maxItemsToGet"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSet``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>If source list is smaller or equal to maxItemsToGet, returns a copy of the source list</summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="maxItemsToGet"></param>
            <returns>A new list with randomly selected items from the source list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandomSet``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32)">
            <summary>If source list is smaller or equal to maxItemsToGet, returns a copy of the source list</summary>
            <typeparam name="T"></typeparam>
            <param name="sourceSet"></param>
            <param name="maxItemsToGet"></param>
            <returns>A new list with randomly selected items from the source list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.RemoveRandom``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Removes a random item from the list</summary>
            <typeparam name="T"></typeparam>
            <param name="set"></param><param name="setSize"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Rand.SelectRandom``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Select a random element from the list - An empty set will error!</summary>
            <typeparam name="T"></typeparam><param name="set"></param>
            <param name="setSize">The known size of the list</param>
            <returns>A random item from the list</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.Rand.Value">
            <summary>Random value between 0 and 1 inclusive</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,UnityEngine.Color)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="color"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,System.String)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="additionalInfoString"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,System.Nullable{UnityEngine.Color},System.String,System.Boolean,System.Boolean)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="color"></param>
            <param name="additionalInfoString">Additional info to show on hover</param>
            <param name="stable"></param>
            <param name="debugMouse"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Debug(UnityEngine.Rect,NQualityOfLife.IColor,System.String,System.Boolean,System.Boolean)">
            <summary>Draw a colorful border on a Rect</summary>
            <param name="rect">Highlight this rect</param>
            <param name="iColor"></param>
            <param name="additionalInfoString">Additional info to show on hover</param>
            <param name="stable"></param>
            <param name="debugMouse"></param>
            <returns>The input rect unchanged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect)">
            <summary>Split the rect into the left and right halfs</summary>
            <param name="rect"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Ratio)">
            <summary>Splits the input rect into two parts</summary>
            <param name="rect">Original rect to split</param><param name="left">The left part of the original rect</param><param name="right">The right part of the original rect</param>
            <param name="rightSideRatio">The size of the right side rect (Ratio) 0.5f means an equal split</param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitHorizontally(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Splits the input rect into two equal parts</summary>
            <param name="rect">Original rect to split</param><param name="left">The left half of the original rect</param><param name="right">The right half of the original rect</param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@)">
            <summary>Splits the input rect into two equal parts</summary>
            <param name="rect">Original rect to split</param><param name="top">The top half of the original rect</param><param name="bottom">The bottom half of the original rect</param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.SplitVertically(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,NQualityOfLife.Ratio,System.Boolean)">
            <summary>Splits the input rect into two parts</summary>
            <param name="rect">Original rect to split</param><param name="top">The left part of the original rect</param><param name="bottom">The right part of the original rect</param>
            <param name="bottomRatio">The size of the bottom half rect (Ratio) 0.5f means an equal split</param>
            <param name="debug"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomHalf(UnityEngine.Rect)">
            <summary>Gets the bottom half of the rect</summary>
            <param name="rect"></param>
            <returns>The bottom 50% of the given rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.BottomPart(UnityEngine.Rect,NQualityOfLife.Ratio)">
            <summary>Gets the bottom part of the given rect</summary>
            <param name="rect"></param><param name="ratio">How much of the original rect we consider the bottom?</param>
            <returns>The bottom part of the original rect with a height of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopHalf(UnityEngine.Rect)">
            <summary>Gets the top half of the rect</summary>
            <param name="rect"></param>
            <returns>The top 50% of the given rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.TopPart(UnityEngine.Rect,NQualityOfLife.Ratio)">
            <summary>Gets the top part of the given rect</summary>
            <param name="rect"></param><param name="ratio">How much of the original rect we consider the top?</param>
            <returns>The top part of the original rect with a height of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightHalf(UnityEngine.Rect)">
            <summary>Gets the right half of the given rect</summary>
            <param name="rect"></param>
            <returns>The right half of the original rect.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightSide(UnityEngine.Rect,NQualityOfLife.Ratio)">
            <summary>Gets the right side of the given rect</summary>
            <param name="rect"></param><param name="ratio">How much of the original rect we consider the right side?</param>
            <returns>The right side of the original rect with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.RightPart(UnityEngine.Rect,NQualityOfLife.Ratio)">
            <summary>Gets the right side of the given rect</summary>
            <param name="rect"></param><param name="ratio">How much of the original rect we consider the right side?</param>
            <returns>The right side of the original rect with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftHalf(UnityEngine.Rect)">
            <summary>Gets the left half of the given rect</summary>
            <param name="rect"></param>
            <returns>The left half of the original rect.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftSide(UnityEngine.Rect,NQualityOfLife.Ratio)">
            <summary>Gets the left side of the given rect</summary>
            <param name="rect"></param><param name="ratio">How much of the original rect we consider the left side?</param>
            <returns>The left side of the original rect with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.LeftPart(UnityEngine.Rect,NQualityOfLife.Ratio)">
            <summary>Gets the left side of the given rect</summary>
            <param name="rect"></param><param name="ratio">How much of the original rect we consider the left side?</param>
            <returns>The left side of the original rect with a width of the original * ratio</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(UnityEngine.Vector2,UnityEngine.Rect)">
            <summary>Is this point inside the given rect?</summary>
            <param name="point"></param><param name="rect"></param>
            <returns>True if the point is inside the rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(NQualityOfLife.Point2D,UnityEngine.Rect)">
            <summary>Is this point inside the given rect?</summary>
            <param name="point"></param><param name="rect"></param>
            <returns>True if the point is inside the rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.IsInside(System.ValueTuple{System.Single,System.Single},UnityEngine.Rect)">
            <summary>Is this point inside the given rect?</summary>
            <param name="point"></param><param name="rect"></param>
            <returns>True if the point is inside the rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.OnScreen(UnityEngine.Rect,System.Nullable{UnityEngine.Vector2},System.Boolean)">
            <summary></summary><param name="rect"></param>
            <param name="debug"></param>
            <param name="positionOffset"></param>
            <returns>True if the input rect is partly or fully visible on screen (Assuming the rect is drawn) / in bounds of the screen </returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.OnScreen(NQualityOfLife.Rectangle,System.Nullable{UnityEngine.Vector2},System.Boolean)">
            <summary></summary><param name="rect"></param>
            <param name="debug"></param>
            <param name="positionOffset"></param>
            <returns>True if the input rect is partly or fully visible on screen (Assuming the rect is drawn) / in bounds of the screen </returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.FullyOnScreen(NQualityOfLife.Rectangle)">
            <summary>Is the input rect fully inside the bounds of the screen?</summary>
            <param name="rect"></param><returns>True if the input rect is fully inside the bounds of the screen</returns>
        </member>
        <member name="P:NQualityOfLife.Utils.RectExtensions.FullScreenRect">
            <summary>Gets a Rect that is the size, shape and position of the screen</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.ContainsOrOverlaps(UnityEngine.Rect,UnityEngine.Rect,System.Nullable{UnityEngine.Vector2},System.Boolean)">
            <summary></summary>
            <param name="rect"></param><param name="innerRect"></param>
            <param name="positionOffset"></param>
            <param name="debug"></param>
            <returns>True if the rects fully or partly overlap each other</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.FullyContains(UnityEngine.Rect,UnityEngine.Rect)">
            <summary>Does this Rect fully contain innerRect?</summary>
            <param name="rect"></param><param name="innerRect"></param>
            <returns>True if all parts of innerRect are inside this rect</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.InnerSquare(UnityEngine.Rect)">
            <summary>Get a square rect fitted inside the input rect</summary>
            <param name="rect"></param>
            <returns>Square</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Squeeze(UnityEngine.Rect,System.Single)">
            <summary>Reduces the height of the Rect, anchoring position on the center</summary>
            <param name="rect"></param><param name="amount">pixels</param>
            <returns>The input rect squeezed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Squeeze(UnityEngine.Rect,UnityEngine.Rect,UnityEngine.Rect)">
            <summary>Gets a rect between the given two</summary>
            <param name="rect"></param>
            <param name="top">The top part of rect</param>
            <param name="bottom">The bottom part of rect</param>
            <returns>Rect between the top and bottom parts</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RectExtensions.Segment(UnityEngine.Rect,UnityEngine.Rect@,UnityEngine.Rect@,UnityEngine.Rect@,System.Single,System.Single,System.Boolean)">
            <summary>Segments the given rect into 3 parts</summary>
            <param name="rect"></param>
            <param name="top"></param>
            <param name="middle"></param>
            <param name="bottom"></param>
            <param name="topHeightPixels"></param>
            <param name="bottomHeightPixels"></param>
            <param name="debug">Draw colored debug rectangles</param>
        </member>
        <member name="T:NQualityOfLife.Utils.DefExtensions">
            <summary>Def extension utils</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.HasOnCameraSubSounds(Verse.SoundDef)">
            <summary>Can this sound be played without a source thing on a map?</summary>
            <param name="soundDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsGrave(Verse.ThingDef)">
            <summary>Is the given def a grave? (or sarchophigy)</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsChair(Verse.ThingDef)">
            <summary>Is the given def a chair used for comfort?</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsLamp(Verse.ThingDef)">
            <summary>Is the given def a lamp?</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsFurniture(Verse.ThingDef)">
            <summary>Is the given def a furniture item?</summary>
            <param name="thingDef"></param>
            <returns>True if chair, table, bed, etc..</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsSpot(Verse.ThingDef,System.Boolean,System.Boolean)">
            <summary>Is the given def a spot, for the purposes of the spot tab, minification or research changes?</summary>
            <param name="thingDef"></param>
            <param name="allowBlueprints"></param>
            <param name="allowFrames"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.CanBeCreatedByPlayer(Verse.ThingDef,System.Boolean)">
            <summary>Can the given thing be created by the player? (crafted / built)</summary>
            <param name="thingDef"></param>
            <param name="searchIndirectRecipesIfNeeded">Check recipe defs if result was inconclusive? - This could be relatively slow!</param>
            <returns>True if the thing can be crafted or built by the player, false if not.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsInstantlyPlaceable(Verse.ThingDef)">
            <summary>Can this thing be placed without requiring a pawn to build it?</summary>
            <param name="thingDef">Thing we are testing.</param>
            <returns>True if can be placed instantly without needing a pawn to work on it, else false. also returns false if thing is not a building.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.UsesNoMaterialsToMake(Verse.ThingDef)">
            <summary>Note: Returns false for things that are not buildable by the player!</summary>
            <param name="thingDef"></param>
            <returns>True if thing uses no materials to build. Returns false for things that cannot be built or crafted.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsWall(Verse.ThingDef)">
            <summary>Check if the given def is a wall</summary>
            <param name="thingDef"></param>
            <returns>True if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.ShouldBeAbleToMinify(Verse.ThingDef)">
            <summary>Is this thing something that should logically (or for gameplay reasons) be able to be moved?</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.ShouldNeverBeAbleToMinify(Verse.ThingDef)">
            <summary>Checks if the thing is something that should logically or for gameplay resons not be able to be minified</summary>
            <param name="thingDef"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.CanMinify(Verse.ThingDef)">
            <summary>Is the given thing a valid minifiable thing?</summary>
            <param name="thingDef"></param>
            <returns>True if minifiable and valid</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.DefExtensions.IsUnderground(Verse.ThingDef)">
            <summary>Is the given thing 'underground'</summary>
            <param name="thingDef"></param>
            <returns>True if the thing is partly or fully buried or underground</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.ThingExtensions">
            <summary>Thing def utils WIP</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.IsLinearResearchPath(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns>True if this research leads to exactly 1 other research</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.DirectChildren(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns>The projects that require the given project to be completed first</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.DirectChildrenList(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="sameTabOnly"></param>
            <param name="includeHidden"></param>
            <returns>The projects that require the given project to be completed first</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.AllPrerequisites(Verse.ResearchProjectDef,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Never null</summary>
            <param name="researchProjectDef"></param>
            <param name="includeNonHidden"></param>
            <param name="includeHidden"></param>
            <param name="sameTabOnly"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.MakeThing(Verse.ThingDef)">
            <summary>Make a new Thing of the given def</summary>
            <param name="def"></param>
            <returns>The newly created Thing</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.NameWithFactionColor(RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param>
            <returns>The player facing name colored with the color of the faction (the color of their icon / base icons)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrFriendlyFaction(Verse.Thing,Verse.Thing)">
            <summary></summary>
            <param name="thing"></param><param name="other"></param>
            <returns>always false if either faction is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrAllyFaction(RimWorld.Faction,RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param><param name="other"></param>
            <returns>always false if either faction is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.SameOrFriendlyFaction(RimWorld.Faction,RimWorld.Faction)">
            <summary></summary>
            <param name="faction"></param><param name="other"></param>
            <returns>always false if either faction is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValuesFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="stat4"></param>
            <param name="stat5"></param>
            <param name="stat6"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValuesFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="stat4"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="stat3"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="stat2"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ThingExtensions.GetStatValueFromList_Fast(System.Collections.Generic.List{RimWorld.StatModifier},RimWorld.StatDef,System.Single)">
            <summary></summary>
            <param name="statList"></param>
            <param name="stat1"></param>
            <param name="defaultValue"></param>
            <returns>Default value if list is null, empty or does not contain the StatDef we are looking for, else the value of the stat.</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.ZoneExtensions">
            <summary>Zone extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTemperature(Verse.IntVec3,Verse.Map)">
            <summary>Get the cell temperature</summary>
            <param name="loc"></param>
            <param name="map"></param>
            <returns>Temperature in Celsius</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.UsesOutdoorTemperature(Verse.IntVec3,Verse.Map)">
            <summary>Does the given cell use the outdoor map temperature</summary><param name="loc"></param><param name="map"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.IsPolluted(Verse.IntVec3,Verse.Map)">
            <summary></summary><param name="c"></param><param name="map"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover(Verse.Map,Verse.IntVec3)">
            <summary>Get the cover at the cell</summary><param name="c"></param><param name="map"></param><returns>null if no cover at 'c'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetCover(Verse.IntVec3,Verse.Map)">
            <summary>Get the cover at the cell</summary><param name="c"></param><param name="map"></param><returns>null if no cover at 'c'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged(Verse.Thing,Verse.Map)">
            <summary></summary>
            <param name="thing"></param><param name="map"></param>
            <returns>True if the fog grid is fogged at thing</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="c"></param><param name="map"></param>
            <returns>True if the fog grid is fogged at c</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Fogged(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary></summary>
            <param name="c"></param><param name="map"></param><param name="mapSize"></param>
            <returns>True if the fog grid is fogged at c</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Roofed(Verse.IntVec3,Verse.Map,Verse.RoofDef@)">
            <summary>Returns true if GetRoof is null</summary>
            <param name="c"></param><param name="map"></param><param name="roofDef"></param>
            <returns>True if the cell has a roof - Use GetRoof if you need to get the def anyways</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Roofed(Verse.IntVec3,Verse.Map)">
            <summary>Returns true if GetRoof is null</summary>
            <param name="c"></param><param name="map"></param>
            <returns>True if the cell has a roof - Use GetRoof if you need to get the def anyways</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Get the roof def from the roof grid</summary>
            <param name="c"></param><param name="map"></param>
            <param name="mapSize"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRoof(Verse.IntVec3,Verse.Map)">
            <summary>Get the roof def from the roof grid</summary>
            <param name="c"></param><param name="map"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain(Verse.Map,Verse.IntVec3)">
            <summary>Gets the terrain def directly from the terrainGrid</summary>
            <param name="map"></param><param name="at"></param>
            <returns>The terrainGrid TerrainDef at 'at'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Gets the terrain def directly from the terrainGrid</summary>
            <param name="map"></param><param name="mapSize"></param><param name="c"></param>
            <returns>The terrainGrid TerrainDef at c</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetTerrain(Verse.IntVec3,Verse.Map)">
            <summary>Gets the terrain def directly from the terrainGrid - Normally non null</summary>
            <param name="map"></param><param name="c"></param>
            <returns>The terrainGrid TerrainDef at c - Normally non null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt(Verse.Map,Verse.IntVec3,Verse.IntVec3)">
            <summary>Gets the terrain def directly from the terrainGrid - Normally non null</summary>
            <param name="map"></param><param name="at"></param>
            <param name="mapSize"></param>
            <returns>The terrainGrid TerrainDef at 'at' - Normally non null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt(Verse.Map,Verse.IntVec3)">
            <summary>Gets the terrain def directly from the terrainGrid - Normally non null</summary>
            <param name="map"></param><param name="at"></param>
            <returns>The terrainGrid TerrainDef at 'at' - Normally non null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.TerrainAt(Verse.IntVec3,Verse.Map)">
            <summary>Gets the terrain def directly from the terrainGrid - Normally non null</summary>
            <param name="map"></param><param name="c"></param>
            <returns>The terrainGrid TerrainDef at c</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3,Verse.MapInfo)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapInfo"></param><returns>c.z * mapInfo.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3,Verse.Map)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="map"></param><returns>c.z * map.info.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.Map,Verse.IntVec3)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="map"></param><returns>c.z * map.info.Size.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3,Verse.IntVec3)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapSize"></param><returns>c.z * mapSize.x + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CellToIndex(Verse.IntVec3,System.Int32)">
            <summary>Get the index of the cell in the direct grid</summary>
            <param name="c"></param><param name="mapSizeX"></param><returns>c.z * mapSizeX + c.x</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RegionAt(Verse.IntVec3,Verse.Map,Verse.RegionType)">
            <summary>Get the region at the given cell</summary>
            <param name="loc"></param>
            <param name="map"></param>
            <param name="allowedRegionTypes"></param>
            <returns>The region at the cell, or null if out of bounds or not valid type</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetRegion(Verse.IntVec3,Verse.Map,Verse.RegionType)">
            <summary>Get the region at the given cell</summary>
            <param name="loc"></param>
            <param name="map"></param>
            <param name="allowedRegionTypes"></param>
            <returns>The region at the cell, or null if out of bounds or not valid type</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetZone(Verse.IntVec3,Verse.Map)">
            <summary>Get the zone at the specifed cell</summary>
            <param name="c"></param><param name="map"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Get the things at the specifed cell</summary>
            <param name="c"></param><param name="map"></param><param name="mapSize"></param>
            <returns>Thing list, not null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstPawn(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first thing of type Pawn at cell</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing(Verse.IntVec3,Verse.Map,Verse.ThingDef)">
            <summary></summary>
            <param name="cell"></param><param name="map"></param><param name="ofDef"></param>
            <returns>The first thing of the provided def</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstBed(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first thing of type Building_Bed at cell</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstBuilding(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first thing of type Building at cell</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThing``1(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first thing of type T at cell</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWithComp``1(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <typeparam name="TC"></typeparam>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first found ThingWithComps with the specified comp, or null if none found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirstThingWithComp``1(Verse.IntVec3,Verse.Map,``0@)">
            <summary></summary>
            <typeparam name="TC"></typeparam>
            <param name="cell"></param>
            <param name="map"></param>
            <param name="comp"></param>
            <returns>The first found ThingWithComps with the specified comp, or null if none found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetFirst``1(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="cell"></param>
            <param name="map"></param>
            <returns>The first thing of type T at cell</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingListAt(Verse.Map,Verse.IntVec3)">
            <summary>Get the things at the specifed cell</summary>
            <param name="c"></param><param name="map"></param>
            <returns>Thing list, not null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.GetThingList(Verse.IntVec3,Verse.Map)">
            <summary>Get the things at the specifed cell</summary>
            <param name="c"></param><param name="map"></param>
            <returns>Thing list, not null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InvalidOrZero(Verse.IntVec3)">
            <summary>Is the cell invalid or 0 (0 is bottom left corner of the map)</summary><param name="cell"></param><returns>True if is invalid or zero</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CanZone(Verse.IntVec3,Verse.Map,Verse.IntVec3)">
            <summary>Can the cell be zoned right now?</summary>
            <param name="c"></param><param name="map"></param>
            <param name="mapSize"></param>
            <returns>True if the cell can be zoned</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CanZone(Verse.IntVec3,Verse.Map)">
            <summary>Can the cell be zoned right now?</summary>
            <param name="c"></param><param name="map"></param>
            <returns>True if the cell can be zoned</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InBounds(Verse.IntVec3,Verse.IntVec3)">
            <summary>Is the given cell in bounds of the map (size)</summary><param name="cell"></param><param name="mapSize"></param><returns>True if in bounds</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InNoZoneEdgeArea(Verse.IntVec3,Verse.IntVec3)">
            <summary>Is the cell too close to the map edge to allow zoning</summary>
            <param name="c"></param><param name="mapSize"></param>
            <returns>True if too close to edge</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.InNoZoneEdgeArea(Verse.IntVec3,Verse.Map)">
            <summary>Is the cell too close to the map edge to allow zoning</summary>
            <param name="c"></param><param name="map"></param>
            <returns>True if too close to edge</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CloseToEdge(Verse.IntVec3,Verse.IntVec3,System.Int32)">
            <summary></summary>
            <param name="c"></param>
            <param name="mapSize"></param>
            <param name="edgeDist"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.OnEdge(Verse.IntVec3,Verse.IntVec3,RimWorld.Direction8Way@)">
            <summary>Is this cell right on the edge of the map?</summary>
            <param name="c">Cell</param><param name="mapSize">Map.Size</param>
            <param name="dir">The map edge (or corner) of the cell, or invalid if not on edge</param>
            <returns>True if the cell is right on the edge of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.OnEdge(Verse.IntVec3,Verse.IntVec3)">
            <summary>Is this cell right on the edge of the map?</summary>
            <param name="c">Cell</param><param name="mapSize">Map.Size</param>
            <returns>True if the cell is right on the edge of the map || also returns true if out of bounds</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.DirectionAwayFrom(Verse.IntVec3,Verse.IntVec3,System.Boolean)">
            <summary>Get the direction from one cell to another, if 'from' and 'to' are the same, or one of them is 'IntVec3.Invalid', returns 'Direction8Way.Invalid'</summary>
            <param name="from">Direction 'from' this cell away 'awayFrom'</param><param name="awayFrom">Direction 'from' cell away from cell 'awayFrom'</param>
            <param name="errorOnInvalidInput">Log error if one of the input cells is 'IntVec3.Invalid' - Set to false if invalid cells are to be expected in normal operation.</param>
            <returns>Direction8Way of the direction, or 'Direction8Way.Invalid'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.DirectionTo(Verse.IntVec3,Verse.IntVec3,System.Boolean)">
            <summary>Get the direction from one cell to another, if 'from' and 'to' are the same, or one of them is 'IntVec3.Invalid', returns 'Direction8Way.Invalid'</summary>
            <param name="from">Direction 'from' this cell towards 'to'</param><param name="to">Direction 'from' cell towards 'to'</param>
            <param name="errorOnInvalidInput">Log error if one of the input cells is 'IntVec3.Invalid' - Set to false if invalid cells are to be expected in normal operation.</param>
            <returns>Direction8Way of the direction, or 'Direction8Way.Invalid'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.ToCardinal(RimWorld.Direction8Way)">
            <summary>Ensures Direction8Way is cardinal - Chooses closest random cardinal if direction is not cardinal</summary>
            <param name="direction8Way"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.ToCardinal_Rot4(RimWorld.Direction8Way)">
            <summary>Converts Direction8Way to Rot4 - Chooses closest random cardinal if direction is not cardinal</summary>
            <param name="direction8Way"></param>
            <returns>The Rot4 equivalent of the given Direction8Way</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.Thing,System.Int32@,Verse.Map)">
            <summary>Gets all the valid cardinal cells for the given thing</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>A list of all the cardinals in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.Thing,Verse.Map,System.Int32@)">
            <summary>Gets all the valid cardinal cells for the given thing</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>A list of all the cardinals in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.IntVec3,Verse.Map,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide Map.Size for better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours_ToList(Verse.IntVec3,Verse.IntVec3,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="mapSize">Provide for better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.Thing,System.Int32@,Verse.Map)">
            <summary>Gets all the valid cardinal cells for the given thing</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>An array of the 4 cardinals from the given thing's position (or less if on map edge)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.Thing,Verse.Map,System.Int32@)">
            <summary>Gets all the valid cardinal cells for the given thing</summary>
            <param name="thing"></param><param name="map"></param><param name="cardinalCount">The amount of cardinals returned</param>
            <returns>An array of the 4 cardinals from the given thing's position (or less if on map edge)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3,Verse.Map)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide Map.Size for better performance if this method is called multiple times for the same map</param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3,Verse.Map,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="map">Provide Map.Size for better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbours(Verse.IntVec3,Verse.IntVec3,System.Int32@)">
            <summary></summary>
            <param name="cell"></param>
            <param name="mapSize">Provide for better performance if this method is called multiple times for the same map</param>
            <param name="cardinalCount"></param>
            <returns>Cardinal neighbours that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyCardinalNeighbourCells(Verse.Thing)">
            <summary></summary>
            <param name="t"></param>
            <returns>All the cells directly bordering the given thing</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbours(Verse.IntVec3,Verse.Map)">
            <summary>Get all valid neighbouring cells of the given cell</summary>
            <param name="cell"></param><param name="map">used for Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbours(Verse.IntVec3,Verse.IntVec3)">
            <summary>Get all valid neighbouring cells of the given cell</summary>
            <param name="cell"></param><param name="mapSize">Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighboursArray(Verse.IntVec3,Verse.IntVec3)">
            <summary>Get all valid neighbouring cells of the given cell</summary>
            <param name="cell"></param><param name="mapSize">Map.Size</param>
            <returns>all neighbour cells that are in bounds of the map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.CloserAxisIsX(Verse.IntVec3,Verse.IntVec3)">
            <summary></summary>
            <param name="from"></param><param name="to"></param>
            <returns>True if x axis is closer than y, null if equal</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.Opposite(RimWorld.Direction8Way)">
            <summary>Get the opposite direction of the given direction</summary>
            <param name="direction8Way"></param>
            <returns>'North -> South' etc</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RotateClockwise(RimWorld.Direction8Way)">
            <summary></summary>
            <param name="direction8Way"></param>
            <returns>The input rotation rotated, if input is 'Direction8Way.Invalid' -> returns 'Direction8Way.Invalid'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.RotateCounterClockwise(RimWorld.Direction8Way)">
            <summary></summary>
            <param name="direction8Way"></param>
            <returns>The input rotation rotated, if input is 'Direction8Way.Invalid' -> returns 'Direction8Way.Invalid'</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.MyNeighbourInDirection(Verse.IntVec3,RimWorld.Direction8Way,System.Boolean,System.Nullable{System.Boolean})">
            <summary>Gets the cell in the specified direction from the current cell - The returned cell could be out of bounds!</summary>
            <param name="cell"></param><param name="direction"></param>
            <param name="onlyCardinals">Only return cardinals</param><param name="preferXOverZOrRandom">Cardinal preference</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ZoneExtensions.SoilStability(Verse.Region,Verse.Map)">
            <summary>Gets the soil stability of a given region (terrain affordance) 0f is 100% water, 1f is max soil stability</summary>
            <param name="region"></param><param name="map"></param>
            <returns>0f-1f as a ratio of soil stability</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.LogParamExtensions">
            <summary>Methods used for easier debug log message creation</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String,System.String)">
            <summary>Returns s1 if it is not null or empty, else returns s2.OrNull()</summary>
            <param name="s1">primary string</param><param name="s2">back up string</param>
            <returns>Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(System.String)">
            <summary>Returns the input string if it is not null or empty, else returns a null or empty symbol</summary>
            <returns>the input string, a null symbol or empty symbol - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(System.String,``0)">
            <summary>Never null</summary>
            <typeparam name="T2"></typeparam>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns>t1 if it is not null or empty, else t2.OrNull() - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0,System.Object)">
            <summary>Never null</summary>
            <typeparam name="T1"></typeparam>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns>The input as a string if its not null else: t2.OrNull() - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull(RimWorld.TechLevel)">
            <summary></summary>
            <param name="techLevel"></param>
            <returns>The value translated</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.OrNull``1(``0)">
            <summary>The generic 'OrNull' method || Never null</summary>
            <typeparam name="T"></typeparam><param name="classOrStruct"></param>
            <returns>The input converted to a string, or a null symbol string || Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam(System.String,System.String)">
            <summary>Format the string in a method parameter format, intended to be used in log messages</summary><param name="t"></param><param name="paramName"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(``0,System.String,System.String)">
            <summary>Generic method for formatting objects for log messages</summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="type"></param>
            <param name="paramName"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.LogParamExtensions.AsParam``1(System.Collections.Generic.List{``0},System.String,System.String)">
            <summary>Format AsParam</summary>
            <typeparam name="T">The type of the list</typeparam>
            <param name="list">The list</param>
            <param name="type">The type of T. if null it will be auto resolved.</param>
            <param name="paramName">The custom name of the param, such as 'targets'. can be left null.</param>
            <returns>The input list formatted as a param.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Undo(UnityEngine.Event)">
            <summary>Returns true if the user is pressing contol z, and consumes the event - Does not consume non undo events</summary>
            <param name="event">The event is consumed if it is an undo event</param>
            <returns>True if pressing control + Z, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ReDo(UnityEngine.Event)">
            <summary>Returns true if the user is pressing contol y, and consumes the event - Does not consume non redo events</summary>
            <param name="event">The event is consumed if it is a redo event</param>
            <returns>True if pressing control + Y, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Escape(UnityEngine.Event)">
            <summary></summary>
            <param name="event"></param>
            <returns>True if escape is pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftAltOnly(NQualityOfLife.KeyCombination)">
            <summary>Shift and Alt pressed?</summary><param name="keyCombination"></param><returns>True if shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlAltOnly(NQualityOfLife.KeyCombination)">
            <summary>Control and Alt pressed?</summary><param name="keyCombination"></param><returns>True if control and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShiftOnly(NQualityOfLife.KeyCombination)">
            <summary>Control and Shift pressed?</summary><param name="keyCombination"></param><returns>True if control and shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftOnly(NQualityOfLife.KeyCombination)">
            <summary>Shift pressed?</summary><param name="keyCombination"></param><returns>True if shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlOnly(NQualityOfLife.KeyCombination)">
            <summary>Control pressed?</summary><param name="keyCombination"></param><returns>True if control pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.AltOnly(NQualityOfLife.KeyCombination)">
            <summary>Alt pressed?</summary><param name="keyCombination"></param><returns>True if alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ShiftAlt(NQualityOfLife.KeyCombination)">
            <summary>Shift and Alt pressed?</summary><param name="keyCombination"></param><returns>True if shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShiftAlt(NQualityOfLife.KeyCombination)">
            <summary>Control, Shift and Alt pressed?</summary><param name="keyCombination"></param><returns>True if control, shift and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlAlt(NQualityOfLife.KeyCombination)">
            <summary>Control and Alt pressed?</summary><param name="keyCombination"></param><returns>True if control and alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ControlShift(NQualityOfLife.KeyCombination)">
            <summary>Control and Shift pressed?</summary><param name="keyCombination"></param><returns>True if control and shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Shift(NQualityOfLife.KeyCombination)">
            <summary>Shift pressed?</summary><param name="keyCombination"></param><returns>True if shift pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Control(NQualityOfLife.KeyCombination)">
            <summary>Control pressed?</summary><param name="keyCombination"></param><returns>True if control pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.Alt(NQualityOfLife.KeyCombination)">
            <summary>Alt pressed?</summary><param name="keyCombination"></param><returns>True if alt pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.None(NQualityOfLife.KeyCombination)">
            <summary>No modifier keys pressed?</summary><param name="keyCombination"></param><returns>True if none of the modifier keys are pressed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ModifierKeys(UnityEngine.Event)">
            <summary>Get the held modifier keys (shift, control, alt)</summary>
            <param name="event"></param>
            <returns>The key combination of the held modifier keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ModifierKeys(UnityEngine.Event,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>Get the held modifier keys (shift, control, alt)</summary>
            <param name="event"></param>
            <param name="control"></param>
            <param name="alt"></param>
            <param name="shift"></param>
            <returns>The key combination of the held modifier keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollUp(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll up event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (positive float)</param>
            <returns>True if event is scroll up</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollWheel(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (positive float for up, negative for down)</param>
            <returns>True if event is scroll up or down</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.ScrollDown(UnityEngine.Event,System.Single@)">
            <summary>Is the current event a mouse scroll down event?</summary>
            <param name="event"></param>
            <param name="scrollSpeed">The scroll speed / amount (negative float)</param>
            <returns>True if event is scroll down</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.AnyMouseButtonPress(UnityEngine.Event)">
            <summary></summary><param name="ev"></param>
            <returns>True if any of the 3 main mouse buttons are clicked (L, R, M)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.EventExtensions.LeftClickPress(UnityEngine.Event)">
            <summary></summary><param name="event"></param>
            <returns>True when left click is pressed</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.PawnExtensions">
            <summary>Pawn extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetFactionlessLord(Verse.Pawn,Verse.Map)">
            <summary>Returns the factionless lord of the given pawn, or null if no lord or the lord has a faction</summary>
            <param name="pawn"></param><param name="map"></param>
            <returns>The lord of the pawn if the faction of the lord is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.GetFactionLord(Verse.Pawn,RimWorld.Faction,Verse.Map)">
            <summary>Returns the lord of the given pawn if the faction of the lord matches. or null if no lord or the lord has a different or null faction</summary>
            <param name="pawn"></param><param name="faction"></param><param name="map"></param>
            <returns>The lord of the pawn if the faction of the lord is the same as the provided faction</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Starving(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>True if the given pawn has a food need, and the food need level is &lt;= 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.DraftIfCan(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>True if pawn was drafted or was already drafted</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsNightOwl(Verse.Pawn)">
            <summary>Null checks included</summary>
            <param name="pawn"></param>
            <returns>true if has NightOwl trait</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsBrawler(Verse.Pawn)">
            <summary>Null checks included</summary>
            <param name="pawn"></param>
            <returns>true if has brawler trait</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasTrait(Verse.Pawn,RimWorld.TraitDef)">
            <summary>Null checks included</summary>
            <param name="pawn"></param>
            <param name="trait"></param>
            <returns>true if has specified trait - returns false if trait is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasAWeapon(Verse.Pawn)">
            <summary>Is this pawn equipped with a weapon?</summary>
            <param name="pawn">this pawn</param>
            <returns>true if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.CapableOfViolence(Verse.Pawn)">
            <summary>Is this pawn capable of violence?</summary>
            <param name="pawn">this pawn</param>
            <returns>true if yes</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPregnant(Verse.Pawn)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPregnant(Verse.Pawn,Verse.Hediff@)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <param name="pregnancyHediff"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Pregnancy(Verse.Pawn)">
            <summary>Works on humans and animals</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsRelatedTo(Verse.Pawn,Verse.Pawn)">
            <summary>Check if this pawn is blood related to other pawn</summary>
            <param name="thisPawn">Is this pawn related to otherPawn</param>
            <param name="otherPawn">The pawn to check</param>
            <returns>bool, true if is blood related</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsHomeOwner(Verse.Pawn)">
            <summary>Check if the pawn is currently a home owner</summary>
            <param name="pawn">The pawn to check</param>
            <returns>bool, true if is home owner</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.Home(Verse.Pawn)">
            <summary>Get the home of this pawn</summary>
            <param name="pawn">Get home of this pawn</param>
            <returns>bool = true if found the home. and the Home or (false, null)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsRelatedToAnyHomeOwner(Verse.Pawn)">
            <summary>Is this pawn related to any home owner</summary>
            <param name="pawn">Is this pawn related to any home owner</param>
            <returns>true if is related</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsOccupantOf(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is this pawn an occupant of the given home</summary>
            <param name="pawn">Is this pawn an occupant of the given home</param>
            <param name="home">The home to check</param>
            <returns>true if is an occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsLoverOfAnyOccupant(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home,System.Boolean)">
            <summary>Is this pawn a lover of any occupant in the given home</summary>
            <param name="pawn">Is this pawn a lover of any occupant in the given home</param>
            <param name="home">The home to check</param>
            <param name="forceUpdateCache">Update cache</param>
            <returns>true if is lover of any occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.IsPetOfFamily(Verse.Pawn,NQualityOfLife.HomeSystem.HomeUtility.Home)">
            <summary>Is this pawn a bonded animal of a family member</summary>
            <param name="pawn">Is this pawn a bonded animal of a family member</param>
            <param name="home">The home to check</param>
            <returns>true if is pet of any occupant</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.MyLoverIs(Verse.Pawn,Verse.Pawn)">
            <summary>Is the given pawn my lover</summary>
            <param name="pawn">Me</param>
            <param name="lover">Is this pawn my lover</param>
            <returns>true if the given pawn is lover of this pawn</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.HasALoverOnMap(Verse.Pawn,Verse.Pawn@,System.Boolean,Verse.Map)">
            <summary>Is my lover on the same map as me</summary>
            <param name="pawn">Is my lover on the same map as me</param>
            <param name="lover">The lover that was found, if method returns false => null</param>
            <param name="sortByCommitment">Sort the list of lovers if exists and more than 1</param>
            <param name="map">This map, or my map if null</param>
            <returns>true if lover is on map</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.PawnExtensions.MyLoverHasAHome(Verse.Pawn)">
            <summary>Is my lover a home owner or living in a home</summary>
            <param name="pawn">Me</param>
            <returns>true if lover has home</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0})">
            <summary>Makes a copy of the list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns>A copy of the original list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>Makes a copy of the list starting at the given index</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="startingFrom"></param>
            <param name="count"></param>
            <returns>A copy of the original list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.List{``0})">
            <summary>Makes a copy of the list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns>A copy of the original list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(``0[])">
            <summary>Makes a new list from the array</summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <returns>A new list with the same items as the source array</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Makes a copy of the list</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <returns>A copy of the original list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Count how many items in the list match the given predicate</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Count how many items in the list match the given predicate</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Get the count of items</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountWhere``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Count how many items in the list match the given predicate</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Count``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Count how many items in the list match the given predicate</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(``0[],System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Predicate{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Int32,System.Predicate{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <param name="knownSize">The total size of the list</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(NQualityOfLife.IListInterface{``0},System.Int32,System.Predicate{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <param name="knownSize">The total size of the list</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.List{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount. || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Predicate{``0})">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <param name="predicate"></param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountTill``2(System.Collections.Generic.Dictionary{``0,``1},System.Int32)">
            <summary>Counts until the max value or end of the list.</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="source"></param>
            <param name="maxCount">When to stop counting</param>
            <returns>Element count or maxCount if more elements than maxCount.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAll_ToArray``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="toArray"></param>
            <param name="predicate"></param>
            <returns>A new array with all the members from the input list that matched the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAllWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A new list with all the members from the input list that matched the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Where``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A new list with all the members from the input list that matched the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A new list with all the members from the input list that matched the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FindAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>A new list with all the members from the input list that matched the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Make a new list from the given collection where the items satisfy the predicate</summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="where"></param>
            <returns>The matching input elements to list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Make a new list from the given collection where the items satisfy the predicate, The int in the predicate is the index of the item</summary>
            <typeparam name="T"></typeparam>
            <param name="iList"></param>
            <param name="where">Func&lt;T item, int index, bool mathes&gt;</param>
            <returns>The matching input elements to list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Make a new list from the given collection where the items satisfy the predicate</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="where"></param>
            <returns>The matching input elements to list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``1(System.Collections.Generic.IEnumerable{``0},System.Int32@)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="count">the count of elements</param>
            <returns>The input elements to list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ToList``2(System.Collections.Generic.Dictionary{``0,``1}.KeyCollection,System.Int32@)">
            <summary>Copies all the keys to a new list</summary>
            <typeparam name="K">Keys</typeparam>
            <typeparam name="V">Values</typeparam>
            <param name="keyCollection"></param>
            <param name="count"></param>
            <returns>A new list of the keys</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns true if the collection is null or empty</summary><typeparam name="T"></typeparam><param name="iEnumerable"></param>
            <returns>True if the collection is null or has a Count() of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.IList{``0})">
            <summary>Returns true if the list is null or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns>True if the list is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(``0[])">
            <summary>Returns true if the array is null or empty</summary><typeparam name="T"></typeparam><param name="array"></param>
            <returns>True if the array is null or has a Length of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(``0[])">
            <summary>Returns true if the array is null or empty</summary><typeparam name="T"></typeparam><param name="array"></param>
            <returns>True if the array is null or has a Length of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.List{``0})">
            <summary>Returns true if the list is null or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns>True if the list is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary>Returns true if the list is null or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="count"></param>
            <returns>True if the list is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(``0[],System.Int32@)">
            <summary>Returns true if the array is null or empty</summary><typeparam name="T"></typeparam><param name="array"></param>
            <param name="count"></param>
            <returns>True if the array is null or has a Length of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.List{``0})">
            <summary>Returns true if the list is null or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns>True if the list is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IList{``0})">
            <summary>Returns true if the list is null or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns>True if the list is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Returns true if the list is null or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns>True if the list is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Returns true if the list is null or empty</summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns>True if the list is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.NullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Returns true if the dictionary is null or empty</summary><typeparam name="K">Key</typeparam><typeparam name="V">Value</typeparam><param name="dictionary"></param>
            <returns>True if the dictionary is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsNullOrEmpty``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>Returns true if the dictionary is null or empty</summary><typeparam name="K">Key</typeparam><typeparam name="V">Value</typeparam><param name="dictionary"></param>
            <returns>True if the dictionary is null or has a Count of 0</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(``0[])">
            <summary></summary><typeparam name="T"></typeparam><param name="array"></param>
            <returns>True if not null and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IEnumerable{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="enumerable"></param>
            <returns>True if not null and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="iList"></param>
            <returns>True if not null and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.HasAny``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary></summary><typeparam name="T"></typeparam><param name="iList"></param>
            <param name="count"></param>
            <returns>True if not null and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0},System.Int32@)">
            <summary></summary><typeparam name="T"></typeparam><param name="iList"></param>
            <param name="count"></param>
            <returns>True if not null and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.List{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns>True if not null and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <returns>True if not null and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary></summary><typeparam name="K"></typeparam><typeparam name="V"></typeparam><param name="array"></param>
            <returns>True if not null and has at least 1 item</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns>True if not null and has at least 1 item that satisfies the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Any``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns>True if not null and has at least 1 item that satisfies the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AnyWhere``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns>True if not null and has at least 1 item that satisfies the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AnyWhere``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary><typeparam name="T"></typeparam><param name="list"></param>
            <param name="predicate"></param>
            <returns>True if not null and has at least 1 item that satisfies the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.All``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>True if all elements in the list satisfy the condition</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetTypeWithHighestValueInDictionary``1(System.Collections.Generic.Dictionary{``0,System.UInt16},System.UInt16@)">
            <summary>Returns the T instance with the highest value in the input dictionary</summary>
            <typeparam name="T"></typeparam>
            <param name="dictionary"></param>
            <param name="highestFoundValue">The highest value</param>
            <returns>The instance of T with the highest value in the dictionary</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IncrementOrAdd``1(System.Collections.Generic.Dictionary{``0,System.UInt16},``0,System.UInt16,System.UInt16)">
            <summary>Increments the existing value or adds the start value</summary>
            <typeparam name="K"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="startValue">Set the value to this if there was no value for the key</param>
            <param name="incrementBy">Increment the existing value by this amount</param>
            <returns>The existing value incremented, or the new value if there was no existing value</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IncrementOrAdd``1(System.Collections.Generic.Dictionary{``0,System.Int32},``0,System.Int32,System.Int32)">
            <summary>Increments the existing value or adds the start value</summary>
            <typeparam name="K"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="startValue">Set the value to this if there was no value for the key</param>
            <param name="incrementBy">Increment the existing value by this amount</param>
            <returns>The existing value incremented, or the new value if there was no existing value</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>Adds the new item only if it doesn't already exist</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Adds the new item only if it doesn't already exist</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="range"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.AddSafe``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Adds the new item only if it doesn't already exist</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="value"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SetOrAddValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>Set the value of an existing entry or add new entry with the provided value</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="value">New value for the key</param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SetOrAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>Set the value of an existing entry or add new entry with the provided value</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="value">New value for the key</param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetAndSetSafe``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1,``1@)">
            <summary>Gets the existing value from the dictionary and writes the new value</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="newValue">The new value to add or set</param>
            <param name="oldValue">The old value if it was found, or null</param>
            <returns>True if existing value was in the dictionary, false if it was added now - also returns true on error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>Gets the value from the dictionary, or adds the provided value</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam>
            <param name="dictionary"></param>
            <param name="key"></param>
            <param name="value">The new value to add if there is no existing value</param>
            <returns>The existing value || or the provided value if there was no existing value, || returns the new value on error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.GetTypeWithMostDuplicates``1(System.Collections.Generic.IList{``0},System.UInt16@)">
            <summary>Returns the T instance with the highest number of duplicates in the input list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="instancesFoundInList">How many of the most common type were found</param>
            <returns>The instance of T with the most appearances in the list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.CountDuplicatesInAList``1(System.Collections.Generic.IList{``0})">
            <summary>Count how many times each item appears in a list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list">Count duplicates in this list</param>
            <returns>a new dictionary of instances of T and how many of them were in the original list.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Merge``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Merges the contents to this list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="otherList"></param>
            <returns>The input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})">
            <summary>Gets the first items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A new list with the first items from the input tuple list - The returned list has a capacity equal to the size ot the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.SecondItems``2(System.Collections.Generic.IList{System.ValueTuple{``0,``1}})">
            <summary>Gets the second items in a tuple list</summary>
            <typeparam name="T"></typeparam><typeparam name="B"></typeparam><param name="tupleList"></param>
            <returns>A new list with the second items from the input tuple list - The returned list has a capacity equal to the size ot the input list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct``1(System.Collections.Generic.KeyValuePair{``0,System.UInt16},``0@,System.UInt16@)">
            <summary>KeyValuePair deconstruct for a generic key and ushort</summary>
            <typeparam name="K"></typeparam><param name="tuple"></param><param name="key"></param><param name="value"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>KeyValuePair deconstruct for a generic key and value</summary>
            <typeparam name="K"></typeparam><typeparam name="V"></typeparam><param name="tuple"></param><param name="key"></param><param name="value"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Remove``1(System.Collections.Generic.IList{``0},``0,System.Int32)">
            <summary>Remove the specified amount of the item || or until there are none left.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="item"></param>
            <param name="amount">The amount of items to remove.</param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAll``1(``0[],``0)">
            <summary>Remove all the instances of the given item</summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="item"></param>
            <returns>A new array with the specified items removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAll``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Remove all the instances of the given item</summary>
            <typeparam name="T"></typeparam>
            <param name="iListRef"></param>
            <param name="item"></param>
            <returns>The amount of items removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveLast``1(System.Collections.Generic.IList{``0})">
            <summary>Remove the last element from the list - a null or empty list will cause an exception</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.Last``1(System.Collections.Generic.IList{``0})">
            <summary>Get the last item of the list - Will error if the list is null or empty!</summary>
            <typeparam name="T"></typeparam><param name="list"></param>
            <returns>The last item in the list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.First``1(System.Collections.Generic.IList{``0})">
            <summary>Get the last item of the list - Will error if the list is null or empty!</summary>
            <typeparam name="T"></typeparam><param name="list"></param>
            <returns>The last item in the list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrFallBack``1(``0[],System.Predicate{``0},``0)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param><param name="predicate"></param><param name="fallback"></param>
            <returns>The first found thing that matches the predicate, or fallback if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrFallBack``1(System.Collections.Generic.IList{``0},System.Predicate{``0},``0)">
            <summary></summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param><param name="fallback"></param>
            <returns>The first found thing that matches the predicate, or fallback if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicateTypes``1(System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="additionalEqualityComparer"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(``0[],System.Predicate{``0})">
            <summary>First match in the array or the 'default' value of the type 'T'</summary>
            <typeparam name="T"></typeparam><param name="array"></param><param name="predicate"></param>
            <returns>The first found thing that matches the predicate, or default if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <returns>The first found thing that matches the predicate, or default if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstOrDefault``1(System.Collections.Generic.List{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <returns>The first found thing that matches the predicate, or default if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Get the index of the first found match in the list</summary>
            <typeparam name="T"></typeparam><param name="list"></param><param name="predicate"></param>
            <returns>The index of the first found thing that matches the predicate, or -1 if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="match"></param>
            <returns>The index of the first found thing that equals the predicate, or -1 if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.LastIndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>The index of the last found thing that matches the predicate, or -1 if none</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates_ToList``1(System.Collections.Generic.IList{``0})">
            <summary>Remove duplicates so that only one of each item is on the list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns>A copy of the list with duplicates removed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveDuplicates``1(System.Collections.Generic.IList{``0})">
            <summary>Remove duplicates so that only one of each item is on the list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.RemoveAllInstancesWithDuplicates``1(System.Collections.Generic.IList{``0})">
            <summary>Removes all instances of an item if it has any duplicates in the list</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAny``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the list contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns>True if any of the elements are in both lists.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAny``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>Checks if the list contains any elements that satisfy the predicate</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="predicate"></param>
            <returns>True if any of the elements satisfy the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAny``1(``0[],System.Predicate{``0})">
            <summary>Checks if the array contains any elements that satisfy the predicate</summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <param name="predicate"></param>
            <returns>True if any of the elements satisfy the predicate</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAny``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},``0@)">
            <summary>Checks if the list contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <param name="firstMatch"></param>
            <returns>True if any of the elements are in both lists.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAny(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String@)">
            <summary>Checks if the list contains any of the elements in the second list.</summary>
            <param name="list"></param>
            <param name="ofThese"></param>
            <param name="firstMatch"></param>
            <returns>True if any of the elements are in both lists.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAny``1(System.Collections.Generic.List{``0},``0[])">
            <summary>Checks if the list contains any of the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns>True if any of the elements are in both lists.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.IsAny``1(``0,System.Collections.Generic.IList{``0})">
            <summary> </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="ofThese"></param>
            <returns>Returns false if any input is null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAll``1(System.Collections.Generic.IList{``0},``0[])">
            <summary>Checks if the first list contains all the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAll``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the first list contains all the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.ListExtensions.ContainsAll``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0})">
            <summary>Checks if the first list contains all the elements in the second list.</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="ofThese"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.RoomExtensions">
            <summary>Room extension methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Neighbours(Verse.Room,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Get neighbouring rooms of a given room - Never null</summary>
            <param name="room">Get the neighbouring rooms of this room</param>
            <param name="forceCacheUpdate">Force update neighbour cache?</param>
            <param name="canPassHomeSeparators">do doors with an enabled home separator act like walls?</param>
            <param name="treatAirlocksAsDoors"></param>
            <param name="gameTicksNow"></param>
            <returns>List District of the given room's neighbouring rooms (not doorways) - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Cells(Verse.Region,System.Int32@,Verse.Map)">
            <summary>Creates the list of cells for the region directly from the region grid</summary>
            <param name="region"></param>
            <param name="cellCount"></param>
            <param name="map"></param>
            <returns>Not null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetThingsOfType``1(Verse.Room)">
            <summary>Not null</summary>
            <typeparam name="T"></typeparam>
            <param name="room"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetThingsOfType``1(Verse.Room,System.Int32@)">
            <summary>Not null</summary>
            <typeparam name="T"></typeparam>
            <param name="room"></param><param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHomeID(Verse.Room,System.Boolean)">
            <summary>Get the id of the home that a room belongs to</summary>
            <param name="room">Get the id of the home that this room belongs to</param>
            <param name="skipIsPartOfHomeCheck">Skip check if we know that the room is part of a home</param>
            <returns>The id of the home that the room belongs to, or null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHome(Verse.Room)">
            <summary>Get the home that a room belongs to</summary>
            <param name="room">Get the home that this room belongs to</param>
            <returns>The home and a bool of true if it was found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.GetHomeOwner(Verse.Room)">
            <summary>Get the pawn who is the owner of the home that the room belongs to, returns null if failed</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.DoorWays(Verse.Room)">
            <summary>Get the doorway districts of the given room</summary>
            <param name="room">The room whose door ways we want to get.</param>
            <returns>A list of districts</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.RoomExtensions.Doors(Verse.Room,Verse.Map)">
            <summary>Get the doorway things from all neighbouring districts of the given room. If you don't need the 'Thing' use 'IReadOnlyList(District) DoorWays(this Room room)' instead</summary>
            <param name="room">The room whose door ways we want to get.</param>
            <param name="map">Will be taken from room.Map if null, provide it if possible.</param>
            <returns>A list of Things (doors)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenWorkshopItem_Changelog(System.String)">
            <summary>Open the changelog tab of the given workshop item in the web browser</summary>
            <param name="publishedFieldID"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenWorkshopItem(System.String)">
            <summary>Open the workshop page of the given workshop item in the web browser</summary>
            <param name="publishedFieldID"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Networking.Web.OpenURL(NQualityOfLife.URL)">
            <summary>Open the given URL in the browser - Displays on screen and log message, and plays sound.</summary>
            <param name="url">The URL of the web page to open in the web browser</param>
        </member>
        <member name="F:NQualityOfLife.Utils.File_.myLocalModPath">
            <summary>The path on my local PC, only intended to be used for DEV tools that are not supposed to work or be included in released features</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.CaptureFirstMatchingXMLNode(System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="rawText"></param>
            <param name="xmlNode"></param>
            <param name="targetNodeData">Data inside the node must match this.</param>
            <param name="debugLogging"></param>
            <returns>3 nulls if no match found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.ReplaceFirstMatchingXMLNode(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="originalRawText"></param>
            <param name="xmlNode"></param>
            <param name="newValue"></param>
            <param name="oldValue">Node must have this value to be matched</param>
            <param name="debugLogging"></param>
            <returns>The input text with the specifed node replaced</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.UpdateAboutXML(NQualityOfLife.FilePath,System.String,System.Boolean)">
            <summary></summary>
            <param name="folderPath"></param>
            <param name="fileName"></param>
            <param name="debugLogging"></param>
            <returns>True if was succesfully update or no update needed, false if update failed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.IncrementVersion(System.String,System.String@)">
            <summary></summary>
            <param name="oldVersion"></param>
            <param name="newVersion"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.ReadFirstLine(NQualityOfLife.FilePath)">
            <summary>Reads the first line of the specified file</summary>
            <param name="filePath">The full path to the file</param>
            <returns>The text on the first line or null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.ValidateFolderPath(NQualityOfLife.FilePath)">
            <summary>Makes sure the path is valid and that the target folder exists</summary>
            <param name="folderPath"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.ValidateFilePath(NQualityOfLife.FilePath)">
            <summary>Makes sure the path is valid and that the target file exists</summary>
            <param name="fullFilePath"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.ValidateXMLFile(NQualityOfLife.FilePath,System.String,System.Boolean,System.Boolean)">
            <summary>Checks the validity of the path strings, if the fileName ends with an xml file, if the file exists, and has a valid xml header</summary>
            <param name="folderPath">The folder path of the file</param>
            <param name="fileName">The name of the file, must end with '.xml' to be valid</param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="isNewFile"></param>
            <returns>True if valid, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.ValidateXMLFile(NQualityOfLife.FilePath,System.Boolean,System.Boolean)">
            <summary>Checks the validity of the path srting, if it ends with an xml file, if the file exists, and has a valid xml header</summary>
            <param name="filePath">The full file path of the target file</param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="isNewFile"></param>
            <returns>True if valid, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.OverWriteFirstMatchingXMLNode(NQualityOfLife.FilePath,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean)">
            <summary></summary>
            <param name="folderPath"></param>
            <param name="fileName"></param>
            <param name="xmlNode"></param>
            <param name="newValue"></param>
            <param name="oldValue"></param>
            <param name="xmlNode2"></param>
            <param name="newValue2"></param>
            <param name="oldValue2"></param>
            <param name="debugLogging"></param>
            <returns>True if the write was succesfull, or no changes were needed</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.CreateAnalyzerXML(System.Reflection.Assembly,System.String,System.String,NQualityOfLife.FilePath,System.Boolean,System.Boolean)">
            <summary>Create an 'Analyzer.xml' file for use with 'Dubs Performance Analyzer'</summary>
            <param name="assembly">Create the Analyzer.xml for this assembly</param>
            <param name="categoryName">The category name that will be displayed in game in the analyzer ui</param>
            <param name="fileName">Must be: 'Analyzer.xml' for the analyzer to detect it.</param>
            <param name="folderPath">Where to create the file? Should be the root folder of the mod, or the analyzer wont find it.</param>
            <param name="allowOverWrite">Allow over writing the existing file?</param>
            <param name="creatingNew"></param>
            <returns>True if file creation was successful, else false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetAssembliesFromFolder(System.IO.DirectoryInfo,System.String@,System.Boolean,System.Boolean,System.String)">
            <summary>Get a list of (reflection only) assemblies in the specified folder folderPath, or in sub folders of the specified folder</summary>
            <param name="folder">DirectoryInfo of the target folder</param>
            <param name="message">Error message string or null if no error</param>
            <param name="checkSubFolders">Also get assemblies from sub folders inside the specified folder</param>
            <param name="onlyAsFallback">Only check for assemblies in sub folders, if none were found in the primary target folder, checkSubFolders must also be true</param>
            <param name="assemblyFolderMustBeCalled">The assemblies must be inside a folder named x, if null: this condition is ignored</param>
            <returns>List of the found assemblies or empty list</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetAssembliesFromFolder(System.Collections.Generic.List{System.Reflection.Assembly}@,NQualityOfLife.FilePath,System.String@,System.String)">
            <summary>Add the (reflection only) assemblies from a folder to an existing list of assemblies, or if the list is null, create a new list.</summary>
            <param name="assemblies">A pre existing list of assemblies that we want to add more assemblies to</param>
            <param name="folderPath">The full file folderPath to the folder that contains the assemblies</param>
            <param name="message">Soft error message string</param>
            <param name="assemblyFolderMustBeCalled">The folder that contains the .dll files must have this name</param>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetAssembliesFromFolder(NQualityOfLife.FilePath,System.String@,System.Boolean,System.Boolean,System.String)">
            <summary>Get a list of (reflection only) assemblies in the specified folder folderPath, or in sub folders of the specified folder</summary>
            <param name="folderPath">Full folderPath to the target folder, such as a mod root folder</param>
            <param name="message">Error message string or null if no error</param>
            <param name="checkSubFolders">Also get assemblies from sub folders inside the specified folder</param>
            <param name="onlyAsFallback">Only check for assemblies in sub folders, if none were found in the primary target folder, checkSubFolders must also be true</param>
            <param name="assemblyFolderMustBeCalled">The assemblies must be inside a folder named x, if null: this condition is ignored</param>
            <returns>List of the found assemblies or empty list - never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetFileVersion(System.String,System.String@)">
            <summary>Get the file version of the file at the given path</summary>
            <param name="filePath"></param>
            <param name="message"></param>
            <returns>null, null symbol or the found version</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetAssemblyVersion(System.Reflection.Assembly,System.String@)">
            <summary>Get the version from the assembly meta data</summary>
            <param name="assembly"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetFileVersion(System.Reflection.Assembly,System.String@)">
            <summary>Get the actual file version of the given assembly (.dll) file</summary>
            <param name="assembly"></param><param name="message"></param>
            <returns>The file version of the actual .dll file.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetVersion(System.Reflection.Assembly,System.String@,System.String@)">
            <summary>Get the file and assembly version of the given assembly</summary>
            <param name="assembly"></param>
            <param name="messageFileVer">The file version of the actual .dll file</param>
            <param name="messageAssemblyVer">The internal version from the assembly metadata</param>
            <returns>(string? fileVersion, string? assemblyVersion)</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetVersion(Verse.ModMetaData,System.String@)">
            <summary>Try get the mod version from the meta data - Tries to look for the version in the description text if no explicit version field exists - Returns null if the version data is not given or found</summary>
            <param name="modMetaData"></param><param name="message">Null if was succesfull, else contains some info about why info was not found</param>
            <returns>null if no version field or info was found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetVersion(Verse.Mod,System.String@,System.String@,System.String)">
            <summary>Try get the mod version in order: About.xml -> Assembly (version and or file version)</summary>
            <param name="mod"></param>
            <param name="message_FileVer"></param>
            <param name="message_AssemblyVer"></param>
            <param name="skipAssembliesWith">Skip assemblies with the provided string in their name</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetAboutFile(System.String,System.String@)">
            <summary>Get a FileInfo of the about xml, or null if not found</summary>
            <param name="aboutFolderPath">The full path to the About folder that contains the About.xml</param>
            <param name="message">Error message or null</param>
            <returns>FileInfo of the About.xml or null if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetFile(System.String,System.String,System.String@)">
            <summary>Get a file from a folder</summary>
            <param name="fileName">Tho path to the folder containing the file.</param>
            <param name="message">Error message or null</param>
            <param name="folderPath">The name of the file to get</param>
            <returns>FileInfo of the file or null if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetXMLNode_FromModAboutFile(System.String,System.String,Verse.ModMetaData,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Gets the xmlNodes inside the specified node</summary>
            <param name="modPackageId">For example "niilo007.niilosqol"</param>
            <param name="xmlNode">Format in the name of the node, with no slashes or greater / less than symbols For example: "supportedVersions"</param>
            <param name="metaData"></param>
            <param name="logNonCaptureRelatedErrors"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns>string of the value inside the node, or null if not found</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetFirstMatchingXMLNode_FromFile(System.IO.FileInfo,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="file"></param>
            <param name="xmlNode"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.File_.GetFirstMatchingXMLNode_FromFile(NQualityOfLife.FilePath,System.String,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="filePath"></param>
            <param name="xmlNode"></param>
            <param name="tolerateMissingXMLDeclaration">Xml files should always start with an xml declaration, such as: '&lt;?xml version="1.0" encoding="utf-8" ?&gt;' but this can sometimes be missing. Set this to true to tolerate missing xml declaration.</param>
            <param name="debugLogging"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Transpiler.CallsMethod(HarmonyLib.CodeInstruction,System.Reflection.MethodInfo)">
            <summary></summary>
            <param name="instruction"></param>
            <param name="method"></param>
            <returns>True if the instruction calls the given method - if the method is null, will log an error</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.XML.Patch.RemoveDef``1(``0)">
            <summary>Remove the given def from the game</summary>
            <typeparam name="D">The type of the def</typeparam>
            <param name="def">The def to remove</param>
            <returns>True if the def was successfully removed</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Log">
            <summary>Utils for logging errors and warnings</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Log.Strings">
            <summary>Commonly used strings</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.RemoveColorTagsRegex(System.String)">
            <summary>Strips color tags</summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ErrorOnce(System.Exception,Verse.LookTargets)">
            <summary>Log exception once with method resolve mode '(...)' and visible id</summary><param name="exception"></param><param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageOnChange(System.String,System.String,System.Type,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log a message if the message has changed</summary><param name="message"></param>
            <param name="method"></param><param name="type"></param><param name="methodName"></param>
            <param name="logMode"></param>
            <param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.MessageOnChange(System.String,System.Type,System.String)">
            <summary>Log a message if the message has changed</summary><param name="message"></param><param name="type"></param><param name="methodName"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,System.String,Verse.LookTargets)">
            <summary>Log a warning with the method details and look targets</summary><param name="message"></param><param name="method"></param><param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,NQualityOfLife.Utils.Log.LogMode,System.String,Verse.LookTargets)">
            <summary>Log a warning with the given log mode - Logs method name be defuly using the '(omit)' resolve mode</summary><param name="message"></param><param name="logMode"></param><param name="method"></param><param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets,System.String)">
            <summary>Log warning message with look targets and visible method name</summary><param name="message"></param><param name="logMode"></param><param name="lookTargets"></param><param name="method"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String)">
            <summary>Log a warning with message only</summary><param name="message"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Warning(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log a warning with the given method info</summary><param name="message"></param><param name="method">The method info or mode</param><param name="logMode"></param><param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null``1(System.String,System.String,System.String,``0,Verse.LookTargets)">
            <summary>Logs a null error and returns the specified value</summary>
            <param name="nullThing">nameof</param>
            <param name="nullThing2"></param><param name="t">nameof(t)</param>
            <param name="lookTargets"></param><param name="method"></param>
            <returns>T specified value</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null``1(System.String,System.String,``0,Verse.LookTargets)">
            <summary>Logs a null error and returns default or specified value</summary>
            <param name="nullThing">nameof</param><param name="t">nameof(t)</param>
            <param name="lookTargets"></param><param name="method"></param>
            <returns>T default value or given value</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,Verse.LookTargets)">
            <summary>Logs a null error and returns false</summary>
            <param name="t">nameof(t)</param><param name="method"></param>
            <param name="lookTargets"></param><returns>false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,Verse.LookTargets)">
            <summary>Logs a null error and returns false</summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="method"></param>
            <param name="lookTargets"></param><returns>false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.String,Verse.LookTargets)">
            <summary>Logs a null error and returns false</summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="t3"></param><param name="method"></param><param name="lookTargets"></param><returns>false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_Null(System.String,System.String,System.String,System.String,System.String,Verse.LookTargets)">
            <summary>Logs a null error and returns false</summary>
            <param name="t1">nameof(t1)</param><param name="t2">nameof(t2)</param><param name="t3"></param><param name="t4"></param><param name="method"></param>
            <param name="lookTargets"></param><returns>false</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error_InvalidInput``1(System.String,System.String)">
            <summary>Log an error and return the default value of the specifed type</summary>
            <typeparam name="R"></typeparam>
            <param name="parameter"></param>
            <param name="method"></param>
            <returns>Default value of 'R' usually null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error(System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log an error without including the method name or params</summary><param name="message"></param><param name="logMode"></param><param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error(System.String,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log error with the given method info</summary><param name="message"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error``1(``0,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log exception with method name and params</summary><param name="exception"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets"></param><returns>The Exception that was logged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.Error``1(System.String,``0,System.String,NQualityOfLife.Utils.Log.LogMode,Verse.LookTargets)">
            <summary>Log exception with a message and method name and params</summary><param name="message"></param><param name="exception"></param><param name="method"></param><param name="logMode"></param><param name="lookTargets"></param><returns>The Exception that was logged</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.GetLogTypeTagString(NQualityOfLife.Utils.Log.LogMode,System.String)">
            <summary></summary>
            <param name="logMode"></param>
            <param name="tag"></param>
            <returns>"- QA -" or "[E] - QA -" or "-" or "[E] -" etc</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.ResolveMethodInfo(System.String,System.Byte,System.Boolean)">
            <summary>Input can be null</summary>
            <param name="methodToResolve"></param>
            <param name="offsetStackFrames"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Log.FixColorTagParity(System.String,System.Byte,System.Boolean@,System.Boolean,System.Boolean)">
            <summary>Calling Utils.Log.Error can cause an infinite loop!</summary>
            <param name="text"></param>
            <param name="attempts"></param>
            <param name="error"></param>
            <param name="skipNullCheck"></param>
            <param name="skipHasColorTagsCheck"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Settings">
            <summary>Global settings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Settings.DebugMode">
            <summary>global debug mode bool</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Search">
            <summary>Methods for searching for things</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.CheckRegionForThing(Verse.Thing,Verse.ThingDef,System.Boolean,RimWorld.Faction,System.Boolean,System.Func{Verse.Thing,System.Boolean})">
            <summary>Is the given thing the thing we are looking for?</summary>
            <param name="thing">the thing we are comparing to the thing wea are looking for</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as null.</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="thingValidator"></param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing, bool next</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForThingInRegionsSpiralAroundLocation(Verse.IntVec3,Verse.Map,Verse.ThingDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RimWorld.Faction,System.Boolean,System.Boolean,System.Func{Verse.Thing,System.Boolean})">
            <summary>Search for the given thing around surrounding regions</summary>
            <param name="myLocation">Start location of the search.</param>
            <param name="map">The map to search</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as null.</param>
            <param name="findEmptyCell">True if we want to instead find an empty cell.</param>
            <param name="emptyCellMustBeUnroofed">If searching for empty cell, does the cell have to be un-roofed?</param>
            <param name="cellCantBeInMyRegion">If searching for empty cell, does the cell have to be outside the starting region?</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="onlyOurRegion">Check only our region?</param>
            <param name="thingValidator">Custom thing validator if one def is not sufficient</param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Search.SearchForThingInRegionsSpiralAroundLocation(Verse.Region,Verse.Map,Verse.ThingDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RimWorld.Faction,System.Boolean,System.Boolean,System.Func{Verse.Thing,System.Boolean})">
            <summary>Search for the given thing around surrounding regions</summary>
            <param name="myRegion">Start region of the search.</param>
            <param name="map">The map to search</param>
            <param name="thingToFind">If searching for a specific ThingDef, give this argument else leave as null.</param>
            <param name="findEmptyCell">True if we want to instead find an empty cell.</param>
            <param name="emptyCellMustBeUnroofed">If searching for empty cell, does the cell have to be un-roofed?</param>
            <param name="cellCantBeInMyRegion">If searching for empty cell, does the cell have to be outside the starting region?</param>
            <param name="findHostiles">If we should instead look for hostiles of the given faction.</param>
            <param name="myFaction">The faction we want to search for hostiles of.</param>
            <param name="findTrader">Are we looking for a trader?</param>
            <param name="onlyOurRegion">Check only our region?</param>
            <param name="thingValidator">Custom thing validator if one def is not sufficient</param>
            <returns>bool - didFindThing, IntVec3 - foundCell, Thing - foundThing</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Redactor">
            <summary>Used for redacting things like personal information from strings</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo(System.String)">
            <summary>Attempts to redact any personal data, such as usernames</summary>
            <param name="text"></param>
            <returns>The input text with personal data redacted - Note: is not guaranteed to redact everything!</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo_Linux(System.String)">
            <summary>Attempts to redact any personal data, such as usernames</summary>
            <param name="text"></param>
            <returns>The input text with personal data redacted - Note: is not guaranteed to redact everything!</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Redactor.RedactPersonalInfo_Windows(System.String)">
            <summary>Attempts to redact any personal data, such as usernames</summary>
            <param name="text"></param>
            <returns>The input text with personal data redacted - Note: is not guaranteed to redact everything!</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Common">
            <summary>Common utility methods</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.ToInt(System.Char,System.Boolean,System.Int32)">
            <summary>Returns the corresponding int for the given char, Accepts inputs in the '0 - 9' range!</summary>
            <param name="c">char in the '0 - 9' range</param>
            <param name="errorOnFail">Log error on fail before returning -1?</param>
            <param name="fallBackInt"></param>
            <returns>'char '0' -> int 0', 'char '9' -> int 9', 'char 'A/a' -> int 10', 'char 'F/f' -> int 15', returns 'fallBackInt' if input is out of range.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.RatioToColor(System.Single,System.Boolean,System.Single)">
            <summary></summary>
            <param name="ratio"></param>
            <param name="highIsBad"></param>
            <param name="alwaysGoodOrBadAbove"></param>
            <returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.RatioToColor(NQualityOfLife.Ratio,System.Boolean,System.Single)">
            <summary></summary>
            <param name="ratio"></param>
            <param name="highIsBad"></param>
            <param name="alwaysGoodOrBadAbove"></param>
            <returns>UnityEngine.Color</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.ToChar(System.Int32,System.Boolean,System.Char)">
            <summary>Returns the corresponding char for the given int, Accepts inputs in the '0 - 9' range!</summary>
            <param name="i">i in the '0 - 9' range</param>
            <param name="errorOnFail">Log error on fail before returning 'Common.Chars.emptyChar'?</param>
            <param name="fallBackChar">In case of a failed conversion, use this char</param>
            <returns>'int 0 -> char '0'', 'int 9 -> char '9'', 'int 15 -> char 'F'', returns 'fallBackChar' if input is out of range.</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.TryParse(System.Char,System.Int32@)">
            <summary></summary>
            <param name="c">character</param><param name="i"></param>
            <returns>True if successfully parsed char to int</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.TryParse(System.Int32,System.Char@)">
            <summary></summary>
            <param name="c">character</param><param name="i"></param>
            <returns>True if successfully parsed int to char</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.UnsetFlagsGeneric``1(``0,``0)">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="mode"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.micro">
            <summary>'u' with the tail</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Chars.emptySymbol">
            <summary>Symbol for representing an empty string or collection, 'ε' - looks like an inverted 3 or fancy E</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatDate(System.DateTime)">
            <summary>Formats the given date in the format: D.M.Y</summary>
            <param name="dateTime"></param>
            <returns>D.M.Y string</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.ReverseFormatDate(System.String)">
            <summary>Gets the DateTime from a: D.M.Y string</summary>
            <param name="dateString">a date string formatted as: D.M.Y or D:M:Y</param>
            <returns>DateTime from a D.M.Y</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Common.Strings">
            <summary>Commonly used strings</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.redacted">
            <summary>Used to replace user names or other sensitive info from log messages etc..</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.nullSymbol">
            <summary>Used to represent a null value in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.nullSymbol2">
            <summary>Used to represent a null value in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.emptySymbol">
            <summary>Used to represent an empty string in log messages etc...</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.Strings.newLine">
            <summary>The new line symbol string for the current Environment/OS</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.IFormatMode`1.DisplayFormatFor(NQualityOfLife.Utils.Common.DisplayMode)">
            <summary>Format T according to the DisplayMode - default should use ToString()</summary>
            <param name="displayMode"></param>
            <returns>The formatted string representation of T</returns>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.Default">
            <summary>ToString()</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.ShortName">
            <summary>A short identifier/name of the item</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.LongName">
            <summary>Display a long / full name string</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.LabelIfPossible">
            <summary>Display the user facing label if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.IDIfPossible">
            <summary>Display the unique id of the item if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayModeFlags.UseDeterministicColors">
            <summary>Should the string be colored before appending it to the final result?</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.Default">
            <summary>ToString()</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.ShortName">
            <summary>A short identifier/name of the item</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.LongName">
            <summary>Display a long / full name string</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.LabelIfPossible">
            <summary>Display the user facing label if possible</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Common.DisplayMode.IDIfPossible">
            <summary>Display the unique id of the item if possible</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.FormatItemString``1(System.String,``0,System.Text.StringBuilder@,System.Boolean,System.UInt32@,System.String,System.String,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String})">
            <summary></summary>
            <typeparam name="T"></typeparam>
            <param name="displayedString"></param>
            <param name="item"></param>
            <param name="builder"></param>
            <param name="useNumber"></param>
            <param name="c"></param>
            <param name="lineStart"></param>
            <param name="lineEnd"></param>
            <param name="displayMode"></param>
            <param name="specialSuffix"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Common.DisplayFormatFor``1(``0,NQualityOfLife.Utils.Common.DisplayModeFlags,System.Func{``0,System.String})">
            <summary>Format the item to a string accordin to the given DisplayMode or specialFormatter</summary>
            <typeparam name="T"></typeparam>
            <param name="t"></param>
            <param name="displayMode"></param>
            <param name="specialFormatter"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Resolve">
            <summary>Resolve invalid or null values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.MapIsNullAfterResolve``1(Verse.Map,Verse.Map@,``0,System.String,System.String)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="t">Use this thing to find map if available</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.IsNullAfterResolve(Verse.Map,Verse.Map@,System.String,System.String)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.MapIsNullAfterResolve(Verse.Map,Verse.Map@,System.String,System.String,System.Byte)">
            <summary>Do a null check before calling this method! - Try to resolve a null map, and log error on fail</summary>
            <returns>resolved map, and true if failed to resolve. false if succeeded</returns>
            <param name="mapIn">The possibly null map</param>
            <param name="map">The resolved map</param>
            <param name="method">The method name to include in the error</param>
            <param name="details">Additional details to add to the end of the base null map message</param>
            <param name="offsetFrames"></param>
        </member>
        <member name="M:NQualityOfLife.Utils.Resolve.NullMap``1(``0)">
            <summary>Try to find current map</summary>
            <returns>Map or null</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Mouse_">
            <summary>values related to the mouse pointer</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Mouse_.positionOnUIRatio">
            <summary>y1f is the top of the screen, x1f is the right side of the screen</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Mouse_.IsNearWidgetsOrLetters">
            <summary>true if yes, always false if game is unfocused</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Mouse_.IsNearWidgetsOrLettersUpdate">
            <summary>Is the mouse pointer near the widgets or letter stack?</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Colony">
            <summary>values related to the colony</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Room_.Contains">
            <summary>Get room contents</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.ContainsFood(Verse.Room,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns>bool, true if contains food</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.ContainsFood(Verse.District,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns>bool, true if contains food</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.Contains.Food(Verse.District,System.Int32)">
            <summary>Check if the given room contains food</summary>
            <param name="room">The room to check</param>
            <param name="gameTicksNow">Find.TickManager.TicksGame</param>
            <returns>bool, true if contains food</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Room_.My">
            <summary>myRoom's x</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.My.Neighbours(Verse.District,System.Boolean,System.Boolean,Verse.District,Verse.District,Verse.District,System.Boolean,System.Boolean,System.Int32,System.Byte)">
            <summary>Get the neighbouring rooms of a room</summary>
            <param name="myRoom">The room whose neighbours we want to find</param>
            <param name="ignoreAirlocks">treat airlocks like a single door ISSUE: doesn't correctly return all rooms if this is enabled</param>
            <param name="ignoreRoom1">Ignore this room</param>
            <param name="ignoreRoom2">Ignore this room</param>
            <param name="ignoreRoom3">Ignore this room</param>
            <param name="returnFirst">Return the first found neighbour instead of all of them</param>
            <param name="forceCacheUpdate">Force the method to recalculate, instead of using saved values</param>
            <param name="canPassHomeSeparators">Allow the search to return rooms behind home system home separator doors / do doors with an enabled home separator act like walls?</param>
            <param name="gameTicksNow"></param>
            <param name="maxRecursion"></param>
            <returns>List District of the given room's neighbouring rooms (not doorways) - Never null</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Room_.My.FindEndOfDoorChain(Verse.District,Verse.District,System.Byte,System.Collections.Generic.HashSet{Verse.District})">
            <summary>Finds the room at the end of a chain of back to back doors</summary>
            <param name="startRoom">The room where firstDoor connects</param>
            <param name="firstDoor">The door in startRoom at the start of the door chain</param>
            <param name="maxIterations">Log error and give up after this many iterations of recursion</param>
            <param name="checkedDistricts"></param>
            <returns>The room at the end of the chain, that is not the starting room or null</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Best.MedicalCarePolicy">
            <summary>Methods for getting best medical care policy</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Best.MedicalCarePolicy.ForThisPawn(Verse.Map,Verse.Pawn,System.Boolean)">
            <summary>Get the best medical care policy for the given pawn</summary>
            <returns>bool foundValidPolicy, MedicalCareCategory policy</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="pawnToAssign">The Pawn we want to get the policy for</param>
            <param name="forPrisoners"></param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Best.Area_">
            <summary>Get best Area for...</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Best.Area_.ForThisPawn(Verse.Map,Verse.Pawn,System.Boolean,System.Boolean)">
            <summary>Get the best area restriction for a given pawn</summary>
            <returns>Verse.Area of the best fit for the given pawn</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="pawnToAssign">The Pawn we want to get the Area for</param>
            <param name="slave">is the pawn known to be a slave?</param>
            <param name="skipValidation">Skip the checks for "playerSettings", "SupportsAllowedAreas" and "RespectsAllowedArea" because we already checked them</param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Relations">
            <summary>Get Pawn Relation info</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Relations.LoverPairsOnMap(Verse.Map,System.Boolean)">
            <summary>Get the count of lovers on the map</summary>
            <returns>count of lovers, and count of lovers assigned to double beds</returns>
            <param name="map">The Map to use as a reference</param>
            <param name="mustBeAssignedToSameBed">Do we only count lovers if they are assigned to the same bed?</param>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Skills">
            <summary>Get pawn skills</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Skills.AverageOf">
            <summary>Get average skills of </summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Skills.AverageOf.AssignedTo(Verse.Map,Verse.WorkTypeDef,RimWorld.SkillDef,Verse.Pawn)">
            <summary>Get the average skill of pawns assigned to work type</summary>
            <param name="map">The map to get the average from</param>
            <param name="workType">The work-type that the pawns need to be assigned to</param>
            <param name="skill">The skill to get</param>
            <param name="ignorePawn">Do not include this pawn</param>
            <returns>float of the average skill level</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Triage">
            <summary>Utilities for determining medical treatment priority</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns">
            <summary>Saved list of the top pawns who need treatment</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.priorityPawn">
            <summary>The first top priority pawn</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.secondPawn">
            <summary>The second priority pawn</summary>
        </member>
        <member name="F:NQualityOfLife.Utils.Get.Pawn_.Triage.TriagePawns.thirdPawn">
            <summary>The third priority pawn</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.DeadlyHediffs(Verse.Pawn)">
            <summary>Get all the hediffs that can cause the pawn to die</summary>
            <param name="pawn"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.TimeTillDeath(Verse.Pawn,System.Boolean)">
            <summary>Method for estimating time till death in hours</summary>
            <param name="pawn">Estimate time till death for this pawn</param>
            <param name="hasHediffsNeedingTendOrStarving">Skip check for hediffs if we already know</param>
            <returns>float of time left in hours or float.MaxValue</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.Triage.PriorityPatients(Verse.Map,System.Boolean)">
            <summary>Get top 3 critical pawns</summary>
            <param name="map">Get the top 3 patients and rank them</param>
            <param name="save">save the triage pawns to TriagePawns</param>
            <returns>top 3 patients</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.Pawn_.WithBest">
            <summary>Utilities for getting the pawn with the best value of something</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.Pawn_.WithBest.Stat(Verse.Map,RimWorld.StatDef,Verse.WorkTypeDef,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Method for getting the pawn with the best stat</summary>
            <param name="map">The map to check for pawns, if null, will try to find map</param>
            <param name="greaterIsBetter"> larger values are better</param>
            <param name="stat"> the StatDef to check</param>
            <param name="mustBeCapable"> Return the best pawn that is capable?</param>
            <param name="mustBeAwake"> Get the best pawn from the pawns that are awake?</param>
            <param name="workType"> The pawn must be assigned to the relevant work-type to be considered, if set to null, will not be considered</param>
            <param name="mustNotBeOccupied"> Don't return pawns that are currently operating? </param>
            <param name="postProcess"> postProcess for GetStatValue()</param>
            <returns>Pawn bestPawn and float statValue</returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Get.TechLevel_">
            <summary>Utilities for getting tech-level related values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.Color(Verse.ResearchProjectDef,System.Boolean,System.Boolean)">
            <summary></summary>
            <param name="researchProjectDef"></param>
            <param name="finished"></param>
            <param name="locked"></param>
            <returns>The color for the current state of this research</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.ColorHex(RimWorld.TechLevel,System.Boolean)">
            <summary>Gets the color associated with the provided tech level.</summary>
            <param name="techLevel"></param>
            <param name="noErrorOnInvalid"></param>
            <returns>UnityEngine.Color for the tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.OfFaction(RimWorld.Faction)">
            <summary>Method for getting the research level of a specified faction</summary>
            <param name="faction">The faction to check</param>
            <returns>the tech level of the faction</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.OfPlayer">
            <summary>Get the current player tech level</summary>
            <returns>the tech level</returns>
        </member>
        <member name="M:NQualityOfLife.Utils.Get.TechLevel_.ResearchStats(RimWorld.TechLevel,System.Boolean)">
            <summary>
            Retrieves statistics about completed research projects, including the number of completed projects,
            the total number of research projects, and the number of projects completed at a specific research level.
            </summary>
            <param name="checkLevelCompletion_Level">The research level to check for completed projects.</param>
            <param name="debug"></param>
            <returns>
            A tuple containing:
            - The highest level of research achieved.
            - The count of completed projects.
            - The total count of research projects.
            - The count of completed projects at the specified research level.
            - The total count of projects at the specified research level.
            - The count of completed projects at the next research level.
            - The total count of projects at the next research level.
            </returns>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_PrintSettings">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_PrintSettings.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_PreviewSound">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_PreviewSound.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Doc">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Doc.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Trade">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_GetPawn_Trade.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_TryCreate_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_TryCreate_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_TryFillRooms_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_TryFillRooms_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_PrintHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_PrintHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_AnnexRooms_All">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_AnnexRooms_All.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_ValidateHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_ValidateHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.NQoLAction_Home_DeleteHomes">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.NQoLAction_Home_DeleteHomes.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.Utils.Set.TechLevel_">
            <summary>Utilities for setting tech level values</summary>
        </member>
        <member name="M:NQualityOfLife.Utils.Set.TechLevel_.OfPlayer(RimWorld.TechLevel,System.Boolean)">
            <summary>Sets the player factions tech level to the provided level</summary>
            <param name="newTechLevel">The research level to set</param>
            <param name="debug"></param>
        </member>
        <member name="M:NQualityOfLife.QA.SelfScan.ScanTranslations(System.Diagnostics.Stopwatch@)">
            <summary>Scans the mod translation files for any issues</summary>
        </member>
        <member name="M:NQualityOfLife.QA.SelfScan.TestAllMyTypes(System.Boolean,System.Diagnostics.Stopwatch)">
            <summary>Scans all the classes and methods of this mod to make sure everything is ready for a public release</summary>
            <param name="getTodoList"></param>
            <param name="translationScanTime"></param>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.ToList(System.Predicate{`0})">
            <summary>Make a new list from the given collection where the items satisfy the predicate</summary>
            <param name="where"></param>
            <returns>The matching input elements to list</returns>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.ToList">
            <summary>Make a copy of the list</summary>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.ToList(System.Int32,System.Int32)">
            <summary>Makes a copy of the list starting at the given index</summary>
            <param name="startingFrom">Start copying the list from this index</param>
            <param name="count">How many items to get at the maximum</param>
            <returns>A copy of the original list starting at the given index</returns>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.CountWhere(System.Predicate{`0})">
            <summary>Count all the matching items</summary>
            <param name="predicate"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.CountTill(System.Int32,System.Predicate{`0})">
            <summary>Count all the matching items untill the max count or the end of the list</summary>
            <param name="maxCount"></param>
            <param name="predicate"></param><returns></returns>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.Remove(`0,System.Int32)">
            <summary>Remove the specified amount of the item || or until there are none left.</summary>
            <param name="item"></param>
            <param name="amount">The amount of items to remove.</param>
            <returns>The amount of items removed</returns>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.RemoveAll(`0)">
            <summary>Remove all the instances of the given item</summary>
            <param name="item"></param>
            <returns>The amount of items removed</returns>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.ToArray">
            <summary>Create an array from the list</summary>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.Last">
            <summary>Get the last item on the list</summary><returns></returns>
        </member>
        <member name="M:NQualityOfLife.IListInterface`1.First">
            <summary>Get the first item</summary><returns></returns>
        </member>
        <member name="M:NQualityOfLife.OrderedList`1.Add(`0)">
            <summary>Add the given item to the end of the list</summary>
            <param name="item"></param>
        </member>
        <member name="M:NQualityOfLife.OrderedList`1.Remove(`0)">
            <summary>Remove the given item</summary>
            <param name="item"></param>
            <returns>True if the item was successfully removed.</returns>
        </member>
        <member name="M:NQualityOfLife.OrderedList`1.RemoveAt(System.Int32)">
            <summary>Remove the item at the given index from the list</summary>
            <param name="index"></param>
        </member>
        <member name="M:NQualityOfLife.UnOrderedList`1.Insert(System.Int32,`0)">
            <summary>Not supported</summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:NQualityOfLife.UnOrderedList`1.Remove(`0)">
            <summary>Remove the given item, || (The last item on the list will replace the given items index, unless the given index is the last item)</summary>
            <param name="item"></param>
            <returns>True if the item was successfully removed.</returns>
        </member>
        <member name="M:NQualityOfLife.UnOrderedList`1.RemoveAt(System.Int32)">
            <summary>Remove the item at the given index from the list. || (the last item on the list will be moved to this index, unless the given index is the last item)</summary>
            <param name="index"></param>
        </member>
        <member name="P:NQualityOfLife.IFloat.Value">
            <summary>The value of this type when converted to float</summary>
        </member>
        <member name="M:NQualityOfLife.IRatio.Chance">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.IMath.Clamp(System.Single,System.Single)">
            <summary>Clamp inclusive</summary>
        </member>
        <member name="M:NQualityOfLife.IMath.LargerOf(System.Single)">
            <summary>Returns the larger value</summary>
            <param name="other"></param>
            <returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.IMath.SmallerOf(System.Single)">
            <summary>Returns the smaller value</summary>
            <param name="other"></param>
            <returns>The smaller of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.IMath`1.Clamp(`0,`0)">
            <summary>Clamp inclusive</summary>
        </member>
        <member name="M:NQualityOfLife.IMath`1.Abs">
            <summary></summary>
            <returns>The absolute (non negative) value</returns>
        </member>
        <member name="M:NQualityOfLife.IMath`1.SmallerOf(`0)">
            <summary>Returns the smaller value</summary>
            <param name="other"></param>
            <returns>The smaller of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.IMath`1.Min(`0)">
            <summary>Returns the smaller value</summary>
            <param name="other"></param>
            <returns>The smaller of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.IMath`1.LargerOf(`0)">
            <summary>Returns the larger value</summary>
            <param name="other"></param>
            <returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.IMath`1.Max(`0)">
            <summary>Returns the larger value</summary>
            <param name="other"></param>
            <returns>The larger of the 2 values</returns>
        </member>
        <member name="M:NQualityOfLife.IMath`1.RoundToInt">
            <summary>Round to the closest int</summary>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.LineExtensions.RotateAroundA(NQualityOfLife.Line2D,NQualityOfLife.Degrees)">
            <summary></summary>
            <param name="line"></param>
            <param name="angle"></param>
            <returns>A new line rotated around the A point</returns>
        </member>
        <member name="M:NQualityOfLife.LineExtensions.DrawLineVertical(NQualityOfLife.Point2D,NQualityOfLife.Point2D,UnityEngine.Color,System.Single)">
            <summary>Draw a vertical line starting from start going down</summary>
            <param name="color"></param>
            <param name="thickness"></param><param name="start"></param><param name="end"></param>
            <returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.LineExtensions.DrawLineHorizontal(NQualityOfLife.Point2D,NQualityOfLife.Point2D,UnityEngine.Color,System.Single)">
            <summary>Draw a horizontal line starting from start going right</summary>
            <param name="color"></param><param name="start"></param><param name="end"></param><param name="thickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.LineExtensions.DrawLineVertical(NQualityOfLife.Point2D,UnityEngine.Color,System.Single,System.Single)">
            <summary>Draw a vertical line starting from start going down</summary>
            <param name="color"></param>
            <param name="thickness"></param><param name="start"></param><param name="height"></param>
            <returns>The line that was drawn</returns>
        </member>
        <member name="M:NQualityOfLife.LineExtensions.DrawLineHorizontal(NQualityOfLife.Point2D,UnityEngine.Color,System.Single,System.Single)">
            <summary>Draw a horizontal line starting from start going right</summary>
            <param name="color"></param><param name="start"></param><param name="length"></param><param name="thickness"></param><returns>The line that was drawn</returns>
        </member>
        <member name="T:NQualityOfLife.Recursive">
            <summary>The method is recursive on itself directly, or trough other methods</summary>
        </member>
        <member name="M:NQualityOfLife.Recursive.#ctor">
            <summary>The method call itself / Is recursive on itself</summary>
        </member>
        <member name="T:NQualityOfLife.Experimental">
            <summary>Marks a method or class as experimental, Meaning it is still in development and could be unstable or un-optimized.</summary>
        </member>
        <member name="M:NQualityOfLife.ToDo.#ctor(System.String,System.UInt16,System.Byte,System.Byte,System.Boolean)">
            <summary></summary>
            <param name="toDo"></param>
            <param name="critical"></param>
            <param name="deadLine_year">Deadline year</param><param name="deadLine_month">Deadline month</param><param name="deadLine_day">Deadline day</param>
        </member>
        <member name="M:NQualityOfLife.ToDo.#ctor(System.String,System.Boolean,System.UInt16,System.Byte,System.Byte)">
            <summary></summary>
            <param name="toDo"></param>
            <param name="critical"></param>
            <param name="deadLine_year">Deadline year</param><param name="deadLine_month">Deadline month</param><param name="deadLine_day">Deadline day</param>
        </member>
        <member name="T:NQualityOfLife.HasQATester">
            <summary>This method has a QA tester to ensure functionality</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.count">
            <summary>The variable where the patch specific count is stored. (optional)</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.done">
            <summary>The patch to apply after this one succeedes. (optional)</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathed.error">
            <summary>The patch to apply if this one fails. (optional)</summary>
        </member>
        <member name="T:NQualityOfLife.XML.Remove">
            <summary>Removes all matching nodes</summary>
        </member>
        <member name="F:NQualityOfLife.XML.PatchOperationPathedWithValue.value">
            <summary>The xml to add or replace etc</summary>
        </member>
        <member name="M:NQualityOfLife.World.PlayerLegacyTracker.RecordNewEvent(RimWorld.TaleDef,Verse.Pawn,Verse.ResearchProjectDef,RimWorld.TechLevel)">
            <summary></summary>
            <param name="taleDef"></param>
            <param name="pawn"></param>
            <param name="researchProject"></param>
            <param name="newLevel"></param>
        </member>
        <member name="M:NQualityOfLife.World.PlayerLegacyTracker.RecordNewEvent(RimWorld.TaleDef,Verse.Pawn,Verse.ResearchProjectDef)">
            <summary></summary>
            <param name="taleDef"></param>
            <param name="pawn"></param>
            <param name="researchProject"></param>
        </member>
        <member name="F:NQualityOfLife.World.LegacyEventData.renoun">
            <summary></summary>
        </member>
        <member name="F:NQualityOfLife.World.LegacyEventData.infamy">
            <summary></summary>
        </member>
        <member name="M:NQualityOfLife.World.GoodWillUtility.RelevantEvents(RimWorld.Faction,System.Boolean)">
            <summary></summary>
            <param name="faction"></param>
            <param name="onlySpecificToThisFaction">Ignore events that affect all factions?</param>
            <returns></returns>
        </member>
        <member name="F:NQualityOfLife.World.Utils_.Tile_.TileCount">
            <summary>The total number of tiles on the planet map</summary>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.DistanceTo(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldObject,RimWorld.Planet.WorldGrid,System.UInt16)">
            <summary></summary>
            <param name="myLocation"></param><param name="destination"></param>
            <param name="worldGrid"></param><param name="maxDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.DistanceTo(System.Int32,System.Int32,RimWorld.Planet.WorldGrid,System.UInt16)">
            <summary></summary>
            <param name="myLocation"></param><param name="destination"></param>
            <param name="worldGrid"></param><param name="maxDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(System.Int32,System.Int32,RimWorld.Planet.WorldGrid)">
            <summary>Get the tile neighbouring this tile in the direction of the other tile</summary>
            <param name="rootTile"></param>
            <param name="otherTile"></param>
            <param name="worldGrid"></param>
            <returns>The tile id of the Neighbouring tile || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.NeighbourTileInDirection(System.Int32,RimWorld.Direction8Way,RimWorld.Planet.WorldGrid)">
            <summary>Get the tile neighbouring this tile in the given direction</summary>
            <param name="rootTile"></param>
            <param name="direction"></param>
            <param name="worldGrid"></param>
            <returns>The tile id of the Neighbouring tile in the given direction || -1 on error</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.IsConnectedByRoad(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldObject,System.Collections.Generic.List{System.ValueTuple{System.Int32,System.Collections.Generic.List{RimWorld.Planet.Tile.RoadLink}}},System.ValueTuple{System.Int32,System.Int32}@,System.ValueTuple{RimWorld.RoadDef,System.Int32,System.Int32}@,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="worldObject"></param>
            <param name="other"></param>
            <param name="roadTilesOut"></param>
            <param name="roadHasBreakBetweenTiles">will always be (-1, -1) if road is not connected at all or doesn't have gaps</param>
            <param name="bottleNeck"></param>
            <param name="worldGrid"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.ClosestTileWithRoad(System.Int32,System.Int32@,System.Collections.Generic.IList{System.Int32})">
            <summary></summary>
            <param name="rootTile"></param>
            <param name="distanceToTile"></param>
            <param name="excludeTiles"></param>
            <returns>-1 if not found</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.HasRoad(RimWorld.Planet.Tile)">
            <summary></summary><param name="tile"></param>
            <returns>True if the given tile has any roads on it</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(RimWorld.Planet.WorldObject,RimWorld.Planet.WorldGrid,System.Int32)">
            <summary></summary>
            <param name="settlement"></param>
            <param name="worldGrid"></param>
            <param name="radius"></param>
            <returns>1f - 7f</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.LocalFertility(System.Int32,RimWorld.Planet.WorldGrid,System.Int32)">
            <summary></summary>
            <param name="tile"></param>
            <param name="worldGrid"></param>
            <param name="radius"></param>
            <returns>1f - ?f</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.GetCloseTileToSettle(System.Int32,System.Int16@,RimWorld.Planet.WorldGrid,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Boolean,System.Int32,System.Int32)">
            <summary></summary>
            <param name="rootTileId"></param>
            <param name="distanceToTile"></param>
            <param name="worldGrid"></param>
            <param name="forFaction"></param>
            <param name="forFactionFactionExtensions"></param>
            <param name="distanceReducesDesirability"></param>
            <param name="minDistanceBetweenSettlements"></param>
            <param name="maxDistanceApprox"></param>
            <returns>-1 if none found</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileSettleDesirability(System.Int32,NQualityOfLife.Factor,System.Collections.Generic.HashSet{System.Int32},RimWorld.Planet.WorldGrid,RimWorld.Planet.Tile,RimWorld.Faction,NQualityOfLife.World.FactionExtensions,System.Int32)">
            <summary></summary>
            <param name="tileId"></param>
            <param name="minimumScore">Return zero early and skip expensive checks if we know the score is not what we want</param>
            <param name="allOccupiedTiles"></param>
            <param name="worldGrid"></param>
            <param name="tile"></param>
            <param name="forFaction"></param>
            <param name="forFactionFactionExtensions"></param>
            <param name="minDistanceBetweenSettlements"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.MakeWarTorn(RimWorld.Planet.Tile,System.Int32,RimWorld.Planet.WorldGrid)">
            <summary>Try making the tile war torn</summary>
            <param name="tile"></param><param name="tileId"></param>
            <param name="worldGrid"></param>
            <returns>True if was made war torn, false if was already war torn.</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TryMakeUrban(RimWorld.Planet.Tile,System.Int32,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="tile"></param>
            <param name="tileId"></param>
            <param name="worldGrid"></param>
            <returns>True if the tile was changed to urban || False if was already urban or cannot make urban</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileFertilityFactor(System.Int32,RimWorld.Planet.WorldGrid)">
            <summary></summary>
            <param name="tile"></param>
            <param name="worldGrid"></param>
            <returns>0f - ?f (-1f on error)</returns>
        </member>
        <member name="M:NQualityOfLife.World.Utils_.Tile_.TileFertilityFactor(RimWorld.Planet.Tile,System.Int32)">
            <summary></summary>
            <param name="tile"></param>
            <param name="tileId"></param>
            <returns>0f - ?f (-1f on error)</returns>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToSettleBaseValue">
            <summary>The base resource cost to build a new settlement on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToAttack">
            <summary>The base resource cost to perform an attack another settlement on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToDevelopFarmLand">
            <summary>The base resource cost to develop a tile into farmland</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToBuildRoad">
            <summary>The base resource cost to build or upgrade a road on the world map</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.resourcesToDevelopUrban">
            <summary>The base resource cost to develop a tile into urban</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.closeSettlementsMax">
            <summary>The maximum amount of close by settlements to save for fast lookup</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.minimumPopulationToAttack">
            <summary>The minimum population required to be able to perform an attack on another settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.tickInterval">
            <summary>The base tick interval of this comp</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.tickInterval_Population">
            <summary>The base population growth tick interval</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginalOwner">
            <summary>Get the original owner / creator faction of this settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.originalOwner">
            <summary>The original owner / creator faction of this settlement</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginalName">
            <summary>Get the original name of this settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.originalName">
            <summary>The original name of this settlement</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.Faction">
            <summary>The current owner faction of this settlement</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.localTilePopulationCapCached">
            <summary>The maximum population that this settlement can currently hold</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.populationDensityRatio">
            <summary>1 means there is no more room for the population to grow, 0 means there are no people</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.localFertilityCached">
            <summary>Should be 0~1 - Can go above 1</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.attackDesire">
            <summary>The momentary desire to attack near by hostile bases.</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.OriginallyFoundedYear">
            <summary>Get the game year that this base was created - Bases that existed at the game start get a random year before the game start date</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.originallyFoundedYear">
            <summary>The game year that this base was created - Bases that existed at the game start get a random year before the game start date</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.FailedToFindEnemyInARowCounter">
            <summary>Get how many times this base has tried to attack a near by settlement but found nothing to attack - also known as the peace score</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.failedToFindEnemyInARowCounter">
            <summary>How many times this base has tried to attack a near by settlement but found nothing to attack - also known as the peace score</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.Isolated">
            <summary>Get if this settlement is isolated from other settlements - This is used to stop isolated bases from ticking in some cases</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.iAmIsolated">
            <summary>If this settlement is isolated from other settlements - This is used to stop isolated bases from ticking in some cases</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanBeAttacked">
            <summary>Are other settlements allowed to attack this settlement?</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.canBeAttacked">
            <summary>Are other settlements allowed to attack this settlement?</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanAttackEver">
            <summary>Can this settlement ever attack anyone</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.canAttackEver">
            <summary>Can this settlement ever attack anyone</summary>
        </member>
        <member name="P:NQualityOfLife.World.NQoL_World_Object_Comp.CanAttackNow">
            <summary>Get if this settlement can attack another settlement at this moment</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_World_Object_Comp.canAttackNow">
            <summary>If this settlement can attack another settlement at this moment</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.PostMapGenerate">
            <summary>Triggers when a local map is generated - We disable attacking to prevent strange issues while the player is visiting the map</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.PostMyMapRemoved">
            <summary>Triggers when a local map is deleted - We restore the settings when the player leaves</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.AttackDesire">
            <summary>Calculate the momentary desire for this settlement to attack nearby hostile settlements</summary>
            <returns>attackDesire</returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.GetPopulationCapForTile(System.Int32,NQualityOfLife.Factor,NQualityOfLife.Factor,RimWorld.Planet.Tile,System.Int32)">
            <summary></summary>
            <param name="tileId"></param>
            <param name="populationSoftCap"></param>
            <param name="hardCap"></param>
            <param name="tile"></param>
            <param name="radius">At what radius do we take tiles into account</param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.UpdateLocalExpansionDesire">
            <summary>Update the value of 'localExpansionDesireCached'</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.UpdateCachedFertility">
            <summary>Update the value of 'localFertilityCached'</summary>
            <returns>the new value of 'localFertilityCached'</returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.TryTransferStuff(NQualityOfLife.World.NQoL_World_Object_Comp,NQualityOfLife.World.NQoL_World_Object_Comp,RimWorld.Faction,RimWorld.Faction)">
            <summary>Try to trade resources or population between friendly faction bases</summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="fromFaction"></param>
            <param name="toFaction"></param>
            <returns>True if successfully transferred something</returns>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_World_Object_Comp.DoBattleSim(NQualityOfLife.Factor,RimWorld.TechLevel,NQualityOfLife.Factor@,NQualityOfLife.World.NQoL_World_Object_Comp.BattleGoal@,NQualityOfLife.Factor,RimWorld.TechLevel,NQualityOfLife.Factor@,RimWorld.Planet.Hilliness,NQualityOfLife.Ratio@,RimWorld.Faction,RimWorld.Faction,RimWorld.BiomeDef,NQualityOfLife.World.NQoL_World_Object_Comp)">
            <summary></summary>
            <param name="attackers"></param>
            <param name="attackerTechLevel"></param>
            <param name="attackerCasualties"></param>
            <param name="battleGoal"></param>
            <param name="defenders"></param>
            <param name="defenderTechLevel"></param>
            <param name="defenderCasualties"></param>
            <param name="hilliness"></param>
            <param name="attackSuccessChance"></param>
            <param name="attackerFaction"></param>
            <param name="defenderFaction"></param>
            <param name="biome">The biome where the battle takes place</param>
            <param name="defenderComp"></param>
            <returns>True if attackers won the battle</returns>
        </member>
        <member name="T:NQualityOfLife.World.NQoL_WorldComp">
            <summary>The world comp for managing faction relations on a given world</summary>
        </member>
        <member name="M:NQualityOfLife.World.NQoL_WorldComp.#ctor(RimWorld.Planet.World)">
            <summary>The world comp for managing faction relations on a given world</summary>
        </member>
        <member name="F:NQualityOfLife.World.NQoL_WorldComp.enabled">
            <summary>Is the world project stuff enabled?</summary>
        </member>
        <member name="T:NQualityOfLife.World.NQoL_Faction_Population_Display_Patch_2">
            <summary>Extends the alternating grey box/line to match the extended height of the interact areas etc</summary>
        </member>
        <member name="T:NQualityOfLife.World.FactionRelationUtility">
            <summary>Utilities for adjusting faction relations</summary>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.ChangeGoodwill(RimWorld.Faction,RimWorld.Faction,System.Int32,System.String,System.Boolean)">
            <summary>Change the goodwill between two faction by a given value</summary>
            <param name="faction">faction 1</param>
            <param name="other">faction 2</param>
            <param name="goodwillChange">how much to change the goodwill by</param>
            <param name="translatedReasonString">The reason for the goowill change</param>
            <param name="sendLetter"></param>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.CalculateFactionExpansionDesire(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>Calculate a faction's desire to expand it's settlement count</summary>
            <param name="faction">The faction who's expansion desire we are calculating</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns>float in a range of 0f-1f</returns>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.CalculateTruceDesire(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>Calculate a faction's general desire to make peace with other factions</summary>
            <param name="faction">The faction who's truce desire we are calculating</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns>float in a range of 0f-1f</returns>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.AttemptATruceWithAllHostileFactions(RimWorld.Faction)">
            <summary>The given faction will attempt to truce with all other factions, based on truce desire and other factors</summary>
            <param name="faction">The faction who's attempting truce</param>
            <returns>true if truce is agreed upon</returns>
        </member>
        <member name="M:NQualityOfLife.World.FactionRelationUtility.ConditionalSurrender(RimWorld.Faction,RimWorld.Faction,RimWorld.Faction)">
            <summary>The given faction will attempt to surrender to other factions</summary>
            <param name="surrenderingFaction">The faction who's trying to surrender</param>
            <param name="strongest">Strongest faction on the map</param>
            <param name="weakest">weakest faction on the map</param>
            <returns>true if the given faction's surrender is accepted</returns>
        </member>
        <member name="M:NQualityOfLife.World.Get.SettlementCount(RimWorld.Faction)">
            <summary>Get the count of the settlements of the given faction</summary>
            <param name="faction"></param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.UI_.ArchitectButtonOrganizer.Action_Reset_Arch">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.ArchitectButtonOrganizer.Action_Reset_Arch.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.MainButtonOrganizer.Action_Reset_MainButtons">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.MainButtonOrganizer.Action_Reset_MainButtons.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.CompProperties_ExtraGizmos">
            <summary>Xml properties for extra gizmos</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.CompProperties_ExtraGizmos.#ctor">
            <summary>The gizmo class these properties belong to</summary>
        </member>
        <member name="T:NQualityOfLife.UI_.CompExtraGizmos">
            <summary>Extra gizmos class</summary>
        </member>
        <member name="P:NQualityOfLife.UI_.CompExtraGizmos.Props">
            <summary>Use the xml defined properties</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.CompExtraGizmos.CompGetGizmosExtra">
            <summary>IEnumerable containing all the extra gizmos</summary>
        </member>
        <member name="M:NQualityOfLife.UI_.Designator_SelectSimilar.GetAllSimilarThingsOnCell(Verse.IntVec3,Verse.Map,System.Int32@)">
            <summary>Never null</summary>
            <param name="cell"></param><param name="map"></param><param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.TradeWithBestNegotiator(Verse.Map)">
            <summary>Gizmo to select the best available trader on the map</summary>
            <param name="map"></param>
            <returns>The gizmo</returns>
        </member>
        <member name="M:NQualityOfLife.UI_.Gizmos.SurgeryWithBestSurgeon(Verse.Map)">
            <summary>Gizmo to select the best available surgeon on the map</summary>
            <param name="map"></param>
            <returns>The gizmo</returns>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.NQoL_Minification_ErrorFix_Patch.Prefix(System.SByte)">
            <summary>Stops doors from ticking if un installed, this fixes some errors</summary>
            <param name="___mapIndexOrState"></param>
            <returns>False if should not tick</returns>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.MassPatcher.AddMass(Verse.ThingDef,System.Boolean)">
            <summary>Dynamically add a proper mass value to the def - Will error if the def already has a defined mass!</summary>
            <param name="thingDef">The def that needs a mass value</param>
            <param name="debug"></param>
            <returns>True if successful</returns>
        </member>
        <member name="M:NQualityOfLife.MassAndMinificationAdvanced.MassPatcher.Validate(Verse.ThingDef,System.Boolean)">
            <summary>Checks if the Def is valid</summary>
            <param name="thingDef"></param>
            <param name="skipMassValidation"></param>
            <returns>False if the def has config errors</returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.OnGameLoad_Patch.NQoLAction_PopNewPlayerInfo">
            <summary>Used to trigger the new player pop up manually, for debugging / translation purposes</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Text_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_MessageFilter_Patch.NQoLAction_MessageFilter_Text_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Text_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.NQoLAction_LetterFilter_Text_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.LetterUtility.NQoL_ReceiveLetter_Patch.Prefix(Verse.Letter,System.Int32,System.Boolean@)">
            <summary></summary>
            <param name="let"></param>
            <param name="delayTicks"></param>
            <param name="__state">Letter was supressed</param>
            <returns></returns>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch">
            <summary>Patch for triggering auto assign stuff when capturing a prisoner</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch.Prefix(RimWorld.JobDriver_TakeToBed,System.Boolean@)">
            <summary></summary>
            <param name="__instance"></param>
            <param name="__state">Will be set to true in the prefix, if the pawn is not yet a prisoner</param>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.TriggerAutoPolicyOnPrisnoerCapture_Patch.Postfix(RimWorld.JobDriver_TakeToBed,System.Boolean@)">
            <summary></summary>
            <param name="__instance"></param>
            <param name="__state">Will be true here if was not yet prisoner in prefix</param>
        </member>
        <member name="T:NQualityOfLife.MiscFixes.NQoL_FoodUtility">
            <summary>Utilities for giving hediffs after food consumption</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.NQoL_FoodUtility.AddRandomFoodParasitesHediff(Verse.Pawn,Verse.Thing,RimWorld.FoodPoisonCause)">
            <summary>50/50 chance to add either the GutWorms or MuscleParasites hediff</summary>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.NQoL_Pawn_Downed_Self_Preservation_Patch.Postfix(System.Boolean,Verse.Pawn_HealthTracker)">
            <summary></summary>
            <param name="__result">ShouldBeDowned return</param>
            <param name="__instance"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.NQoL_QuestNode_GetFaction_Patch.Postfix(System.Boolean,RimWorld.Faction)">
            <summary></summary>
            <param name="__result">IsGoodFaction return</param>
            <param name="faction"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.NQoL_IncidentWorker_CanFireNow_Patch.Postfix(System.Boolean,RimWorld.IncidentWorker,RimWorld.IncidentParms)">
            <summary></summary>
            <param name="__result">IncidentWorker.CanFireNow return</param>
            <param name="__instance"></param>
            <param name="parms"></param>
            <returns></returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.ShouldSuppress(RimWorld.TechLevel,RimWorld.IncidentDef)">
            <summary>Should the given IncidentDef be disallowed from happening?</summary>
            <param name="playerTechLevel"></param>
            <param name="instanceDef"></param>
            <returns>True if this IncidentDef should not be allowed to fire</returns>
        </member>
        <member name="M:NQualityOfLife.MiscFixes.IncidentSuppression.ShouldSuppress(RimWorld.IncidentDef,RimWorld.TechLevel,RimWorld.IncidentParms)">
            <summary>Check it the given incident def should be suppressed given the specific params</summary>
            <param name="instanceDef"></param>
            <param name="playerTechLevel"></param>
            <param name="parms"></param>
            <returns>True if this incident should not be allowed to happen</returns>
        </member>
        <member name="T:NQualityOfLife.Plants.Plant_NoRest">
            <summary>Plant sub class for disabling rest period</summary>
        </member>
        <member name="P:NQualityOfLife.Plants.Plant_NoRest.Resting">
            <summary>Resting = always false</summary>
        </member>
        <member name="F:NQualityOfLife.Infestation.Settings.maxInsectLightLevel">
            <summary>float 0f - 1f</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Spot">
            <summary>The parent of all NQoL spots</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Trader_Spot">
            <summary>Spot that designates trader chillSpot</summary>
        </member>
        <member name="T:NQualityOfLife.Things.Spots.NQoL_Drop_Spot">
            <summary>Spot that designates drop pod delivery location</summary>
        </member>
        <member name="T:NQualityOfLife.TraitExtensions">
            <summary>Extra values for traits, used in various NQoL systems</summary>
        </member>
        <member name="F:NQualityOfLife.TraitExtensions.isBad">
            <summary>Is this a negative trait? affects calculations</summary>
        </member>
        <member name="F:NQualityOfLife.TraitExtensions.germResistanceOffset">
            <summary>float of germ resistance offset caused by the trait expects positive values between 0.25 and 0</summary>
        </member>
        <member name="M:NQualityOfLife.TraitExtensions.ConfigErrors">
            <summary>Validate and give errors for invalid config values in xml</summary>
        </member>
        <member name="T:NQualityOfLife.AutoAssign.NQoLAction_AutoAssign_Popup">
            <summary>An action that can be triggered from the settings menu</summary>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.NQoLAction_AutoAssign_Popup.ApplyAction">
            <summary>Code that is run after triggering it from the settings menu</summary>
        </member>
        <member name="T:NQualityOfLife.AutoAssign.Settings">
            <summary>Local Settings</summary>
        </member>
        <member name="F:NQualityOfLife.AutoAssign.Settings.debugMode">
            <summary>local debug mode bool</summary>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.TimeTableSetter.AutoSetTimeTable(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary></summary>
            <param name="pawn"></param>
            <param name="forSlaves"></param>
            <param name="map"></param>
            <returns>True if the timetable was successfully set, else false</returns>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.TimeTableSetter.AutoSetNightOwlSleep(Verse.Pawn)">
            <summary></summary>
            <param name="pawn"></param>
            <returns>True if pawn timetable was changed, else false.</returns>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.PolicySetter.SmartReadingPolicySetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary>Set the pawn reading policy to the most popular reading policy on the map</summary>
            <param name="pawn"></param>
            <param name="forSlaves">un-used</param>
            <param name="map"></param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.ThreatResponseSetter.SmartThreatResponseSetter(Verse.Pawn)">
            <summary>Set HostilityResponseMode to attack if capable of violence</summary>
            <param name="pawn">Set for this pawn</param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.MedicalCareSetter.SmartMedicalCareSetter(Verse.Pawn,System.Boolean,Verse.Map)">
            <summary>Set the default medical care policy based on what other pawns are set to</summary>
            <param name="pawn"></param>
            <param name="forPrisoners"></param>
            <param name="map"></param>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.WorkSetter.PawnIsAboveAverageAtWorkRelatedSkill(Verse.Pawn,Verse.WorkTypeDef,RimWorld.SkillDef,System.Boolean,Verse.Map)">
            <summary>Is the given Pawn above average in the work related skill?</summary>
            <param name="pawn">This pawn</param>
            <param name="work">The work</param>
            <param name="skill">The skill relevant to the work</param>
            <param name="gameStart"></param>
            <param name="map"></param>
            <returns>True if pawn has above average skill compared to other pawns assigned to the WorkType on the map</returns>
        </member>
        <member name="M:NQualityOfLife.AutoAssign.WorkSetter.EnableWorkIfAboveAverageSkill(Verse.Pawn,Verse.WorkTypeDef,RimWorld.SkillDef,System.Boolean,Verse.Map)">
            <summary>Set the work type to active and set priority if pawn is above average in skill at the work type compared to the other pawns on the map.</summary>
            <param name="pawn"></param>
            <param name="work"></param>
            <param name="skill"></param>
            <param name="gameStart"></param>
            <param name="map"></param>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo">
            <summary>Place worker for preventing placing adjacent to something</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.preventPlacingNextToType">
            <summary>Prevent placing next to thing of this type</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.allowTouchingCorners">
            <summary>Are corners allowed to touch?</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.checkForBlueprintsAndFrames">
            <summary>Check for unfinished versions of the thing</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.errorMessageString">
            <summary>The message to display if placement is not allowed</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.warningOnly">
            <summary>Only do a warning message, instead of preventing placement - Used with other comps and stuff</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for preventing placing adjacent to something</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed">
            <summary>Place worker for preventing bed cramming</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed.#ctor">
            <summary>Place worker for preventing bed cramming</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed_Warning">
            <summary>Place worker for warning about bed cramming debuffs</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_NeverAdjacentTo_Bed_Warning.#ctor">
            <summary>Place worker for warning about bed cramming debuffs</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_Hang_From_Roof">
            <summary>Place worker for hanging things from roofs</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_Hang_From_Roof.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for hanging things from roofs</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall">
            <summary>Place worker for placing things on walls</summary>
        </member>
        <member name="F:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall.mustFaceEmptyTile">
            <summary>There has to be an empty tile in front</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach_OnWall.AllowsPlacing(Verse.BuildableDef,Verse.IntVec3,Verse.Rot4,Verse.Map,Verse.Thing,Verse.Thing)">
            <summary>Place worker for placing things on walls</summary>
        </member>
        <member name="T:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach">
            <summary>Place worker for placing things on walls, facing an empty tile</summary>
        </member>
        <member name="M:NQualityOfLife.PlaceWorkers.PlaceWorker_NQoL_WallAttach.#ctor">
            <summary>Place worker for placing things on walls, facing an empty tile</summary>
        </member>
        <member name="T:NQualityOfLife.HarmonyPatches">
            <summary>Apply harmony patches based on settings</summary>
        </member>
    </members>
</doc>
